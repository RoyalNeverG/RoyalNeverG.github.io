{"pages":[{"title":"关于我","text":"渣渣二本毕业，希望通过写文章的方式，提高自己的技能！","link":"/about/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"springboot整合JDBCTemplate及多数据源","text":"springboot整合JDBCTemplate源码分析==&gt; 当我们没有配置任何jdbcTemplate时，springboot自动为我们创建了一个jdbctemplate 当我们配置了jdbctemplate时候，自动配置失效 org.springframework.boot.autoconfigure.jdbc.JdbcTemplateConfiguration==&gt; 123456789101112131415161718192021@Configuration( proxyBeanMethods = false)@ConditionalOnMissingBean({JdbcOperations.class})class JdbcTemplateConfiguration { JdbcTemplateConfiguration() { } @Bean @Primary JdbcTemplate jdbcTemplate(DataSource dataSource, JdbcProperties properties) { JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); Template template = properties.getTemplate(); jdbcTemplate.setFetchSize(template.getFetchSize()); jdbcTemplate.setMaxRows(template.getMaxRows()); if (template.getQueryTimeout() != null) { jdbcTemplate.setQueryTimeout((int)template.getQueryTimeout().getSeconds()); } return jdbcTemplate; }} 12345678910111213public class JdbcTemplate extends JdbcAccessor implements JdbcOperations { private static final String RETURN_RESULT_SET_PREFIX = \"#result-set-\"; private static final String RETURN_UPDATE_COUNT_PREFIX = \"#update-count-\"; private boolean ignoreWarnings = true; private int fetchSize = -1; private int maxRows = -1; private int queryTimeout = -1; private boolean skipResultsProcessing = false; private boolean skipUndeclaredResults = false; private boolean resultsMapCaseInsensitive = false; //**** //****} 单数据源配置：pom.xml 1234567891011121314151617181920212223242526272829303132&lt;dependencies&gt; &lt;!-- test --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;!--只会在测试时使用 不会被打包--&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--jdbctemplate操作--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--阿里的starter--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.18&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;!--只会在项目运行和测试时有效 不会随着项目一起打包发布--&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;version&gt;5.1.27&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 12345678910111213spring:# 数据源配置 datasource:#数据源类型 type: com.alibaba.druid.pool.DruidDataSource# 驱动类 driver-class-name: com.mysql.jdbc.Driver# 数据库地址 url: jdbc:mysql://127.0.0.1:3306/test# 用户名 username: root# 密码 password: 123456 12345678public class User { private Integer id; private String username; private String address; //settter //getter //toStr·ing} 123456CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(20) DEFAULT NULL, `address` varchar(50) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8mb4; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960@Servicepublic class UserService { @Autowired private JdbcTemplate jdbcTemplate; /** * 添加操作 * @param user * @return */ public Integer addUser(User user){ return jdbcTemplate.update(\"insert into user(username,address) values(?,?)\", user.getUsername(), user.getAddress()); } /** * 删除操作 * @param integer * @return */ public Integer deleteUser(Integer integer) { return jdbcTemplate.update(\"delete from user where id =?\", integer); } /** * 更新操作 * @param user * @return */ public Integer updateUser(User user) { return jdbcTemplate.update(\"update user set address=? where id=?\", user.getAddress(), user.getId()); } /** * 获取所有 并传递参数 * 一般属性名和数据库字段名不一致时手动设置值 * @return */ public List&lt;User&gt; getAllUser(User user){ return jdbcTemplate.query(\"select * from user where address =?\",new Object[]{user.getAddress()}, new RowMapper&lt;User&gt;() { @Override public User mapRow(ResultSet resultSet, int i) throws SQLException { User user=new User(); user.setId(resultSet.getInt(\"id\")); user.setUsername(resultSet.getString(\"username\")); user.setAddress(resultSet.getString(\"address\")); return user; } }); } /** * 属性名和数据库字段名一致的情况 * @param user * @return */ public List&lt;User&gt; getAllUserSameArgs(User user){ return jdbcTemplate.query(\"select * from user where address =?\", new Object[]{user.getAddress()}, new BeanPropertyRowMapper&lt;&gt;(User.class)); }} 测试使用： 123456789101112131415161718192021222324252627282930313233@SpringBootTest(classes = JDBCTemplateApplication.class)@RunWith(SpringRunner.class)public class JDBCTemplateTest { @Autowired private UserService userService; @Test public void test01() { User user=new User(); user.setUsername(\"张三\").setAddress(\"湖北孝感\"); Integer integer = userService.addUser(user); System.out.println(integer); } @Test public void test02() { Integer integer = userService.deleteUser(1); System.out.println(integer); } @Test public void test03() { Integer integer = userService.updateUser(new User().setId(1).setAddress(\"上海\")); System.out.println(integer); } @Test public void test04() { List&lt;User&gt; allUser = userService.getAllUserSameArgs(new User().setAddress(\"武汉\")); System.out.println(allUser); }} 多数据源配置：pom.xml和单数据源一致 这里注意，在yaml文件中，属性名的字母不要写大写，大写字母前加 - 后转小写 12345678910111213141516171819#配置多数据后，所有的数据源自动配置将会失效spring:#数据源1 datasourceone: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver #传输时 使用统一的utf-8编码 url: jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=UTF-8 username: root password: 123456#数据源2 datasourcetwo: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver #传输时 使用统一的utf-8编码 url: jdbc:mysql://47.96.141.44:3306/test?useUnicode=true&amp;characterEncoding=UTF-8 username: root password: xxxxxxx 数据源配置注入==&gt; 1234567891011121314151617@Configurationpublic class DataSourceConfig { @Bean //配置前缀和yaml中的属性对应，完成属性的安全注入 @ConfigurationProperties(prefix = \"spring.datasourceone\") public DataSource dataSourceOne(){ return DruidDataSourceBuilder.create().build(); } @Bean @ConfigurationProperties(prefix = \"spring.datasourcetwo\") public DataSource dataSourceTwo(){ return DruidDataSourceBuilder.create().build(); }} jdbcTemplate配置==&gt; @Autowired 默认按照类型进行注入``（多个或者找不到报错） @Qualifier 按照名称进行配置 一般是结合起来使用==&gt; 如： @Qualifier(“dataSourceOne”)@Autowiredprivate DataSource dataSourceOne @Resource 默认直接按照名称进行注入 （可同时指定name和type一起查找注入，也可都省略）注意@Resource不能存在于方法的参数上 如： @Resource(name = “dataSourceTwo”) DataSource dataSourceTwo; 123456789101112131415@Configurationpublic class JDBCTemplateConfig { @Bean public JdbcTemplate jdbcTemplateOne(@Qualifier(\"dataSourceOne\")DataSource dataSource){ return new JdbcTemplate(dataSource); } @Resource(name = \"dataSourceTwo\")DataSource dataSource; @Bean public JdbcTemplate jdbcTemplateTwo(){ return new JdbcTemplate(dataSource); }} 这里数据库的结构和实体两个数据源中的保持一致 先从数据源一查询一个用户，再把该用户插入另一个数据源==&gt; 12345678910111213141516171819202122@Servicepublic class UserToUserService { @Qualifier(\"jdbcTemplateOne\") @Autowired private JdbcTemplate jdbcTemplateOne; @Qualifier(\"jdbcTemplateTwo\") @Autowired private JdbcTemplate jdbcTemplateTwo; public Integer userToAddUser(User user) { List&lt;User&gt; list= jdbcTemplateOne.query(\"select * from user where id =?\", new Object[]{user.getId()}, new BeanPropertyRowMapper&lt;&gt;(User.class)); if(list!=null&amp;&amp;!list.isEmpty()&amp;&amp;list.size()==1){ User resUser = list.get(0); int update = jdbcTemplateTwo.update(\"insert into user(id,username,address) values (?,?,?)\", resUser.getId(), resUser.getUsername(), resUser.getAddress()); if(update==1){ return 1; } } return 0; }} 注意：当我们有多个数据源和多个jdbcTemplate配置的时候，我们在注入jdbctemplate的时候必须加限定名，即哪个jdbctemplate。 1234567@Servicepublic class UserService { @Qualifier(\"jdbcTemplateTwo\") @Autowired private JdbcTemplate jdbcTemplate;} 否则需要在数据源和jdbctemplate配置上加默认配置 即注解@Primary 1234567891011121314151617@Configurationpublic class DataSourceConfig { @Primary @Bean @ConfigurationProperties(prefix = \"spring.datasourceone\") public DataSource dataSourceOne(){ return DruidDataSourceBuilder.create().build(); } @Bean @ConfigurationProperties(prefix = \"spring.datasourcetwo\") public DataSource dataSourceTwo(){ return DruidDataSourceBuilder.create().build(); }} 1234567891011121314151617@Configurationpublic class JDBCTemplateConfig { @Primary @Bean public JdbcTemplate jdbcTemplateOne(@Qualifier(\"dataSourceOne\")DataSource dataSource){ return new JdbcTemplate(dataSource); } @Resource(name = \"dataSourceTwo\")DataSource dataSource; @Bean public JdbcTemplate jdbcTemplateTwo(){ return new JdbcTemplate(dataSource); }} 我们在使用时，直接注入即可（默认注入标记的默认数据源） 12345@Servicepublic class UserService { @Autowired private JdbcTemplate jdbcTemplate;} 注解@Autowired 默认按照类型进行注入（多个或者找不到报错） @Qualifier 按照名称进行配置 一般是结合起来使用==&gt; 如： @Qualifier(“dataSourceOne”)@Autowiredprivate DataSource dataSourceOne @Resource 默认直接按照名称进行注入 （可同时指定name和type一起查找注入，也可都省略）注意@Resource不能存在于方法的参数上 如： @Resource(name = “dataSourceTwo”)DataSource dataSourceTwo; @Primary当有多个配置文件时 标记为默认的注入配置","link":"/2020/04/17/multipledatasource/%E6%95%B4%E5%90%88JDBCTemplate%E5%8F%8A%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90/"},{"title":"Git基本操作","text":"1、添加、提交、推送123456789101112131415161718192021//直接克隆代码git clone 'https://gitee.com'//初始化仓库git init//添加所有文件到暂存区git add . //提交到仓库区&lt;!-- more --&gt;git commit -m '添加的消息' //初始添加远端仓库地址git remote add origin 'https://gitee.com'//将本地的master分支推送到远端主机master，同时指定origin为默认主机，以后直接使用git pushgit push -u origin master 或者 git push --set-upstream origin master//推送当前分支到已设置的远端地址git push//提交到远端的指定分支git push origin branchName//推送到远端地址(默认推送当前分支)git push 'https://gitee.com' //推送到远端地址的master分支git push 'https://gitee.com' master 2、分支操作12345678910111213141516//创建分支git branch branchName//切换分支git checkout branchName//创建并切换分支git checkout -b branchName//查看所有分支 有 * 的为当前分支git branch //将当前分支合并到指定分支（合并后的分支，对合并之前的当前分支和指定分支都有影响）git merge branchName//将当前分支移动到指定分支，当做指定分支的子节点。指定分支再移动到子节点即到同一分支git rebase branchName//从远程仓库下载本地仓库中缺失的提交记录 更新远程分支指针git fetch//拉取代码 相当于git pull 和 git fetchgit pull","link":"/2020/04/17/git/git%E6%9E%81%E7%AE%80/"},{"title":"SpringBoot整合ActiveMQ","text":"SpringBoot整合ActiveMQ一、安装ActiveMQ这里我们采用docker安装 1、搜索镜像docker search activemq 2、拉取镜像 docker pull webcenter/activemq 3、初始化容器61616 为通信端口 8161 为管理界面 docker run -d --name activemq01 -p 61616:61616 -p 8161:8161 webcenter/activemq 4、访问activemqxxx.xxx.xxx.xxx:8161 默认用户名和密码为 admin/admin 二、springboot整合ActiveMQ1、pom.xmlspring-boot-starter-activemq 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;activemq&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;activemq&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-activemq&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、实体消息bean12345678910111213@Getter@Setter@ToStringpublic class Message implements Serializable { /** * 发送的消息内容 */ private String content; /** * 发送的日期 */ private Date sendDate;} 3、队列配置1234567891011@Configurationpublic class QueueConfig { /** * 新建队列 * @return */ @Bean Queue queue() { return new ActiveMQQueue(\"hello.lc\"); }} 4、jms配置 1234567891011121314151617181920212223242526272829303132@Componentpublic class JmsComponent { /** * jms(java messgae service(java消息服务) )消息模板 */ @Autowired JmsMessagingTemplate jmsMessagingTemplate; @Autowired Queue queue; /** * 生产者 * @param message */ public void send(Message message) { //发送的目的地(指定队列) ; 发送的消息对象 jmsMessagingTemplate.convertAndSend(this.queue,message); } /** * 消费者 * JmsListener监听消息队列 destination 指定队列的名称 * @param message */ @JmsListener(destination = \"hello.lc\") public void receive(Message message){ System.out.println(message); }} 4、properties配置1234567#activemq代理的urlspring.activemq.broker-url=tcp://47.96.141.44:61616#发送消息时可为字符串或者一个对象。若为一个对象，则需要设为true#信任所有的包 如果传输的对象是Obeject 这里必须加上这句或者指定信任的包 否则会导致对象序列化失败spring.activemq.packages.trust-all=truespring.activemq.user=adminspring.activemq.password=admin 5、测试使用12345678910111213141516@SpringBootTestclass ActivemqApplicationTests { //默认注入单例 @Autowired JmsComponent jmsComponent; @Test void contextLoads() { Message message = new Message(); message.setContent(\"hello lc\"); message.setSendDate(new Date()); jmsComponent.send(message); }}","link":"/2020/04/17/mq/SpringBoot%E6%95%B4%E5%90%88ActiveMQ/"},{"title":"springboot整合MongoDB","text":"springboot整合MongoDB一、docker安装mongodb1、拉取最近的镜像docker pull 2、初始化mongo容器 -d 后台运行 -p 端口映射 –name 容器名称 –restar docker每次重启后，该容器也启动 -e 参数设置 初始化用户名为root 密码为你的密码 docker run -d -p 27017:27017 --name mongo01 --restart=always -e MONGO_INITDB_ROOT_USERNAME=root -e MONGO_INITDB_ROOT_PASSWORD=你的密码 mongo 3、每个数据库有独立的账号和密码①进入容器docker exec -it 容器id bash ②进入mongomongo ③切换到admin数据库use admin ④添加用户操作的对应数据库db.createUser({user:&quot;admin&quot;,pwd:&quot;xiiasdfiik34&quot;,roles:[{role: 'root', db: 'admin'}]}) ⑤ 验证db.auth('admin', 'xiiasdfiik34') // 返回1 就是认证成功 二、使用MongoRepository1、pom.xmlspring-boot-starter-data-mongodb 1234567891011121314151617181920212223&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2、yaml配置1234567891011spring: data: mongodb: # mongodb每个库都有自己的认证方式 authentication-database: lc username: root password: 你的密码 port: 27017 database: lc uri: mongodb://root:你的密码@47.96.141.44:27017/lc# host: 47.96.141.44 3、实体12345678@Getter@Setter@ToStringpublic class Book { private Integer id; private String name; private String author;} 4、dao接口123456789101112131415/** * 继承MongoRepository * 第一个参数为 操作的实体 * 第二个参数为 操作的主键类型 */public interface BookDao extends MongoRepository&lt;Book,Integer&gt; { /** * 和jap一致 遵循方法名称的表达式进行查询 * @param name * @return */ List&lt;Book&gt; findBooksByNameContaining(String name);} 5、测试使用12345678910111213141516171819202122232425262728@RunWith(SpringRunner.class)@SpringBootTest(classes = RedisApplication.class)public class mongoTest { @Autowired private BookDao bookDao; //插入一条数据 @Test public void Test1() { Book b = new Book(); b.setId(3); b.setName(\"红楼梦\"); b.setAuthor(\"曹雪芹\"); bookDao.insert(b); } @Test public void Test2() { //查询所有 List&lt;Book&gt; all = bookDao.findAll(); System.out.println(all); //查询包含书名称为 “红” 的book //这里满足名称表达式 和jpa类似 List&lt;Book&gt; list = bookDao.findBooksByNameContaining(\"红\"); System.out.println(list); }} 三、使用MongoTemplate1、pom.xml和上面配置一致 2、yaml配置和上面配置一致 3、实体和上面配置一致 4、直接使用（和RedisTmeplate类似）12345678910111213141516171819202122@RunWith(SpringRunner.class)@SpringBootTest(classes = RedisApplication.class)public class mongoTest { @Autowired private MongoTemplate mongoTemplatel; @Test public void Test3() { Book book = new Book(); book.setId(4); book.setName(\"水浒传\"); book.setAuthor(\"施耐庵\"); //插入数据 mongoTemplatel.insert(book); //查询所有 List&lt;Book&gt; all = mongoTemplatel.findAll(Book.class); System.out.println(all); }}","link":"/2020/04/17/nosql/springboot%E6%95%B4%E5%90%88mongodb/"},{"title":"Maven基础知识","text":"1、dependencyManagement和dependencies的区别 123456789101112131415161718192021222324 &lt;!--定义父版本--&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;!--如果没有指定版本 则使用父版本 否则使用指定的版本--&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--json格式工具--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; ①定义 123 在Maven中dependencyManagement的作用其实相当于一个对所依赖jar包进行版本管理的管理器。 在dependencyManagement下申明的dependencies，Maven并不会去实际下载所依赖的jar包，而是 在dependencyManagement中用一个Map记录了jar的三维坐标。 ②jar的版本1234567 这个是一个重要的概念，也是dependencyManagement独有的特色。 1：如果dependencies里的dependency自己没有声明version元素，那么maven就 会倒dependencyManagement里面去找有没有对该artifactId和groupId进行过版本声明，如果有，就继承它，如果没有就会报错，告诉你必须为dependency声明一个version 2：如果dependencies中的dependency声明了version，那么无论dependencyManagement中有无对该jar的version声明，都以dependency里的version为准。 2、maven 常用命令(工具)①clean1清除项目中编译文件和本地仓库中已打包的文件 ②compile1编译项目中的java文件，并存放在项目的编译目录（根据不同的配置，编译目录也不一样） ③test1运行项目中的测试用例文件，如果测试用例未通过，也会打包失败，另，这里的test过程可以在pom中通过配置跳过 ④package123依次执行了clean、resources、compile、testResources、testCompile、test、jar(打包)等７个阶段。package命令完成了项目编译、单元测试、打包功能，但没有把打好的可执行jar包（war包或其它形式的包）布署到本地maven仓库和远程maven私服仓库 ⑤install123依次执行了clean、resources、compile、testResources、testCompile、test、jar(打包)、install等8个阶段install命令完成了项目编译、单元测试、打包功能，同时把打好的可执行jar包（war包或其它形式的包）布署到本地maven仓库，但没有布署到远程maven私服仓库 ⑥deploy123依次执行了clean、resources、compile、testResources、testCompile、test、jar(打包)、install、deploy等９个阶段。deploy命令完成了项目编译、单元测试、打包功能，同时把打好的可执行jar包（war包或其它形式的包）布署到本地maven仓库和远程maven私服仓库 3、dependency中scope的用法 compile，缺省值，适用于所有阶段，会随着项目一起发布。 provided，类似compile，期望JDK、容器或使用者会提供这个依赖。如servlet.jar。 runtime，只在运行时使用，如JDBC驱动，适用运行和测试阶段。 test，只在测试时使用，用于编译和运行测试代码。不会随项目发布。 system，类似provided，需要显式提供包含依赖的jar，Maven不会在Repository中查找它。 123456&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.20&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 依赖范围控制哪些依赖在哪些classpath 中可用，哪些依赖包含在一个应用中。让我们详细看一下每一种范围： ① compile （编译范围）compile是默认的范围；如果没有提供一个范围，那该依赖的范围就是编译范围。编译范围依赖在所有的classpath 中可用，同时它们也会被打包。 ②provided （已提供范围）provided 依赖只有在当JDK 或者一个容器已提供该依赖之后才使用。例如， 如果你开发了一个web 应用，你可能在编译 classpath 中需要可用的Servlet API 来编译一个servlet，但是你不会想要在打包好的WAR 中包含这个Servlet API；这个Servlet API JAR 由你的应用服务器或者servlet 容器提供。已提供范围的依赖在编译classpath （不是运行时）可用。它们不是传递性的，也不会被打包。 ③runtime （运行时范围）runtime 依赖在运行和测试系统的时候需要，但在编译的时候不需要。比如，你可能在编译的时候只需要JDBC API JAR，而只有在运行的时候才需要JDBC驱动实现。 ④test （测试范围）test范围依赖 在一般的编译和运行时都不需要，它们只有在测试编译和测试运行阶段可用。 ⑤system （系统范围）system范围依赖与provided 类似，但是你必须显式的提供一个对于本地系统中JAR 文件的路径。这么做是为了允许基于本地对象编译，而这些对象是系统类库的一部分。这样的构件应该是一直可用的，Maven 也不会在仓库中去寻找它。如果你将一个依赖范围设置成系统范围，你必须同时提供一个 systemPath 元素。注意该范围是不推荐使用的（你应该一直尽量去从公共或定制的 Maven 仓库中引用依赖）。 4、指定maven编译 Compiler插件编译时和编译后运行的JVM版本12345678910111213&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;8&lt;/source&gt; &lt;target&gt;8&lt;/target&gt; &lt;encoding&gt;utf-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 5、idea创建项目Group: 会作为包名的前一部分 Artifact: 会作为包的最后一部分 例如：Group：com.mybatis ​ Artifact: spring-boot-lc-mybatis 然后设置项目名 随便设置，不会影响项目内容 最后生成的项目： 12&lt;groupId&gt;com.mybatis&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-lc-mybatis&lt;/artifactId&gt; 生成的包名： com.mybatis.springbootlcmybatis 6、Maven 中 SHAPSHOT 和 RELEASE 版本的区别？1、Snapshot版本代表不稳定、尚处于开发中的版本 2、Release版本则代表稳定的版本","link":"/2020/04/17/projectBuildAndDev/Maven%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"SpringBoot应用监控可视化","text":"SpringBoot应用监控可视化Spring Boot Admin监控系统SBA则是基于Actuator更加进化了一步，其是一个针对Actuator接口进行UI美化封装的监控工具。 一、创建服务端1.pom.xmlspring-boot-admin-starter-server 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;admin&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;admin&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-boot-admin.version&gt;2.2.1&lt;/spring-boot-admin.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-starter-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-dependencies&lt;/artifactId&gt; &lt;version&gt;${spring-boot-admin.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、启用Spring Boot Admin12345678@SpringBootApplication//开启admin服务@EnableAdminServerpublic class AdminApplication { public static void main(String[] args) { SpringApplication.run(AdminApplication.class, args); }} 3、访问监控页面 localhost:8080/index.html ![](F:\\桌面内容\\springboot2\\springboot应用监控\\images\\批注 2020-04-08 210708.png) 二、创建client(监控的Spring Boot应用)1、pom.xmlspring-boot-admin-starter-client spring-boot-starter-actuator 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;client&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;client&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-boot-admin.version&gt;2.2.1&lt;/spring-boot-admin.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-starter-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-dependencies&lt;/artifactId&gt; &lt;version&gt;${spring-boot-admin.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、配置客户端的一些信息12345#暴露所有端口信息management.endpoints.web.exposure.include=*server.port=8081#声明该客户端的url地址spring.boot.admin.client.url=http://localhost:8080 3、启动该程序三、访问服务端监控页面 localhost:8080/index.html ![](F:\\桌面内容\\springboot2\\springboot应用监控\\images\\批注 2020-04-08 211142.png)","link":"/2020/04/17/projectcontrol/SpringBoot%E5%BA%94%E7%94%A8%E7%9B%91%E6%8E%A7%E5%8F%AF%E8%A7%86%E5%8C%96/"},{"title":"springboot实现session共享","text":"一、springboot实现session共享注意①redis的配置和springSecutiy的引入 1、基本配置①pom.xml spring-session-data-redis spring-boot-starter-data-redis spring-boot-starter-security 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;redis&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--spring session 与redis应用基本环境配置,需要开启redis后才可以使用，不然启动Spring boot会报错 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; ②yaml配置12345678910111213spring: redis:# 主机 host: 47.96.141.44# 默认使用的数据库（第一个） database: 0 port: 6379 password: 你的密码# 配置lettuce连接池的相关属性#需要设置启动的服务器server: port: 8080 ③控制器123456789101112131415161718@RestControllerpublic class UserController { // 这个必须配置启动的服务器 @Value(\"${server.port:8080}\") Integer port; @GetMapping(\"/set\") public String set(HttpSession httpSession){ httpSession.setAttribute(\"name\", \"lcc\"); return String.valueOf(port); } @GetMapping(\"/get\") public String get(HttpSession httpSession) { return (String) httpSession.getAttribute(\"name\")+port; }} ④模拟两个服务器启动分别启动两个不同端口的jar包==&gt; 服务器1==&gt; java -jar redis-1.0-SNAPSHOT.jar --server.port=8080 服务器2==&gt; java -jar redis-1.0-SNAPSHOT.jar --server.port=8081 请求8080的set接口：http://localhost:8080/set 设置session值 请求8081的get接口：http://localhost:8081/get 得到session值 结论:==&gt; 这时我们发现请求的服务1的接口输入user用户名和密码后，再去请求服务器2的接口后无需输入user和密码， 因为此时redis中，已经帮我们存取了session的详细对象。即操作的为同一个session。 2、使用nginx服务器很简单，进入 Nginx 的安装目录的 conf 目录下（默认是在 /usr/local/nginx/conf），编辑 nginx.conf 文件: 在这段配置中： upstream 表示配置上游服务器 javaboy.org 表示服务器集群的名字，这个可以随意取名字 upstream 里边配置的是一个个的单独服务 weight 表示服务的权重，意味者将有多少比例的请求从 Nginx 上转发到该服务上 location 中的 proxy_pass 表示请求转发的地址，/ 表示拦截到所有的请求，转发转发到刚刚配置好的服务集群中 proxy_redirect 表示设置当发生重定向请求时，nginx 自动修正响应头数据（默认是 Tomcat 返回重定向，此时重定向的地址是 Tomcat 的地址，我们需要将之修改使之成为 Nginx 的地址）。 配置完成后，将本地的 Spring Boot 打包好的 jar 上传到 Linux ，然后在 Linux 上分别启动两个 Spring Boot 实例： 12nohup java -jar sessionshare-0.0.1-SNAPSHOT.jar --server.port=8080 &amp;nohup java -jar sessionshare-0.0.1-SNAPSHOT.jar --server.port=8081 &amp; 其中 nohup 表示当终端关闭时，Spring Boot 不要停止运行 &amp; 表示让 Spring Boot 在后台启动 配置完成后，重启 Nginx： 1/usr/local/nginx/sbin/nginx -s reload Nginx 启动成功后，我们首先手动清除 Redis 上的数据，然后访问 192.168.66.128/set 表示向 session 中保存数据，这个请求首先会到达 Nginx 上，再由 Nginx 转发给某一个 Spring Boot 实例： 如上，表示端口为 8081 的 Spring Boot 处理了这个 /set 请求，再访问 /get 请求： 可以看到，/get 请求是被端口为 8080 的服务所处理的。","link":"/2020/04/17/nosql/springboot%E5%AE%9E%E7%8E%B0session%E5%85%B1%E4%BA%AB/"},{"title":"Redis位图的操作","text":"Redis位图的操作一、基本介绍​ 用户一年的签到记录，如果你用 string 类型来存储，那你需要 365 个 key/value，操作起来麻烦。通过位图可以有效的简化这个操作。 它的统计很简单： 01111000111 ​ 每天的记录占一个位，365 天就是 365 个位，大概 46 个字节，这样可以有效的节省存储空间，如果有一天想要统计用户一共签到了多少天，统计 1 的个数即可。 对于位图的操作，可以直接操作对应的字符串（get/set），可以直接操作位（getbit/setbit）. 二、基本操作1、零存整取存储的方式以二进制形式，取出的方式以字符串 例如：存储字符串Java 字符 ASCII 十进制 J 74 01001010 a 97 01100001 v 118 01110110 在redis中使用set [key] [offset] [value]的形式设置当前字母的bit位，设置1的位置即可，0无需设置 修改 key 对应的 value 在 offset(偏移) 处的 bit 值 设置J set name 1 1 set name 4 1 set name 6 1 设置a set name 9 1 set name 10 1 set name 15 1 设置v set name 17 1 set name 18 1 set name 19 1 set name 21 1 set name 22 1 设置a set name 25 1 set name 26 1 set name 31 1 取出字符串: 1get name #==&gt; \"Java\" 2、整存零取存一个字符串进去，但是通过位操作获取字符串 设置值： 1set k1 louchen.top 此时字符串一共有11*8位=88个二进制字符 获取二进制位： key 对应的 value 在 offset 处的 bit 值。 getbit [key] [offset] 1234getbit k1 0getbit k1 1......getbit k1 87 三、统计1、bitcount统计二进制中1的个数 注意：这里的start和end表示字符的起始（包含start,end），而不是bit位的起始 bitcount [key] [start] [end] 2、bitpos统计在0或1第一次出现的位置 bit ：0或1 start/end: 字符出现的位置(包含start，end),不是bit位的起始 bitpos [key] [bit] [start] [end] 四、Bit批处理在 Redis 3.2 之后，新加了一个功能叫做 bitfiled ，可以对 bit 进行批量操作。 1、bitfield单个获取BITFIELD name get u4 0 表示获取 name 中的位，从 0 开始获取，获取 4 个位，返回一个无符号数字。 u 表示无符号数字 i 表示有符号数字，有符号的话，第一个符号就表示符号位，1 表示是一个负数。 BITFIELD name get u4 0 即 0100 ==&gt; 6 BITFIELD name get i4 0 即0100 ==&gt; 6 bitfield name get u4 1 即 1001==&gt;9 bitfield name get i4 1 即 1001 ，首位为1那么这个二进制位负数 ，则 -8+1=-7 批量获取：bitfield name get u4 1 get i4 1 get u4 0 get i4 0 2、setfieldbitfield name set u8 8 98 表示从第8位开始获取8个无符号二进制位大小的数替换为98 此时的Java==&gt;Jbva 3、incrby对指定范围进行自增操作，自增操作可能会出现溢出，既可能是向上溢出，也可能是向下溢出。Redis 中对于溢出的处理方案是折返。 8位无符号数 255 加 1 溢出变为 0；8 位有符号数 127，加 1 变为 - 128. 默认的的溢出策略： 在Jbva基础上操作 bitfield name incrby u2 6 1 设置第6位开始，将2个bit位后面加1 ，即10 加1，得 11 ==&gt; 01001011 get name ==&gt; &quot;Kbva&quot; bitfield name incrby u2 6 1 还是从第六位开始，在两个bit位后面加1，即 11 加 1，溢出。 则将这两位全部置为0 ==&gt; 01001000 get name ==&gt; &quot;Hbva&quot; 修改默认的溢出策略： 在我们对Hbva基础上操作 H: 010010 00 fail策略： bitfield name overflow fail incrby u2 6 1 执行上述命令三次 get name ==&gt; &quot;Kbva&quot; 此时K: 010010 11 再次执行 bitfield name overflow fail incrby u2 6 1 1) (nil) 操作失败！ 此时的值还是为 “Kbva” sat策略 bitfield name overflow fail incrby u2 6 1 无论执行多少次，值还是不会变。保持原来的最大或最小值 1) (integer) 3","link":"/2020/04/25/redis/Redis%E4%BD%8D%E5%9B%BE%E6%93%8D%E4%BD%9C/"},{"title":"SpringBoot邮件监控报警","text":"SpringBoot邮件监控报警但我们要用SBA(Spring-Boot-Admin)实现应用的监控并实时了解应用的上下线时，我们可以使用邮件报警的方式 一、服务端配置1、pom.xmlspring-boot-admin-starter-server spring-boot-starter-mail 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;admin&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;admin&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-boot-admin.version&gt;2.2.1&lt;/spring-boot-admin.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-starter-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-dependencies&lt;/artifactId&gt; &lt;version&gt;${spring-boot-admin.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、properties配置12345678910111213141516171819202122#指定邮件服务器的地址 这里我们使用qq的smtp服务器发送邮件spring.mail.host=smtp.qq.com# 服务器的端口号修改成465或587；spring.mail.port=587# 邮件发送者的邮件spring.mail.username=421192425@qq.com# 这里使用的为授权码（不能使用邮箱密码）spring.mail.password=eqsdqizwdnenbgif#设置默认编码spring.mail.default-encoding=UTF-8#设置ssl协议spring.mail.properties.mail.smtp.socketFactory.class=javax.net.ssl.SSLSocketFactory#打印发送邮件的日志spring.mail.properties.mail.debug=true#邮件发送给谁spring.boot.admin.notify.mail.to=421192425@qq.com#谁发的spring.boot.admin.notify.mail.from=421192425@qq.com#忽略的事件（这里没有配置，则应用的上线和下线都要发送邮件）spring.boot.admin.notify.mail.ignore-changes= 3、开启admin服务12345678@SpringBootApplication//开启admin服务@EnableAdminServerpublic class AdminApplication { public static void main(String[] args) { SpringApplication.run(AdminApplication.class, args); }} 二、客户端配置(监控的应用)1、pom.xmlspring-boot-starter-actuator spring-boot-admin-starter-client 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;client&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;client&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-boot-admin.version&gt;2.2.1&lt;/spring-boot-admin.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-starter-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-dependencies&lt;/artifactId&gt; &lt;version&gt;${spring-boot-admin.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、客户端信息配置12345#暴露所有端口信息management.endpoints.web.exposure.include=*server.port=8081#声明该客户端的url地址spring.boot.admin.client.url=http://localhost:8080 3、启动应用三、应用上下线邮件提示1、上线邮件模板spring-boot-application (65685b0ef8f8) is UPInstance 65685b0ef8f8 changed status from UNKNOWN to UP Status DetailsRegistrationService Url http://LAPTOP-LJJM9R29:8081/Health Url http://LAPTOP-LJJM9R29:8081/actuator/healthManagement Url http://LAPTOP-LJJM9R29:8081/actuator 2、下线邮件模板spring-boot-application (65685b0ef8f8) is OFFLINEInstance 65685b0ef8f8 changed status from UP to OFFLINE Status Detailsexceptionio.netty.channel.AbstractChannel$AnnotatedConnectExceptionmessageConnection refused: no further information: LAPTOP-LJJM9R29/169.254.1.137:8081RegistrationService Url http://LAPTOP-LJJM9R29:8081/Health Url http://LAPTOP-LJJM9R29:8081/actuator/healthManagement Url http://LAPTOP-LJJM9R29:8081/actuator","link":"/2020/04/17/projectcontrol/SpringBoot%E9%82%AE%E4%BB%B6%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6/"},{"title":"IDEA快捷键详解","text":"一、idea快捷键1234567891011121314151617181920212223242526272829303132333435363738394041ctrl + D 赋值ctrl + y 删除该行ctrl + / 单行注释ctrl +shift +/ 多行注释ctrl +alt +T 快速插入包围的代码 try catch if whilectrl + alt +v 快速生成返回类型ctrl + alt +L 整理代码格式ctrl+shift+F10 执行代码ctrl+shift+alt+N 搜索类ctrl+F12 查看当前类下的所有方法ctrl+alt+b 查看所有实现或继承该接口的类ctrl+o 查看可重写该类 方法ctrl+h 查看该类的继承数关系ctrl+w 按照范围由小到大选择代码区域ctrl+f9 重新编译ctrl+N 全局查找ctrl+shift+N 查找ctrl+F 当前文件查询ctrl+R 查找替换ctrl+E 弹出最近使用的文件ctrl+F4 关闭当前窗口ctrl+alt+shift+u 展示树状图类的继承关系ctrl+insert 复制选中的内容ctrl+shift 粘贴选中的内容ctrl+shift+u 将选中的单词全部转为大写/小写Ctrl+shift+enter 整理当前行代码格式/结束当前语句/加分号ctrl+j 插入代码模板shift+enter 换行shift 搜索全局文件shift + F6 选中文件和文件夹 修改名称shift+alt 鼠标点击多出，生成多个光标alt+Enter 快速导包alt+/ 代码提示alt+insert 快速插入属性，tostring 构造函数alt+insert 选中文件夹，快速创建一个文件alt+E 打开最近的文件选中项目+F4 //查看项目结构配置选中文件夹+F6 //移动文件夹到别的目录 二、代码多选和多选换行：多选换行：按住alt键选中多行，再按shift后回车。可多选换行。三、强制刷新浏览器12CTRL+F5 //强制刷新浏览器（清除缓存保留的js和css,等）CTRL+sift+del //快捷键 清除浏览器cookie和session 四、定义代码片段1、定义list后缀补全片段①File–&gt;Setting–&gt;Editor–&gt;General–&gt;Postfix Completion ②点击＋号–&gt;选择java–&gt;输入key为list–&gt;选择java1.8及以上(Minimum language level:8-lambdas,type annotations etc) ③定义表达式： 1List&lt;$EXPR$&gt; $END$ =new ArrayList&lt;&gt;(); ④使用： 1集合类型.list 2、定义mapper.xml模板①File–&gt;New–&gt;Edit File Templates–&gt;默认在Files下 ②点击+号–&gt;输入Name为模板名称–&gt;Extension为文件扩展类型 ③定义模板内容： 123456&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" &gt;&lt;mapper namespace=\"#[[$Title$]]#\"&gt; &lt;/mapper&gt; ④勾选√ Enabled Live Templates (启用激活模板) 3、定义单元测试片段①ctrl+j–&gt;点击灯泡–&gt; 或者 File–&gt;Setting–&gt;Editor–&gt;Live Templates ②点击+号–&gt;自定义一个组(Template Group)/直接定义一个片段(Live Tempalte)–&gt;在Abbreviation输入片段名称–&gt;输入描述 ③定义代码片段： $name$ :变量输入的位置 $END$: 光标最后的停留位置 1234@Testpublic void $name$Test(){ $END$} ④点击Define ， 勾选只在java中使用","link":"/2020/04/17/other/idea%E4%BD%BF%E7%94%A8/"},{"title":"Redis正确安装的几种姿势","text":"Redis正确安装的几种姿势一、在线体验RedisRedis官网 http://try.redis.io/ ####二、直接编译安装 1、准备gcc环境 基于c++1yum install gcc-c++ 2、下载安装Redis12345678910#下载安装包wget http://download.redis.io/releases/redis-5.0.8.tar.gz#解压tar -zxvf redis-5.0.8.tar.gz #切换到解压目录cd redis-5.0.8#编译make#安装make install 3、启动Redis1redis-server redis.conf 4、后台启动Redis1234#修改安装目录下的 redis.conf文件daemonize no 变更为: daemonize yes #保存退出，再次启动redis-server redis.conf 5、关闭redis①redis-cli shutdown②kill -9 ‘pid’12#搜索到该进程 强行关闭ps -ef|grep redis 6、redis外网访问并设置永久密码修改redis.conf文件 12345bind 127.0.0.1注释掉，即变更为：#bind 127.0.0.1#去掉保护模式(有密码时无需设置)protected-mode yes 修改为 protected-mode no #设置永久密码(默认无需密码)#requirepass footbared 修改为 requirepass 自己的密码 7、进入命令行1redis-cli -a '密码' 三、docker安装(推荐方式)1、镜像安装与容器创建1234//拉取镜像docker pull redis//创建容器 --requirepass 123 设置密码123docker run -d -p 6379:6379 --restart=always --name myredis 镜像名 --requirepass 123 2、查看redis版本docker exec -it 9a7d1cf2c234 redis-cli -v //查看版本 3、修改redis密码（临时，重启失效）①进入redis管理页面不带密码进入（进入后需验证）==&gt; docker exec -it 9a7d1cf2c234 redis-cli //进入redis管理界面 带密码进入（进入后无需验证）==&gt; docker exec -it 9a7d1cf2c234 redis-cli -a '密码' //带密码进入管理界面 ②查询密码config get requirepass //查看密码(初始为空) ③设置密码config set requirepass 密码 //设置密码 ④验证密码auth 密码 //验证密码才能够进行查询密码和设置密码等操作 4、redis-cli连接docker上的redis①宿主机上的客户端(redis-cli)连接docker中的服务端1redis-cli -a '密码' ②进入docker容器中操作服务端1docker exec -it 9a7d1cf2c234 redis-cli 四、直接安装centos:1yum insatll redis ubuntu:1apt-get install redis mac:1brew install redis","link":"/2020/04/20/redis/Redis%E5%AE%89%E8%A3%85%E6%96%B9%E5%BC%8F/"},{"title":"Jedis和Letture客户端连接Redis","text":"Jedis和Letture客户端连接Redis一、JedisJedis官网地址： https://github.com/xetorthio/jedis 基本配置使用①、pom.xml1234567&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt; ②、简单的配置12345678910111213141516171819public class MyJedis { public static void main(String[] args) {// 1、构造一个jedis对象，并设置端口（默认6379） Jedis jedis=new Jedis(\"47.96.141.44\",6379);// 2、密码验证 jedis.auth(\"你的密码\");// 3、测试是否连接成功 String ping = jedis.ping();// 输出pong 表示连接成功 System.out.println(ping);// 在jedis中，操作键值的方法和在Redis命令行中的api完成一致。这里不再过多赘述// jedis.set()// jedis.zadd()// jedis.hset()// jedis.lpush()// jedis.sadd() }} ②、连接池配置在实际应用中，Jedis 实例我们一般都是通过连接池来获取，由于 Jedis 对象不是线城安全的，所以，当我们使用 Jedis 对象时，从连接池获取 Jedis，使用完成之后，再还给连接池。 12345678910111213141516171819 public static void main(String[] args) { Jedis jedis=null;// 1、构造一个jedis连接池 JedisPool pool = new JedisPool(\"47.96.141.44\", 6379);// 2、从连接池中获取一个jedis连接 jedis = pool.getResource(); try {// 3、jedis测试连接操作 String ping = jedis.ping(); System.out.println(ping); } catch (Exception e) { e.printStackTrace(); } finally {// 4、归还连接 if (jedis!=null) { jedis.close(); } } } try语法糖的使用： 这里我们使用一个语法糖，只是一种简写的方式，编译最后其实还是转为try-catch-finally的形式 1234567891011public static void main(String[] args) {// 1、构造一个jedis连接池 JedisPool pool = new JedisPool(\"47.96.141.44\", 6379);// 2、从连接池中获取一个jedis连接 try(Jedis jedis = pool.getResource()){// 认证密码 jedis.auth(\"你的密码\"); String ping=jedis.ping(); System.out.println(ping); } } 最后的编译的文件 1234567891011121314151617181920212223242526public static void main(String[] args) { JedisPool pool = new JedisPool(\"47.96.141.44\", 6379); Jedis jedis = pool.getResource(); Throwable var3 = null; try { jedis.auth(\"你的密码\"); String ping = jedis.ping(); System.out.println(ping); } catch (Throwable var12) { var3 = var12; throw var12; } finally { if (jedis != null) { if (var3 != null) { try { jedis.close(); } catch (Throwable var11) { var3.addSuppressed(var11); } } else { jedis.close(); } } } } ③、对连接池的改进，实现强约束 CallWithJedis 123public interface CallWithJedis { void call(Jedis jedis);} Redis 12345678910111213141516171819202122232425262728293031public class Redis { private JedisPool jedisPool; public Redis() {// 连接池配置对象 GenericObjectPoolConfig config=new GenericObjectPoolConfig();// 连接池最大空闲数 config.setMaxIdle(300);// 最大连接数 config.setMaxTotal(1000);// 连接最大等待时间（毫秒）。-1表示无限制 config.setMaxWaitMillis(30000);// 在空闲时检查有效性 config.setTestOnBorrow(true); /** * 1、连接池配置 * 2、redis地址 * 3、端口 * 4、超时时间 * 5、密码 */ jedisPool = new JedisPool(config, \"47.96.141.44\",6379,30000,\"你的密码\"); } public void execute(CallWithJedis callWithJedis) { try (Jedis jedis=jedisPool.getResource()) { callWithJedis.call(jedis); } }} 测试使用： 1234567891011public class JedisPoolUtil { public static void main(String[] args) {// 初始化连接池 Redis redis=new Redis();// 完成jedis的获取，并执行实现 redis.execute(jedis -&gt; { String ping = jedis.ping(); System.out.println(ping); }); }} 二、Lettureletture官网地址：https://github.com/lettuce-io/lettuce-core 基本配置使用①、pom.xml12345&lt;dependency&gt; &lt;groupId&gt;io.lettuce&lt;/groupId&gt; &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt; &lt;version&gt;5.1.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; ②、使用1234567891011public class LettuceTest { public static void main(String[] args) {// 注意这里的redis密码可以写在url地址中 RedisClient redisClient = RedisClient.create(\"redis://你的密码@47.96.141.44\"); StatefulRedisConnection&lt;String, String&gt; connect = redisClient.connect(); RedisCommands&lt;String, String&gt; sync = connect.sync(); sync.set(\"name\", \"lc\"); String s = sync.get(\"name\"); System.out.println(s); }} 三、Jedis和Lettuce的比较共同点：Lettuce和Jedis的定位都是Redis的cilent,所以他们当然可以直接连接redis server 不同点：①应用场景Jedis：是Redis的Java实现客户端，提供了比较全面的Redis命令的支持。使用阻塞的I/O，且其方法调用都是同步的，程序流需要等到sockets处理完I/O才能执行，不支持异步。Jedis客户端实例不是线程安全的，所以需要通过连接池来使用Jedis。 Lettuce：高级Redis客户端，用于线程安全同步，异步和响应使用，支持集群，Sentinel，管道和编码器。 基于Netty框架的事件驱动的通信层，其方法调用是异步的。Lettuce的API是线程安全的，所以可以操作单个Lettuce连接来完成各种操作。主要在一些分布式缓存框架上使用比较多。 ②线程安全Jedis：在实现上是直接连接的Redis Server，如果在多线程环境下是非线程安全的。每个线程都去拿自己的 Jedis 实例，当连接数量增多时，资源消耗阶梯式增大，连接成本就较高了。 解决方式: 使用连接池，为每个Jedis实例增加物理连接 Lettuce： Lettuce的连接是基于Netty的，连接实例（StatefulRedisConnection）可以在多个线程间并发访问，应为StatefulRedisConnection是线程安全的，所以一个连接实例（StatefulRedisConnection）就可以满足多线程环境下的并发访问，当然这个也是可伸缩的设计，一个连接实例不够的情况也可以按需增加连接实例。 总结1、Jedis 在实现的过程中是直接连接 Redis 的，在多个线程之间共享一个 Jedis 实例，这是线程不安全的，如果想在多线程场景下使用 Jedis，就得使用连接池，这样，每个线程都有自己的 Jedis 实例。 2、Lettuce 基于目前很火的 Netty NIO 框架来构建，所以克服了 Jedis 中线程不安全的问题，Lettuce 支持同步、异步 以及 响应式调用，多个线程可以共享一个连接实例。","link":"/2020/04/23/redis/Redis%E7%9A%84java%E5%AE%A2%E6%88%B7%E7%AB%AF/"},{"title":"是否担心配置文件被盗获取密码？","text":"SpringBoot配置文件加密​ 当我们在发布项目部署的时候，是否会发现配置文件被暴露在环境中，且配置文件里面的密码为明文，这样非常不安全。 例如： 123456789101112spring: datasource: driver-class-name: com.mysql.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource username: root #明文 不安全 password: 123456 redis: database: 0 #明文 不安全 password: 123456 port: 6379 这是我们需要一个加密组件jasypt-spring-boot 一、引入组件依赖123456&lt;!--配置文件加密--&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.ulisesbocchio&lt;/groupId&gt; &lt;artifactId&gt;jasypt-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt;&lt;/dependency&gt; 二、加入加密密钥(盐)我们在application.yaml中加入以下配置 123jasypt: encryptor: password: louchen 可以理解为jasypt会使用这个自定义加密密钥，对配置文件里的重要项进行加密。 三、加密测试使主配置类实现CommandLineRunner接口,在启动程序时输出指定内容 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@SpringBootApplicationpublic class VrhApplication implements CommandLineRunner { @Autowired private ApplicationContext appCtx @Autowired private StringEncryptor stringEncryptor; public static void main(String[] args) { SpringApplication.run(VrhApplication.class, args); } @Override public void run(String... args) throws Exception { //读取配置文件 Environment environment = appCtx.getBean(Environment.class); // 首先获取配置文件里的原始明文信息 String mysqlOriginPswd = environment.getProperty(\"spring.datasource.password\"); String redisOriginPswd = environment.getProperty(\"spring.redis.password\"); String mysqlencrypt = encrypt(mysqlOriginPswd); System.out.println(\"加密:\"+mysqlOriginPswd+\"&gt;&gt;&gt;&gt;&gt;密文:\"+ mysqlencrypt); System.out.println(\"解密:&gt;&gt;&gt;&gt;&gt;明文:\"+decrypt(mysqlencrypt)); System.out.println(\"----------------\"); String redisencrypt = encrypt(redisOriginPswd); System.out.println(\"加密:\"+mysqlOriginPswd+\"&gt;&gt;&gt;&gt;&gt;密文:\"+ redisencrypt); System.out.println(\"解密:&gt;&gt;&gt;&gt;&gt;明文:\"+decrypt(redisencrypt)); } /** * 加密 * @param orginPws 明文 * @return */ private String encrypt(String orginPws){ return stringEncryptor.encrypt(orginPws); } /** *解密 * @param depryptPwd 密文 * @return */ private String decrypt(String depryptPwd){ return stringEncryptor.decrypt(depryptPwd); }} 四、修改配置文件替换明文123456789101112spring: datasource: driver-class-name: com.mysql.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource username: root #替换的密文 password: ENC(HRdQoZQEkagFOmHEFP3+FAPHasQJoxHmgezz559eMnBhGj2W1nj) redis: database: 0 #替换的密文 password: ENC(YJvMXx9L4h3dr3gPFr+lm1wA1WGTordEGSDhymm8YtnN43yReAp5udGy662) port: 6379 这里我们可以看出。在代码中使用时，jasypt-spring-boot组件会自动将ENC()语法包裹的配置项加密字段自动解密，数据得以还原。 五、加密密钥为什么在ENC()中，可以更改吗？自定义加密前缀12345jasypt: encryptor: property: prefix: lc( suffix: ) 再次修改application.yaml文件 123456789101112spring: datasource: driver-class-name: com.mysql.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource username: root #替换的密文 password: lc(HRdQoZQEkagFOmHEFP3+FAPHasQJoxHmgezz559eMnBhGj2W1nj) redis: database: 0 #替换的密文 password: lc(YJvMXx9L4h3dr3gPFr+lm1wA1WGTordEGSDhymm8YtnN43yReAp5udGy662) port: 6379 六、担心jasypt.encryptor.password设置的盐被泄露？我们的加密密钥放在配置application.yaml中难免有些不安全，这时我们可以使用自定义加密器 使用自定义加密器我们自自定义一个加密器配置类即可 123456789101112131415161718192021222324@Configurationpublic class ConfigEncryptBean { @Bean public StringEncryptor lcEncryptBean() { PooledPBEStringEncryptor encryptor=new PooledPBEStringEncryptor(); SimpleStringPBEConfig config=new SimpleStringPBEConfig();// 设置盐 config.setPassword(\"louchen\");// 设置加密算法 config.setAlgorithm(\"PBEWITHHMACSHA512ANDAES_256\");// 迭代次数 config.setKeyObtentionIterations(\"1000\");// 池的大小 config.setPoolSize(\"1\"); config.setProviderName(\"SunJCE\"); config.setSaltGeneratorClassName(\"org.jasypt.salt.RandomSaltGenerator\"); config.setIvGeneratorClassName(\"org.jasypt.iv.RandomIvGenerator\"); config.setStringOutputType(\"base64\"); encryptor.setConfig(config); return encryptor; }} 注意：上面bean的名字默认为方法名。我们可以使用@Bean注解更改bean的名称· 更改application.yaml 1234567# 加密配置jasypt: encryptor: property: prefix: lc( suffix: ) bean: lcEncryptBean 这是我们的密钥盐就在bean中，比较安全的防止别人获取盐 七、其他密钥设置方式方式一：直接作为程序启动时的命令行参数来带入 java -jar yourproject.jar --jasypt.encryptor.password=louchen 方式二：直接作为程序启动时的应用环境变量来带入 java -Djasypt.encryptor.password=louchen -jar yourproject.jar 方式三：甚至可以作为系统环境变量的方式来带入 比方说，我们提前设置好系统环境变量JASYPT_ENCRYPTOR_PASSWORD = louchen，则直接在Spring Boot的项目配置文件中做如下配置即可： jasypt.encryptor.password=${JASYPT_ENCRYPTOR_PASSWORD:} 这时候也会安全得多。","link":"/2020/04/25/springboot/SpringBoot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86/"},{"title":"springboot开发者工具及单元测试","text":"springboot开发者工具及单元测试一、使用devtools热部署1、idea与eclipse运行和编译的区别:①eclipse没有自动保存的功能，所有我们在使用eclipse时，保存之后，eclipse就进行编译了，点击运行就直接运行了，所以启动时，eclipse相对较快 ②idea是点击运行的时候，才进行编译，然后运行的。 2、使用热部署后，我们只需要点击编译，项目即重新编译运行。3、热部署默认只会对类的修改进行重新编译，对静态资源无效①配置静态资源的热部署任选一种即可 1234567spring: devtools: restart:# 包含能够热部署的位置 （需要从src下进行配置） additional-paths: src/main/resources/static# 排除默认配置中不能热部署的位置# exclude: classpath:/static/** pom.xmlspring-boot-devtools 123456789101112131415161718192021222324252627&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;!--只在运行时有效--&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;!--防止devtools传递到其他模块 即修改该类时，引用该模块的不需要动态更新--&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 4、使用liveReload插件动态更新静态资源google下载liveReload插件 这里我们禁用了只要修改文件就自动编译。而是我们修改之后去手动点击编译。 修改静态文件后==&gt; 点击编译==&gt;点击浏览器liveReload即可动态刷新页面 禁止自动更新页面: 1234spring: devtools: livereload: enabled: false 5、禁用热部署（如果pom中有此依赖）1234spring: devtools: restart: enabled: false 或者==&gt; 123456789@SpringBootApplicationpublic class JpaRestApplication { public static void main(String[] args) { System.setProperty(\"spring.devtools.restart.enabled\", \"false\"); SpringApplication.run(JpaRestApplication.class, args); }} 6、使用触发文件进行重启1234spring: devtools: restart: trigger-file: .trigger-file 在resources下新建一个名为.trigger-file.txt的文件==&gt; 当类修改时，编译不会重启，修改.trigger-file.txt ，再点击编译 ，即可重启 当类没有修改时，编译不会重启，修改.trigger-file.txt，再点击编译，也不会重启 7、使用全局触发文件当我们使用微服务的时候，只要引用了该修改的模块的都重新加载 在我们当前用户下新建一个 .spring-boot-devtools.properties 文件==&gt; 1spring.devtools.restart.trigger-file=.trigger-file 在resources下新建一个 .trigger-file 文件==&gt; 修改此内容则全局更新引用了该模块的内容 二、springboot中使用单元测试1、基本配置①pom.xml12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; ②Test@RunWith(SpringRunner.class): 使用junit4测试 @SpringBootTest(classes = JpaRestApplication.class) ： 找到主程序 在springboot我们可以省略指定主程序，springboo自动帮我们寻找主程序 @SpringBootTest即可 123456789101112@RunWith(SpringRunner.class)@SpringBootTest(classes = JpaRestApplication.class)class JpaRestApplicationTests { @Autowired private BookService bookService; @Test void contextLoads() { bookService.hello(); }} 2、对接口进行测试①使用MockMVcbean==&gt; 12345678@Setter@Getter@ToStringpublic class Book { private Integer id; private String name; private String author;} controller==&gt; 12345678910111213@RestControllerpublic class HelloController { @GetMapping(\"/hello\") public String hello(String name){ return \"hello\"+name; } @PostMapping(\"/book\") public Book addBook(@RequestBody Book book) { return book; }} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465@RunWith(SpringRunner.class)@SpringBootTest(classes = JpaRestApplication.class)//开启MockMvc自动配置@AutoConfigureMockMvcclass JpaRestApplicationTests { @Autowired WebApplicationContext webApplicationContext; @Autowired MockMvc mockMvc;// 每次只需test方法之前 初始化MockMvc @Before public void before() { mockMvc = MockMvcBuilders.webAppContextSetup(webApplicationContext).build(); } @Test void test1() throws Exception { MvcResult mvcResult = mockMvc.perform(// get请求地址 MockMvcRequestBuilders.get(\"/hello\") //请求头类型 .contentType(MediaType.APPLICATION_FORM_URLENCODED)// 请求参数 .param(\"name\", \"lccc\"))// 期望的结果 .andExpect(MockMvcResultMatchers.status().isOk())// 对结果的处理 打印 .andDo(MockMvcResultHandlers.print())// 返回该对象 .andReturn();// 从结果的响应 打印 System.out.println(mvcResult.getResponse().getContentAsString()); } @Test void test2() throws Exception { Book book=new Book(); book.setId(1); book.setAuthor(\"罗贯中\"); book.setName(\"三国演义\"); //对象转为字符串形式的json String s = new ObjectMapper().writeValueAsString(book); MvcResult mvcResult = mockMvc.perform( //post请求 MockMvcRequestBuilders.post(\"/book\")// 设置请求头类型 .contentType(MediaType.APPLICATION_JSON)// 内容 .content(s))// 期望的目标 .andExpect(MockMvcResultMatchers.status().isOk())// 返回结果 .andReturn(); MockHttpServletResponse response = mvcResult.getResponse();// 设置编码 response.setCharacterEncoding(\"UTF-8\"); System.out.println(response.getContentAsString()); }} ②使用RestTemplate此方法不需要开启主程序 他默认帮我们启动了一个servlet为已定义的端口 123456789101112131415161718@RunWith(SpringRunner.class)//使用环境中确定的端口@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.DEFINED_PORT)class TestTemplate { @Autowired private TestRestTemplate restTemplate; @Test public void test() { /**\"/hello?name={1}\" 请求的地址 * String.class 响应的类型 * \"lcccc\" 参数 */ String lcccc = restTemplate.getForObject(\"/hello?name={1}\", String.class, \"lcccc\"); System.out.println(lcccc); }} 3、json测试……","link":"/2020/04/17/springboot/springboot%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"},{"title":"Spring-Security使用JSON登录","text":"SpringSecurity 整合JSON登录1、pom.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;springsecurity-json&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;springsecurity-json&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、yaml配置临时的用户名密码配置 12345spring: security: user: name: lc password: 123 3、核心配置①自定义认证过滤器在这里我们只是扩展UsernamePasswordAuthenticationFilter的attemptAuthentication获得用户名和参数的规则 123456789101112131415161718192021222324252627282930313233343536373839public class MyAuthenticationFilter extends UsernamePasswordAuthenticationFilter { @Override public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {// 若为非post请求 if (!request.getMethod().equals(\"POST\")) { throw new AuthenticationServiceException(\"Authentication method not supported: \" + request.getMethod()); }// 如果是以json形式的登录方式 if (request.getContentType().equals(MediaType.APPLICATION_JSON_VALUE)) {// 有body的才有流，能够用流去解析 。get和delete没有流 String username = null; String password = null; try {// 从请求流中获取 参数对象 Map&lt;String,String&gt; map = new ObjectMapper().readValue(request.getInputStream(), Map.class); username = map.get(\"username\"); password = map.get(\"password\"); } catch (IOException e) { e.printStackTrace(); } if (username == null) { username = \"\"; } if (password == null) { password = \"\"; } username = username.trim(); UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(username, password); this.setDetails(request, authRequest); return this.getAuthenticationManager().authenticate(authRequest); }// 以key value形式 return super.attemptAuthentication(request, response); }} ②Security配置123456789101112131415161718192021222324252627282930313233343536@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .anyRequest().authenticated() .and()// 登录相关的都运行访问（这里的是默认的登录页） .formLogin().permitAll() .and() .csrf().disable(); http.addFilterAt(myAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class); } @Bean MyAuthenticationFilter myAuthenticationFilter() throws Exception { MyAuthenticationFilter filter = new MyAuthenticationFilter();// 自定义登录成功的处理方法 filter.setAuthenticationSuccessHandler(new AuthenticationSuccessHandler(){ @Override public void onAuthenticationSuccess(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication) throws IOException, ServletException { PrintWriter printWriter=httpServletResponse.getWriter(); httpServletResponse.setContentType(\"text/html\"); printWriter.write(\"hello\"); printWriter.flush(); printWriter.close(); } });// 失败的处理方法 //....... filter.setAuthenticationManager(authenticationManagerBean()); return filter; }} 4、controller12345678910@RestControllerpublic class HelloController { @GetMapping(\"/hello\") public String hello() { return \"hello securtiy\"; }} 5、接口请求测试经过以上的扩展配置，可同时支持post的key-value形式的请求登录和json形式的请求登录 ①key-value形式POST: http://localhost:8080/login content-type: x-www-form-urlencoded 请求参数==&gt; key:username value: lc key:password value:123 ②json形式POST: http://localhost:8080/login content-type: application/json 请求参数==&gt; 1234{ \"username\":\"lc\", \"password\":\"123\"}","link":"/2020/04/17/springsecurity/Spring-Security%E4%BD%BF%E7%94%A8JSON%E7%99%BB%E5%BD%95/"},{"title":"Redis中的HyperLogLog","text":"Redis中的HyperLogLog一、HyperLogLog：1、特点高级不精确去重的数据结构.(一般是超过一百个就开始不准确了)占用空间小(一个键最多12k,可以计算2^64个元素)没有contains操作 因此有些他就支持不了,拓展到 布隆过滤器 适用于一个热点页面的去重访问次数.不适合单个用户的数据统计 2、背景一般我们评估一个网站的访问量，有几个主要的参数： pv，Page View，网页的浏览量 uv，User View，访问的用户 一般来说，pv 或者 uv 的统计，可以自己来做，也可以借助一些第三方的工具，比如 cnzz，友盟 等。 如果自己实现，pv 比较简单，可以直接通过 Redis 计数器就能实现。但是 uv 就不一样，uv 涉及到另外一个问题，去重。 我们首先需要在前端给每一个用户生成一个唯一 id，无论是登录用户还是未登录用户，都要有一个唯一 id，这个 id 伴随着请求一起到达后端，在后端我们通过 set 集合中的 sadd 命令来存储这个 id，最后通过 scard 统计集合大小，进而得出 uv 数据。 如果是千万级别的 UV，需要的存储空间就非常惊人。而且，像 UV 统计这种，一般也不需要特别精确，800w 的 uv 和 803w 的 uv，其实差别不大。所以，我们要介绍今天的主角—HyperLogLog Redis 中提供的 HyperLogLog 就是专门用来解决这个问题的，HyperLogLog 提供了一套不怎么精确但是够用的去重方案，会有误差，官方给出的误差数据是 0.81%，这个精确度，统计 UV 够用了。 二、在Redis中的基本命令1、pfadd用来添加记录，类似于 sadd ，添加过程中，重复的记录会自动去重。 element：用户的标识 pfadd [key] [element...] 2、pfcount统计一个或多个key的值的个数。取并集（去重），这种操作不会改变原key的大小 pfcount [key] [key...] 12345pfadd k1 u1 u2 u3 u4pfcount k1 #==&gt; 4pfadd k2 u4 u5pfcount k2 #==&gt; 2pfcount k1 k2 #===&gt; 5 3、pfmerge合并多个key到某一个key中，会去重。会改变目标key的大小 destkey :目标key sourcekey 源key pfmerge destkey sourcekey [sourcekey...] 1234pfcount uv #==&gt; 994pfadd u1 aa bb #==&gt;添加不在uv的两个值 aa bbpfmerge u1 uv #==&gt;合并uv到u1中pfcount u1 #==&gt; 996 三、通过java代码来模拟大数据量的用户访问先准备连接redis代码 1234567891011121314151617181920212223242526272829303132public class Redis { private JedisPool jedisPool; public Redis() {// 连接池配置对象 GenericObjectPoolConfig config=new GenericObjectPoolConfig();// 连接池最大空闲数 config.setMaxIdle(300);// 最大连接数 config.setMaxTotal(1000);// 连接最大等待时间（毫秒）。-1表示无限制 config.setMaxWaitMillis(30000);// 在空闲时检查有效性 config.setTestOnBorrow(true); /** * 1、连接池配置 * 2、redis地址 * 3、端口 * 4、超时时间 * 5、密码 */ jedisPool = new JedisPool(config, \"主机\",6379,30000,\"你的密码\"); } public void execute(CallWithJedis callWithJedis) { try (Jedis jedis=jedisPool.getResource()) { callWithJedis.call(jedis); } }} 123public interface CallWithJedis { void call(Jedis jedis);} 1234567891011121314public class HyperLogLogTest { public static void main(String[] args) { Redis redis = new Redis(); redis.execute(jedis -&gt; { for (int i = 0; i &lt; 1000; i++) {// 理论上我们累加的为1001次 jedis.pfadd(\"uv\", \"u\"+i,\"u\"+(i+1)); } long uv = jedis.pfcount(\"uv\"); //实际输出 994 System.out.println(uv); }); }} 理论值是 1001，实际打印出来 994，有误差，但是在可以接受的范围内。","link":"/2020/04/27/redis/Redis%E4%B9%8BHyperLogLog/"},{"title":"SpringSecurity项目使用总结","text":"SpringSecurity项目使用总结一、在SpringSecurity中获取和设置的登录用户信息在任何地方获取和设置用户登录信息 直接注入Authentication对象 通过getPrincipal()获取用户信息 1234@GetMapping(\"/hr/info\")public Hr getCurrentHr(Authentication authentication) { return ((Hr) authentication.getPrincipal());} SecurityContextHolder.getContext().getAuthentication() 是一个静态方法，也就是利用这个方法，我们可以随时随地拿到用户信息（需要注意 ThreadLocal 的限制），即当前获取的不能为其他线程或子线程，必须为当前的本地线程 获取用户信息： 1Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); 设置用户信息： authResult为Authentication对象 SecurityContextHolder.getContext().setAuthentication(authResult); 123456 @PutMapping(\"/hr/info\")//这里直接注入Authentication public ResponseBean updateHr(@RequestBody Hr hr,Authentication authentication){ SecurityContextHolder.getContext().setAuthentication(new UsernamePasswordAuthenticationToken(hr,authentication.getCredentials(),authentication.getAuthorities())); } 二、SpringSecurity登录流程","link":"/2020/04/17/springsecurity/SpringSecurity%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98/"},{"title":"sprinboot与mongodb构建restful风格","text":"sprinboot与mongodb构建restful风格所有的请求模式和jpa构建的restful一致 1、pom.xmlspring-boot-starter-data-rest spring-boot-starter-data-mongodb 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;jpa-rest&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;jpa-rest&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-rest&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、实体bean12345678@Setter@Getter@ToStringpublic class Book { private Integer id; private String name; private String author;} 3、dao接口配置123public interface BookDao extends MongoRepository&lt;Book,Integer&gt; {} 4、yaml配置1234567891011spring: data: mongodb: # mongodb每个库都有自己的认证方式 authentication-database: lc username: root password: 你的密码 port: 27017 database: lc uri: mongodb://root:你的密码@47.96.141.44:27017/lc# host: 47.96. 5、接口测试1、添加数据post: http://localhost:8080/books 123456789101112{ \"name\": \"曹雪芹\", \"author\": \"红楼梦\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/books/1\" }, \"book\": { \"href\": \"http://localhost:8080/books/1\" } }} 2、查询所有get: http://localhost:8080/books 123456789101112131415161718192021222324252627282930313233{ \"_embedded\": { \"books\": [ { \"name\": \"曹雪芹\", \"author\": \"红楼梦\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/books/1\" }, \"book\": { \"href\": \"http://localhost:8080/books/1\" } } } ] }, \"_links\": { \"self\": { \"href\": \"http://localhost:8080/books{?page,size,sort}\", \"templated\": true }, \"profile\": { \"href\": \"http://localhost:8080/profile/books\" } }, \"page\": { \"size\": 20, \"totalElements\": 1, \"totalPages\": 1, \"number\": 0 }}","link":"/2020/04/17/restful/mongodb%E6%9E%84%E5%BB%BArestful%E9%A3%8E%E6%A0%BC/"},{"title":"Windows常用命令","text":"命令 -help //第1种形式的使用帮助 命令 /? //第2种形式的使用帮助 1，列出所有任务及进程号，杀进程 ​ tasklist ​ tasklist /? 获取使用帮助 ​ taskkill ​ taskkill /? 获取使用帮助 2，cd 切换目录 cd /? //获取使用帮助 cd \\ //跳转到硬盘的根目录 cd C:\\WINDOWS //跳转到当前硬盘的其他文件 d: //跳转到其他硬盘 cd /d e:\\software //跳转到其他硬盘的其他文件夹 注意此处必须加/d参数。否则无法跳转。 cd.. //跳转到上一层目录 3，netstat 查看网络连接状态1234567显示协议统计信息和当前 TCP/IP 网络连接。该命令可以查看当前机器建立的所有网络链接状态，以及对应哪个进程。netstat -help 获取命令行使用帮助信息netstat -ano //查看所有网络连接、状态以及对应的进程idnetstat -ano|findstr \"8081\" //查看被占用端口对应的 PIDtasklist|findstr \"9088\" //查看指定 PID 的进程taskkill /PID 9088 //终止 pid 为 9088的进程taskkill /T /F /PID 9088 //强制（/F参数）杀死 pid 为 9088 的所有进程包括子进程（/T参数） 5，ping 查看网络连通性​ ping -help 6，tracerttracert也被称为Windows路由跟踪实用程序，在命令提示符（cmd）中使用tracert命令可以用于确定IP数据包访问目标时所选择的路径。 tracert /? 获取使用帮助 例子：tracert www.baidu.com7、ipconfig #查看自己的ip8、cls 清屏9、telnet使用测试连接指定主机的端口地址 telnet 47.96.141.44 8081","link":"/2020/04/17/shell/windows-10/"},{"title":"Springboot整合Shiro","text":"Springboot整合Shiro拦截器介绍 https://www.jianshu.com/p/54b573c7b4db https://blog.csdn.net/fenglixiong123/article/details/77119857 一、整合Shiro1、pom.xml shiro-spring shiro-web 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;springboot-shiro&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;springboot-shiro&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-web&lt;/artifactId&gt; &lt;version&gt;1.4.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.4.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、Realm配置12345678910111213141516public class MyRealm extends AuthorizingRealm { @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) { return null; } @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException { String username = (String) authenticationToken.getPrincipal(); if (\"lc\".equals(username)) { return new SimpleAuthenticationInfo(username, \"123\", getName()); } return null; }} 3、shiro配置123456789101112131415161718192021222324@Configurationpublic class ShrioConfig { @Bean Realm realm() { TextConfigurationRealm realm =new TextConfigurationRealm();// 设置用户和角色 realm.setUserDefinitions(\"lc=123,user \\n admin=123,admin\");// 设置角色权限 realm.setRoleDefinitions(\"admin=read,write \\n user=read\"); return realm; } @Bean ShiroFilterChainDefinition shiroFilterChainDefinition() { DefaultShiroFilterChainDefinition definition=new DefaultShiroFilterChainDefinition(); definition.addPathDefinition(\"/doLogin\", \"anon\"); definition.addPathDefinition(\"/**\", \"authc\"); return definition; }} 4、controller123456789101112131415161718192021222324252627@RestControllerpublic class LoginController { @GetMapping(\"/hello\") public String hello() { return \"hello shiro\"; } @GetMapping(\"/login\") public String login() { return \"please login!\"; } @PostMapping(\"/doLogin\") public void doLogin(String username,String password) { Subject subject = SecurityUtils.getSubject(); try { subject.login(new UsernamePasswordToken(username, password)); System.out.println(\"登录成功！\"); } catch (AuthenticationException e) { System.out.println(); System.out.println(\"登录失败！\"+e.getMessage()); } }} 二、spring-boot-starter 整合shrio1、pom.xmlshiro-spring-boot-web-starter 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;springbootstarter-shiro&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;springbootstarter-shiro&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring-boot-web-starter&lt;/artifactId&gt; &lt;version&gt;1.4.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、yaml配置1234567891011121314shiro: enabled: true unauthorizedUrl: /unauthorizedUrl web: enabled: true successUrl: /success loginUrl: /login # 就是每次请求是否支持把sessionid放在cookie中或者通过url携带sessionid# sessionManager:# 是否允许通过url实现会话跟踪# sessionIdUrlRewritingEnabled: true# 是否允许放在cookie中# sessionIdCookieEnabled: true 3、shiro配置123456789101112131415161718192021@Configurationpublic class ShrioConfig { @Bean Realm realm() { TextConfigurationRealm realm =new TextConfigurationRealm();// 设置用户和角色 realm.setUserDefinitions(\"lc=123,user \\n admin=123,admin\");// 设置角色权限 realm.setRoleDefinitions(\"admin=read,write \\n user=read\"); return realm; } @Bean ShiroFilterChainDefinition shiroFilterChainDefinition() { DefaultShiroFilterChainDefinition definition=new DefaultShiroFilterChainDefinition(); definition.addPathDefinition(\"/doLogin\", \"anon\"); definition.addPathDefinition(\"/**\", \"authc\"); return definition; }} 4、controller配置1234567891011121314151617181920212223242526@RestControllerpublic class LoginController { @GetMapping(\"/hello\") public String hello() { return \"hello shiro\"; } @GetMapping(\"/login\") public String login() { return \"please login!\"; } @PostMapping(\"/doLogin\") public void doLogin(String username,String password) { Subject subject = SecurityUtils.getSubject(); try { subject.login(new UsernamePasswordToken(username, password)); System.out.println(\"登录成功！\"); } catch (AuthenticationException e) { System.out.println(); System.out.println(\"登录失败！\"+e.getMessage()); } }}","link":"/2020/04/17/springsecurity/SpringBoot%E6%95%B4%E5%90%88Shiro/"},{"title":"WebSocket和Socket初识","text":"一、WebSocket和Socket的区别​ 由计算机网络知识我们可以知道，软件通信有七层结构，下三层结构偏向与数据通信，上三层更偏向于数据处理，中间的传输层则是连接上三层与下三层之间的桥梁，每一层都做不同的工作，上层协议依赖与下层协议。基于这个通信结构的概念。 1、Socket 其实并不是一个协议，是应用层与 TCP/IP 协议族通信的中间软件抽象层，它是一组接口。当两台主机通信时，让 Socket 去组织数据，以符合指定的协议。TCP 连接则更依靠于底层的 IP 协议，IP 协议的连接则依赖于链路层等更低层次。 2、WebSocket 则是一个典型的应用层协议。 总的来说：Socket 是传输控制层协议，WebSocket 是应用层协议。 二、什么是WebSocket​ WebSocket是一种在单个TCP连接上进行全双工通信的协议。WebSocket通信协议于2011年被IETF定为标准RFC 6455，并由RFC7936补充规范。WebSocket API也被W3C定为标准。 ​ WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。—-百度百科 WebSocket 是独立的、创建在 TCP 上的协议。 Websocket 通过HTTP/1.1 协议的101状态码进行握手。 为了创建Websocket连接，需要通过浏览器发出请求，之后服务器进行回应，这个过程通常称为“握手” 1、什么是全双工通信和半双工通信？①单工通信 ​ 单工通信，是指消息只能单方向传输的工作方式，只能有一个方向的通信而没有反方向的交互； ​ 在单工通信中，通信的信道是单向的，发送端与接收端也是固定的，即发送端只能发送信息，不能接收信息；接收端只能接收信息，不能发送信息，基于这种情况，数据信号从一端传送到另外一端，信号流是单方向的；举例：电视、广播 ②半双工通信 ​ 半双工通信是指数据可以沿两个方向传送，但同一时刻一个半双工总线结构信道只允许单方向传送，因此又被称为双向交替通信 ​ 半双工通信可以实现双向的通信，但不能在两个方向上同时进行，必须轮流交替地进行， ​ 在这种工作方式下，发送端可以转变为接收端；相应地，接收端也可以转变为发送端。但是在同一个时刻，信息只能在一个方向上传输，因此也可以将半双工通信理解为一种切换方向的单工通信；举例：对讲机 ③全双工通信 ​ 全双工通信称为双向同时通信，即通信的双方可以同时发送和接收信息的信息交互方式； ​ 全双工通信是指在通信的任意时刻，线路上存在A到B和B到A的双向信号传输，全双工通信允许数据同时在两个方向上传输，又称为双向同时通信，即通信的双方可以同时发送和接收数据， ​ 在全双工方式下，通信系统的每一端都设置了发送器和接收器，因此，能控制数据同时在两个方向上传送；举例：电话通讯 三、为什么需要WebSocket？​ 初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？ ​ 答案很简单，因为 HTTP 协议有一个缺陷：通信只能由客户端发起。 举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。 ​ 这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用”轮询”：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。 ​ 现在，很多网站为了实现推送技术，所用的技术都是 Ajax 轮询。轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。 ​ 轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。因此，工程师们一直在思考，有没有更好的方法。WebSocket 就是这样发明的。 ​ HTML5 定义的 WebSocket 协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。 ​ WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。 它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。 其他特点包括： （1）建立在 TCP 协议之上，服务器端的实现比较容易。 （2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。 （3）数据格式比较轻量，性能开销小，通信高效。 （4）可以发送文本，也可以发送二进制数据。 （5）没有同源限制，客户端可以与任意服务器通信。 （6）协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。 1ws://example.com:80/some/path 四、webSocket实例​ 为了建立一个 WebSocket 连接，客户端浏览器首先要向服务器发起一个 HTTP 请求，这个请求和通常的 HTTP 请求不同，包含了一些附加头信息，其中附加头信息”Upgrade: WebSocket”表明这是一个申请协议升级的 HTTP 请求，服务器端解析这些附加的头信息然后产生应答信息返回给客户端，客户端和服务器端的 WebSocket 连接就建立起来了，双方就可以通过这个连接通道自由的传递信息，并且这个连接会持续存在直到客户端或者服务器端的某一方主动的关闭连接。","link":"/2020/04/17/websocket/WebSocket%E7%AE%80%E4%BB%8B/"},{"title":"nginx极简入门","text":"一、基本介绍Nginx 是一个高性能的 HTTP 和反向代理 web 服务器，同时也提供了 IMAP/POP3/SMTP 服务。 Nginx 是由伊戈尔·赛索耶夫为俄罗斯访问量第二的 Rambler.ru 站点开发的，第一个公开版本 0.1.0 发布于 2004 年 10 月 4 日。 Nginx 特点是占有内存少，并发能力强。 事实上 nginx 的并发能力确实在同类型的网页服务器中表现较好，一般来说，如果我们在项目中引入了 Nginx ，我们的项目架构可能是这样： 在这样的架构中 ， Nginx 所代表的角色叫做负载均衡服务器或者反向代理服务器，所有请求首先到达 Nginx 上，再由 Nginx 根据提前配置好的转发规则，将客户端发来的请求转发到某一个 Tomcat 上去。那么这里涉及到两个概念： 负载均衡服务器 就是进行请求转发，降低某一个服务器的压力。负载均衡策略很多，也有很多层，对于一些大型网站基本上从 DNS 就开始负载均衡，负载均衡有硬件和软件之分，各自代表分别是 F5 和 Nginx （目前 Nginx 已经被 F5 收购），早些年，也可以使用 Apache 来做负载均衡，但是效率不如 Nginx ，所以现在主流方案是 Nginx 。 反向代理服务器： 另一个概念是反向代理服务器，要说反向代理，得先说正向代理，看下面一张图： 在这个过程中，Google 并不知道真正访问它的客户端是谁，它只知道这个中间服务器在访问它。因此，这里的代理，实际上是中间服务器代理了客户端，这种代理叫做正向代理。 那么什么是反向代理呢？反向代理有点类似于大家打 10086 客服，看下面一张图： 在这个过程中，10086 这个号码相当于是一个代理，真正提供服务的，是话务员，但是对于客户来说，他不关心到底是哪一个话务员提供的服务，他只需要记得 10086 这个号码就行了。 所有的请求打到 10086 上，再由 10086 将请求转发给某一个话务员去处理。因此，在这里，10086 就相当于是一个代理，只不过它代理的是话务员而不是客户端，这种代理称之为反向代理。 二、Nginx 的优势在 Java 开发中，Nginx 有着非常广泛的使用，随便举几点： 使用 Nginx 做静态资源服务器：Java 中的资源可以分为动态和静态，动态需要经过 Tomcat 解析之后，才能返回给浏览器，例如 JSP 页面、Freemarker 页面、控制器返回的 JSON 数据等，都算作动态资源，动态资源经过了 Tomcat 处理，速度必然降低。对于静态资源，例如图片、HTML、JS、CSS 等资源，这种资源可以不必经过 Tomcat 解析，当客户端请求这些资源时，之间将资源返回给客户端就行了。此时，可以使用 Nginx 搭建静态资源服务器，将静态资源直接返回给客户端。 使用 Nginx 做负载均衡服务器，无论是使用 Dubbo 还是 Spirng Cloud ，除了使用各自自带的负载均衡策略之外，也都可以使用 Nginx 做负载均衡服务器。 支持高并发、内存消耗少、成本低廉、配置简单、运行稳定等。 三、Nginx 安装：由于基本上都是在 Linux 上使用 Nginx，因此松哥这里主要向大家展示 CentOS 7 安装 Nginx： 首先下载 Nginx 1wget http://nginx.org/download/nginx-1.17.0.tar.gz 然后解压下载的目录，进入解压目录中，在编译安装之前，需要安装两个依赖： 1yum -y install pcre-develyum -y install openssl openssl-devel 然后开始编译安装： 1./configuremakemake install 装好之后，默认安装位置在 ： 1/usr/local/nginx/sbin/nginx 四、基本命令https://www.jianshu.com/p/03d17156616d 进入到该目录的 sbin 目录下，执行 nginx 即可启动 Nginx 进入到/sbin目录下 1./nginx 如果修改了 Nginx 配置，则可以通过如下命令重新加载 Nginx 配置文件： 1./nginx -s reload 启动服务 1/usr/local/nginx/sbin/nginx 查看配置 1vi /usr/local/nginx/conf/nginx.conf 重启服务 1/usr/local/nginx/sbin/nginx -s reopen 查看服务 1ps -ef | grep nginx 查看配置：vi /usr/local/nginx/conf/nginx.conf 编辑配置：vim /usr/local/nginx/conf/nginx.conf 重启配置：/usr/local/nginx/sbin/nginx -s reload 重启服务：/usr/local/nginx/sbin/nginx -s reopen 查看Nginx的版本 在/usr/local/nginx/sbin目录下 1./nginx -v 查看Nginx的编译模块 1./nginx -V nginx添加环境变量 123ln -s /usr/local/nginx/sbin/nginx /usr/local/bin/nginx(做软链，添加到环境变量)nginx -t (检测配置文件)nginx -s reload (平滑重启) 停止服务 1nginx -s stop 1systemctl stop nginx 查看当前操作的文件夹 1pwd 五、Nginx添加新的模块有时候我们安装模块后，查看Nginx已经安装的模块： /usr/local/nginx/sbin/nginx -V 12built by gcc 4.8.5 20150623 (Red Hat 4.8.5-39) (GCC) configure arguments: --prefix=/usr/local/nginx --add-module=/usr/local/fastdfs-nginx-module-1.22/src 这里我们添加新的模块 --with-http_gzip_static_module 进入nginx的源文件按安装目录 /root/nginx-1.8.1/ 1cd /root/nginx-1.8.1/ 添加编译新的模块 注意：这里要携带已经安装的模块参数 1./configure --prefix=/usr/local/nginx --add-module=/usr/local/fastdfs-nginx-module-1.22/src --with-http_gzip_static_module 编译 1make 注意：在这之后千万不要make install否则会覆盖之前安装好的模块 关闭nginx服务 1systemctl stop nginx 或者 nginx -s stop 备份原有nginx二进制文件 1cp /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.bak 复制新编译好的nginx二进制文件。此目录为 /root/nginx-1.8.1/ 1cp ./objs/nginx /usr/local/nginx/sbin/nginx 启动nginx 1systemctl start nginx 或者 /usr/local/nginx/sbin/nginx 重新查看nginx模块信息 123nginx version: nginx/1.8.1built by gcc 4.8.5 20150623 (Red Hat 4.8.5-39) (GCC) configure arguments: --prefix=/usr/local/nginx --add-module=/usr/local/fastdfs-nginx-module-1.22/src --with-http_gzip_static_module","link":"/2020/04/17/nginx/Nginx/"},{"title":"SpringBoot整合Redis","text":"一、docker中安装redis1、镜像安装与容器创建12docker pull redis //拉取镜像docker run -d -p 6379:6379 --restart=always --name myredis 镜像名 //创建容器 2、查看redis版本docker exec -it 9a7d1cf2c234 redis-cli -v //查看版本 3、修改redis密码（临时，重启失效）①进入redis管理页面不带密码进入（进入后需验证）==&gt; docker exec -it 9a7d1cf2c234 redis-cli //进入redis管理界面 带密码进入（进入后无需验证）==&gt; docker exec -it 9a7d1cf2c234 redis-cli -a '密码' //带密码进入管理界面 ②查询密码config get requirepass //查看密码(初始为空) ③设置密码config set reuqirepass 密码 //设置密码 ④验证密码auth 密码 //验证密码才能够进行查询密码和设置密码等操作 4、永久设置密码（需要修改配置文件）二、springboot整合Redis注意：①在Springboot 2.1.5及之后使用redis必须引入springSecurity ②redis5及之后远程访问连接必须要设置密码 ③使用jedis和lettuce客户端连接redis服务器的区别：使用jedis：当多线程使用同一个连接时，是线程不安全的。所以要使用连接池，为每个jedis实例分配一个连接。 Jedis在实现上是直接连接的redis server，如果在多线程环境下是非线程安全的，这个时候只有使用连接池，为每个Jedis实例增加物理连接 使用Lettuce：当多线程使用同一连接实例时，是线程安全的 Lettuce的连接是基于Netty的，连接实例（StatefulRedisConnection）可以在多个线程间并发访问，应为StatefulRedisConnection是线程安全的，所以一个连接实例（StatefulRedisConnection）就可以满足多线程环境下的并发访问，当然这个也是可伸缩的设计，一个连接实例不够的情况也可以按需增加连接实例。 1、基于lettuce底层的redis配置引入SpringSecurity后，SpringSecurity帮我们生成一个密码 在我们第一个请求redis会要求输入账号密码 用户名为:uers 密码为：Using generated security password: 648dcfaa-ce97-459d-a6d4-b02f73532f89 pom.xmlspring-boot-starter-data-redis spring-boot-starter-security 123456789101112131415161718192021222324252627282930&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; yaml配置123456789spring: redis:# 主机 host: 47.96.141.44# 默认使用的数据库（第一个） database: 0 port: 6379 password: 你的密码# 配置lettuce连接池的相关属性 controller1234567891011121314151617181920@RestControllerpublic class HelloController { @Autowired StringRedisTemplate stringRedisTemplate; @GetMapping(\"/set\") public void set(){ ValueOperations&lt;String, String&gt; ops = stringRedisTemplate.opsForValue(); ops.set(\"lc\", \"louchen.top\"); } @GetMapping(\"/get\") public void get() { ValueOperations&lt;String, String&gt; ops = stringRedisTemplate.opsForValue(); System.out.println(ops.get(\"lc\")); }} 自动配置详解org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration=&gt; 123456789101112131415161718192021222324252627282930@Configuration( proxyBeanMethods = false)@ConditionalOnClass({RedisOperations.class})@EnableConfigurationProperties({RedisProperties.class})@Import({LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class})public class RedisAutoConfiguration { public RedisAutoConfiguration() { } @Bean @ConditionalOnMissingBean( name = {\"redisTemplate\"} ) //操作健值为对象的redistemplate public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException { RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate(); template.setConnectionFactory(redisConnectionFactory); return template; } @Bean @ConditionalOnMissingBean //主要操作健值为字符串的对象 public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException { StringRedisTemplate template = new StringRedisTemplate(); template.setConnectionFactory(redisConnectionFactory); return template; }}","link":"/2020/04/17/nosql/springboot%E6%95%B4%E5%90%88redis/"},{"title":"springboot整合Jpa及多数据源","text":"springboot整合Jpa1、基本配置：①pom.xml配置： 123456789101112131415161718192021222324252627282930313233343536373839&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.18&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;version&gt;5.1.27&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; ②yaml配置：1234567891011121314151617181920212223spring: datasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=UTF-8 username: root password: 123456 jpa:# 显示sql语句 show-sql: true# 数据库 database: mysql # 数据库平台 database-platform: mysql# 设置表的结构的生成类型 hibernate:# 每次启动更新表结构 ddl-auto: update properties: hibernate:# 设置方言 mysql57 dialect: org.hibernate.dialect.MySQL57Dialect ③实体配置：1234567891011121314151617181920212223242526272829303132/** * 指定表的名称 若不存在 则自动为你创建此表 */@Entity(name = \"t_book\")@Getter@Setter@ToStringpublic class Book { /** *在jpa中一个表必须设置主键，否则创建会失败 * @Id标注的属性为主键 * @GeneratedValue指定生成策略为自增长 * @column中可设置字段的约束操作（长度为10） */ @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(length = 10) private Integer id; /** * 设置自动不能为空，长度为50,设置数据库中和属性的对应名称 */ @Column(nullable = false,length = 50,name = \"name\") private String name; /** * 设置自动不能为空，长度为20,设置数据库中和属性的对应名称 */ @Column(nullable = false,length = 20,name = \"author\") private String author;} ④jpa接口配置：123456789/** * 这里要实现 JpaRepository 接口 * JpaRepository已经帮我们实现了很多操作直接使用即可 * 第一个参数为 操作的实体的类型 * 第二个参数为 主键的类型 */public interface BookDao extends JpaRepository&lt;Book,Integer&gt; {} ⑤测试：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475@SpringBootTestclass JpaApplicationTests { @Autowired private BookDao bookDao; /** * 增加 */ @Test void addBokk() { Book book=new Book(); book.setName(\"西游记\"); book.setAuthor(\"施耐庵\"); bookDao.save(book); } /** * 有则更新 无则添加 */ @Test void updateBook() { Book book=new Book(); book.setName(\"xiyouji\"); book.setAuthor(\"shinaian\"); book.setId(1); bookDao.saveAndFlush(book); } /** * 通过id删除 */ @Test void deleteBook() { bookDao.deleteById(1); } /** * 通过id查询 查询所有 */ @Test void findBook() { Optional&lt;Book&gt; byId = bookDao.findById(2); System.out.println(byId.get()); List&lt;Book&gt; all = bookDao.findAll(); System.out.println(all); } /** * 按照id 降序排序 */ @Test void findBookSort() { List&lt;Book&gt; all = bookDao.findAll(Sort.by(Sort.Direction.DESC, \"id\")); System.out.println(all); } /** * 分页查询 */ @Test void findBookPage() { //从第一页开始查询（起始为0），每页大小为2 Pageable pageable = PageRequest.of(2, 2); Page&lt;Book&gt; all = bookDao.findAll(pageable); System.out.println(\"总记录数:\"+all.getTotalElements()); System.out.println(\"当前页记录数:\"+all.getNumberOfElements()); System.out.println(\"每页记录数:\" + all.getSize()); System.out.println(\"总页数:\" + all.getTotalPages()); System.out.println(\"查询结果数据:\" + all.getContent()); System.out.println(\"当前页数(从0开始):\" + all.getNumber()); System.out.println(\"是否为首页:\" + all.isFirst()); System.out.println(\"是否为尾页:\" + all.isLast()); }} 2、jpa使用关键字进行查询：关键字查询参考表： Keyword Sample JPQL snippet And findByLastnameAndFirstname … where x.lastname = ?1 and x.firstname = ?2 Or findByLastnameOrFirstname … where x.lastname = ?1 or x.firstname = ?2 Is,Equals findByFirstname,findByFirstnameIs … where x.firstname = ?1 Between findByStartDateBetween … where x.startDate between ?1 and ?2 LessThan findByAgeLessThan … where x.age &lt; ?1 LessThanEqual findByAgeLessThanEqual … where x.age &lt;= ?1 GreaterThan findByAgeGreaterThan … where x.age &gt; ?1 GreaterThanEqual findByAgeGreaterThanEqual … where x.age &gt;= ?1 After findByStartDateAfter … where x.startDate &gt; ?1 Before findByStartDateBefore … where x.startDate &lt; ?1 IsNull findByAgeIsNull … where x.age is null IsNotNull,NotNull findByAge(Is)NotNull … where x.age not null Like findByFirstnameLike … where x.firstname like ?1 NotLike findByFirstnameNotLike … where x.firstname not like ?1 StartingWith findByFirstnameStartingWith … where x.firstname like ?1(parameter bound with appended %) EndingWith findByFirstnameEndingWith … where x.firstname like ?1(parameter bound with prepended %) Containing findByFirstnameContaining … where x.firstname like ?1(parameter bound wrapped in %) OrderBy findByAgeOrderByLastnameDesc … where x.age = ?1 order by x.lastname desc Not findByLastnameNot … where x.lastname &lt;&gt; ?1 In findByAgeIn(Collection ages) … where x.age in ?1 NotIn findByAgeNotIn(Collection ages) … where x.age not in ?1 True findByActiveTrue() … where x.active = true False findByActiveFalse() … where x.active = false IgnoreCase findByFirstnameIgnoreCase … where UPPER(x.firstame) = UPPER(?1) ①接口配置1234567891011121314151617181920212223242526272829303132/** * 这里要实现 JpaRepository 接口 * JpaRepository已经帮我们实现了很多操作直接使用即可 * 第一个参数为 操作的实体的类型 * 第二个参数为 主键的类型 */public interface BookDao extends JpaRepository&lt;Book,Integer&gt; { /** * 根据id查找 * @param id * @return */ Book findBookById(Integer id); /** * 查询比id小的 * @param integer * @return */ List&lt;Book&gt; findBookByIdLessThan(Integer integer); /** * 查询比id大的或者包含此名称的 * @param id * @param name * @return */ List&lt;Book&gt; findBookByIdGreaterThanOrNameContaining(Integer id, String name);} ②测试123456789 @Testvoid customeFind(){ Book bookById = bookDao.findBookById(4); System.out.println(bookById); List&lt;Book&gt; bookByIdLessThan = bookDao.findBookByIdLessThan(3); System.out.println(bookByIdLessThan); List&lt;Book&gt; finc = bookDao.findBookByIdGreaterThanOrNameContaining(6, \"马\"); System.out.println(finc);} 3、jpa自定义sql查询@Query标记为自定义的sql查询，nativeQuery=true，使用原生的sql操作 @Modifying标记为更新删除或新增的方法 @Transactional当方法为更新删除或者新增的时候，需要在自定义的方法上加上事务，或者在方法所在的dao或者service上加上事务@Transactional 两种传参形式：① 冒号形式 12Query(value = \"insert into t_book(name,author) values(:name,:author)\",nativeQuery = true)Integer addBook(@Param(\"name\")String name,@Param(\"author\")String author); ② ?形式 1234@Modifying@Transactional @Query(value = \"insert into t_book(name,author) values(?1,?2)\",nativeQuery = true) Integer addBook1(String name,String author); 12345678910111213141516171819202122/** * 这里要实现 JpaRepository 接口 * JpaRepository已经帮我们实现了很多操作直接使用即可 * 第一个参数为 操作的实体的类型 * 第二个参数为 主键的类型 */public interface BookDao extends JpaRepository&lt;Book,Integer&gt; { @Query(value = \"select * from t_book where id=(select max(id) from t_book)\",nativeQuery = true) Book getMaxIdBook(); @Modifying @Transactional @Query(value = \"insert into t_book(name,author) values(:name,:author)\",nativeQuery = true) Integer addBook(@Param(\"name\")String name,@Param(\"author\")String author); @Modifying @Transactional @Query(value = \"insert into t_book(name,author) values(?1,?2)\",nativeQuery = true) Integer addBook1(String name,String author);} 4、多数据源配置①pom.xml配置一致②yaml配置12345678910111213141516171819202122232425262728293031spring: datasourceone: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=UTF-8 username: root password: 123456 datasourcetwo: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://47.96.141.44:3306/test?useUnicode=true&amp;characterEncoding=UTF-8 username: root password: 你的密码 jpa: # 显示sql语句 show-sql: true # 数据库 database: mysql # 数据库平台 database-platform: mysql # 设置表的结构的生成类型 hibernate: # 每次启动更新表结构 ddl-auto: create properties: hibernate:# 搜索mysql57即可 找到类路径 # 设置方言 mysql57 dialect: org.hibernate.dialect.MySQL57Dialect ③实体bean1234567891011121314151617181920212223242526272829303132/** * 指定表的名称 若不存在 则自动为你创建此表 */@Entity(name = \"t_book\")@Getter@Setter@ToStringpublic class Book { /** *在jpa中一个表必须设置主键，否则创建会失败 * @Id标注的属性为主键 * @GeneratedValue指定生成策略为自增长 * @column中可设置字段的约束操作（长度为10） */ @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(length = 10) private Integer id; /** * 设置自动不能为空，长度为50,设置数据库中和属性的对应名称 */ @Column(nullable = false,length = 50,name = \"name\") private String name; /** * 设置自动不能为空，长度为20,设置数据库中和属性的对应名称 */ @Column(nullable = false,length = 20,name = \"author\") private String author;} ④数据源注入1234567891011121314151617@Configurationpublic class DataSourceConfig { @Primary @Bean @ConfigurationProperties(\"spring.datasourceone\") DataSource dataSourceOne(){ return DruidDataSourceBuilder.create().build(); } @Bean @ConfigurationProperties(\"spring.datasourcetwo\") DataSource dataSourceTwo() { return DruidDataSourceBuilder.create().build(); }} ⑤事务及LocalContainerEntityManagerFactoryBean配置1234567891011121314151617181920212223242526272829303132333435363738394041/** * basePackages 扫描所在接口的包 * entityManagerFactoryRef 引用配置的localContainerEntityManagerFactoryBeanOne * transactionManagerRef 引用配置的 事务platformTransactionManagerOne */@EnableJpaRepositories(basePackages = \"org.lc.jpa.dao.dao1\",entityManagerFactoryRef = \"localContainerEntityManagerFactoryBeanOne\",transactionManagerRef = \"platformTransactionManagerOne\")@Configurationpublic class JpaConfigOne { @Autowired @Qualifier(\"dataSourceOne\") DataSource dataSourceOne; //注入yaml中的其他属性配置 @Autowired JpaProperties jpaProperties; @Bean LocalContainerEntityManagerFactoryBean localContainerEntityManagerFactoryBeanOne(EntityManagerFactoryBuilder builder) { //注入数据源 return builder.dataSource(dataSourceOne)// 配置操作的实体bean .packages(\"org.lc.jpa.bean\")// 注入配置属性文件 .properties(jpaProperties.getProperties())// 初始化单元 不同即可 .persistenceUnit(\"pu1\") .build(); } /** * 事务的配置 * @param builder * @return */ @Bean PlatformTransactionManager platformTransactionManagerOne(EntityManagerFactoryBuilder builder) { return new JpaTransactionManager(localContainerEntityManagerFactoryBeanOne(builder).getObject()); }} 123456789101112131415161718192021222324252627282930313233343536373839404142/** * basePackages 扫描所在接口的包 * entityManagerFactoryRef 引用配置的localContainerEntityManagerFactoryBeanOne * transactionManagerRef 引用配置的 事务platformTransactionManagerOne */@EnableJpaRepositories(basePackages = \"org.lc.jpa.dao.dao2\",entityManagerFactoryRef = \"localContainerEntityManagerFactoryBeanTwo\",transactionManagerRef = \"platformTransactionManagerTwo\")@Configurationpublic class JpaConfigTwo { @Autowired @Qualifier(\"dataSourceTwo\") DataSource dataSourceTwo; //注入yaml中的其他属性配置 @Autowired JpaProperties jpaProperties; @Primary @Bean LocalContainerEntityManagerFactoryBean localContainerEntityManagerFactoryBeanTwo(EntityManagerFactoryBuilder builder) { //注入数据源 return builder.dataSource(dataSourceTwo)// 配置操作的实体bean .packages(\"org.lc.jpa.bean\")// 注入配置属性文件 .properties(jpaProperties.getProperties())// 初始化单元 不同即可 .persistenceUnit(\"pu1\") .build(); } /** * 事务的配置 * @param builder * @return */ @Primary @Bean PlatformTransactionManager platformTransactionManagerTwo(EntityManagerFactoryBuilder builder) { return new JpaTransactionManager(localContainerEntityManagerFactoryBeanTwo(builder).getObject()); }} ⑥两个不同包及名称的接口123public interface BookDaoOne extends JpaRepository&lt;Book,Integer&gt; { } 123public interface BookDaoTwo extends JpaRepository&lt;Book,Integer&gt; { } ⑦测试注入不同的dao进行测试 123456789101112@Autowiredprivate BookDaoOne bookDaoOne; @Autowiredprivate BookDaoTwo bookDaoTwo;@Testvoid multipleFind() { List&lt;Book&gt; all = bookDaoOne.findAll(); System.out.println(all); List&lt;Book&gt; all1 = bookDaoTwo.findAll(); System.out.println(all1);}","link":"/2020/04/17/multipledatasource/%E6%95%B4%E5%90%88Jpa%E5%8F%8A%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90/"},{"title":"springboot整合Mybatis及多数据源","text":"springboot整合Mybatis注意：1、mapper映射文件存放位置：①存放在java文件夹中当mapper映射文件存放的位置在src/mian/java中，即和mapper接口文件位置一致时。由于maven编译时会忽略配置xml文件，所以我们需要手动配置过滤其java文件夹下的xml文件即resource下的xml 12345678910111213&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; ②存放在resources下放在同一目录结构==&gt; 放在resources下的文件夹要和接口中的文件夹目录结构一致。 注意：这里新建包名要一个一个建，不要想java目录中的结果一样，直接把所有的包名写在一起。 例如：接口目录 src/main/org/lc/mybatis/mapper/xxxx.java mappes映射文件目录 resources/org/lc/mybatis/mapper/xxxx.mapper 放在不同目录结构==&gt; 例如：resources/mapper/mybatis01/xxxx.mapper 则需要在yaml中重新指定mappe映射位置： 1234567891011spring: datasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=UTF-8 username: root password: 123456mybatis: #映射resources资源目录下的mapper文件夹下的任意目录下的xml文件 mapper-locations: classpath:/mapper/**/*.xml 2、@Mapper @MapperScan(s）@Mapper 扫描单个mapper接口 @MapperScans({ ​ @MapperScan(), ​ @MapperScan() }) @MapperScan() 扫描指定包下的所有mapper接口，多数据源时，则需要指定对应的sqlSessionFactoryRef，sqlSessionTemplateRef 1234 @MapperScan(basePackages = \"org.lc.mybatis.mapper.mapper1\",sqlSessionFactoryRef = \"sqlSessionFactoryOne\",sqlSessionTemplateRef = \"sqlSessionTemplateOne\")@Configurationpublic class MybatisConfig {} 单数据源配置:pom.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;mybatis&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.18&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;version&gt;5.1.27&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt;&lt;/project&gt; 1234567spring: datasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=UTF-8 username: root password: 123456 Lombok插件的使用:==&gt; 生成getter setter及 tostring 12345678@Getter@Setter@ToStringpublic class User { private Integer id; private String username; private String address;} *@Mapper *扫描mapper注入容器中 1234@Mapperpublic interface UserMapper { List&lt;User&gt; getAllUser();} 1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" &gt;&lt;mapper namespace=\"org.lc.mybatis.mapper.UserMapper\"&gt; &lt;select id=\"getAllUser\" resultType=\"org.lc.mybatis.bean.User\"&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 使用==&gt; 123456789101112@SpringBootTestclass MybatisApplicationTests { @Autowired private UserMapper userMapper; @Test void contextLoads() { List&lt;User&gt; allUser = userMapper.getAllUser(); System.out.println(allUser); }} 多数据源配置:1234567891011121314spring: datasourceone: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=UTF-8 username: root password: 123456 datasourcetwo: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://47.96.141.44:3306/test?useUnicode=true&amp;characterEncoding=UTF-8 username: root password: xxxx 数据源属性注入==&gt; 12345678910111213141516@Configurationpublic class DataSourceConfig { @ConfigurationProperties(\"spring.datasourceone\") @Bean public DataSource dataSourceOne(){ return DruidDataSourceBuilder.create().build(); } @ConfigurationProperties(\"spring.datasourcetwo\") @Bean public DataSource dataSourceTwo(){ return DruidDataSourceBuilder.create().build(); }} SqlSessionFactory与SqlSessionTemplate配置==&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768@MapperScans({ //数据源一的对应的mapper接口位置 @MapperScan(basePackages = \"org.lc.mybatis.mapper.mapper1\",sqlSessionFactoryRef = \"sqlSessionFactoryOne\",sqlSessionTemplateRef = \"sqlSessionTemplateOne\"), //数据源二的对应的mapper接口位置 @MapperScan(basePackages = \"org.lc.mybatis.mapper.mapper2\",sqlSessionFactoryRef =\"sqlSessionFactoryTwo\",sqlSessionTemplateRef = \"sqlSessionTemplatelTwo\")})@Configurationpublic class MybatisConfig { /** * 数据源一注入 */ @Qualifier(\"dataSourceOne\") @Autowired DataSource dataSourceOne; /** * 数据源二注入 */ @Resource(name = \"dataSourceTwo\") DataSource dataSourceTwo; /** * SqlSessionFactory 属性配置 * @return */ @Bean public SqlSessionFactory sqlSessionFactoryOne(){ SqlSessionFactoryBean sqlSessionFactoryBean=new SqlSessionFactoryBean(); sqlSessionFactoryBean.setDataSource(dataSourceOne); try { //配置在resources下的自定义mapper文件位置 sqlSessionFactoryBean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(\"classpath:mapper/mybatis01/**/*.xml\")); return sqlSessionFactoryBean.getObject(); } catch (Exception e) { e.printStackTrace(); } return null; } /** * SqlSessionTemplate 一模板操作配置 * @return */ @Bean public SqlSessionTemplate sqlSessionTemplateOne(){ return new SqlSessionTemplate(sqlSessionFactoryOne()); } @Bean public SqlSessionFactory sqlSessionFactoryTwo(){ SqlSessionFactoryBean sqlSessionFactoryBean=new SqlSessionFactoryBean(); sqlSessionFactoryBean.setDataSource(dataSourceTwo); try { //配置在resources下的自定义mapper文件位置 sqlSessionFactoryBean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(\"classpath:mapper/mybatis02/**/*.xml\")); return sqlSessionFactoryBean.getObject(); } catch (Exception e) { e.printStackTrace(); } return null; } @Bean public SqlSessionTemplate sqlSessionTemplatelTwo(){ return new SqlSessionTemplate(sqlSessionFactoryTwo()); }} 同理=&gt; ①当mapper.xml在java文件夹下，则不需要配置mapper.xml的位置 ②当mapper.xml在resources自定义的文件夹下，则需要配置mapper.xml的位置 12//配置在resources下的自定义mapper文件位置 sqlSessionFactoryBean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(\"classpath:mapper/mybatis02/**/*.xml\") 因为多数据源的关系，所以所有在yaml的基本mybatis的配置失效，需要重新在SqlSessionFactory配置","link":"/2020/04/17/multipledatasource/%E6%95%B4%E5%90%88MyBatis%E5%8F%8A%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90/"},{"title":"JAR包和WAR包","text":"JAR包和WAR包一、JAR包1、简介JAR（Java Archive，Java 归档文件）是与平台无关的文件格式，它允许将许多文件组合成一个压缩文件。JavaSE程序可以打包成Jar包(J其实可以理解为Java了)。 JAR 文件格式以流行的 ZIP 文件格式为基础。与 ZIP 文件不同的是，JAR 文件不仅用于压缩和发布，而且还用于部署和封装库、组件和插件程序，并可被像编译器和 JVM 这样的工具直接使用。在 JAR 中包含特殊的文件，如 manifests 和部署描述符，用来指示工具如何处理特定的 JAR。 简单来说，jar包就是别人已经写好的一些类，然后对这些类进行打包。可以将这些jar包引入到你的项目中，可以直接使用这些jar包中的类和属性，这些jar包一般放在lib目录下。 2、Spring Boot 可执行 jarSpring Boot 中默认打包成的 jar 叫做 可执行 jar，这种 jar 不同于普通的 jar，普通的 jar 不可以通过 java -jar xxx.jar 命令执行，普通的 jar 主要是被其他应用依赖，Spring Boot 打成的 jar 可以执行，但是不可以被其他的应用所依赖，即使强制依赖，也无法获取里边的类。但是可执行 jar 并不是 Spring Boot 独有的，Java 工程本身就可以打包成可执行 jar 。 我们在springboot项目中可以看到一个默认的插件配置 spring-boot-maven-plugin这个打包插件存在 5 个方面的功能，从插件命令就可以看出： 五个功能分别是： build-info：生成项目的构建信息文件 build-info.properties repackage：这个是默认 goal，在 mvn package 执行之后，这个命令再次打包生成可执行的 jar，同时将 mvn package 生成的 jar 重命名为 *.origin run：这个可以用来运行 Spring Boot 应用 start：这个在 mvn integration-test 阶段，进行 Spring Boot 应用生命周期的管理 stop：这个在 mvn integration-test 阶段，进行 Spring Boot 应用生命周期的管理 这里功能，默认情况下使用就是 repackage 功能，其他功能要使用，则需要开发者显式配置。 3、打包repackage 功能的 作用，就是在打包的时候，多做一点额外的事情： 首先 mvn package 命令 对项目进行打包，打成一个 jar，这个 jar 就是一个普通的 jar，可以被其他项目依赖，但是不可以被执行 repackage命令，对第一步 打包成的jar进行再次打包，将之打成一个 可执行jar，通过将第一步打成的jar重命名为*.original` 文件 可执行jar(不能作为依赖):代码是存在 于 BOOT-INF/classes/ 目录下，另外，还有一个 META-INF 的目录，该目录下有一个 MANIFEST.MF 文件，打开该文件，内容如下： 12345678910Manifest-Version: 1.0Implementation-Title: adminImplementation-Version: 0.0.1-SNAPSHOTStart-Class: org.lc.admin.AdminApplicationSpring-Boot-Classes: BOOT-INF/classes/Spring-Boot-Lib: BOOT-INF/lib/Build-Jdk-Spec: 1.8Spring-Boot-Version: 2.2.5.RELEASECreated-By: Maven Archiver 3.4.0Main-Class: org.springframework.boot.loader.JarLauncher 可以看到，这里定义了一个 Start-Class，这就是可执行 jar 的入口类，Spring-Boot-Classes 表示我们自己代码编译后的位置，Spring-Boot-Lib 则表示项目依赖的 jar 的位置。 换句话说，如果自己要打一个可执行 jar 包的话，除了添加相关依赖之外，还需要配置 META-INF/MANIFEST.MF 文件。 不可执行jar(只能作为依赖)：这是可执行 jar 的结构，那么不可执行 jar 的结构呢？ 我们首先将默认的后缀 .original 除去，然后给文件重命名，重命名完成，进行解压： 解压后可以看到，不可执行 jar 根目录就相当于我们的 classpath，解压之后，直接就能看到我们的代码，它也有 META-INF/MANIFEST.MF 文件，但是文件中没有定义启动类等。 12345Manifest-Version: 1.0Implementation-Title: adminImplementation-Version: 0.0.1-SNAPSHOTBuild-Jdk-Spec: 1.8Created-By: Maven Archiver 3.4.0 注意这个不可以执行 jar 也没有将项目的依赖打包进来。 从这里我们就可以看出，两个 jar ，虽然都是 jar 包，但是内部结构是完全不同的，因此一个可以直接执行，另一个则可以被其他项目依赖。 4、一次打包两个 jar（自定义可执行jar名称）一般来说，Spring Boot 直接打包成可执行 jar 就可以了，不建议将 Spring Boot 作为普通的 jar 被其他的项目所依赖。如果有这种需求，建议将被依赖的部分，单独抽出来做一个普通的 Maven 项目，然后在 Spring Boot 中引用这个 Maven 项目。 如果非要将 Spring Boot 打包成一个普通 jar 被其他项目依赖，技术上来说，也是可以的，给 spring-boot-maven-plugin 插件添加如下配置： 1234567891011&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;classifier&gt;exec&lt;/classifier&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 配置的 classifier 表示可执行 jar 的名字，配置了这个之后，在插件执行 repackage 命令时，就不会给 mvn package 所打成的 jar 重命名了，所以，打包后的 jar 如下： ![](F:\\桌面内容\\springboot2\\项目构建与部署与Maven使用\\images\\批注 2020-04-08 231513.png) 第一个jar可被其他项目依赖的jar 第二个jar则表示是一个可执行jar(自定义可执行jar名) 二、WAR包1、简介war是一个可以直接运行的web模块，通常用于网站，打成包部署到容器中。以Tomcat来说，将war包放置在其\\webapps\\目录下，然后启动Tomcat，这个包就会自动解压，就相当于发布了。 war包是Sun提出的一种web应用程序格式，与jar类似，是很多文件的压缩包。war包中的文件按照一定目录结构来组织。根据其根目录下包含有html和jsp文件，或者包含有这两种文件的目录，另外还有WEB-INF目录。通常在WEB-INF目录下含有一个web.xml文件和一个classes目录，web.xml是这个应用的配置文件，而classes目录下则包含编译好的servlet类和jsp，或者servlet所依赖的其他类（如JavaBean）。通常这些所依赖的类也可以打包成jar包放在WEB-INF下的lib目录下。 简单来说，war包是JavaWeb程序打的包，war包里面包括写的代码编译成的class文件，依赖的包，配置文件，所有的网站页面，包括html，jsp等等。一个war包可以理解为是一个web项目，里面是项目的所有东西。 区别：WAR文件代表了一个Web应用程序，JAR是类的归档文件 2、部署war包到Tomcat1）. 我这里工作中一般是开发打war包给测试，比如说现在测试拿到一个war包，名字叫test.war。 2）. 打开Tomcat的安装路径 ，假设是“D:\\Tomcat\\apache-tomcat-7.0.68”，然后进入到 webapps文件夹中，把 test.war放到 webapps文件夹。 3）. 启动Tomcat。 如果不需要更改配置文件：到这一步就可以了。 在浏览器输入“http:localhost:tomcat_port/test即可打开test项目的 index.jsp页面（port是自己的端口号）。如果test项目没有index.jsp页面，那就需要打开其他相应的页面。 如果需要更改配置文件： 4）. 关闭 Tomcat。 5）. 删除 test.war文件（如果在tomcat启动的状态下删去war包，解压好的文件夹也会被一并删除，所以需要在解压后停止tomcat， 然后删掉war包，这时再启动。这时项目文件夹就会被认为不是war解压而来。）。 6）. 由于刚刚启动过Tomcat，Tomcat会自动解压缩test.war为 test文件夹。所以我们在webapps下面可以看到test文件夹。打开test文件夹更改配置文件即可。 7）. 更新完配置之后，启动Tomcat。 8）. 浏览器打开即可。","link":"/2020/04/17/projectBuildAndDev/Jar%E5%8C%85%E4%B8%8EWar%E5%8C%85/"},{"title":"SpringBoot和Nginx实现gzip压缩","text":"SpringBoot和Nginx实现gzip压缩前后端分离项目如果做成 SPA（单页面）的形式，就必然面临一个首屏加载的问题，因为默认情况下首页文件比较大，可能超过 1 MB，进而带来首页加载很慢的问题。所以我们要通过优化，来提高首页的加载速度。 问题的解决，一般来说有这样几种思路： UI 组件按需加载 路由懒加载 组件重复打包 gzip 这些加载方式中，UI 组件按需加载和 gzip 是两种比较常用的方案，另外两种优化方式则要结合具体的项目，看看是否具备相关条件。 一、ElementUI按需加载1.1 问题不做任何优化，我们一般是在 main.js 中按照如下方式来引入 ElementUI 的： 即一次加载全部组件 123import ElementUI from 'element-ui';import 'element-ui/lib/theme-chalk/index.css';Vue.use(ElementUI,{size:'small'}); 这样做，没有用上的组件必然会造成资源的浪费 通过如下命令对项目生成 report.html 用来帮助我们分析包内容： 1vue-cli-service build --report 访问 report.html即可查看个文件的占用情况 ![](F:\\桌面内容\\springboot2\\项目构建与部署与Maven使用\\images\\批注 2020-04-12 193314.png) 1.2解决办法只在开发环境使用 -D 1npm install babel-plugin-component -D 这时会生成一个babel.config.js文件，修改其内容： 1234567891011121314151617181920module.exports = { presets: [ '@vue/cli-plugin-babel/preset', [ '@babel/preset-env', { modules: false } ] ], plugins: [ [ \"component\", { \"libraryName\": \"element-ui\", \"styleLibraryName\": \"theme-chalk\" } ] ]} 然后修改main.js，将elementUI组件按需导入 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import { Button, Input, Table, TableColumn, Dialog, Card, Container, Footer, Icon, Select, Form, Tag, Tree, Pagination, Badge, Loading, Message, MessageBox, Menu, Tabs, TabPane, Breadcrumb, BreadcrumbItem, Dropdown, Steps, Tooltip, Popover, Collapse, FormItem, Checkbox, Header, DropdownMenu, DropdownItem, Aside, Main, MenuItem, Submenu, Option, Col, Row, Upload, Radio, DatePicker, RadioGroup, CollapseItem, Switch} from 'element-ui';//注册组件Vue.prototype.$ELEMENT = {size: 'small', zIndex: 3000};Vue.use(Switch);Vue.use(CollapseItem);Vue.use(Radio);Vue.use(RadioGroup);Vue.use(DatePicker);Vue.use(Upload);Vue.use(Row);Vue.use(Col);Vue.use(Option);Vue.use(Submenu);Vue.use(MenuItem);Vue.use(Header);Vue.use(DropdownMenu);Vue.use(DropdownItem);Vue.use(Aside);Vue.use(Main);Vue.use(Checkbox);Vue.use(FormItem);Vue.use(Collapse);Vue.use(Popover);Vue.use(Menu);Vue.use(Tabs);Vue.use(TabPane);Vue.use(Breadcrumb);Vue.use(BreadcrumbItem);Vue.use(Dropdown);Vue.use(Steps);Vue.use(Tooltip);Vue.use(Tree);Vue.use(Pagination);Vue.use(Badge);Vue.use(Loading);Vue.use(Button);Vue.use(Input);Vue.use(Table);Vue.use(Footer);Vue.use(TableColumn);Vue.use(Dialog);Vue.use(Card);Vue.use(Container);Vue.use(Icon);Vue.use(Select);Vue.use(Form);Vue.use(Tag);Vue.prototype.$alert = MessageBox.alertVue.prototype.$confirm = MessageBox.confirm 这里的代码倒是不难，有两个需要注意的地方： MessageBox 的引入方式和其他组件不太一样，需要注意。 给组件统一定制 size 和 zIndex 的方式有所变化。 其他具体不同的引入和注册方式查看 ElementUI官网：https://element.faas.ele.me/#/zh-CN/component/quickstart 再次执行 vue-cli-service build --report ，查看打包结果，发现相比上次文件大小减少不小 二、gzip我们可以下上面的基础上，使用gzip继续压缩 2.1服务端配置压缩前端编译打包后拷贝到后端，直接部署后端项目即可 这里我们在springboot的application.yaml中 1234server:# 当前端项目在static目录下 则开启压缩 compression: enabled: true 配置完成后，重启后端项目，访问项目首页，如下，可以看到文件基本上都被压缩了： 我们任意点开一个js文件： ![](F:\\桌面内容\\springboot2\\项目构建与部署与Maven使用\\images\\批注 2020-04-12 194559.png) 我们发现响应头已经有gzip的信息，即该文件已被压缩。 2.2 Nginx的动态压缩和静态压缩 Nginx 动态压缩，静态文件还是普通文件，前端在Nginx部署上的文件时普通文件，当请求来了Nginx再压缩，然后将压缩文件返回给前端，交由前端再解压回显。 Nginx 静态压缩，前端提前把文件压缩成 .gz 格式，然后部署在Nginx，此时Nginx是压缩文件，请求来了，Nginx直接将该文件返回即可。 2.2.1 Nginx动态压缩动态压缩 Vue 还是使用普通的打包编译后的文件，将前端编译打包后的文件拷贝到 Nginx 的 html 目录下，然后访问 nginx： 确保 nginx 运行成功后，接下来对 nginx 进行配置： 1234gzip on; # 开启 gzipgzip_min_length 2k;# 超过 2kb 进行压缩gzip_disable msie6; # ie6 不适用 gzipgzip_types text/css application/javascript text/javascript image/jpeg image/png image/gif; # 需要处理的文件 配置完成后，重启 Nginx： 1/usr/lcoal/nginx/sbin/nginx -s reload 启动成功后，再去访问前端页面，就可以看到压缩效果了。 直接访问ip 2.2.2 Nginx静态压缩上面的动态压缩有一个问题，就是每次请求响应的时候都要压缩，其实都是相同的文件，总是压缩有点浪费资源。 我们可以提前将文件压缩好，就保存在服务端，需要用的时候直接返回，就会方便很多。 这需要我们首先在前端安装压缩插件： 1npm install compression-webpack-plugin -D 安装成功之后，接下来在 vue.config.js 中进行配置： 1234567891011121314151617181920212223242526//插件导入const CompressionPlugin = require(\"compression-webpack-plugin\");module.exports={ // 前端服务器的地址信息 devServer:{ host:'localhost', //前端地址 port:8080, //前端端口 proxy:proxyObj }, //静态压缩配置 configureWebpack: config =&gt; { if (process.env.NODE_ENV === 'production') { return { plugins: [ new CompressionPlugin({ test: /\\.js$|\\.html$|\\.css/, //超过1kb即压缩 threshold: 1024, //压缩后是否删除源文件 deleteOriginalAssets: false }) ] } } }} 配置完成后，再次执行打包命令 vue-cli-service build。这次打包完成后，我们可以在 js 目录下看到 .gz 文件，如下：我们发现超过1kb的文件即被压缩 ![](F:\\桌面内容\\springboot2\\项目构建与部署与Maven使用\\images\\批注 2020-04-12 201221.png) 接下来将文件上传到 Nginx 服务器，然后对 Nginx 重新进行编译打包。想让 Nginx 返回已经压缩好的文件，需要用到 Nginx 中的 http_gzip_static_module 模块，这个模块可以发送以 .gz 作为文件扩展名的预压缩文件，所以我们要对 Nginx 重新进行编译打包： 123./configure --with-http_gzip_static_module 或者 /root/nginx-1.8.1/configure --with-http_gzip_static_modulemakemake install 然后在 Nginx 配置文件中开启 gzip_static，如下： 12gzip_static on;#动态压缩的其他配置注释 注意，开启了 gzip_static 后，gzip_types 就失效了，所以也没必要配置这个属性了。 配置完成后，重启 Nginx，再去访问，查看浏览器日志，就会发现 gzip 已经生效了。 注意： 静态压缩返回的 gzip 压缩文件都是提前准备好的，没有 .gz 格式的文件就会自动返回原文件。这是一种和动态压缩不同的响应策略。动态压缩是根据 Nginx 中的配置，超过配置的大小就会自动进行压缩。 好了，这一波操作下来，首屏加载速度提高了 5 倍左右。","link":"/2020/04/17/projectBuildAndDev/Springboot%E5%92%8CNginx%E5%AE%9E%E7%8E%B0gzip%E5%8E%8B%E7%BC%A9/"},{"title":"Redis做消息队列","text":"Redis做消息队列​ 我们平时说到消息队列，一般都是指 RabbitMQ、RocketMQ(阿里)、ActiveMQ 以及大数据里边的 Kafka，这些是我们比较常见的消息中间件，也是非常专业的消息中间件，作为专业的中间件，它里边提供了许多功能。 但是，当我们需要使用消息中间件的时候，并非每次都需要非常专业的消息中间件，假如我们只有一个消息队列，只有一个消费者，那就没有必要去使用上面这些专业的消息中间件，这种情况我们可以直接使用 Redis 来做消息队列。 Redis 的消息队列不是特别专业，他没有很多高级特性，适用简单的场景，如果对于消息可靠性有着极高的追求，那么不适合使用 Redis 做消息队列。 一、Redis 做消息队列​ 使用它里边的 List 数据结构就可以实现，我们可以使用 lpush/rpush 操作来实现入队，然后使用 lpop/rpop 来实现出队。 ​ 在客户端（例如 Java 端），我们会维护一个死循环来不停的从队列中读取消息，并处理，如果队列中有消息，则直接获取到，如果没有消息，就会陷入死循环，直到下一次有消息进入，这种死循环会造成大量的资源浪费，这个时候，我们可以使用之前讲的 blpop/brpop(阻塞式的弹出) 二、延迟消息队列延迟队列可以通过 zset 来实现，因为 zset 中有一个 score，我们可以把时间作为 score，将 value 存到 redis 中，然后通过轮询的方式，去不断的读取消息出来。 首先，如果消息是一个字符串，直接发送即可，如果是一个对象，则需要对对象进行序列化，这里我们使用 JSON 来实现序列化和反序列化。 1、pom.xml123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;distributed_lock&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;!--序列化我们需要使用到的jackson--&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.10.3&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2、jedis和jedis连接池工具 CallWithJedis 1234public interface CallWithJedis { void call(Jedis jedis);} Redis 12345678910111213141516171819202122232425262728293031public class Redis { private JedisPool jedisPool; public Redis() {// 连接池配置对象 GenericObjectPoolConfig config=new GenericObjectPoolConfig();// 连接池最大空闲数 config.setMaxIdle(300);// 最大连接数 config.setMaxTotal(1000);// 连接最大等待时间（毫秒）。-1表示无限制 config.setMaxWaitMillis(30000);// 在空闲时检查有效性 config.setTestOnBorrow(true); /** * 1、连接池配置 * 2、redis地址 * 3、端口 * 4、超时时间 * 5、密码 */ jedisPool = new JedisPool(config, \"47.96.141.44\",6379,30000,\"你的密码\"); } public void execute(CallWithJedis callWithJedis) { try (Jedis jedis=jedisPool.getResource()) { callWithJedis.call(jedis); } }} 3、消息对象 LcMessgae 123456789101112131415161718192021222324252627282930public class LcMessgae implements Serializable { private String id; private Object data; public String getId() { return id; } public LcMessgae setId(String id) { this.id = id; return this; } public Object getData() { return data; } public LcMessgae setData(Object data) { this.data = data; return this; } @Override public String toString() { return \"LcMessgae{\" + \"id='\" + id + '\\'' + \", data=\" + data + '}'; }} 4、延迟消息队列对象1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * 延迟消息队列 */public class DelayMsgQueue { private Jedis jedis; private String queue; public DelayMsgQueue(Jedis jedis, String queue) { this.jedis = jedis; this.queue = queue; } /** * 消息入队 * @param data 要发送的数据 */ public void queue(Object data) {// 构造一个消息对象 LcMessgae msg=new LcMessgae(); msg.setId(UUID.randomUUID().toString()); msg.setData(data);// 序列化对象 try {// 序列化对象为字符串 String s = new ObjectMapper().writeValueAsString(msg); System.out.println(\"msg publish:\"+new Date());// 队列的名称; 延迟五秒发送; 发送的消息 jedis.zadd(queue, System.currentTimeMillis() + 5000, s); } catch (JsonProcessingException e) { e.printStackTrace(); } } /** * 消息消费 */ public void loop() {// 如果当前线程没有被打断 则一直循环查找消息 while (!Thread.interrupted()){// 读取的队列; 从0开始; 到当前时间戳结束; 偏移量; 读取的个数 Set&lt;String&gt; zrange= jedis.zrangeByScore(queue, 0, System.currentTimeMillis(), 0, 1);// 如果读到的为空 if (zrange.isEmpty()) { try {// 休息0.5秒 Thread.sleep(500); } catch (InterruptedException e) {// 抛出异常直接。直接跳出循环 break; }// 否则 直接进行下一次循环 continue; }// 如果有消息 直接加载消息 String next = zrange.iterator().next();// 如果成功弹出指定消息 if(jedis.zrem(queue, next)&gt;0){// 处理业务// 消费该队列即可 try {// 将该字符串member反序列化为对象 LcMessgae lcMessgae = new ObjectMapper().readValue(next, LcMessgae.class); System.out.println(\"receive msg:\"+new Date()+\"&gt;&gt;&gt;&gt;&gt;&gt;&gt;\"+lcMessgae); } catch (JsonProcessingException e) { e.printStackTrace(); } } } }} 5、测试123456789101112131415161718192021222324252627282930313233343536373839404142package org.lc.distributed_lock;import javax.annotation.Resource;/** * @BelongsProject: distributed_lock * @BelongsPackage: org.lc.distributed_lock * @Author: lc * @CreateTime: 2020-04-23 22:17 * @Description: */public class DelayMsgTest { public static void main(String[] args) { Redis redis=new Redis(); redis.execute(jedis-&gt;{// 构造一个消息队列 DelayMsgQueue queue = new DelayMsgQueue(jedis, \"lc-queue\"); Thread producer= new Thread(() -&gt; { for (int i = 0; i &lt; 5; i++) {// 生产者 queue.queue(\"louchen.top&gt;&gt;&gt;&gt;\"+i); } });// 消费者 Thread consumer = new Thread(() -&gt; queue.loop());// 启动 producer.start(); consumer.start();// 休息7s，停止程序 try { Thread.sleep(7000); //中断消费 consumer.interrupt(); } catch (InterruptedException e) { e.printStackTrace(); } }); }} 12345678910msg publish:Thu Apr 23 22:44:55 GMT+08:00 2020msg publish:Thu Apr 23 22:44:55 GMT+08:00 2020msg publish:Thu Apr 23 22:44:55 GMT+08:00 2020msg publish:Thu Apr 23 22:44:55 GMT+08:00 2020msg publish:Thu Apr 23 22:44:55 GMT+08:00 2020receive msg:Thu Apr 23 22:45:00 GMT+08:00 2020&gt;&gt;&gt;&gt;&gt;&gt;&gt;LcMessgae{id='d366029d-0a62-49f5-96fb-20f87c51db4e', data=louchen.top&gt;&gt;&gt;&gt;0}receive msg:Thu Apr 23 22:45:01 GMT+08:00 2020&gt;&gt;&gt;&gt;&gt;&gt;&gt;LcMessgae{id='e9c730f6-aebc-4244-982c-28063f2ad439', data=louchen.top&gt;&gt;&gt;&gt;1}receive msg:Thu Apr 23 22:45:01 GMT+08:00 2020&gt;&gt;&gt;&gt;&gt;&gt;&gt;LcMessgae{id='ef6129d3-b62b-4222-9c89-dffce6a3ed7c', data=louchen.top&gt;&gt;&gt;&gt;2}receive msg:Thu Apr 23 22:45:01 GMT+08:00 2020&gt;&gt;&gt;&gt;&gt;&gt;&gt;LcMessgae{id='7077679f-f968-4261-a688-cd8f637874d9', data=louchen.top&gt;&gt;&gt;&gt;3}receive msg:Thu Apr 23 22:45:01 GMT+08:00 2020&gt;&gt;&gt;&gt;&gt;&gt;&gt;LcMessgae{id='1089b3e5-bea4-47a0-886f-b020091fe01a', data=louchen.top&gt;&gt;&gt;&gt;4}","link":"/2020/04/25/redis/Redis%E5%81%9A%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"title":"Redis实现分布式锁的方式","text":"Redis实现分布式锁的方式问题场景：​ 例如一个简单的用户操作，一个线城去修改用户的状态，首先从数据库中读出用户的状态，然后在内存中进行修改，修改完成后，再存回去。在单线程中，这个操作没有问题，但是在多线程中，由于读取、修改、存 这是三个操作，不是原子操作，所以在多线程中，这样会出问题。 对于这种问题，我们可以使用分布式锁来限制程序的并发执行。 一、基本用法这里我们提前封装jedis连接池，拿到jedis对象 pom.xml 1234567&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt; CallWithJedis 123public interface CallWithJedis { void call(Jedis jedis);} Redis 1234567891011121314151617181920212223242526272829303132public class Redis { private JedisPool jedisPool; public Redis() {// 连接池配置对象 GenericObjectPoolConfig config=new GenericObjectPoolConfig();// 连接池最大空闲数 config.setMaxIdle(300);// 最大连接数 config.setMaxTotal(1000);// 连接最大等待时间（毫秒）。-1表示无限制 config.setMaxWaitMillis(30000);// 在空闲时检查有效性 config.setTestOnBorrow(true); /** * 1、连接池配置 * 2、redis地址 * 3、端口 * 4、超时时间 * 5、密码 */ jedisPool = new JedisPool(config, \"47.96.141.44\",6379,30000,\"你的密码\"); } public void execute(CallWithJedis callWithJedis) { try (Jedis jedis=jedisPool.getResource()) { callWithJedis.call(jedis); } }} 1、基本实现方式：123456789101112131415161718192021public class LockTest { public static void main(String[] args) { Redis redis = new Redis(); redis.execute(jedis -&gt; {// 获得锁，只有获得了锁才能进行数据的操作// 这里我们只是测试作用，作为占坑检验操作 Long setnx = jedis.setnx(\"k1\", \"v1\"); if (set != null &amp;&amp; set.equals(\"OK\")) {// 获得了锁 即没人占位 插入真正的key jedis.set(\"name\", \"lc\"); String s = jedis.get(\"name\"); System.out.println(s);// 释放占用的资源 jedis.del(\"k1\"); } else {// 修改失败 有人占位 System.out.println(\"有人占坑\"); } }); }} 上述代码问题：程序异常无法释放锁​ 如果我们的业务代码在执行的过程中抛出异常或者挂了，这样会导致del指令没有被调用(没有释放锁)，那么后面的请求全部堵塞在这，锁永远得不到释放 ​ 这里我们的解决方式就是在获得锁后，给锁添加过期时间，确保锁在一定的时间之后，能够得到释放。 2、给锁添加过期时间jedis.expire(&quot;k1&quot;, 5); 1234567891011121314151617181920212223public class LockTest { public static void main(String[] args) { Redis redis = new Redis(); redis.execute(jedis -&gt; {// 获得锁，只有获得了锁才能进行数据的操作// 这里我们只是测试作用，作为占坑检验操作 Long setnx = jedis.setnx(\"k1\", \"v1\"); if (set != null &amp;&amp; set.equals(\"OK\")) { //给锁添加一个过期时间，防止应用在运行过程中抛出异常导致锁无法及时得到释放 jedis.expire(\"k1\", 5);// 获得了锁 即没人占位 插入真正的key jedis.set(\"name\", \"lc\"); String s = jedis.get(\"name\"); System.out.println(s);// 释放占用的资源 jedis.del(\"k1\"); } else {// 修改失败 有人占位 System.out.println(\"有人占坑\"); } }); }} 上述代码的问题：获得锁和设置过期时间不能保证原子性​ 我们在获得锁和设置锁的过期时间如果服务器挂掉，这个时候锁被占用，过期时间也没有设置，那么也会发生死锁，因为获取锁和设置过期时间为两个操作，不具备原子性 ​ 解决方式：让setnx和exprie同时执行，即在获得锁的同时，同时设置锁的过期时间，保证原子性 3、获得锁同时设置锁过期时间为了解决这个问题，从 Redis2.8 开始，setnx 和 expire 可以通过一个命令一起来执行了 String set = jedis.set(&quot;k1&quot;, &quot;v1&quot;, new SetParams().nx().ex(5)); 1234567891011121314151617181920212223public class LockTest { public static void main(String[] args) { Redis redis = new Redis(); redis.execute(jedis -&gt; {// 这里我们可以在set操作的同时，同时加入其他参数：nx不存在时操作，ex设置过期时间// 这样我们可以防止在获得锁和设置过期时间，如果服务器挂掉，则这个时候锁被占用，无法及时得到释放，从而造成死锁。因为获得锁和设置过期时间是两个操作，不具备原子性。 String set = jedis.set(\"k1\", \"v1\", new SetParams().nx().ex(5)); if (set != null &amp;&amp; set.equals(\"OK\")) {// 给锁添加一个过期时间，防止应用在运行过程中抛出异常导致锁无法及时得到释放 jedis.expire(\"k1\", 5);// 修改成功 即没人占位 插入真正的key jedis.set(\"name\", \"lc\"); String s = jedis.get(\"name\"); System.out.println(s);// 释放占用的资源 jedis.del(\"k1\"); } else {// 修改失败 有人占位 System.out.println(\"有人占坑\"); } }); }} 二、解决超时问题​ 通过以上业务代码我们可以发现，为了防止业务在执行的时候抛出异常，我们给每一个锁添加一个超时时间，超时之后，锁自动释放。当业务时间过长，那么会出现线程紊乱。 ​ 案例：第一个线程首先获得锁，然后开始执行业务代码，这是执行业务代码的时间超过了锁设定的过期时间，那么该线程还未执行完业务代码该锁就被释放了。此时第二个线程获取到锁开始执行，此时该线程执行了几秒之后，第一个线程也执行完了，那么该第一个线程就会释放锁(del)，但是注意，它释放的这个锁是第二个线程的锁，第三个第四个线程也如此，那么就会造成线程紊乱，修改紊乱。 解决方式： ①尽量避免在获取锁的时候，执行耗时操作 ②我么可以在锁上考虑，将锁的value设置为一个随机字符串，每次释放锁的时候，都去比较随机字符串是否一致，如果一致，再去释放锁，否则，不释放。 对于第二种方案，由于释放锁的时候，要去查看锁的 value，第二个比较 value 的值是否正确，第三步释放锁，有三个步骤，很明显三个步骤不具备原子性，为了解决这个问题，我们得引入Lua脚本 Lua 脚本的优势： 使用方便，Redis 中内置了对 Lua 脚本的支持。 Lua 脚本可以在 Redis 服务端原子的执行多个 Redis 命令。 由于网络在很大程度上会影响到 Redis 性能，而使用 Lua 脚本可以让多个命令一次执行，可以有效解决网络给 Redis 带来的性能问题。 在 Redis 中，使用 Lua 脚本，大致上两种思路： 提前在 Redis 服务端写好 Lua 脚本，然后在 Java 客户端去调用脚本（推荐）。 可以直接在 Java 端去写 Lua 脚本，写好之后，需要执行时，每次将脚本发送到 Redis 上去执行。 在Redis服务器中创建Lua脚本基本步骤①、切换到redis安装目录，创建存储lua的文件夹 ②、创建vi releasewherevalueequal.lua文件 ③、编写内容,保存退出 12345if redis.call(\"get\",KEYS[1])==ARGV[1] then return redis.call(\"del\",KEYS[1])else return 0end reids.call 表示调用get操作方式，KEYS[1]表示传过来要操作的key(可以有多个key，索引从1开始)，ARGV表示传过来的其他参数。 ④、给Lua脚本求一个SHA1和(相当于给该lua文件算出一个标识符) redis-cli script load &quot;$(cat lua/releasewherevalueequal.lua)&quot; 返回的标识符： 19d0abd0b3b3bfd1b5294f957dcab483e58b97c84 script load相当于这个命令会在 Redis 服务器中缓存 Lua 脚本，并返回脚本内容的 SHA1 校验和，然后在 Java 端调用时，传入 SHA1 校验和作为参数，这样 Redis 服务端就知道执行哪个脚本了。 接下来，在 Java 端调用这个脚本。 1234567891011121314151617181920212223242526272829303132public class LuaTest { public static void main(String[] args) { Redis redis=new Redis(); redis.execute(jedis -&gt; {// 1、获取一个随机字符串 String s = UUID.randomUUID().toString();// 2、获取锁 String k1 = jedis.set(\"k1\", s, new SetParams().nx().ex(50));// 3、判断是否拿到锁 if (k1 != null &amp;&amp; k1.equals(\"OK\")) {// 4、业务操作 jedis.set(\"lc\", \"louchen.top\"); System.out.println(jedis.get(\"lc\"));// 5、释放锁// 校验和; keys; 其他的参数// 使用redis中加载的lua// jedis.evalsha(\"9d0abd0b3b3bfd1b5294f957dcab483e58b97c84\", Arrays.asList(\"k1\"),Arrays.asList(s));// 直接在java客户端中写lua String script = \"if redis.call('get',KEYS[1]) == ARGV[1] then\" + \" return redis.call('del',KEYS[1]) \" + \"else\" + \" return 0 \" + \"end\"; jedis.eval(script, Arrays.asList(\"k1\"), Arrays.asList(s)); }else{ System.out.println(\"没有拿到锁\"); } }); }} 三、基本命令介绍​ 使用jedis的2.7.x及以上版本。 ​ 命令：SET key value [NX|XX] [EX|PX] seconds ​ NX – 只有键key不存在的时候才会设置key的值 ​ XX – 只有键key存在的时候才会设置key的值 ​ EX seconds – 设置键key的过期时间，单位时秒 ​ PX milliseconds – 设置键key的过期时间，单位时毫秒","link":"/2020/04/23/redis/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"},{"title":"Redis","text":"Redis之布隆过滤器 (Bloom Filter)一、布隆过滤器的应用场景场景1：推送不同消息我们用 HyperLogLog 来估计一个数，有偏差但是也够用。HyperLogLog 主要提供两个方法： pfadd pfcount ​ 但是 HyperLogLog 没有判断是否包含的方法，例如 pfexists 、pfcontains 等。没有这样的方法存在，但是我们有这样的业务需求。 ​ 例如刷今日头条，推送的内容有相似的，但是没有重复的。这就涉及到如何在推送的时候去重？ ​ 解决方案很多，例如将用户的浏览历史记录下来，然后每次推送时去比较该条消息是否已经给用户推送了。但是这种方式效率极低，不推荐。 所以这里我们使用布隆过滤器以今日头条为例，假设我们将用户的浏览记录用 B 表示，A 表示用户没有浏览的新闻，现在要给用户推送消息，先去 B 里边判断这条消息是否已经推送过，如果判断结果说没推送过（B 里边没有这条记录），那就一定没有推送过。如果判断结果说有推送过（B 里边也有可能没有这条消息），这个时候该条消息就不会推送给用户，导致用户错过该条消息，当然这是概率极低的。 场景2：缓存穿透(查不存在的数据)描述：缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。 ​ 我们经常会把一部分数据放在Redis等缓存，比如产品详情。这样有查询请求进来，我们可以根据产品Id直接去缓存中取数据，而不用读取数据库，这是提升性能最简单，最普遍，也是最有效的做法。一般的查询请求流程是这样的：先查缓存，有缓存的话直接返回，如果缓存中没有，再去数据库查询，然后再把数据库取出来的数据放入缓存，一切看起来很美好。但是如果现在有大量请求进来，而且都在请求一个不存在的产品Id，会发生什么？既然产品Id都不存在，那么肯定没有缓存，没有缓存，那么大量的请求都怼到数据库，数据库的压力一下子就上来了，还有可能把数据库打死。虽然有很多办法都可以解决这问题，但是我们的主角是“布隆过滤器”，没错，“布隆过滤器”就可以解决（缓解）缓存穿透问题。 题外话：1、缓存击穿(并发查同一条数据)​ 缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力 2、缓存雪崩 缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。 二、什么是布隆过滤器？布隆过滤器是一个叫“布隆”的人提出的，它本身是一个很长的二进制向量，既然是二进制的向量，那么显而易见的，存放的不是0，就是1。 Bloom Filter 专门用来解决我们上面所说的去重问题的，使用 Bloom Filter 不会像使用缓存那么浪费空间。当然，他也存在一个小小问题，就是不太精确。 Bloom Filter 相当于是一个不太精确的 set 集合，我们可以利用它里边的 contains 方法去判断某一个对象是否存在，但是需要注意，这个判断不是特别精确。一般来说，通过 contains 判断某个值不存在，那就一定不存在，但是判断某个值存在的话，则他可能不存在。 三、Bloom Filter实现原理每一个布隆过滤器，在 Redis 中都对应了一个大型的bit位数组以及几(3)个不同的 hash 函数。 如果我们要映射一个值到布隆过滤器中，首先根据几个不同的hash函数给元素(存储对象)生成多个哈希值，拿到这些哈希值后分别对位数组长度进行取模(取余)运算得到一个位置，将位数组中对应的位置设置为1。这样就完成元素的添加操作。 取模：a= c%bit数组长度 就是取余的过程 ​ 例如针对值 “baidu” 和三个不同的哈希函数分别生成了哈希值 ：1、4、7，取模为：1，4, 7 ​ 例如针对值“zhihu”和三个不同的哈希函数分别生成了哈希值：1，4，9 ,取模为：1 ，4，9 则上图转换如下： 当判断元素是否存在时，依然先对元素进行 hash 运算，将运算的结果和位数组取模，然后去对应的位置查看是否有相应的数据，如果有，表示元素可能存在（因为这个有数据的地方也可能是其他元素存进来的），如果没有表示元素一定不存在。 可以看出，仅仅从布隆过滤器本身而言，根本没有存放完整的数据，只是运用一系列随机映射函数计算出位置，然后填充二进制向量。 这有什么用呢？比如现在再给你一个数据，你要判断这个数据是否重复，你怎么做？ 你只需利用上面的三种固定的计算方式，计算出这个数据占据哪些格子，然后看看这些格子里面放置的是否都是1，如果有一个格子不为1，那么就代表这个数字不在其中。这很好理解吧，比如现在又给你了刚才你添加进去的数据，你通过三种固定的计算方式，算出的结果肯定和上面的是一模一样的，也是占据了布隆过滤器“1”，“4”，“9”三个格子。 但是有一个问题需要注意，如果这些格子里面放置的都是1，不一定代表给定的数据一定重复，也许其他数据经过三种固定的计算方式算出来的结果也是相同的。这也很好理解吧，比如我们需要判断对象是否相等，是不可以仅仅判断他们的哈希值是否相等的。 也就是说布隆过滤器只能判断数据是否一定不存在，而无法判断数据是否一定存在。 Bloom Filter 中，误判的概率和位数组的大小有很大关系，位数组越大，误判概率越小，当然占用的存储空间越大；位数组越小，误判概率越大，当然占用的存储空间就小。 按理来说，介绍完了新增、查询的流程，就要介绍删除的流程了，但是很遗憾的是布隆过滤器是很难做到删除数据的，为什么？你想想，比如你要删除刚才给你的数据，你把“1”，“4”，“9”三个格子都改成了0，但是可能其他的数据也映射到了“1”，“4”，“9”三个格子啊，这不就乱套了吗？ 四、Bloom Filter的优缺点： 优点：由于存放的不是完整的数据，所以占用的内存很少，而且新增，查询速度够快； 缺点： 随着数据的增加，误判率随之增加；无法做到删除数据；只能判断数据是否一定不存在，而无法判断数据是否一定存在。 五、Bloom Filter的安装官网：https://oss.redislabs.com/redisbloom/Quick_Start/ 1、docker安装1docker run -p 6379:6379 --name redis-redisbloom redislabs/rebloom:latest 2、编译安装123456789cd redis-5.0.7git clone https://github.com/RedisBloom/RedisBloom.gitcd RedisBloom/##编译make##切换上级目录cd ..##运行redis-server --loadmodule ./RedisBloom/redisbloom.so 后台运行，加入配置文件： 1redis-server redis.conf --loadmodule ./RedisBloom/redisbloom.so 进入redis测试是否安装成功： 123redis-cli -a 密码## 插入值bf.add k1 v1 避免每次启动布隆过滤器都要redis-server redis.conf --loadmodule ./RedisBloom/redisbloom.so这样写，比较麻烦。 我们修改redis.conf文件： 12345678################################## MODULES ###################################### Load modules at startup. If the server is not able to load modules# it will abort. It is possible to use multiple loadmodule directives.## loadmodule /path/to/my_module.so# loadmodule /path/to/other_module.soloadmodule /root/redis-5.0.8/RedisBloom/redisbloom.so 保存退出。这是我们次正常启动即可 redis-server redis.conf 六、基本用法1、bf.add/bf.madd 添加成功返回1 ，否则返回0 添加： bf.add [key] [value] 批量添加： bf.madd [key] [value1] [value2] [ value3] 2、bf.exists/bf.mexists 存在返回1，不存在返回0 判断是否存在 bf.exists [key] [value] 批量判断是否存在 bf.mexists [key] [value1] [value2] [value3] 12bf.add k1 v1 #==&gt; 1bf.exists k1 v1 #==&gt; 1 1234bf.madd k1 v1 v2 v3 1) (integer) 0 #重复的添加失败2) (integer) 13) (integer) 1 12345BF.MEXISTS k1 v1 v2 v3 v41) (integer) 12) (integer) 13) (integer) 14) (integer) 0 #不存在返回0 七、jedis实现布隆过滤器1、pom.xml注意这里的jedis版本必须在3以上才能使用布隆过滤器 1234567891011121314&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;&lt;!--布隆过滤器--&gt;&lt;dependency&gt; &lt;groupId&gt;com.redislabs&lt;/groupId&gt; &lt;artifactId&gt;jrebloom&lt;/artifactId&gt; &lt;version&gt;1.2.0&lt;/version&gt;&lt;/dependency&gt; 2、测试代码123456789101112131415161718192021public class BloomFilerTest { public static void main(String[] args) { GenericObjectPoolConfig config=new GenericObjectPoolConfig(); config.setMaxIdle(300); config.setMaxTotal(1000); config.setMaxWaitMillis(30000); config.setTestOnBorrow(true); JedisPool jedisPool = new JedisPool(config, \"47.96.141.44\", 6379, 30000, \"你的密码\"); Client client=new Client(jedisPool); for (int i = 0; i &lt; 1000; i++) {// 存入数据 client.add(\"k1\", \"lc:\"+i); }// 判断是否存在 //boolean exists= client.exists(\"k1\", \"lc:1001\"); //false //存在误判情况 boolean exists=client.exists(\"k1\",\"lc:1002\") //true System.out.println(exists); }} 八、设置布隆过滤器的错误率默认情况下，我们使用的布隆过滤器它的错误率是 0.01 ，默认的元素大小是 100。但是这两个参数也是可以配置的。 我们可以调用 bf.reserve 方法进行配置。 BF.RESERVE k1 0.0001 1000000 前提是该k1要存在，否则将设置为默认的值 第一个参数是 key，第二个参数是错误率，错误率越低，占用的空间越大，第三个参数预计存储的数量，当实际数量超出预计数量时，错误率会上升。 https://www.cnblogs.com/CodeBear/p/10911177.html","link":"/2020/04/27/redis/Redis%E4%B9%8B%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"},{"title":"Redis基本数据类型的操作","text":"Redis基本数据类型与key相关的基本操作1、删除keydel [key] 2、删除当前数据库中的所有key1flushdb 3、删除所有数据库的key1flushall 4、序列化给定的keydump [key] 5、判断指定的key是否存在0不存在；1存在 exists [key] 6、查看key的有效期（秒）-2已过期 -1永久有效 ttl [key] 7、设置key的有效期注意：如果key在过期时间被重新set了，那么过期时间会失效 1设置成功 0设置失败 expire [key] [seconds(秒)] 8、移除一个key的过期时间persist [key] 9、通配符查看所有的keykeys * 查看所有key keys k 查看以k开头的所有key keys [pattern] 10、查看key的有效期（毫秒）pttl [key] 注意：四种数据类型（list/set/zset/hash），在第一次使用时，如果容器不存在，就自动创建一个 四种数据类型（list/set/zset/hash），如果里边没有元素了，那么立即删除容器，释放内存。 一、StringString 是 Redis 里边最最简单的一种数据结构。在 Redis 中，所以的 key 都是字符串，但是，不同的 key 对应的 value 则具备不同的数据结构，我们所说的五种不同的数据类型，主要是指 value 的数据类型不同。 Redis 中的字符串是动态字符串，内部是可以修改的，像 Java 中的 StringBuffer，它采用分配冗余空间的方式来减少内存的频繁分配。在 Redis 内部结构中，一般实际分配的内存会大于需要的内存，当字符串小于 1M 的时候，扩容都是在现有的空间基础上加倍，扩容每次扩 1M 空间，最大 512M。 1、append追加操作append [key] [value] 12345append k1 lcappend k1 .hello#获取键值get k1 #==&gt; 'lc.hello' 2、set给key赋值set [key] [value] 12set k2 33get k2 # ==&gt; '33' 3、decr可以实现对 value 的减 1 操作（前提是 value 是一个数字），如果 value 不是数字，会报错，如果 value 不存在，则会给一个默认的值为 0，在默认值的基础上减一。 decr [key] 1decr k3 # ==&gt; '-1' 12set k2 33decr k2 #==&gt; '32' 4、decrby设置减的步长decrby [key] [decrement] 12set k2 100decrby k2 10 #==&gt; '90' 5、get获取key的valueget [key] 6、getrange截取指定范围的字符串，相当于java中的substringstart 表示开始的位置(包含此位置) end 表示结束的位置 -1 表示截取到最后一个(包含) getrange [key] [start] [end] 1234set lou www.louchen.topget lou #==&gt; \"www.louchen.top\"getrange lou 4 -1 #==&gt; \"louchen.top\"getrange lou 4 -5 #==&gt; \"louchen\" 7、getset获取并更新某一个keygetset [key] [value] 123set k2 90getset k2 100get k2 #==&gt; \"100\" 8、incr给某一个key的value自增incr [key] 9、incrby给某一个key的value自增，并设置步长incrby [key] 10、incrbyfloat和incrby类似，步长可以设置为浮点数incrbyfloat [key] [increment] 123set k2 100incrbyfloat k2 0.22get k2 #==&gt; 100.22 11、mget 和 mset批量获取与批量设置mget [key1] [key2] [key3] [key...] mset [key1] [value1] [key2] [value2] [key...] [value..] 12mset k1 11 k2 22 k3 33mget k1 k2 k3 #===&gt; \"11\" \"22\" \"33\" 12、setex给key设置value并同时设置过期时间(秒)set [key] [seconds] [value] 123set k1 10 woshi#十秒后再获取get k1 #==&gt; \"nil(表示不存在)\" 13、ttl查看key的过期时间 -1表示不会过期 -2表示已过期ttl [key] 14、psetex给key设置value并同时设置过期时间(毫秒)set [key] [millseconds] [value] 15、setnx默认情况下set命令会覆盖已存在的key, setnx不会修改已存在的key0表示修改失败 setnx [key] [value] 15、msetnx批量设置，只要有一个已存在的key都不会修改msetnx [key1] [value1] [key2] [value2] [key...] [value..] 16、setrange覆盖一个已经存在的key的value，指定范围覆盖offset为偏移量,若偏移量超过本身字符的长度，则超过的位置用0补齐 setrange [key] [offset] [value] 123456set k1 louchensetrange k1 0 222get k1 #==&gt; \"222chen\"setrange k1 10 333get k1 #==&gt; \"222chen\\x00\\x00\\x00333\" 17、strlen查看字符串总长度strlen [key] 二、String的BIT操作在 Redis 中，字符串都是以二进制的方式来存储的。例如 set k1 a，a 对应的 ASCII 码是 97，97 转为二进制是 01100001，BIT 相关的命令就是对二进制进行操作的。 getbit key 对应的 value 在 offset 处的 bit 值。 getbit [key] [offset] setbit 修改 key 对应的 value 在 offset 处的 bit 值 setbit [key] [offset] [value] bitcount 统计二进制数据中 1 的个数。 bitcount [key] 三、List集合(可重复)1、lpush 和 lrangelpush将所有指定的值插入到存于 key 的列表的头部(相当于栈,先进后出)。如果 key 不存在，那么在进行 push 操作前会创建一个空列表。 如果 key 对应的值不是一个 list 的话，那么会返回一个错误。 lpush [key] [value1] [value2] [value...] lrange返回列表指定区间内的元素 返回列表所有元素 lrange [key] 0 -1 lrange [key] [start] [stop] 12lpush lc louchen.top lc.vhrlrange lc 0 1 #==&gt; 1) \"lc.vhr\" 2) \"louchen.top\" 2、rpush从右往左插入，先进先出rpush [key] [value1] [value2] [value...] 3、rpop移除并返回列表的尾元素rpop [key] 4、lpop移除并返回列表的头元素lpop [key] 5、lindex返回列表中下标为index的元素，只是查询索引从0开始 lindex [key] [index] 6、ltrim对列表进行修剪从指定start索引位置(包含此位置)到stop位置截取(包含此位置) ltrim [key] [start] [stop] 7、blpop阻塞式的弹出，相当于lpop的阻塞版即当弹出所有元素时，再次弹出会阻塞此操作，等待下一次插入再弹出，阻塞时间设置为秒 blpop [key] [timeout秒] 四、set集合(不可重复)1、sadd添加元素到集合若有重复的value，则只会添加一个 sadd [key] [value1] [value2] [value...] 2、smembers获取该key的所有元素smembers [key] 3、srem移除指定的元素,可以同时移除多个srem [key] [member1] [member2] 4、sismember返回某一个元素是否在集合中0 代表不存在，1代表存在 sismember [key] [member] 5、scard返回集合的数量scard [key] 6、srandmember随机返回一个或多个元素count表示随机返回元素的个数。没有count则返回一个 srandmember [key] [count] 7、spop随机返回并出栈一个元素spop [key] 8、smove把一个元素从一个集合移动到另一个集合source:源集合 destination：目标集合 member：元素 smove [source] [destination] [member] 123sadd k1 a b c#将k1中的a元素移动到k2中smove k1 k2 a 9、sdiff返回两个集合的差集这里注意 是key1-key2集合。除去key2在key1中的元素。反之类似 sidff [key1] [key2] 10、sinter返回两个集合的交集sinter [key1] [key2] 11、sdiffstore类似于sdiff,只不过，计算出来的结果会保存在一个新的集合中destination:保存的新集合的key key1-key2的差集 sdiffstore [destination] [key1] [key2] 12、sinterstore类似于sinter,只不过，计算出来的交集会保存在一个新的集合中destination:保存的新集合的key key1，key2的交集 sinterstore [destination] [key1] [key2] 13、sunion求并集14、sunionstore求并集保存到新的集合中五、Hash在 hash 结构中，key 是一个字符串，value 则是一个 key/value 键值对 1、hset添加值hset [key] [field] [value] 123hset k1 name lchset k1 age 18hset k1 gender male 2、hget获取值hget [key] [field] 1hget k1 name #==&gt; \"lc\" 3、hmset批量设置hmset [key] [field1] [value1] [field2] [value2].. 1hmset k2 name lcc age 18 gender femle 4、hmget批量获取hmget [key] [field1] [field2]... 12345hmget k2 name age gender------1) \"lcc\"2) \"18\"3) \"femle\" 5、hdel删除一个指定的fieldhdel [key] [field1] [field2] 6、hsetnx默认情况下，如果field存在则会覆盖已有的value。但是hsetn不能覆盖已有的field值hsetnx [key] [field] [value] 7、hvals获取所有的valuehvals [key] 8、hkeys获取所有的keyhkeys [key] 9、hgetall同时获取所有的key和valuehgetall [key] 10、hexists返回指定field是否存在不存在返回0 存在返回1 hexists [key] [field] 11、hincrby给指定的value自增1或指定步长increment:步长 hincrby [key] [field] [increment] 12、hincrbyfloat给指定的value自增指定浮点数hincrby [key] [field] [increment] 13、hlen返回某一个key中value的数量hlen [key] 14、hstrlen返回某一个key中的某一个field的字符串长度hstrlen [key] [filed] 六、ZSet有序set集合 1、zadd将指定的元素添加到有序集合中score：分数 作为值 member1： 作为键 zadd [key] [score1] [member1] [score2] [member2]... 1zadd k1 20 v1 k1 30 v2 40 v3 50 v4 2、zscore返回member的score值zscore [key] [member] 1zscore k1 v1 # ==&gt; \"20\" 3、zrange返回指定集合范围中的一组元素withsocres: 返回score值(可选) 返回k1集合中的所有member和score zcore k1 0 -1 withsocres zcore [key] [start] [stop] withsocres 123456789101112131415161718zrange k1 0 -1 withscores---------1) \"v1\"2) \"20\"3) \"v2\"4) \"30\"5) \"v3\"6) \"40\"7) \"v4\"8) \"50\"zrange k1 0 3--------------1) \"v1\"2) \"v2\"3) \"v3\"4) \"v4\" 4、zrevrange逆序返回指定集合范围中的一组元素zrevrange [key] [start] [stop] withscores 5、zcard返回元素个数member键的个数 zcard [key] 6、zcount返回score在某一个区间内的元素的个数默认是闭区间 即包含min和max zcount [key] [min] [max] 1234#包含20，50ZCOUNT k1 20 50 #==&gt; 4#在20到50之间 不包含20，50zocunt k1 (20 (50 #==&gt; 2 7、zrangebyscore按照score的范围返回元素withscores: 是否携带score(可选) zrangebyscore [key] [min] [max] withscores 8、zrank返回元素的排名(从小到大，从0开始)zrank [key] [member] 1zrank k1 v1 #==&gt; 0 9、zrevrank返回元素排名(从大到小)zrevrank [key] [memeber] 1zrevrank k1 v1 #==&gt; 3 10、zincrby按照指定步长自增increment: 步长 zincrby [key] [increment] [member] 11、zinterstore求两个集合的交集并存入新的集合destination：新的目标集合 numkeys：相同member的个数 把key1和key2中的members相同的元素把其score累加得到新的score zinterstore [destination] [numkeys] [key1] [key2].. 12、zrem弹出指定member元素zrem [key] [member1] [member2] 13、zlexcount计算有序集合中成员数量ZLEXCOUNT k1 - + 返回最小的到最大的成员数量(即全部) zlexcount [key] [min] [max] 12#统计v2到v3之间的成功数 包括v2和v3zlexcount k1 [v2 [v3 #==&gt; 2 14、zrangebylex返回指定区间内的成员zrangebylex [key] [min] [max] 12345ZRANGEBYLEX k1 - +------------------1) \"v2\"2) \"v3\"3) \"v4\"","link":"/2020/04/20/redis/Redis%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"title":"SpringBoot整合Swagger2","text":"SpringBoot整合Swagger2一、swagger简介Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。总体目标是使客户端和文件系统作为服务器以同样的速度来更新。 作用： 接口的文档在线自动生成。 功能测试。 二、基本配置1、pom.xmlspringfox-swagger2 springfox-swagger-ui 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;swagger2&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;swagger2&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、swagger配置文件1234567891011121314151617181920212223242526272829303132333435@Configuration@EnableSwagger2//是否开启swagger，正式环境一般是需要关闭的（避免不必要的漏洞暴露！），可根据springboot的多环境配置进行设置//这里properties中的配置的swagger.enable和havingValue相等这个配置文件才会生效@ConditionalOnProperty(name = \"swagger.enable\", havingValue = \"true\")public class Swagger2Config { /** *构建swagger摘要 * @return */ @Bean Docket docket() {// 选择文本类型为SWAGGER_2 return new Docket(DocumentationType.SWAGGER_2) .select()// 指定controller所在的包 .apis(RequestHandlerSelectors.basePackage(\"org.lc.swagger2.controller\"))// 指定包下的所有路径生成文档 .paths(PathSelectors.any()) .build().apiInfo(new ApiInfoBuilder()// 文档描述信息 .description(\"这是接口文档描述信息\")// 标题 .title(\"这是项目标题\")// 联系信息 .contact(new Contact(\"lc\", \"www.louchen.top\", \"421192425@qq.com\"))// 版本 .version(\"v0.0.1\")// 许可证 .license(\"apache2.0\") .build()); }} 3、是否开启swagger配置1swagger.enable=true 4、实体描述123456789101112@Getter@Setter@ToString@ApiModel(value = \"用户实体类\",description = \"用户信息描述\")public class User { @ApiModelProperty(value = \"用户id\") private Integer id; @ApiModelProperty(value = \"用户名\") private String name; @ApiModelProperty(value = \"用户地址\") private String address;} ![](F:\\桌面内容\\springboot2\\springboot整合定时任务及swagger2\\images\\批注 2020-04-07 211747.png) 5、接口描述1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859@RestController//接口上的描述@Api(tags = \"用户数据接口\")public class UserController { /** * 这里需要指定的请求方式 否则swagger会启用所有方法类型调用 * @param id * @return */// 接口方法上的描述 @ApiOperation(value = \"查询用户\",notes = \"根据用户id查询用户\")// 接口参数上的描述// 这里的name为参数名，value为对该参数的解释，required只是对swagger的约束表示必填，默认值为11 @ApiImplicitParam(name = \"id\",value = \"用户id\",required = true,defaultValue = \"11\") @GetMapping(\"/user\") public User getUserById(Integer id) { User user=new User(); user.setId(id); return user; } @ApiOperation(value = \"删除用户\",notes = \"根据用户id删除用户\") @ApiImplicitParam(name = \"id\",value = \"用户id\",required = true,defaultValue = \"22\")// 设置响应的状态码的描述信息 @ApiResponses({ @ApiResponse(code = 200, message = \"删除成功\"), @ApiResponse(code = 500, message = \"删除失败\") }) @DeleteMapping(\"/user/{id}\") public void deleteById(@PathVariable(\"id\")Integer id){ System.out.println(\"deleteById:\"+id); } @ApiOperation(value = \"更新用户\",notes = \"根据用户id更新用户\") @ApiImplicitParams({ @ApiImplicitParam(name = \"username\",value = \"用户名\",required = true,defaultValue = \"lc\"), @ApiImplicitParam(name = \"id\",value = \"用户id\",required = true,defaultValue = \"1\") }) // 表示忽略此接口生成在swagger中// @ApiIgnore @PutMapping(\"/user\") public User updateUserById(String username,Integer id){ User user=new User(); user.setId(id); user.setName(username); return user; } @ApiOperation(value = \"添加用户\",notes = \"添加用户信息\") @PostMapping(\"/user\") public User addUser(@RequestBody User user){ return user; }} ![](F:\\桌面内容\\springboot2\\springboot整合定时任务及swagger2\\images\\批注 2020-04-07 211922.png) ![](F:\\桌面内容\\springboot2\\springboot整合定时任务及swagger2\\images\\批注 2020-04-07 211949.png) ![](F:\\桌面内容\\springboot2\\springboot整合定时任务及swagger2\\images\\批注 2020-04-07 212014.png) 6、swagger注解介绍 @Api：可设置对控制器的描述- @ApiOperation：: 可设置对接口方法的描述 @ApiIgnore: Swagger 文档不会显示拥有该注解的接口。 @ApiImplicitParams: 用于描述接口的非对象参数集。 @ApiImplicitParam: 用于描述接口的非对象参数，一般与 @ApiImplicitParams 组合使用。 @ApiImplicitParam 注解用来描述一个参数，可以配置参数的中文含义，也可以给参数设置默认值，这样在接口测试的时候可以避免手动输入。 如果有多个参数，则需要使用多个 @ApiImplicitParam 注解来描述，多个 @ApiImplicitParam 注解需要放在一个 @ApiImplicitParams 注解中。 需要注意的是，@ApiImplicitParam 注解中虽然可以指定参数是必填的，但是却不能代替 @RequestParam(required = true) ，前者的必填只是在 Swagger2 框架内必填，抛弃了 Swagger2 ，这个限制就没用了，所以假如开发者需要指定一个参数必填， @RequestParam(required = true) 注解还是不能省略。 @ApiModel:可设置接口相关实体的描述 @ApiModelProperty: 可设置实体属性的相关描述。 7、在 Security 中的配置​ 如果我们的 Spring Boot 项目中集成了 Spring Security，那么如果不做额外配置，Swagger2 文档可能会被拦截，此时只需要在 Spring Security 的配置类中重写 configure 方法，添加如下过滤即可： 1234567@Overridepublic void configure(WebSecurity web) throws Exception { web.ignoring() .antMatchers(\"/swagger-ui.html\") .antMatchers(\"/v2/**\") .antMatchers(\"/swagger-resources/**\");} 如此之后，Swagger2 文件就不需要认证就能访问了","link":"/2020/04/17/springboot/SpringBoot%E6%95%B4%E5%90%88Swagger2/"},{"title":"SpringBoot国际化","text":"SpringBoot国际化​ 国际化，也叫 i18n，为啥叫这个名字呢？因为国际化英文是 internationalization ，在 i 和 n 之间有 18 个字母，所以叫 i18n。我们的应用如果做了国际化就可以在不同的语言环境下，方便的进行切换，最常见的就是中文和英文之间的切换，国际化这个功能也是相当的常见。在 Spring 中，就通过 AcceptHeaderLocaleResolver 对国际化提供了支持，开发者通过简单配置，就可以在项目中直接使用国际化功能了。 一、基本使用Spring Boot 和 Spring 一脉相承，对于国际化的支持，默认是通过 AcceptHeaderLocaleResolver 解析器来完成的，这个解析器，默认是通过请求头的 Accept-Language 字段来判断当前请求所属的环境的，进而给出合适的响应。 首先创建一个普通的 Spring Boot 项目，添加 web 依赖即可。项目创建成功后，默认的国际化配置文件放在 resources 目录下，所以我们直接在该目录下创建四个测试文件，如下： 我们的 message 文件是直接创建在 resources 目录下的，IDEA 在展示的时候，会多出一个 Resource Bundle，这个大家不用管，千万别手动去创建这个目录。 messages.properties 这个是默认的配置，其他的则是不同语言环境下的配置，en_US 是英语(美国)，zh_CN 是中文简体，zh_TW 是中文繁体（文末附录里边有一个完整的语言简称表格）。 ![](F:\\桌面内容\\springboot2\\springboot系列\\images\\批注 2020-04-12 110435.png) 四个文件创建好之后，第一个默认的我们可以先空着，另外三个分别填入以下内容： messages.properties 1user.name=default messages_zh_CN.properties 1user.name=张三 messages_zh_TW.properties 1user.name=張三 messages_en_US.properties 1user.name=lc 配置完成后，我们就可以直接开始使用了。在需要使用值的地方，直接注入 MessageSource 实例即可。 在 Spring 中需要配置的 MessageSource 现在不用配置了，Spring Boot 会通过 org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration 自动帮我们配置一个 MessageSource 实例。 引用web依赖即可使用 spring-boot-starter-web 直接创建一个controller使用即可 1234567891011@RestControllerpublic class HelloController { @Autowired MessageSource messageSource; @GetMapping(\"/hello\") public String hello() { return messageSource.getMessage(\"user.name\", null, LocaleContextHolder.getLocale()); }} 在 HelloController 中我们可以直接注入 MessageSource 实例，然后调用该实例中的 getMessage 方法去获取变量的值，第一个参数是要获取变量的 key，第二个参数是如果 value 中有占位符，可以从这里传递参数进去，第三个参数传递一个 Locale 实例即可，这相当于当前的语言环境。 接下来我们就可以直接去调用这个接口了。 默认情况下，在接口调用时，通过请求头的 Accept-Language 来配置当前的环境，我这里通过 POSTMAN 来进行测试，结果如下： 直接在请求头中设置Accept-Language即可 直接切换：Accept-Language的value值即可 输出不同的语言 注意：这种方式只能将参数放在请求头中，不能放在url即params中 二、自定义切换将参数放在请求参数中，即url上 localeResolver的名字必须为这个 12345678910111213141516171819@Configurationpublic class WebConfig implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { LocaleChangeInterceptor interceptor=new LocaleChangeInterceptor();// 设置参数名 interceptor.setParamName(\"lang\"); registry.addInterceptor(interceptor); } //注意 这里的localeResolver只能叫这个名，不能叫其他名 @Bean LocaleResolver localeResolver() { SessionLocaleResolver localeResolver=new SessionLocaleResolver();// 默认语言中文 localeResolver.setDefaultLocale(Locale.SIMPLIFIED_CHINESE); return localeResolver; }} 在这段配置中，我们首先提供了一个 SessionLocaleResolver 实例，这个实例会替换掉默认的 AcceptHeaderLocaleResolver，不同于 AcceptHeaderLocaleResolver 通过请求头来判断当前的环境信息，SessionLocaleResolver 将客户端的 Locale 保存到 HttpSession 对象中，并且可以进行修改（这意味着当前环境信息，前端给浏览器发送一次即可记住，只要 session 有效，浏览器就不必再次告诉服务端当前的环境信息）。 另外我们还配置了一个拦截器，这个拦截器会拦截请求中 key 为 lang 的参数（不配置的话是 locale），这个参数则指定了当前的环境信息。 这个指定只需要一次即可，也就是说，在 session 不变的情况下，下次请求可以不必带上 lang 参数，服务端已经知道当前的环境信息了。 ![](F:\\桌面内容\\springboot2\\springboot系列\\images\\批注 2020-04-12 114357.png) 三、自定义位置默认情况下，我们的配置文件放在 resources 目录下，如果大家想自定义，也是可以的，例如定义在 resources/i18n 目录下： ![](F:\\桌面内容\\springboot2\\springboot系列\\images\\批注 2020-04-12 114632.png) 但是这种定义方式系统就不知道去哪里加载配置文件了，此时还需要 application.properties 中进行额外配置(注意这是一个相对路径)： ![](F:\\桌面内容\\springboot2\\springboot系列\\images\\批注 2020-04-12 115638.png) 四、语言简称表 语言 简称 简体中文(中国) zh_CN 繁体中文(中国台湾) zh_TW 繁体中文(中国香港) zh_HK 英语(中国香港) en_HK 英语(美国) en_US 英语(英国) en_GB 英语(全球) en_WW 英语(加拿大) en_CA 英语(澳大利亚) en_AU 英语(爱尔兰) en_IE 英语(芬兰) en_FI 芬兰语(芬兰) fi_FI 英语(丹麦) en_DK 丹麦语(丹麦) da_DK 英语(以色列) en_IL 希伯来语(以色列) he_IL 英语(南非) en_ZA 英语(印度) en_IN 英语(挪威) en_NO 英语(新加坡) en_SG 英语(新西兰) en_NZ 英语(印度尼西亚) en_ID 英语(菲律宾) en_PH 英语(泰国) en_TH 英语(马来西亚) en_MY 英语(阿拉伯) en_XA 韩文(韩国) ko_KR 日语(日本) ja_JP 荷兰语(荷兰) nl_NL 荷兰语(比利时) nl_BE 葡萄牙语(葡萄牙) pt_PT 葡萄牙语(巴西) pt_BR 法语(法国) fr_FR 法语(卢森堡) fr_LU 法语(瑞士) fr_CH 法语(比利时) fr_BE 法语(加拿大) fr_CA 西班牙语(拉丁美洲) es_LA 西班牙语(西班牙) es_ES 西班牙语(阿根廷) es_AR 西班牙语(美国) es_US 西班牙语(墨西哥) es_MX 西班牙语(哥伦比亚) es_CO 西班牙语(波多黎各) es_PR 德语(德国) de_DE 德语(奥地利) de_AT 德语(瑞士) de_CH 俄语(俄罗斯) ru_RU 意大利语(意大利) it_IT 希腊语(希腊) el_GR 挪威语(挪威) no_NO 匈牙利语(匈牙利) hu_HU 土耳其语(土耳其) tr_TR 捷克语(捷克共和国) cs_CZ 斯洛文尼亚语 sl_SL 波兰语(波兰) pl_PL 瑞典语(瑞典) sv_SE 西班牙语(智利) es_CL","link":"/2020/04/17/springboot/springboot%E5%9B%BD%E9%99%85%E5%8C%96/"},{"title":"springboot与jpa构建restful风格","text":"springboot与jpa构建restful风格一、基本配置1、pom.xmlspring-boot-starter-data-rest 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;jpa-rest&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;jpa-rest&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-rest&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.18&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;version&gt;5.1.27&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、实体bean1234567891011@Getter@Setter@ToString@Entity(name = \"t_book\")public class Book { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; private String name; private String author;} 3、yaml配置1234567891011121314151617181920212223spring: datasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=UTF-8 username: root password: 123456 jpa: # 显示sql语句 show-sql: true # 数据库 database: mysql # 数据库平台 database-platform: mysql # 设置表的结构的生成类型 hibernate: # 每次启动更新表结构 ddl-auto: update properties: hibernate: # 设置方言 mysql57 dialect: org.hibernate.dialect.MySQL57Dialect 4、dao接口配置12public interface BookDao extends JpaRepository&lt;Book,Integer&gt; {} 二、基本的restful风格的增删改查1、查询所有数据要查询的实体的类名首字母小写，然后在后面加s get: http://localhost:8080/books 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384{ \"_embedded\": { \"books\": [ { \"name\": \"三国演义\", \"author\": \"罗贯中\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/books/1\" }, \"book\": { \"href\": \"http://localhost:8080/books/1\" } } }, { \"name\": \"水浒传\", \"author\": \"施耐庵\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/books/2\" }, \"book\": { \"href\": \"http://localhost:8080/books/2\" } } }, { \"name\": \"红楼梦\", \"author\": \"曹雪芹\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/books/3\" }, \"book\": { \"href\": \"http://localhost:8080/books/3\" } } }, { \"name\": \"西游记\", \"author\": \"吴承恩\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/books/4\" }, \"book\": { \"href\": \"http://localhost:8080/books/4\" } } }, { \"name\": \"童年\", \"author\": \"鲁迅\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/books/5\" }, \"book\": { \"href\": \"http://localhost:8080/books/5\" } } } ] }, \"_links\": { \"self\": { //可对分页进行排序操作 \"href\": \"http://localhost:8080/books{?page,size,sort}\", \"templated\": true }, \"profile\": { \"href\": \"http://localhost:8080/profile/books\" } }, //分页信息 //页的大小20 ；总记录数为5 ，总页数为1 ， 当前页为1（jpa中页面从0开始） \"page\": { \"size\": 20, \"totalElements\": 5, \"totalPages\": 1, \"number\": 0 }} 2、分页查询查询第二页，每页大小为2 get: http://localhost:8080/books?page=1&amp;size=2 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162{ \"_embedded\": { \"books\": [ { \"name\": \"红楼梦\", \"author\": \"曹雪芹\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/books/3\" }, \"book\": { \"href\": \"http://localhost:8080/books/3\" } } }, { \"name\": \"西游记\", \"author\": \"吴承恩\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/books/4\" }, \"book\": { \"href\": \"http://localhost:8080/books/4\" } } } ] }, \"_links\": { //首页地址 \"first\": { \"href\": \"http://localhost:8080/books?page=0&amp;size=2\" }, //上一页地址 \"prev\": { \"href\": \"http://localhost:8080/books?page=0&amp;size=2\" }, //排序 \"self\": { \"href\": \"http://localhost:8080/books{&amp;sort}\", \"templated\": true }, //下一页地址 \"next\": { \"href\": \"http://localhost:8080/books?page=2&amp;size=2\" }, //最后一页地址 \"last\": { \"href\": \"http://localhost:8080/books?page=2&amp;size=2\" }, \"profile\": { \"href\": \"http://localhost:8080/profile/books\" } }, \"page\": { \"size\": 2, \"totalElements\": 5, \"totalPages\": 3, \"number\": 1 }} 3、分页排序查询先按照id降序排列，然后查询出第二页的数据 get : http://localhost:8080/books?page=1&amp;size=2&amp;sort=id,desc 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556{ \"_embedded\": { \"books\": [ { \"name\": \"红楼梦\", \"author\": \"曹雪芹\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/books/3\" }, \"book\": { \"href\": \"http://localhost:8080/books/3\" } } }, { \"name\": \"水浒传\", \"author\": \"施耐庵\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/books/2\" }, \"book\": { \"href\": \"http://localhost:8080/books/2\" } } } ] }, \"_links\": { \"first\": { \"href\": \"http://localhost:8080/books?page=0&amp;size=2&amp;sort=id,desc\" }, \"prev\": { \"href\": \"http://localhost:8080/books?page=0&amp;size=2&amp;sort=id,desc\" }, \"self\": { \"href\": \"http://localhost:8080/books\" }, \"next\": { \"href\": \"http://localhost:8080/books?page=2&amp;size=2&amp;sort=id,desc\" }, \"last\": { \"href\": \"http://localhost:8080/books?page=2&amp;size=2&amp;sort=id,desc\" }, \"profile\": { \"href\": \"http://localhost:8080/profile/books\" } }, \"page\": { \"size\": 2, \"totalElements\": 5, \"totalPages\": 3, \"number\": 1 }} 4、查询指定id数据查询id为3的数据 get: http://localhost:8080/books/3 123456789101112{ \"name\": \"红楼梦\", \"author\": \"曹雪芹\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/books/3\" }, \"book\": { \"href\": \"http://localhost:8080/books/3\" } }} 5、添加数据post: http://localhost:8080/books application-type: json 1234{ \"name\":\"史记\", \"author\":\"司马迁\"} 123456789101112{ \"name\": \"史记\", \"author\": \"司马迁\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/books/6\" }, \"book\": { \"href\": \"http://localhost:8080/books/6\" } }} 6、根据id修改put: http://localhost:8080/books/6 application-type: json 这里的修改必须要传所有字段，否则没有传的字段会赋值为null 1234{ \"name\":\"《史记》\", \"author\":\"司马老贼\"} 123456789101112{ \"name\": \"《史记》\", \"author\": \"司马老贼\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/books/6\" }, \"book\": { \"href\": \"http://localhost:8080/books/6\" } }} 7、根据id删除delete: http://localhost:8080/books/6 三、自定义查询方法接口1、dao接口123456789public interface BookDao extends JpaRepository&lt;Book,Integer&gt; { /** * 查询包含的名称的数据 * @param name * @return */ List&lt;Book&gt; findBooksByNameContaining(@Param(\"name\") String name);} 2、postman测试①查询所有可使用的接口get： http://localhost:8080/books/search 1234567891011{ \"_links\": { \"findBooksByNameContaining\": { \"href\": \"http://localhost:8080/books/search/findBooksByNameContaining{?name}\", \"templated\": true }, \"self\": { \"href\": \"http://localhost:8080/books/search\" } }} ②使用自定义的接口查询名称包含红的集合 get: http://localhost:8080/books/search/findBooksByNameContaining?name=红 1234567891011121314151617181920212223{ \"_embedded\": { \"books\": [ { \"name\": \"红楼梦\", \"author\": \"曹雪芹\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/books/3\" }, \"book\": { \"href\": \"http://localhost:8080/books/3\" } } } ] }, \"_links\": { \"self\": { \"href\": \"http://localhost:8080/books/search/findBooksByNameContaining?name=%E7%BA%A2\" } }} ③修改请求路径及集合路径@RepositoryRestResource(path = “bs”,collectionResourceRel = “bs1”,itemResourceRel = “b”) path： 请求的一级路径 collectionResourceRel ： 集合名称 itemResourceRel： 集合中的路径herf元素名称 @RestResource(exported = true,path = “byname”,rel = “findByName”) exported : 是否暴露此接口（默认为true） path: 请求的二级路径 rel : 查询所有接口时的该方法的对象名称 修改dao接口==&gt; 123456789101112@RepositoryRestResource(path = \"bs\",collectionResourceRel = \"bs1\",itemResourceRel = \"b\")public interface BookDao extends JpaRepository&lt;Book,Integer&gt; { /** * 查询包含的名称的数据 * @param name * @return */ @RestResource(exported = true,path = \"byname\",rel = \"findByName\") List&lt;Book&gt; findBooksByNameContaining(@Param(\"name\") String name); } 查询所有接口==&gt; get: http://localhost:8080/bs/search 1234567891011{ \"_links\": { \"findByName\": { \"href\": \"http://localhost:8080/bs/search/byname{?name}\", \"templated\": true }, \"self\": { \"href\": \"http://localhost:8080/bs/search\" } }} 使用该findByName接口==&gt; get : http://localhost:8080/bs/search/byname?name=红 1234567891011121314151617181920212223{ \"_embedded\": { \"bs1\": [ { \"name\": \"红楼梦\", \"author\": \"曹雪芹\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/bs/3\" }, \"b\": { \"href\": \"http://localhost:8080/bs/3\" } } } ] }, \"_links\": { \"self\": { \"href\": \"http://localhost:8080/bs/search/byname?name=%E7%BA%A2\" } }} 四、实现跨域@CrossOrigin 默认为允许所有请求 @CrossOrigin(“*”) 12345678910111213@CrossOrigin@RepositoryRestResource(path = \"bs\",collectionResourceRel = \"bs1\",itemResourceRel = \"b\")public interface BookDao extends JpaRepository&lt;Book,Integer&gt; { /** * 查询包含的名称的数据 * @param name * @return */ @RestResource(exported = true,path = \"byname\",rel = \"findByName\") List&lt;Book&gt; findBooksByNameContaining(@Param(\"name\") String name);} 五、更改spring中对restful的自动配置org.springframework.boot.autoconfigure.data.rest.RepositoryRestProperties==&gt; 12345678910111213141516171819202122232425@ConfigurationProperties( prefix = \"spring.data.rest\")public class RepositoryRestProperties { //基础路径 private String basePath; //默认页 private Integer defaultPageSize; //每页的最大尺寸 private Integer maxPageSize; //页码的参数名称 private String pageParamName; private String limitParamName; //排序的参数名称 private String sortParamName; private RepositoryDetectionStrategies detectionStrategy; private MediaType defaultMediaType; //创建后并返回 private Boolean returnBodyOnCreate; //更新后并返回 private Boolean returnBodyOnUpdate; private Boolean enableEnumTranslation; //**** //****} 1、yaml的配置12345spring: data: rest:# 加前缀 base-path: /api 2、配置文件配置1234567891011121314/** * 此类的优先级配置 高于 yaml中的配置 */@Configurationpublic class RestConfig implements RepositoryRestConfigurer { @Override public void configureRepositoryRestConfiguration(RepositoryRestConfiguration config) { //设置默认路径 config.setBasePath(\"/lc\") //设置默认页大小 .setDefaultPageSize(2); }} 请求测试：==&gt; get: http://localhost:8080/lc/bs/search/byname?name=红 1234567891011121314151617181920212223{ \"_embedded\": { \"bs1\": [ { \"name\": \"红楼梦\", \"author\": \"曹雪芹\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/lc/bs/3\" }, \"b\": { \"href\": \"http://localhost:8080/lc/bs/3\" } } } ] }, \"_links\": { \"self\": { \"href\": \"http://localhost:8080/lc/bs/search/byname?name=%E7%BA%A2\" } }}","link":"/2020/04/17/restful/jpa%E6%9E%84%E5%BB%BArestful%E9%A3%8E%E6%A0%BC/"},{"title":"springsecurity&#x2F;Spring-Security整合OAuth2","text":"Spring-Security整合OAuth2基本配置1、pom.xmlspring-security-oauth2 spring-boot-starter-security spring-boot-starter-data-redis 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lx&lt;/groupId&gt; &lt;artifactId&gt;security-oauth&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;security-oauth&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security.oauth&lt;/groupId&gt; &lt;artifactId&gt;spring-security-oauth2&lt;/artifactId&gt; &lt;version&gt;2.3.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--redis 存储token--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、yaml配置1234567spring:# redis配置 redis: port: 6379 password: xxxxxx host: 47.96.141.44 database: 0 3、controller123456789101112131415161718192021222324252627282930@RestControllerpublic class controller { /** * 模拟admin用户 * @return */ @GetMapping(\"/admin/hello\") public String admin() { return \"hello admin\"; } /** * 模拟user用户 * @return */ @GetMapping(\"/user/hello\") public String user() { return \"user hello\"; } /** * 普通用户（登录即可访问） * @return */ @GetMapping(\"/hello\") public String hello() { return \"hello\"; }} 4、核心配置①授权服务器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/** * 授权服务器 */@Configuration//开启授权服务器@EnableAuthorizationServerpublic class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter { /** * 注入认证管理器 来支持password的认证模式 * * 在oauth2模式中，有四种不同的认证模式. * 第三方登录一般使用授权码模式 * 前后端分离一般使用password模式 */ @Autowired private AuthenticationManager authenticationManager; @Autowired private RedisConnectionFactory redisConnectionFactory; @Autowired private UserDetailsService userDetailsService; @Bean PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); } /** * 配置password模式 * 配置用户 * @param clients * @throws Exception */ @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception {// 配置在内存中 clients.inMemory()// 设置认证模式 设置客户端id .withClient(\"password\")// 配置授权模式 标准的oauth并不包含refresh_token。但是在springsecurity实现下refresh_token归为其中一种// 获取token 和 刷新token的 .authorizedGrantTypes(\"password\", \"refresh_token\")// 设置过期时间 1800s .accessTokenValiditySeconds(1800)// 设置资源id .resourceIds(\"rid\") .scopes(\"all\")// 需要的密码（加密之后）密码 123 .secret(\"$2a$10$vMu/taZjUE/JPUUi8Aep/epAjQjT5XqJj1/fOKqH/n1k9x8DOnkW6\"); } /** * 令牌的存储 * @param endpoints * @throws Exception */ @Override public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception { endpoints.tokenStore(new RedisTokenStore(redisConnectionFactory)) .authenticationManager(authenticationManager) .userDetailsService(userDetailsService); } /** *支持client id和 client secret 作登录认证 * @param security * @throws Exception */ @Override public void configure(AuthorizationServerSecurityConfigurer security) throws Exception { security.allowFormAuthenticationForClients(); }} ②资源服务器（提供资源，即访问的路径，引用的令牌）123456789101112131415161718192021222324252627282930/** * 资源服务器 提供资源 */@Configuration//开启资源服务器@EnableResourceServerpublic class ResourceServerConfig extends ResourceServerConfigurerAdapter{ @Override public void configure(ResourceServerSecurityConfigurer resources) throws Exception {// 指定资源id resources.resourceId(\"rid\")// 这些资源基于令牌进行认证 .stateless(true); } /** * 先去授权服务器获取token，再去访问资源 * 在这里我们提供访问资源的路径 * @param http * @throws Exception */ @Override public void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers(\"/admin/**\").hasRole(\"admin\") .antMatchers(\"/user/**\").hasRole(\"user\") .anyRequest().authenticated(); }} ③security配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter { @Bean @Override public AuthenticationManager authenticationManagerBean() throws Exception { return super.authenticationManagerBean(); } @Bean @Override protected UserDetailsService userDetailsService() { return super.userDetailsService(); } /** * 配置模拟用户 * @param auth * @throws Exception */ @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.inMemoryAuthentication() //密码123 .withUser(\"lc\").password(\"$2a$10$vMu/taZjUE/JPUUi8Aep/epAjQjT5XqJj1/fOKqH/n1k9x8DOnkW6\") .roles(\"admin\") .and() //密码123 .withUser(\"zs\").password(\"$2a$10$vMu/taZjUE/JPUUi8Aep/epAjQjT5XqJj1/fOKqH/n1k9x8DOnkW6\") .roles(\"user\"); } /** * 拦截指定的请求 * @param http * @throws Exception */ @Override protected void configure(HttpSecurity http) throws Exception { http.antMatcher(\"/oauth/**\")// 拦截像/oauth/**的请求 .authorizeRequests()// 符合/oauth/** .antMatchers(\"/oauth/**\")// 全部放行 .permitAll() .and() .csrf().disable(); }} 5、请求过程详解① 获取令牌PUT: http://localhost:8080/oauth/token content-type : x-www-form-urlencoded 请求参数==&gt; username 和 password 为登录的用户名和密码 123456\"key\":\"username\",\"value\":\"lc\"\"key\":\"password\",\"value\":\"123\"\"key\":\"grant_type\",\"value\":\"password\"\"key\":\"client_id\",\"value\":\"password\"\"key\":\"scope\",\"value\":\"all\"\"key\":\"client_secret\",\"value\":\"123\" 结果: ==&gt; 123456789{ \"access_token\": \"d274cd88-1c84-4d6a-9da4-11ed734aed6f\", \"token_type\": \"bearer\", //用户请求获得新的token的验证 \"refresh_token\": \"0a454a83-9bf5-4331-bf12-35d4ac519f30\", //过期时间 \"expires_in\": 1064, \"scope\": \"all\"} ②请求资源接口访问普通接口==&gt; GET: http://localhost:8080/hello?access_token=d274cd88-1c84-4d6a-9da4-11ed734aed6f admin接口==&gt; GET: http://localhost:8080/admin/hello?access_token=d274cd88-1c84-4d6a-9da4-11ed734aed6f user接口==&gt; GET: http://localhost:8080/user/hello?access_token=d274cd88-1c84-4d6a-9da4-11ed734aed6f ③获取新的token，旧token失效POST: http://localhost:8080/oauth/token 请求参数==&gt; refresh_token 是之前用户登录 refresh_token的的值 1234\"key\":\"grant_type\",\"value\":\"refresh_token\"\"key\":\"refresh_token\",\"value\":\"0a454a83-9bf5-4331-bf12-35d4ac519f30\"\"key\":\"client_id\",\"value\":\"password\"\"key\":\"client_secret\",\"value\":\"123\" 请求结果==&gt; 1234567{ \"access_token\": \"8b03dd6a-18c7-49c0-b2ab-e0962627608c\", \"token_type\": \"bearer\", \"refresh_token\": \"0a454a83-9bf5-4331-bf12-35d4ac519f30\", \"expires_in\": 1799, \"scope\": \"all\"}","link":"/2020/04/17/springsecurity/Spring-Security%E6%95%B4%E5%90%88OAuth2/"},{"title":"Spring-Security整合jwt","text":"Spring-Security整合jwt一、有状态登录和无状态登录有状态：有状态服务，即服务端需要记录每次会话的客户端信息，从而识别客户端身份，根据用户身份进行请求的处理，典型的设计如Tomcat中的Session。例如登录：用户登录后，我们把用户的信息保存在服务端session中，并且给用户一个cookie值，记录对应的session，然后下次请求，用户携带cookie值来（这一步有浏览器自动完成），我们就能识别到对应session，从而找到用户的信息。这种方式目前来看最方便，但是也有一些缺陷，如下： 服务端保存大量数据，增加服务端压力 服务端保存用户状态，不支持集群化部署 无状态：微服务集群中的每个服务，对外提供的都使用RESTful风格的接口。而RESTful风格的一个最重要的规范就是：服务的无状态性，即： 服务端不保存任何客户端请求者信息 客户端的每次请求必须具备自描述信息，通过这些信息识别客户端身份 那么这种无状态性有哪些好处呢？ 客户端请求不依赖服务端的信息，多次请求不需要必须访问到同一台服务器 服务端的集群和状态对客户端透明 服务端可以任意的迁移和伸缩（可以方便的进行集群化部署） 减小服务端存储压力 二、如何实现无状态登录无状态登录的流程： 首先客户端发送账户名/密码到服务端进行认证 认证通过后，服务端将用户信息加密并且编码成一个token，返回给客户端 以后客户端每次发送请求，都需要携带认证的token 服务端对客户端发送来的token进行解密，判断是否有效，并且获取用户登录信息 三、JWT简介JWT包含三部分数据： Header：头部，通常头部有两部分信息： 声明类型，这里是JWT 加密算法，自定义 我们会对头部进行Base64Url编码（可解码），得到第一部分数据。 Payload：载荷，就是有效数据，在官方文档中(RFC7519)，这里给了7个示例信息： iss (issuer)：表示签发人 exp (expiration time)：表示token过期时间 sub (subject)：主题 aud (audience)：受众 nbf (Not Before)：生效时间 iat (Issued At)：签发时间 jti (JWT ID)：编号 这部分也会采用Base64Url编码，得到第二部分数据。 Signature：签名，是整个数据的认证信息。一般根据前两步的数据，再加上服务的的密钥secret（密钥保存在服务端，不能泄露给客户端），通过Header中配置的加密算法生成。用于验证整个数据完整和可靠性。 生成的数据格式如下： eyJhbGciOiJIUzUxMiJ9. ==&gt; 1{\"alg\":\"HS512\"} eyJhdXRob3JpdGllcyI6IlJPTEVfdXNlciwiLCJzdWIiOiJ6cyIsImV4cCI6MTU4NTY2ODQyM30. ==&gt; 1{\"authorities\":\"ROLE_user,\",\"sub\":\"zs\",\"exp\":1585668423} 5IgsesOWhkVPpyLbIHWbgeNNQFZvIRik2FlZHWCIoD7jH1b2BOgYHqWKb7LehZ_lyK53ZggXIdLVQJ_cqnVPtQ 最后一段无法解密 jwt交互流程： 应用程序或客户端向授权服务器请求授权 获取到授权后，授权服务器会向应用程序返回访问令牌 应用程序使用访问令牌来访问受保护资源（如API） 因为JWT签发的token中已经包含了用户的身份信息，并且每次请求都会携带，这样服务的就无需保存用户信息，甚至无需去数据库查询，这样就完全符合了RESTful的无状态规范。 四、基本配置1、pom.xmljjwt 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;springsecurity-jwt&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;springsecurity-jwt&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、实体1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package org.lc.springsecurityjwt.bean;import org.springframework.security.core.GrantedAuthority;import org.springframework.security.core.userdetails.UserDetails;import java.util.Collection;/** * @BelongsProject: springsecurity-jwt * @BelongsPackage: org.lc.springsecurityjwt.bean * @Author: lc * @CreateTime: 2020-03-31 16:53 * @Description: */public class User implements UserDetails { private Integer id; private String username; private String password; public User setId(Integer id) { this.id = id; return this; } public Integer getId() { return id; } public User setUsername(String username) { this.username = username; return this; } public User setPassword(String password) { this.password = password; return this; } @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() { return null; } @Override public String getPassword() { return password; } @Override public String getUsername() { return username; } @Override public boolean isAccountNonExpired() { return true; } @Override public boolean isAccountNonLocked() { return true; } @Override public boolean isCredentialsNonExpired() { return true; } @Override public boolean isEnabled() { return true; }} 3、jwt登录的过滤器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class JwtLoginFilter extends AbstractAuthenticationProcessingFilter { public JwtLoginFilter(String defaultFilterProcessesUrl, AuthenticationManager authenticationManager) { super(defaultFilterProcessesUrl); setAuthenticationManager(authenticationManager); } @Override public Authentication attemptAuthentication(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws AuthenticationException, IOException, ServletException {// 从过滤的请求中 ，获得流。获取登录的用户对象// 以json形式登录 User user=new ObjectMapper().readValue(httpServletRequest.getInputStream(), User.class); return getAuthenticationManager().authenticate(new UsernamePasswordAuthenticationToken(user.getUsername(), user.getPassword())); } //登录成功的回调 @Override protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult) throws IOException, ServletException {// 获取登录用户的角色 Collection&lt;? extends GrantedAuthority&gt; authorities=authResult.getAuthorities(); StringBuffer sb=new StringBuffer(); for (GrantedAuthority authority : authorities) {// 将角色所有角色加到一个以逗号隔开的字符串中 sb.append(authority.getAuthority()).append(\",\"); }// 构建jwt String jwt = Jwts.builder()// 构建角色 .claim(\"authorities\", sb)// 构建的主题 一般为用户名 .setSubject(authResult.getName())// 设置过期时间为 当前时间加上一个小时，即一个小时的过期时间 .setExpiration(new Date(System.currentTimeMillis() + 60 * 60 * 1000))// 签名 .signWith(SignatureAlgorithm.HS512, \"louchen\") .compact(); Map&lt;String,String&gt; map=new HashMap&lt;&gt;(); map.put(\"token\", jwt); map.put(\"msg\", \"登录成功！\"); response.setContentType(\"application/json;charset=utf-8\"); PrintWriter printWriter=response.getWriter(); printWriter.write(new ObjectMapper().writeValueAsString(map)); printWriter.flush(); printWriter.close(); }// 登录失败的回调 @Override protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed) throws IOException, ServletException { Map&lt;String,String&gt; map=new HashMap&lt;&gt;(); map.put(\"msg\", \"登录失败！\"); response.setContentType(\"application/json;charset=utf-8\"); PrintWriter printWriter=response.getWriter(); printWriter.write(new ObjectMapper().writeValueAsString(map)); printWriter.flush(); printWriter.close(); }} 4、jwt的Token验证过滤器12345678910111213141516public class JwtFilter extends GenericFilterBean { @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { HttpServletRequest req = (HttpServletRequest)servletRequest; String jwtToken = req.getHeader(\"authorization\"); Jws&lt;Claims&gt; jws= Jwts.parser().setSigningKey(\"louchen\") .parseClaimsJws(jwtToken.replace(\"Bearer\", \"\")); Claims claims=jws.getBody(); String username = claims.getSubject(); List&lt;GrantedAuthority&gt; authorities= AuthorityUtils.commaSeparatedStringToAuthorityList((String) claims.get(\"authorities\")); UsernamePasswordAuthenticationToken token = new UsernamePasswordAuthenticationToken(username, null, authorities); SecurityContextHolder.getContext().setAuthentication(token); filterChain.doFilter(servletRequest, servletResponse); }} 5、security配置123456789101112131415161718192021222324252627282930313233343536373839@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter { @Bean PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); } @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.inMemoryAuthentication() .withUser(\"lc\") .password(\"$2a$10$qrWxqVUCyOc.C5/uTx.9cO8cu89ast7g.mGhSms8yfj/4VPGRLab2\") .roles(\"admin\") .and() .withUser(\"zs\") .password(\"$2a$10$qrWxqVUCyOc.C5/uTx.9cO8cu89ast7g.mGhSms8yfj/4VPGRLab2\") .roles(\"user\"); } @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers(\"/hello\") .hasRole(\"user\") .antMatchers(\"/admin\") .hasRole(\"admin\") .antMatchers(HttpMethod.POST,\"/login\")// 允许登录的接口 .permitAll() .anyRequest().authenticated() .and()// 传入JwtLoginFilter中第一个参数 。作为过滤之前的请求 .addFilterBefore(new JwtLoginFilter(\"/login\", authenticationManager()), UsernamePasswordAuthenticationFilter.class) .addFilterBefore(new JwtFilter(),UsernamePasswordAuthenticationFilter.class) .csrf().disable(); }} 6、controller1234567891011121314@RestControllerpublic class HelloController { @GetMapping(\"/hello\") public String hello() { return \"hello everyone\"; } @GetMapping(\"/admin\") public String admin() { return \"hello admin\"; }} 7、请求测试请求登录：POST: http://localhost:8080/logincontent-type: application/json ==&gt; 请求参数 1234{ \"username\":\"zs\", \"password\":\"123\"} 结果==&gt; 1234{ \"msg\": \"登录成功！\", \"token\": \"eyJhbGciOiJIUzUxMiJ9.eyJhdXRob3JpdGllcyI6IlJPTEVfdXNlciwiLCJzdWIiOiJ6cyIsImV4cCI6MTU4NTY2ODQyM30.5IgsesOWhkVPpyLbIHWbgeNNQFZvIRik2FlZHWCIoD7jH1b2BOgYHqWKb7LehZ_lyK53ZggXIdLVQJ_cqnVPtQ\"} 请求接口：GET: http://localhost:8080/hello 选择Authorization的type为Bearer Token ，将Token输入。每次请求携带此token","link":"/2020/04/17/springsecurity/Spring-Security%E6%95%B4%E5%90%88jwt/"},{"title":"Springboot整合Quartz","text":"Springboot整合Quartz一、什么是Quartz在Quartz官网上是这么写的 1、Quartz 是一个完全由 Java 编写的开源作业调度框架，为在 Java 应用程序中进行作业调度提供了简单却强大的机制。2、Quartz 可以与 J2EE 与 J2SE 应用程序相结合也可以单独使用。 3、Quartz 允许程序开发人员根据时间的间隔来调度作业。4、Quartz 实现了作业和触发器的多对多的关系，还能把多个作业与不同的触发器关联。 二、Quartz核心概念1、Job 表示一个工作，要执行的具体内容。2、JobDetail 表示一个具体的可执行的调度程序，Job 是这个可执行程调度程序所要执行的内容，另外 JobDetail 还包含了这个任务调度的方案和策略。3、Trigger 代表一个调度参数的配置，什么时候去调。4、Scheduler 代表一个调度容器，一个调度容器中可以注册多个 JobDetail 和 Trigger。当 Trigger 与 JobDetail 组合，就可以被 Scheduler 容器调度了。 三、基本配置使用1、pom.xmlspring-boot-starter-quartz 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;quartz&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;quartz&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-quartz&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、启用定时任务12345678910@SpringBootApplication//启动定时任务@EnableSchedulingpublic class QuartzApplication { public static void main(String[] args) { SpringApplication.run(QuartzApplication.class, args); }} 3、job任务配置①直接定义一个Bean作为任务 首先将这个 Job 注册到 Spring 容器中。 这种定义方式有一个缺陷，就是无法传参。 123456789@Componentpublic class MyFirstJob { /** * 这种方式配置的任务不支持传参 */ public void sayHello() { System.out.println(\"first job say hello:\"+new Date()); }} ②继承 QuartzJobBean 并实现默认的方法这种方式支持传参，任务启动时，executeInternal 方法将会被执行。 12345678910111213141516171819202122public class MySecondJob extends QuartzJobBean { /** * 给当前job传入参数 */ private String name; public MySecondJob setName(String name) { this.name = name; return this; } /** * 这种形式的job支持传参 * @param jobExecutionContext * @throws JobExecutionException */ @Override protected void executeInternal(JobExecutionContext jobExecutionContext) throws JobExecutionException { System.out.println(\"second job say hello:\"+name+\":\"+new Date()); }} 4、JobDetail和Trigger配置JobDetail（要做的事情），另一个是触发器（什么时候做） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384@Configurationpublic class QuartzConfig { /** * 配置job实例 * MethodInvokingJobDetailFactoryBean配置的任务不能传输参数 * @return */ @Bean MethodInvokingJobDetailFactoryBean methodInvokingJobDetailFactoryBean() { MethodInvokingJobDetailFactoryBean bean=new MethodInvokingJobDetailFactoryBean();// 设置job所在的类名 （类名开头小写） bean.setTargetBeanName(\"myFirstJob\");// 设置指定job方法名 bean.setTargetMethod(\"sayHello\"); return bean; } /** * 配置job实例 *JobDetailFactoryBean 可以设置job参数 * @return */ @Bean JobDetailFactoryBean jobDetailFactoryBean() { JobDetailFactoryBean bean=new JobDetailFactoryBean();// 向job传入参数 JobDataMap dataMap=new JobDataMap(); dataMap.put(\"name\", \"lccc\"); bean.setJobDataMap(dataMap);// 设置该job所在的class对象// 此job因为实现QuartzJobBean类所以自动实现内部的执行executeInternal方法完成任务 bean.setJobClass(MySecondJob.class); return bean; } /** * 配置简单的触发器(执行时间规则) * @return */ @Bean SimpleTriggerFactoryBean simpleTriggerFactoryBean() { SimpleTriggerFactoryBean bean=new SimpleTriggerFactoryBean();// 将job对象和触发器绑定 bean.setJobDetail(methodInvokingJobDetailFactoryBean().getObject());// job开启的时间 --当前时间 bean.setStartTime(new Date());// job重复间隔 bean.setRepeatInterval(2000);// job执行次数 bean.setRepeatCount(3); return bean; } /** *配置cron表达式 * @return */ @Bean CronTriggerFactoryBean cronTriggerFactoryBean() { CronTriggerFactoryBean bean=new CronTriggerFactoryBean();// 绑定job任务和触发器对象 bean.setJobDetail(jobDetailFactoryBean().getObject());// 设置cron表达式// 每秒执行一次 bean.setCronExpression(\"* * * * * ?\"); return bean; } /** * 配置调度任务 * @return */ @Bean SchedulerFactoryBean schedulerFactoryBean() { SchedulerFactoryBean bean=new SchedulerFactoryBean();// 向调度任务中加入配置好的触发器和job对象 bean.setTriggers(simpleTriggerFactoryBean().getObject(),cronTriggerFactoryBean().getObject()); return bean; }} 5、配置解释关于这个配置说如下几点： JobDetail 的配置有两种方式：MethodInvokingJobDetailFactoryBean 和 JobDetailFactoryBean 。 使用 MethodInvokingJobDetailFactoryBean 可以配置目标 Bean 的名字和目标方法的名字，这种方式不支持传参。 使用 JobDetailFactoryBean 可以配置 JobDetail ，任务类继承自 QuartzJobBean ，这种方式支持传参，将参数封装在 JobDataMap 中进行传递。 Trigger 是指触发器，Quartz 中定义了多个触发器，这里向大家展示其中两种的用法，SimpleTrigger 和 CronTrigger 。 SimpleTrigger 有点类似于前面说的 @Scheduled 的基本用法。 CronTrigger 则有点类似于 @Scheduled 中 cron 表达式的用法。","link":"/2020/04/17/task/SpringBoot%E6%95%B4%E5%90%88Quartz/"},{"title":"SpringCache 整合Ehcache","text":"SpringCache 整合Ehcache一 、介绍​ EhCache 是一个纯Java的进程内缓存框架，具有快速、精干等特点，是Hibernate中默认CacheProvider。Ehcache是一种广泛使用的开源Java分布式缓存。主要面向通用缓存,Java EE和轻量级容器。它具有内存和磁盘存储，缓存加载器,缓存扩展,缓存异常处理程序,一个gzip缓存servlet过滤器,支持REST和SOAP api等特点。 特性 快速、简单 多种缓存策略 缓存数据有两级：内存和磁盘，因此无需担心容量问题 缓存数据会在虚拟机重启的过程中写入磁盘 可以通过RMI、可插入API等方式进行分布式缓存 具有缓存和缓存管理器的侦听接口 支持多缓存管理器实例，以及一个实例的多个缓存区域 提供Hibernate的缓存实现 集成​ 可以单独使用，一般在第三方库中被用到的比较多（如mybatis、shiro等）ehcache 对分布式支持不够好，多个节点不能同步，通常和redis一块使用 灵活性​ ehcache具备对象api接口和可序列化api接口 不能序列化的对象可以使用出磁盘存储外ehcache的所有功能 支持基于Cache和基于Element的过期策略，每个Cache的存活时间都是可以设置和控制的。 提供了LRU、LFU和FIFO缓存淘汰算法，Ehcache 1.2引入了最少使用和先进先出缓存淘汰算法，构成了完整的缓存淘汰算法。 提供内存和磁盘存储，Ehcache和大多数缓存解决方案一样，提供高性能的内存和磁盘存储。 动态、运行时缓存配置，存活时间、空闲时间、内存和磁盘存放缓存的最大数目都是可以在运行时修改的。 应用持久化​ 在vm重启后，持久化到磁盘的存储可以复原数据 Ehache是第一个引入缓存数据持久化存储的开源java缓存框架，缓存的数据可以在机器重启后从磁盘上重新获得​ 根据需要将缓存刷到磁盘。将缓存条目刷到磁盘的操作可以通过cache.fiush方法执行,这大大方便了ehcache的使用 二、ehcache 和 redis 比较ehcache直接在jvm虚拟机中缓存，速度快，效率高；但是缓存共享麻烦，集群分布式应用不方便。 redis是通过socket访问到缓存服务，效率比ecache低，比数据库要快很多， 处理集群和分布式缓存方便，有成熟的方案。如果是单个应用或者对缓存访问要求很高的应用，用ehcache。如果是大型系统，存在缓存共享、分布式部署、缓存内容很大的，建议用redis。 三、基本配置所有的存储操作还是SpringCache的那一套，只是存储采取的载体不同 1、pom.xmlehcache spring-boot-starter-cache 1234567891011121314151617181920212223242526272829&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--ehcache依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt; &lt;artifactId&gt;ehcache&lt;/artifactId&gt; &lt;version&gt;2.10.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2、yaml配置若缓存配置文件名为ehcache.xml则无需配置此项 配置ehcache文件的存放位置 ==&gt; 1234spring: cache: ehcache: config: classpath:ehcache/ehcache1.xml 3、ehcache配置文件配置文件说明==&gt; diskStore path ：指定磁盘存储的位置 defaultCache 默认的缓存 cache 自定的缓存，当自定的配置不满足实际情况时可以通过自定义（可以包含多个cache节点） name : 缓存的名称，可以通过指定名称获取指定的某个Cache对象 maxElementsInMemory ：内存中允许存储的最大的元素个数，0代表无限个 clearOnFlush：内存数量最大时是否清除。 eternal ：设置缓存中对象是否为永久的，如果是，超时设置将被忽略，对象从不过期。根据存储数据的不同，例如一些静态不变的数据如省市区等可以设置为永不过时 timeToIdleSeconds ： 设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。 timeToLiveSeconds ：缓存数据的 生存时间（TTL），也就是一个元素从构建到消亡的最大时间间隔值，这只能在元素不是永久驻留时有效，如果该值是0就意味着元素可以停顿无穷长的时间。(和上面的两者取最小值) overflowToDisk：内存不足时，是否启用磁盘缓存。 maxEntriesLocalDisk：当内存中对象数量达到maxElementsInMemory时，Ehcache将会对象写到磁盘中。 maxElementsOnDisk：硬盘最大缓存个数。 diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。 diskPersistent：是否在VM重启时存储硬盘的缓存数据。默认值是false。 diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。 memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。这里比较遗憾，Ehcache并没有提供一个用户定制策略的接口，仅仅支持三种指定策略，感觉做的不够理想。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;ehcache&gt; &lt;!-- 磁盘缓存位置 --&gt; &lt;!-- diskStore:为缓存路径，ehcache分为内存和磁盘 2级，此属性定义磁盘的缓存位置 user.home - 用户主目录 user.dir - 用户当前工作目录 java.io.tmpdir - 默认临时文件路径--&gt; &lt;diskStore path=\"java.io.tmpdir/ehcache\"/&gt; &lt;!-- name:缓存名称。 maxElementsInMemory:缓存最大数目 maxElementsOnDisk：硬盘最大缓存个数。 eternal:对象是否永久有效，一但设置了，timeout将不起作用。 overflowToDisk:是否保存到磁盘，当系统宕机时 timeToIdleSeconds:设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。 timeToLiveSeconds:设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。 diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false. diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。 diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。 memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。 clearOnFlush：内存数量最大时是否清除。 memoryStoreEvictionPolicy:可选策略有：LRU（最近最少使用，默认策略）、FIFO（先进先出）、LFU（最少访问次数）。 FIFO，first in first out，这个是大家最熟的，先进先出。 LFU， Less Frequently Used，就是上面例子中使用的策略，直白一点就是讲一直以来最少被使用的。如上面所讲，缓存的元素有一个hit属性，hit值最小的将会被清出缓存。 LRU，Least Recently Used，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。--&gt; &lt;!-- 默认缓存 --&gt; &lt;defaultCache maxEntriesLocalHeap=\"10000\" eternal=\"false\" timeToIdleSeconds=\"120\" timeToLiveSeconds=\"120\" maxEntriesLocalDisk=\"10000000\" diskExpiryThreadIntervalSeconds=\"120\" memoryStoreEvictionPolicy=\"LRU\"&gt; &lt;persistence strategy=\"localTempSwap\"/&gt; &lt;/defaultCache&gt; &lt;!-- 自定义缓存 --&gt; &lt;!--name 为缓存名称--&gt; &lt;cache name=\"mycache\" maxElementsInMemory=\"1000\" eternal=\"false\" timeToIdleSeconds=\"600\" timeToLiveSeconds=\"600\" overflowToDisk=\"true\" memoryStoreEvictionPolicy=\"LRU\"/&gt;&lt;/ehcache&gt; 4、实体bean(实现serializable)12345678@Getter@Setter@ToStringpublic class User implements Serializable { private Integer id; private String username; private String address;} 5、开启缓存12345678910@SpringBootApplication//启用缓存@EnableCachingpublic class JpaRestApplication { public static void main(String[] args) { SpringApplication.run(JpaRestApplication.class, args); }} 6、service层123456789101112@Servicepublic class UserService { @Cacheable(cacheNames = \"mycache\",key = \"#id\") public User getUserById(Integer id){ User user=new User(); user.setId(id); System.out.println(\"id=====&gt;\"+id); return user; }} 测试==&gt; 12345678910111213@SpringBootTestclass JpaRestApplicationTests { @Autowired private UserService userService; @Test void contextLoads() { User userById = userService.getUserById(1); User userById1 = userService.getUserById(1); System.out.println(userById); System.out.println(userById1); }}","link":"/2020/04/17/springcache/Spring%20Cache%E6%95%B4%E5%90%88Ehcache/"},{"title":"SpringBoot整合@Scheduled定时任务","text":"SpringBoot整合@Scheduled定时任务一、JAVA常见的几种定时任务比较1、Timer： ​ jdk自带的java.util.Timer类，这个类允许你调度一个java.util.TimerTask任务。使用这种方式可以让程序按照某一个频度执行，但不能在指定时间运行，一般很少使用，主要用于非Spring项目简单的任务调度。 2、Spring Task： ​ Spring3.0以后自带的Task，可以将它看成一个轻量级的Quartz，使用起来比Quartz简单很多，在Spring应用中，直接使用@Scheduled注解即可，但对于集群项目比较麻烦，需要避免集群环境下任务被多次调用的情况，而且不能动态维护，任务启动以后不能修改、暂停等。 3、Quartz： ​ 好用的第三方任务调度工具，可谓是企业级应用系统任务调度工具的老大。可以方便的在集群下使用、可以动态增加、删除、暂停等维护任务，动态定时任务更加灵活。而且，和Spring Boot集成非常方便。 基本配置1、pom.xmlspring3之后自带定时任务 spring-boot-starter-web 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;sechdule&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;sechdule&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、开启定时任务123456789@SpringBootApplication//开启定时任务@EnableSchedulingpublic class SechduleApplication { public static void main(String[] args) { SpringApplication.run(SechduleApplication.class, args); }} 3、任务123456789101112131415161718192021222324252627282930313233343536373839404142@Servicepublic class HelloService { /** * rate速率 * 第一次任务和第二次任务开始的时间间隔(可能第一次任务还没结束，第二次就接着执行) * 毫秒为单位(这里为2s) */ @Scheduled(fixedRate = 2000) public void fixedRate() { System.out.println(\"fixedRate&gt;&gt;&gt;&gt;\"+new Date()); } /** * delay延期 * 第一次任务的结束时间和第二次任务开始的时间间隔(即第一次任务已经执行完毕后再执行第二次任务的间隔) * 毫秒为单位(这里为3s) */ @Scheduled(fixedDelay = 3000) public void fixedDelay() { System.out.println(\"fixedDelay&gt;&gt;&gt;&gt;\"+new Date()); } /** * initialDelay 表示首次任务启动的延迟时间 */ @Scheduled(initialDelay = 2000,fixedDelay = 2000) public void initialDelay() { System.out.println(\"initialDelay&gt;&gt;&gt;\"+new Date()); } /** * cron表达式 * [秒] [分] [小时] [日] [月] [周] [年](可省略) * 在这里 / 用于递增触发，如在秒上面设置”0/5” 表示从0秒开始，每增5秒触发(0,5,10,15……) */ @Scheduled(cron = \"0/5 * * * * *\") public void cron() { System.out.println(\"cron&gt;&gt;&gt;&gt;&gt;\"+new Date()); }} 配置详解1、@Scheduled常用属性： 首先使用 @Scheduled 注解开启一个定时任务。 fixedRate 表示任务执行之间的时间间隔，具体是指两次任务的开始时间间隔，即第二次任务开始时，第一次任务可能还没结束。 fixedDelay 表示任务执行之间的时间间隔，具体是指本次任务结束到下次任务开始之间的时间间隔。 initialDelay 表示首次任务启动的延迟时间。 所有时间的单位都是毫秒。 其他属性： fixedDelayString：与fixedDelay含义一样，只是参数类型变为String； fixedRateString: 与fixedRate的含义一样，只是将参数类型变为String； initialDelayString：与initialDelay的含义一样，只是将参数类型变为String； #####2、cron表达式 [秒] [分] [小时] [日] [月] [周] [年](可省略) 具体取值 序号 说明 是否必填 允许填写的值 允许的通配符 1 秒 是 0-59 - * / 2 分 是 0-59 - * / 3 时 是 0-23 - * / 4 日 是 1-31 - * ? / L W 5 月 是 1-12 or JAN-DEC - * / 6 周 是 1-7 or SUN-SAT - * ? / L # 7 年 否 1970-2099 - * / 这一块需要大家注意的是，月份中的日期和星期可能会起冲突，因此在配置时这两个得有一个是 ? 在线Cron表达式生成器 示例： 0 0 10 ？ * WED 每个星期三的10:00:00 @Scheduled(cron = &quot;0/5 * * * * *&quot;) 每隔5秒触发一次 通配符含义： ? 表示不指定值，即不关心某个字段的取值时使用。需要注意的是，月份中的日期和星期可能会起冲突，因此在配置时这两个得有一个是 ? * 表示所有值，例如:在秒的字段上设置 *,表示每一秒都会触发 , 用来分开多个值，例如在周字段上设置 “MON,WED,FRI” 表示周一，周三和周五触发 - 表示区间，例如在秒上设置 “10-12”,表示 10,11,12秒都会触发 / 用于递增触发，如在秒上面设置”5/15” 表示从5秒开始，每增15秒触发(5,20,35,50) # 序号(表示每月的第几个周几)，例如在周字段上设置”6#3”表示在每月的第三个周六，(用 在母亲节和父亲节再合适不过了) 周字段的设置，若使用英文字母是不区分大小写的 ，即 MON 与mon相同 L 表示最后的意思。在日字段设置上，表示当月的最后一天(依据当前月份，如果是二月还会自动判断是否是润年), 在周字段上表示星期六，相当于”7”或”SAT”（注意周日算是第一天）。如果在”L”前加上数字，则表示该数据的最后一个。例如在周字段上设置”6L”这样的格式,则表示”本月最后一个星期五” W 表示离指定日期的最近工作日(周一至周五)，例如在日字段上设置”15W”，表示离每月15号最近的那个工作日触发。如果15号正好是周六，则找最近的周五(14号)触发, 如果15号是周未，则找最近的下周一(16号)触发，如果15号正好在工作日(周一至周五)，则就在该天触发。如果指定格式为 “1W”,它则表示每月1号往后最近的工作日触发。如果1号正是周六，则将在3号下周一触发。(注，”W”前只能设置具体的数字,不允许区间”-“) L 和 W 可以一组合使用。如果在日字段上设置”LW”,则表示在本月的最后一个工作日触发(一般指发工资 )","link":"/2020/04/17/task/SpringBoot%E6%95%B4%E5%90%88@Scheduled%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"},{"title":"Linux常用命令","text":"简单命令：ip addr 查看ip地址 uname -r 查看系统内核版本 service network restart 重启虚拟机网络 clear 清屏 各发行版本命令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199ctrl + alt 脱离控制ctrl+alt+t 开启多个终端 命令 选项 参数command [-options] [parameter] //选项和参数与顺序无关/ 代表根目录./ 代表当前路径sudo 获取权限ctrl+c 不执行 换行一次tab补全信息两次tab显示所有文件内容sudo apt-get install 文件名 //安装新的软件//安装 sudo apt-get install net-toolsifconfig [-a] //查看网络配置 sudo ifconfig ens33 192.168.183.111 为ens33设置ip地址ps [-aux] //查看所有进程信息 只显示kill 端口号 //关闭指定进程kill -9 端口号 //强制关闭指定进程//安装 sudo apt-get install treetree //以树状的形式显示所有文件信息 ls [目录] //显示当前目录的文件信息(list)ls -ah 等于 llls -a //显示所有文件（包括以点开头的文件即为隐藏文件）ls -l //以列表的方式显示ls -l -h //以列表显示文件并显示文件大小或者 ls -alh //此方式为简写 与顺序无关ls -alh &gt; xxx.txt //将此目录下的显示内容 覆盖xxx.txt文件中ls &gt;&gt; xxx.txt //将此目录下的显示内容 追加到xxx.txt中ls -alh /bin | more //将bin下的文件以分页的方式显示 （此方式为管道） pwd //显示当前操作目录cd [目录] //切换目录（change directory）cd / //跳转到根目录cd ./xx //跳转到当前文件夹的指定目录cd .. //跳转到上一层路径cd ../.. //跳转到上上层路径 （利用相对路径） cd - //跳转到上一次文件目录cd ~ //跳转回原始根目录 touch //创建文件 mkdir //创建文件夹(make directory) mkdir [] -p //创建文件夹 自动创建不存在文件夹clear //清屏命令 --help //查看命令信息man 命名 //查看命令信息man [2,3..] 函数 //查看使用（manual手册） 可以查看底层cat //查看文件内容 （一次加载全部）car 1.txt 2.txt &gt; xxx.txt //将1.txt和2.txt的内容合并并且覆盖到xxx.txt中 more //查看文件内容 （可翻页 b上一页 f下一页 ）vi //编辑文件gedit //打开编辑器history //查看历史命令记录!行号 //执行历史记录命令rm //删除文件（仅能删除文件）rm [] -r //递归删除 能够删除文件和文件夹rmdir //删除文件夹 （此文件夹必须为空）mv [原] [旧] //更新文件或文件夹名称mv [原文件] [目录] //剪切文件或文件夹并粘贴到目录cp [原文件] [目录] //拷贝文件到目录cp [文件夹] [目录] -r //recursion递归拷贝文件夹到目录ln -s [原] [快捷] //为文件创建快捷方式 软链接（soft links 删除原文件则快捷方式会失效）ln [原] [快键] //为文件创建快捷方式 硬链接（删除源文件快捷方式不会失效） 数字代表链接数-rw-r--r-- 1 mybuntu mybuntu 0 2月 21 19:26 12das.txt-rw-r--r-- 1 mybuntu mybuntu 0 2月 21 19:26 312.txtdrwxr-xr-x 3 mybuntu mybuntu 4.0K 2月 21 20:08 a-rw-r--r-- 1 mybuntu mybuntu 17 2月 21 21:50 hardlink.txtdrwxr-xr-x 2 mybuntu mybuntu 4.0K 2月 21 18:16 myq-rw-r--r-- 1 mybuntu mybuntu 557 2月 21 19:38 xx.txt正则：* 匹配所有？ 匹配显示一个位置[1-5] 匹配选项的条件[12345]grep [-n] \"\" xxx.txt //查询包含的指定的内容 -n //带行号grep \"^xx\" xxx.txt //查询以xx开头的指定的内容grep \"xx$\" xxx.txt //查询以xx结尾的指定的内容sudo find / -name \"*na*\" //以根路径下查找 包含文件名为na的文件 （sudo获取所有权限）tar -cvf xxx.tar *.py //将当前所有为.py的文件打包为xxx.tar格式（基本不用）tar -xvf xxx.tar //解压 （基本不用）//常用两中压缩和解压方式：tar -zcvf xxx.tar.gz *.py //将当前所有为.py的文件打包并且压缩为xxx.tar.gz的格式 （此文件大小更小）tar -zxvf xxx.tar.gz [-C] [d/s]/ //解压到指定路径tar -jcvf xxx.tar.bz2 *.py ////将当前所有为.py的文件打包并且压缩为xxx.tar.bz2的格式tar -jxvf xxx.tar.bz2 //解压zip zzz.zip *.py //压缩unzip zzz.zip //解压which 命令 //查看命令所在的目录cal [-y] //查看日历date //查看时间date \"+%Y-%m-%d\" //以xxxx-xx-xx显示reboot 重启shutdown -h now [20:25] 立刻关机 或者在20:25的时候关机df //查看硬盘信息du [-h] [-a] //(disk usage)查看当前目录大小情况//安装sshsudo apt-get install openssh-serverssh 用户名@ip地址 //连接指定的ip地址服务器// sudo为获取权限sudo useradd louchen -m //添加用户（-m为该用户创建目录）su louchen //切换登录用户（默认无密码）sudo passwd louchen //为用户设置密码 sudo passwd louchen //为用户设置新密码whoami //查看当前用户who //查看登录的用户信息exit //退出并且切换到原来用户sudo userdel louchen [-r] //删除用户（-r删除该用户的目录）su - louchen //登录并且切换到该用户的目录sudu -s //切换到超级管理员用户$ 为普通用户# 为超级管理员 用户 组drwxr-xr-x 17 mybuntu mybuntu 4096 2月 22 00:30 ./drwxr-xr-x 4 root root 4096 2月 22 00:57 ../drwxr-xr-x 2 mybuntu mybuntu 4096 2月 21 18:21 桌面/-rw------- 1 mybuntu mybuntu 2878 2月 22 01:01 .bash_history-rw-r--r-- 1 mybuntu mybuntu 220 2月 21 01:07 .bash_logout//你创建一个用户的时候 也为该用户创建了一个组//新创建的用户默认不能设置为超级管理员权限 （sudo -s）sudo groupadd lou1 //创建一个新的组cat /etc/group //查看组groupmod tal键2次 //查看组sudo groupdel lou1 //删除一个组①sudo usermod -a -G adm lou1 //为新创建的用户添加能够为超级管理员的权限 ①②同时满足②sudo usermod -a -G sudo lou1chgrp 组名 文件名 //将指定的文件 改为相应的组名权限信息chown 组名 文件名 //将指定的文件 改为相应的用户所属信息权限：第一组：-为文件 ，d 为文件夹第二组：文件拥有者的权限第三组：同组者的权限 第四组：其他人的权限r:可读 w:可写 x(execute):可执行① ② ③ ④ 拥有者 所属组d rwx r-x r-x 17 mybuntu mybuntu 4096 2月 22 00:30 ./drwxr-xr-x 4 root root 4096 2月 22 00:57 ../drwxr-xr-x 2 mybuntu mybuntu 4096 2月 21 18:21 桌面/-rw------- 1 mybuntu mybuntu 2878 2月 22 01:01 .bash_history修改权限：x r w1、修改拥有者权限：chmod u=xrw 文件名 //修改该文件名的拥有者权限为可读可写可执行2、修改同组者权限：chmod g=xrw 文件名3、修改其他人权限：chmod o=xrw 文件名4、一起修改chmod u=x,g=w,o=r 文件名 //分别为所属者拥有者其他人设置为可执行可写可读5、修改为无权限chmod u=,g=,o= 文件名 //设置为无任何权限6、数字法修改权限x:1 w:2 r:4相加做出判断chmod 137 文件名 //设置为 用户可执行 ，所属组可执行可写，其他组可读可写可执行 vi编辑操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//安装sudo apt install vimvi（vim）命令：vim 文件 //新建或者打开一个新文件ESC退出当前模式： 切换行末模式vi命令①插入模式②命令模式: i 在当前光标之前插入 I 在当前光标行首插入 a 在当前光标之后插入 A 在当前光标行末插入 x 删除当前光标内容 o 在光标下方插入 O 在光标上方插入 yy:复制 光标所在的这一行 4yy:复制 光标所在行开始向下的4行 p: 粘贴 dd:剪切 光标所在的这一行 2dd:剪切 光标所在行 向下 2行 D:从当前的光标开始剪切，一直到行末 d0:从当前的光标开始剪切，一直到行首 x:删除当前的光标，每次只会删除一个 X:删除当前光标前面的那个，每次只会删除一个 h左 j下 k上 l右 H:当前屏幕的上方 M:当前屏幕的中间 L:当前屏幕的下方 ctrl+f---&gt;向下翻一页代码 ctrl+b---&gt;向上翻一页代码 ctrl+d---&gt;向下翻半页代码 ctrl+u---&gt;向上翻半页代码 20G:快速的定位到第2行代码 G:快速的回到 整个代码的最后一行 gg:快速回到 整个代码的第1行 w:向后跳一个单词的长度，即调到下一个单词的开始出 b:向前跳一个单词的长度，即调到上一个单词的开始出 u:撤销刚刚的操作 ctrl+r:反撤销 选中一片代码 v: V: &gt;&gt;:向右移动代码 &lt;&lt;:向左移动代码 .:重复执行上一次的命令 r:替换一个字符 R:替换光标以及后面的字符 shift+zz:相当于wq③末行模式: w:保存 q:退出 wq:保存并且退出出 :w - 保存文件，不退出 vim:w file -将修改另外保存到 file 中，不退出 vim:w! -强制保存，不退出 vim:wq -保存文件，退出 vim:wq! -强制保存文件，退出 vim:q -不保存文件，退出 vim:q! -不保存文件，强制退出 vim:e! -放弃所有修改，从上次保存文件开始再编辑","link":"/2020/04/17/shell/Linux/"},{"title":"Springboot整合RabbitMQ","text":"Springboot整合RabbitMQ一、安装RabbitMQ这里我们使用docker 通信端口 : 5672 管理界面端口 :15672 默认账户密码都是 guest 1、拉取镜像docker pull rabbitmq:3-management //下载带管理界面的消息队列 2、初始化容器docker run -d -p 5672:5672 -p 15672:15672 --restart=always --name myrabbitmq 镜像id 3、修改rabbitmq密码123docker exec -it fd4f81cdd3e7 bash //进入容器rabbitmqctl list_users //查看所有用户 rabbitmqctl change_password guest 'Newpassword' //修改指定用户密码 4、常见命令12345新建用户：rabbitmqctl add_user username passwd删除用户：rabbitmqctl delete_user username改密码: rabbimqctl change_password {username} {newpassword}设置用户角色：rabbitmqctl set_user_tags {username} {tag ...}rabbitmqctl set_permissions -p / username \".*\" \".*\" \".*\" //添加权限 二、springboot整合RabbitMQ1、什么是RabbitMQ？​ RabbitMQ是一个基于AMQP(Advanced Message Queuing Protocol)协议的高级消息中间件，是应用层协议的一个开放标准。基于Erlang语言，可跨平台。它主要的技术特点是可用性，安全性，集群，多协议支持，可视化的客户端，活跃的社区。 ​ AMQP为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。 AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。 RabbitMQ是一个开源的AMQP实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。 2、基本配置pom.xml配置spring-boot-starter-amqp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;rabbitmq&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;rabbitmq&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.amqp&lt;/groupId&gt; &lt;artifactId&gt;spring-rabbit-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; properties配置12345678#配置主机地址spring.rabbitmq.host=47.96.141.44#通信端口spring.rabbitmq.port=5672#用户名spring.rabbitmq.username=guest#密码spring.rabbitmq.password=guest ①直连交换机(Direct)直连型交换机，根据消息携带的路由键将消息投递给对应队列。 大致流程，有一个队列绑定到一个直连交换机上，同时赋予一个路由键 routing key 。然后当一个消息携带着路由值为X，这个消息通过生产者发送给交换机时，交换机就会根据这个路由值X去寻找绑定值也是X的队列。 队列交换机配置： 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Direct策略 直接指定到发送的队列名称。 */@Configurationpublic class RabbitDirectConfig { /** * 定义directExchange的名称 */ public final static String DIRECTNAME = \"javaMr-direct\"; /** * 注意导的包 org.springframework.amqp.core.Queue; * 定义队列 * @return */ @Bean Queue queue() { return new Queue(\"hello.lc\"); } /** * 定义Direct交换机 * @return */ @Bean DirectExchange directExchange() { //定义的DirectExchange名称; durable(持久性)重启后是否依然有效; autodelete长期未使用是否自动删除 return new DirectExchange(DIRECTNAME,true,false); } /** * 绑定指定的队列到交换机上并指定策略 * @return */ @Bean Binding binding() {// 绑定队列到交换机上 并指定路由匹配规则 return BindingBuilder.bind(queue()).to(directExchange()).with(\"direct\"); }} 消费者： 12345678910111213141516/** * direct消费者 */@Componentpublic class DirectReceiver { /** * 监听指定队列(hello.lc) * @param msg */ @RabbitListener(queues = \"hello.lc\") public void handler(String msg) { System.out.println(\"&gt;&gt;&gt;&gt;&gt;&gt;&gt;:\"+msg); }} 生产者： 1234567891011121314151617@SpringBootTestclass RabbitmqApplicationTests { @Autowired private RabbitTemplate rabbitTemplate; /** * direct模式 发送到指定队列 */ @Test void directTest() {// 发送到指定路由规则(默认为队列名)队列; 发送的消息 rabbitTemplate.convertAndSend(RabbitDirectConfig.DIRECTNAME,\"direct\", \"你好呀 direct!!!\");// 如果不指定发送的交换机名称则直接匹配的routingkey到队列名// rabbitTemplate.convertAndSend(\"hello.lc\", \"你好呀 direct!!!\"); }} ②主题交换机(Topic)前面讲到direct类型的Exchange路由规则是完全匹配binding key与routing key，但这种严格的匹配方式在很多情况下不能满足实际业务需求。topic类型的Exchange在匹配规则上进行了扩展，它与direct类型的Exchage相似，也是将消息路由到binding key与routing key相匹配的Queue中，但这里的匹配规则有些不同，它约定： routing key为一个句点号“. ”分隔的字符串（我们将被句点号“. ”分隔开的每一段独立的字符串称为一个单词），如“stock.usd.nyse”、“nyse.vmw”、“quick.orange.rabbit” binding key与routing key一样也是句点号“. ”分隔的字符串 binding key中可以存在两种特殊字符“ * ”与“#”，用于做模糊匹配，其中“*”用于匹配一个单词，“#”用于匹配多个单词（可以是零个） 队列交换机配置： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** *topic策略 根据指定路径匹配符转发到指定队列 */@Configurationpublic class RabbitTopicCofig { public static final String TOPICNAME = \"javaMr-topic\"; @Bean Queue xiaomi() { return new Queue(\"xiaomi\"); } @Bean Queue huawei() { return new Queue(\"huawei\"); } @Bean Queue iphone() { return new Queue(\"iphone\"); } @Bean TopicExchange topicExchange() { return new TopicExchange(TOPICNAME, true, false); } @Bean Binding xiaomiBinding() {// 绑定xiaomi队列到topic交换机，并指定队列访问规则// 发送匹配的路由规格 以 xiao. 开头的路径 return BindingBuilder.bind(xiaomi()).to(topicExchange()).with(\"xiaomi.#\"); } @Bean Binding huaweiBinding() {// 绑定huawei队列到topic交换机，并指定队列访问规则// 发送匹配的路由规格 以 huawei. 开头的路径 return BindingBuilder.bind(huawei()).to(topicExchange()).with(\"huawei.#\"); } @Bean Binding iphoneBinding() {// 绑定iphone队列到topic交换机，并指定队列访问规则// 发送匹配的路由规格 以 .phone. 规则的路径 return BindingBuilder.bind(iphone()).to(topicExchange()).with(\"#.iphone.#\"); }} 消费者配置： 1234567891011121314151617@Componentpublic class TopicReceiver { @RabbitListener(queues = \"xiaomi\") public void handlerXiaomi(String msg) { System.out.println(\"TopicReceiver:handlerXiaomi&gt;&gt;&gt;&gt;&gt;\"+msg); } @RabbitListener(queues = \"huawei\") public void handlerHuawei(String msg) { System.out.println(\"TopicReceiver:handlerHuawei&gt;&gt;&gt;&gt;&gt;\"+msg); } @RabbitListener(queues = \"iphone\") public void handlerIphone(String msg) { System.out.println(\"TopicReceiver:handlerIphone&gt;&gt;&gt;&gt;&gt;\"+msg); }} 生成者配置： 12345678910111213141516171819@SpringBootTestclass RabbitmqApplicationTests { @Autowired private RabbitTemplate rabbitTemplate; /** * topic模式 发送到指定交换机下的路径匹配的队列 */ @Test void topicTest() {// 发送到指定交换机; 匹配路由为 xiaomi.# 的路径--&gt;指定到xiaomi队列; 发送的消息 rabbitTemplate.convertAndSend(RabbitTopicCofig.TOPICNAME, \"xiaomi.news\", \"小米手机\");// 发送到指定交换机; 匹配路由为 #.iphone.# 的路径--&gt;指定到iphone队列; 发送的消息 rabbitTemplate.convertAndSend(RabbitTopicCofig.TOPICNAME, \"iphoneXR.iphone\", \"iphone手机\");// 发送到指定交换机; 匹配路由为 huawei.# 和 #.iphone.# 的路径--&gt;指定到huawei和iphone队列; 发送的消息 rabbitTemplate.convertAndSend(RabbitTopicCofig.TOPICNAME, \"huawei.iphone\", \"A12系列和麒麟系列芯片\"); }} ③扇形交换机(Fanout)扇型交换机，这个交换机没有路由键概念，就算你绑了路由键也是无视的。 这个交换机在接收到消息后，会直接转发到绑定到它上面的所有队列。 队列交换机配置： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * fanout策略 转发到该交换机下的所有队列（跟路由规则（routingkey）无关） */@Configurationpublic class RabbitFanoutConfig { /** * 定义交换机名称 */ public static final String FANOUTNAME = \"javaMr-fanout\"; /** * 定义第一个队列 * @return */ @Bean Queue queueOne() { return new Queue(\"queue-one\"); } /** * 定义第二个队列 * @return */ @Bean Queue queueTwo() { return new Queue(\"queue-two\"); } /** * 定义Fanout交换机 * @return */ @Bean FanoutExchange fanoutExchange() { return new FanoutExchange(FANOUTNAME,true,false); } /** * 绑定第一个队列到交换机 * @return */ @Bean Binding bindingOne() { return BindingBuilder.bind(queueOne()).to(fanoutExchange()); } /** * 绑定到第二个交换机 * @return */ @Bean Binding bindingTwo() { return BindingBuilder.bind(queueTwo()).to(fanoutExchange()); }} 消费者配置： 1234567891011121314151617/** * 定义消费者 */@Componentpublic class FanoutReceiver { @RabbitListener(queues = \"queue-one\") public void handlerOne(String msg) { System.out.println(\"queue-one&gt;&gt;&gt;&gt;&gt;:\"+msg); } @RabbitListener(queues = \"queue-two\") public void handlerTwo(String msg) { System.out.println(\"queue-two&gt;&gt;&gt;&gt;&gt;:\"+msg); }} 生产者配置： 123456789101112131415@SpringBootTestclass RabbitmqApplicationTests { @Autowired private RabbitTemplate rabbitTemplate; /** * fanout模式 发送到所有该交换机下的队列 */ @Test void fanoutTest(){ //发送到指定交换机; 这里的routingkey队列关键词会无效; 发送的消息 rabbitTemplate.convertAndSend(RabbitFanoutConfig.FANOUTNAME, null, \"java fanout np!!!!\"); }} ④头部交换机(Headers)headers类型的Exchange不依赖于routing key与binding key的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。 在绑定Queue与Exchange时指定一组键值对；当消息发送到Exchange时，RabbitMQ会取到该消息的headers（也是一个键值对的形式），对比其中的键值对是否完全匹配Queue与Exchange绑定时指定的键值对；如果完全匹配则消息会路由到该Queue，否则不会路由到该Queue。 队列交换机配置： 1234567891011121314151617181920212223242526272829303132333435363738394041/** * headers策略 根据指定头部转发到指定队列(跟路由规则routingkey无关) */@Configurationpublic class RabbitHeadersConfig { public static final String HEADERNAME = \"javaMr-header\"; @Bean Queue queueName() { return new Queue(\"name-queue\"); } @Bean Queue queueAge() { return new Queue(\"age-queue\"); } @Bean HeadersExchange headersExchange() { return new HeadersExchange(HEADERNAME, true, false); } @Bean Binding bindingName() { Map&lt;String,Object&gt; map=new HashMap&lt;&gt;(); map.put(\"name\", \"lcc\");// 需要满足发送的消息 携带头部 name为lcc才匹配到该队列// 只需要匹配该map中的任意一个即可 return BindingBuilder.bind(queueName()).to(headersExchange()).whereAny(map).match();// 当有多个键值对时，必须必须匹配所有。// return BindingBuilder.bind(queueName()).to(headersExchange()).whereAll(map).match(); } @Bean Binding bindingAge() {// 满足只要有age属性存在 即可匹配到该队列 return BindingBuilder.bind(queueAge()).to(headersExchange()).where(\"age\").exists(); }} 消费者配置： 123456789101112131415@Componentpublic class HeadersReceiver { @RabbitListener(queues = \"name-queue\") public void handlerName(byte[] msg) {// 将字节数组解码为字符串对象 System.out.println(\"HeaderReceiver:handlerName&gt;&gt;&gt;&gt;&gt;&gt;\"+new String(msg,0,msg.length)); } @RabbitListener(queues = \"age-queue\") public void handlerAge(byte[] msg) {// 将字节数组解码为字符串对象 System.out.println(\"HeaderReceiver:handlerAge&gt;&gt;&gt;&gt;&gt;&gt;\"+new String(msg,0,msg.length)); }} 生产者配置： 1234567891011121314151617181920212223@SpringBootTestclass RabbitmqApplicationTests { @Autowired private RabbitTemplate rabbitTemplate; /** * header模式 发送消息时携带指定的头部信息 满足条件时即转发到指定队列 */ @Test void headerTest() {// 构建消息对象// 传入消息体转为字节数组; 设置匹配到路由的规则（map形式）; Message nameMsg= MessageBuilder.withBody(\"hello lcccccccc\".getBytes()).setHeader(\"name\", \"lcc\").build();// 发送到指定交换机; 此时路由无效; 传入消息 rabbitTemplate.send(RabbitHeadersConfig.HEADERNAME, null, nameMsg);// 构建消息对象// 传入消息体转为字节数组; 设置匹配到路由的规则（map形式）; Message ageMsg=MessageBuilder.withBody(\"i am 20\".getBytes()).setHeader(\"age\", \"22\").build();// 发送到指定交换机; 此时路由无效; 传入消息 rabbitTemplate.send(RabbitHeadersConfig.HEADERNAME, null, ageMsg); }} 三、RabbitMQ 选型和对比1.从社区活跃度按照目前网络上的资料，RabbitMQ 、activeM 、ZeroMQ 三者中，综合来看，RabbitMQ 是首选。 2.持久化消息比较ZeroMq 不支持，ActiveMq 和RabbitMq 都支持。持久化消息主要是指我们机器在不可抗力因素等情况下挂掉了，消息不会丢失的机制。 3.综合技术实现可靠性、灵活的路由、集群、事务、高可用的队列、消息排序、问题追踪、可视化管理工具、插件系统等等。 RabbitMq / Kafka 最好，ActiveMq 次之，ZeroMq 最差。当然ZeroMq 也可以做到，不过自己必须手动写代码实现，代码量不小。尤其是可靠性中的：持久性、投递确认、发布者证实和高可用性。 4.高并发毋庸置疑，RabbitMQ 最高，原因是它的实现语言是天生具备高并发高可用的erlang 语言。 5.比较关注的比较， RabbitMQ 和 KafkaRabbitMq 比Kafka 成熟，在可用性上，稳定性上，可靠性上， RabbitMq 胜于 Kafka （理论上）。 另外，Kafka 的定位主要在日志等方面， 因为Kafka 设计的初衷就是处理日志的，可以看做是一个日志（消息）系统一个重要组件，针对性很强，所以 如果业务方面还是建议选择 RabbitMq 。 还有就是，Kafka 的性能（吞吐量、TPS ）比RabbitMq 要高出来很多。","link":"/2020/04/17/mq/SpringBoot%E6%95%B4%E5%90%88RabbitMQ/"},{"title":"Springboot应用监控","text":"Springboot应用监控使用Actuator实现监控应用端点信息介绍 /info 应用基本信息 /health 健康度信息 /metrics 运行指标 /env 环境变量信息 /loggers 日志相关 /dump 线程相关信息 /trace 请求调用轨迹 ID 描述 是否需要鉴权 actuator 为其他端点提供“发现页面”。要求Spring HATEOAS在classpath路径上。 需要 auditevents 陈列当前应用程序的审计事件信息。 需要 autoconfig 展示自动配置信息并且显示所有自动配置候选人以及他们“被不被”应用的原因。 需要 beans 显示应用程序中所有Spring bean的完整列表。 需要 configprops 显示所有配置信息。 需要 dump dump所有线程。 需要 env 陈列所有的环境变量。 需要 flyway Shows any Flyway database migrations that have been applied. 需要 health 显示应用程序运行状况信息 不需要 info 显示应用信息。 不需要 loggers 显示和修改应用程序中的loggers配置。 需要 liquibase 显示已经应用的任何Liquibase数据库迁移。 需要 metrics 显示当前应用程序的“指标”信息。 需要 mappings 显示所有@RequestMapping的url整理列表。 需要 shutdown 关闭应用（默认情况下不启用）。 需要 trace 显示跟踪信息（默认最后100个HTTP请求）。 需要 一、应用端点1、pom.xmlspring-boot-starter-actuator spring-boot-starter-security 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;actuator&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;actuator&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、security安全配置httpBasic: 使用httpBasic认证 12345678910111213141516@Configurationpublic class SecurtyConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception {// 请求匹配其他所有端点的请求 http.requestMatcher(EndpointRequest.toAnyEndpoint())// 开启所有请求授权 .authorizeRequests()// 其他请求必须要有admin角色 .anyRequest().hasRole(\"admin\") .and()// 使用httpBasic认证 .httpBasic(); }} 3、properties配置123456789101112131415161718192021222324252627282930#关闭默认的配置（即 关闭所有默认开启的端口），一般没有必要配置#management.endpoints.enabled-by-default=false#是否开启远程应用关闭功能 （默认一般只有这个是关闭的）#post：http://localhost:8080/actuator/shutdown 即可关闭应用#但是这样不够安全 需要进行配置securitymanagement.endpoint.shutdown.enabled=true#虽然默认开启了很多端点 但是都没有暴露#暴露所有端点management.endpoints.web.exposure.include=*#配置用户名密码角色spring.security.user.name=lcspring.security.user.password=123spring.security.user.roles=admin#配置访问的基础路径#默认为/actuatormanagement.endpoints.web.base-path=/lc#默认为/actuator/helath#health路径的重新配置management.endpoints.web.path-mapping.health=/lc-health#允许的域（默认* 所有）#自定义运行请求的地址http://localhost:8081management.endpoints.web.cors.allowed-origins=http://localhost:8081#允许的请求方法类型#默认为* 所有management.endpoints.web.cors.allowed-methods=GET,POST 4、访问测试①访问health默认：GET http://localhost:8080/actuaotr/health GET http://localhost:8080/lc/lc-health 选择：Authorization-&gt;Basic Auth Username:lc password:123 ②访问beans默认：GET http://localhost:8080/actuaotr/beans GET http://localhost:8080/lc/beans 选择：Authorization-&gt;Basic Auth Username:lc password:123 二、 health端点123456789101112131415161718192021222324252627282930313233#关闭默认的配置（即 关闭所有默认开启的端口），一般没有必要配置#management.endpoints.enabled-by-default=false#是否开启远程应用关闭功能 （默认一般只有这个是关闭的）#post：http://localhost:8080/actuator/shutdown 即可关闭应用#但是这样不够安全 需要进行配置securitymanagement.endpoint.shutdown.enabled=true#虽然默认开启了很多端点 但是都没有暴露#暴露所有端点management.endpoints.web.exposure.include=*#配置用户名密码角色spring.security.user.name=lcspring.security.user.password=123spring.security.user.roles=admin#配置访问的基础路径#默认为/actuator#management.endpoints.web.base-path=/lc#默认为/actuator/helath#health路径的重新配置#management.endpoints.web.path-mapping.health=/lc-health#允许的域（默认* 所有）#自定义运行请求的地址http://localhost:8081management.endpoints.web.cors.allowed-origins=http://localhost:8081#允许的请求方法类型#默认为* 所有management.endpoints.web.cors.allowed-methods=GET,POST#验证后展示健康信息management.endpoint.health.show-details=when_authorized 当配置其他应用时，如redis,mongo,mysql等都会有健康信息 GET http://localhost:8080/actuaotr/health 12345678910111213141516{ \"status\": \"UP\", \"components\": { \"diskSpace\": { \"status\": \"UP\", \"details\": { \"total\": 492657700864, \"free\": 265716948992, \"threshold\": 10485760 } }, \"ping\": { \"status\": \"UP\" } }} 三、info端点1、自定义信息①通过配置文件配置12345678910111213141516171819202122232425262728293031323334353637383940#关闭默认的配置（即 关闭所有默认开启的端口），一般没有必要配置#management.endpoints.enabled-by-default=false#是否开启远程应用关闭功能 （默认一般只有这个是关闭的）#post：http://localhost:8080/actuator/shutdown 即可关闭应用#但是这样不够安全 需要进行配置securitymanagement.endpoint.shutdown.enabled=true#虽然默认开启了很多端点 但是都没有暴露#暴露所有端点management.endpoints.web.exposure.include=*#配置用户名密码角色spring.security.user.name=lcspring.security.user.password=123spring.security.user.roles=admin#配置访问的基础路径#默认为/actuator#management.endpoints.web.base-path=/lc#默认为/actuator/helath#health路径的重新配置#management.endpoints.web.path-mapping.health=/lc-health#允许的域（默认* 所有）#自定义运行请求的地址http://localhost:8081management.endpoints.web.cors.allowed-origins=http://localhost:8081#允许的请求方法类型#默认为* 所有management.endpoints.web.cors.allowed-methods=GET,POST#验证后展示健康信息management.endpoint.health.show-details=when_authorized#配置应用信息info.app.encoding=@project.build.sourceEncoding@info.app.java.source=@java.version@info.app.java.target=@java.version@info.author.name=lcinfo.author.address=www.louchen.top GET:http://localhost:8080/actuator/info 12345678910111213{ \"app\": { \"encoding\": \"UTF-8\", \"java\": { \"source\": \"1.8.0_191\", \"target\": \"1.8.0_191\" } }, \"author\": { \"name\": \"lc\", \"address\": \"www.louchen.top\" }} ②通过代码配置会覆盖在properties的配置 123456789@Componentpublic class LcInfo implements InfoContributor { @Override public void contribute(Info.Builder builder) { Map&lt;String,Object&gt; info=new HashMap&lt;&gt;(); info.put(\"email\", \"421192425@qq.com\"); builder.withDetail(\"author\", info); }} GET http://localhost:8080/actuaotr/health 123456789101112{ \"app\": { \"encoding\": \"UTF-8\", \"java\": { \"source\": \"1.8.0_191\", \"target\": \"1.8.0_191\" } }, \"author\": { \"email\": \"421192425@qq.com\" }} 2、git信息①创建该项目所在的版本库git init–&gt;git add . –&gt;git commit -m ‘信息’ ②安装git信息插件12345678910111213&lt;build&gt; &lt;plugins&gt; &lt;!--添加git插件 获取git版本信息--&gt; &lt;plugin&gt; &lt;groupId&gt;pl.project13.maven&lt;/groupId&gt; &lt;artifactId&gt;git-commit-id-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; ③生成git.propertiesmaven-&gt;plugins-&gt;git-commit-id 点击：git-commit-id:revision 在target-&gt;classes下生成：git.properties 12345678910111213141516171819202122232425#Generated by Git-Commit-Id-Plugin#Wed Apr 08 16:33:41 GMT+08:00 2020git.branch=mastergit.build.host=LAPTOP-LJJM9R29git.build.time=2020-04-08T16\\:33\\:41+0800git.build.user.email=421192425@qq.comgit.build.user.name=louchen97git.build.version=0.0.1-SNAPSHOTgit.closest.tag.commit.count=git.closest.tag.name=git.commit.id=5a55c763ecfb66fff1986fce9880663a72ab7e88git.commit.id.abbrev=5a55c76git.commit.id.describe=5a55c76-dirtygit.commit.id.describe-short=5a55c76-dirtygit.commit.message.full=创建git.commit.message.short=创建git.commit.time=2020-04-08T16\\:30\\:36+0800git.commit.user.email=421192425@qq.comgit.commit.user.name=louchen97git.dirty=truegit.local.branch.ahead=NO_REMOTEgit.local.branch.behind=NO_REMOTEgit.remote.origin.url=Unknowngit.tags=git.total.commit.count=1 ④主配置文件123456789101112131415161718192021222324252627282930313233343536373839404142434445#关闭默认的配置（即 关闭所有默认开启的端口），一般没有必要配置#management.endpoints.enabled-by-default=false#是否开启远程应用关闭功能 （默认一般只有这个是关闭的）#post：http://localhost:8080/actuator/shutdown 即可关闭应用#但是这样不够安全 需要进行配置securitymanagement.endpoint.shutdown.enabled=true#虽然默认开启了很多端点 但是都没有暴露#暴露所有端点management.endpoints.web.exposure.include=*#配置用户名密码角色spring.security.user.name=lcspring.security.user.password=123spring.security.user.roles=admin#配置访问的基础路径#默认为/actuator#management.endpoints.web.base-path=/lc#默认为/actuator/helath#health路径的重新配置#management.endpoints.web.path-mapping.health=/lc-health#允许的域（默认* 所有）#自定义运行请求的地址http://localhost:8081management.endpoints.web.cors.allowed-origins=http://localhost:8081#允许的请求方法类型#默认为* 所有management.endpoints.web.cors.allowed-methods=GET,POST#验证后展示健康信息management.endpoint.health.show-details=when_authorized#配置应用信息info.app.encoding=@project.build.sourceEncoding@info.app.java.source=@java.version@info.app.java.target=@java.version@info.author.name=lcinfo.author.address=www.louchen.top#git信息配置#simple(默认)展示一些简单信息#full展示所有git信息management.info.git.mode=full GET: http://localhost:8080/actuator/info 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667{ \"app\": { \"encoding\": \"UTF-8\", \"java\": { \"source\": \"1.8.0_191\", \"target\": \"1.8.0_191\" } }, \"author\": { \"email\": \"421192425@qq.com\" }, \"git\": { \"build\": { \"host\": \"LAPTOP-LJJM9R29\", \"version\": \"0.0.1-SNAPSHOT\", \"time\": \"2020-04-08T08:33:41Z\", \"user\": { \"name\": \"louchen97\", \"email\": \"421192425@qq.com\" } }, \"branch\": \"master\", \"commit\": { \"message\": { \"short\": \"创建\", \"full\": \"创建\" }, \"id\": { \"describe\": \"5a55c76-dirty\", \"abbrev\": \"5a55c76\", \"describe-short\": \"5a55c76-dirty\", \"full\": \"5a55c763ecfb66fff1986fce9880663a72ab7e88\" }, \"time\": \"2020-04-08T08:30:36Z\", \"user\": { \"email\": \"421192425@qq.com\", \"name\": \"louchen97\" } }, \"closest\": { \"tag\": { \"name\": \"\", \"commit\": { \"count\": \"\" } } }, \"local\": { \"branch\": { \"ahead\": \"NO_REMOTE\", \"behind\": \"NO_REMOTE\" } }, \"dirty\": \"true\", \"remote\": { \"origin\": { \"url\": \"Unknown\" } }, \"tags\": \"\", \"total\": { \"commit\": { \"count\": \"1\" } } }} 3、项目构建信息maven--&gt;Plugins--&gt;spring-boot 点击：spring-boot:build-info 在classes下的META-INF下生成build-info.properties 12345build.artifact=actuatorbuild.group=org.lcbuild.name=actuatorbuild.time=2020-04-08T09\\:33\\:21.830Zbuild.version=0.0.1-SNAPSHOT GET http://localhost:8080/actuator/info 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374{ \"app\": { \"encoding\": \"UTF-8\", \"java\": { \"source\": \"1.8.0_191\", \"target\": \"1.8.0_191\" } }, \"author\": { \"email\": \"421192425@qq.com\" }, \"git\": { \"build\": { \"host\": \"LAPTOP-LJJM9R29\", \"version\": \"0.0.1-SNAPSHOT\", \"time\": \"2020-04-08T08:33:41Z\", \"user\": { \"name\": \"louchen97\", \"email\": \"421192425@qq.com\" } }, \"branch\": \"master\", \"commit\": { \"message\": { \"short\": \"创建\", \"full\": \"创建\" }, \"id\": { \"describe\": \"5a55c76-dirty\", \"abbrev\": \"5a55c76\", \"describe-short\": \"5a55c76-dirty\", \"full\": \"5a55c763ecfb66fff1986fce9880663a72ab7e88\" }, \"time\": \"2020-04-08T08:30:36Z\", \"user\": { \"email\": \"421192425@qq.com\", \"name\": \"louchen97\" } }, \"closest\": { \"tag\": { \"name\": \"\", \"commit\": { \"count\": \"\" } } }, \"local\": { \"branch\": { \"ahead\": \"NO_REMOTE\", \"behind\": \"NO_REMOTE\" } }, \"dirty\": \"true\", \"remote\": { \"origin\": { \"url\": \"Unknown\" } }, \"tags\": \"\", \"total\": { \"commit\": { \"count\": \"1\" } } }, \"build\": { \"version\": \"0.0.1-SNAPSHOT\", \"artifact\": \"actuator\", \"name\": \"actuator\", \"group\": \"org.lc\", \"time\": \"2020-04-08T09:33:21.830Z\" }}","link":"/2020/04/17/projectcontrol/SpringBoot%E5%BA%94%E7%94%A8%E7%9B%91%E6%8E%A7/"},{"title":"FastDFS构建分布式文件管理系统","text":"FastDFS构建分布式文件管理系统​ 说起分布式文件管理系统，大家可能很容易想到 HDFS、GFS 等系统，前者是 Hadoop 的一部分，后者则是 Google 提供的分布式文件管理系统。除了这些之外，国内淘宝和腾讯也有自己的分布式文件管理系统，都叫 TFS（Taobao File System 和 Tencent File System）。 ​ 相对于上面提到的这些分布式文件管理系统而言，FastDFS 可能离我们 Java 工程师更近一些，因为文件上传这个功能太常见了，而想要搭建独立的分布式文件管理系统，FastDFS+Nginx 组合无疑是最佳方案。 一、FastDFS简介 fastDFS 是以C语言开发的一项开源轻量级分布式文件系统，他对文件进行管理，主要功能有：文件存储，文件同步，文件访问（文件上传/下载）,特别适合以文件为载体的在线服务，如图片网站，视频网站等 分布式文件系统：基于客户端/服务器的文件存储系统 对等特性允许一些系统扮演客户端和服务器的双重角色，可供多个用户访问的服务器，比如，用户可以“发表”一个允许其他客户机访问的目录，一旦被访问，这个目录对客户机来说就像使用本地驱动器一样 FastDFS 由淘宝的余庆大佬在 2008 年开源的一款轻量级分布式文件管理系统，FastDFS 用 C 语言实现，支持 Linux、FreeBSD、MacOS 等类 UNIX 系统。FastDFS 类似 google FS，属于应用级文件系统，不是通用的文件系统，只能通过专有 API 访问，目前提供了 C 和 Java SDK ，以及 PHP 扩展 SDK。 这款开源软件从发布至今，历经数十年，这款开源软件的生命力依然旺盛，在业界依然备受推崇，当然这也得益于作者一直在不断完善该软件。 FastDFS 专为互联网应用量身定做，解决大容量文件存储问题，追求高性能和高扩展性，它可以看做是基于文件的 key/value 存储系统，key 为文件 ID，value 为文件内容，因此称作分布式文件存储服务更为合适。 1.1为什么需要FastDFS？传统的企业级开发对于高并发要求不是很高，而且数据量可能也不大，在这样的环境下文件管理可能非常 Easy。 但是互联网应用访问量大、数据量大，在互联网应用中，我们必须考虑解决文件大容量存储和高性能访问的问题，而 FastDFS 就特别适合干这件事情，常见的图片存储、视频存储、文档存储等等我们都可以采用 FastDFS 来做。 1.2FastDFS 架构作为一款分布式文件管理系统，FastDFS 主要包括四个方面的功能： 文件存储 文件同步 文件上传 文件下载 这个方面的功能，基本上就能搞定我们常见的文件管理需求了。 下面这是一张来自 FastDFS 官网的系统架构图： 从上面这张图中我们可以看到，FastDFS 架构包括 Tracker 和 Storage 两部分，看名字大概就能知道，Tracker 用来追踪文件，相当于是文件的一个索引，而 Storage 则用来保存文件。 我们上传文件的文件最终保存在 Storage 上，文件的元数据信息保存在 Tracker 上，通过 Tracker 可以实现对 Storage 的负载均衡。 Storage 一般会搭建成集群，一个 Storage Cluster 可以由多个组构成，不同的组之间不进行通信，一个组又相当于一个小的集群，组由多个 Storage Server 组成，组内的 Storage Server 会通过连接进行文件同步来保证高可用。 二、安装FastDFS介绍完 FastDFS 之后，相信小伙伴已经摩拳擦掌跃跃欲试了，接下来我们就来看下 FastDFS 的安装。 我这里为了测试方便，就不开启多台虚拟机了，Tracker 和 Storage 我将安装在同一台服务器上。 图片上传我们一般使用 FastDFS，图片上传成功之后，接下来的图片访问我们一般采用 Nginx，所以这里的安装将从三个方面来介绍： Tracker(追踪器) 安装 Storage(存储) 安装 Nginx 安装 2.1 Tracker 安装安装，我们首先需要准备一个环境,两个库以及一个安装包。 2.1.1一个环境先来看一个环境，由于 FastDFS 采用 C 语言开发，所以在安装之前，如果没有 gcc 环境，需要先安装，安装命令如下： 1yum install gcc-c++ 2.1.2两个库再来看两个库，由于 FastDFS 依赖 libevent 库，安装命令如下： 1yum -y install libevent 另一个库是 libfastcommon，这是 FastDFS 官方提供的，它包含了 FastDFS 运行所需要的一些基础库。 libfastcommon 下载地址：https://github.com/happyfish100/libfastcommon/archive/V1.0.43.tar.gz 1wget https://github.com/happyfish100/libfastcommon/archive/V1.0.43.tar.gz 将下载好的 libfastcommon 拷贝至 /usr/local/ 目录下， 1mv V1.0.43.tar.gz /usr/local/ 然后依次执行如下命令： 12345cd /usr/localtar -zxvf V1.0.43.tar.gzcd libfastcommon-1.0.43/./make.sh./make.sh install 2.1.3一个安装包接下来我们下载 Tracker，注意，由于 Tracker 和 Storage 是相同的安装包，所以下载一次即可（2.2 小节中不用再次下载）。 安装文件可以从 FastDFS 的 GitHub 仓库上下载，下载地址：https://github.com/happyfish100/fastdfs/archive/V6.06.tar.gz 1wget https://github.com/happyfish100/fastdfs/archive/V6.06.tar.gz 下载成功后，将下载文件拷贝到 /usr/local 目录下， 1mv V6.06.tar.gz /usr/local 然后依次执行如下命令安装： 12345cd /usr/localtar -zxvf V6.06.tar.gzcd fastdfs-6.06/./make.sh./make.sh install 安装成功后，执行如下命令，将安装目录内 conf 目录下的配置文件拷贝到 /etc/fdfs 目录下： 12cd conf/cp ./* /etc/fdfs/ 2.1.4配置接下来进入 /etc/fdfs/ 目录下进行配置： 打开 tracker.conf 文件： 1vi tracker.conf 修改如下配置： 默认端口是 22122，可以根据实际需求修改，我这里就不改了。然后下面配置一下元数据的保存目录（注意目录要存在）。 设置存储是否需要限额的百分比： 若硬盘的剩余空间不足20%,则会储存失败！ 若不存在home和sang文件夹，则需要创建 12mkdir homemkdir sang 2.1.5启动接下来执行如下命令启动 Tracker： 1/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf start 2.2 Storage 安装简单起见，这里我们搭建一个 Storage 实例即可。Storage 安装也需要 libevent 和 libfastcommon，这两个库的安装参考上文，这里无需再次安装。 Storage 本身的安装，也和 Tracker 一致，执行命令也都一样，因为我这里将 Tracker 和 Storage 安装在同一台服务器上，所以不用再执行安装命令了（相当于安装 Tracker 时已经安装了 Storage 了）。 唯一要做的，就是进入到 /etc/fdfs 目录下，配置 Storage： 1vi storage.conf ![](images\\批注 2020-04-10 152254.png) 这里一共配置三个地方，分别是 base_path、store_path0 以及 tracker_server ，tracker_server 模板有两个地址，我们这里只有一个，配置完成后，记得注释掉另外一个不用的。 配置完成后，执行如下命令启动 Storage： 1/usr/bin/fdfs_storaged /etc/fdfs/storage.conf start 这两个启动完成后，现在就可以做文件的上传了 注意：这里我们的服务器需要暴露 22122(tracker) 和 23000(storage) 端口 2.3 实现文件上传这里我们使用Springboot来整合 1、pom.xmlfastdfs-client-java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;fastdfs&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;fastdfs&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--fastdfs 客户端--&gt; &lt;dependency&gt; &lt;groupId&gt;net.oschina.zcx7878&lt;/groupId&gt; &lt;artifactId&gt;fastdfs-client-java&lt;/artifactId&gt; &lt;version&gt;1.27.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、fastdfs客户端配置修改tracker公网地址即可 12345678910111213141516171819202122232425## fastdfs-client.propertiesfastdfs.connect_timeout_in_seconds = 5fastdfs.network_timeout_in_seconds = 30fastdfs.charset = UTF-8fastdfs.http_anti_steal_token = falsefastdfs.http_secret_key = FastDFS1234567890fastdfs.http_tracker_http_port = 80#修改tracker公网地址fastdfs.tracker_servers = 47.96.141.44:22122## Whether to open the connection pool, if not, create a new connection every timefastdfs.connection_pool.enabled = true## max_count_per_entry: max connection count per host:port , 0 is not limitfastdfs.connection_pool.max_count_per_entry = 500## connections whose the idle time exceeds this time will be closed, unit: second, default value is 3600fastdfs.connection_pool.max_idle_time = 3600## Maximum waiting time when the maximum number of connections is reached, unit: millisecond, default value is 1000fastdfs.connection_pool.max_wait_time_in_ms = 1000 3、测试123456789101112131415161718@SpringBootTestclass FastdfsApplicationTests { @Test void contextLoads() throws IOException, MyException {// 加载配置文件 ClientGlobal.initByProperties(\"fastdfs-client.properties\"); TrackerClient trackerClient = new TrackerClient(); TrackerServer trackerServer= trackerClient.getConnection(); StorageServer storageServer= null; StorageClient1 storageClient1 = new StorageClient1(trackerServer, storageServer); NameValuePair pairs[]=null; String[] fileId= storageClient1.upload_file(\"F:\\\\桌面内容\\\\i\\\\1.jpg\", \"jpg\", pairs); System.out.println(Arrays.toString(fileId)); }} ==&gt;输出 1[group1, M00/00/00/L2CNLF6QAt6AejqEAADgTCtaXcs207.jpg] 这里，首先加载配置文件，然后构造一个 TrackerClient 对象，接着再根据这个对象获取到一个 TrackerServer，然后创建一个 StorageClient1 实例。NameValuePair 中保存的是文件的元数据信息，如果有的话，就以 key/value 的方式来设置，如果没有的话，直接给一个 null 即可。 最后，调用 client 的 upload_file1 方法上传文件，第一个参数是文件路径，第二个参数是文件的扩展名，第三个参数就是文件的元数据信息. group1 表示我们的一个个storage组 M00，M01, M02, 表示我们的storage中的每一台storage服务器 00/00/L2CNLF6QAt6AejqEAADgTCtaXcs207.jpg 才是真真正的路径地址 查看文件的存储位置 1cd /home/sang/fastdfs/data 1cd 00/00/ ![](F:\\桌面内容\\springboot2\\vhr项目\\images\\批注 2020-04-10 154344.png) 即可查看到文件的存储位置 2.4 Nginx的安装实现文件访问Nginx 可以算是 FastDFS 的重要搭档。 Nginx 的安装分为两个步骤： 安装 Nginx 首先在 Storage 下安装 fastdfs-nginx-module 首先下载 fastdfs-nginx-module，下载地址：https://github.com/happyfish100/fastdfs-nginx-module/archive/V1.22.tar.gz 1wget https://github.com/happyfish100/fastdfs-nginx-module/archive/V1.22.tar.gz 下载完成后，将下载的文件拷贝到 /usr/local 目录下。 1mv V1.22.tar.gz /usr/local 然后进入 /usr/local 目录，分别执行如下命令： 12cd /usr/localtar -zxvf V1.22.tar.gz 然后将 /usr/local/fastdfs-nginx-module-1.22/src/mod_fastdfs.conf 文件拷贝到 /etc/fdfs/ 目录下 1cp /usr/local/fastdfs-nginx-module-1.22/src/mod_fastdfs.conf /etc/fdfs/ 并修改该文件的内容： 1vi /etc/fdfs/mod_fastdfs.conf ![](images\\批注 2020-04-10 155554.png) 接下来，回到第一步下载的 nginx 安装文件的解压目录中，执行如下命令，重新配置编译安装： 在/root/nginx-1.8.1/下 123./configure --add-module=/usr/local/fastdfs-nginx-module-1.22/srcmakemake install 安装完成后，修改 nginx 的配置文件，如下： 1vi /usr/local/nginx/conf/nginx.conf ![](images\\批注 2020-04-10 155945.png) 在这里配置 nginx 请求转发。 配置完成后，启动 nginx，看到如下日志，表示 nginx 启动成功： ngx_http_fastdfs_set pid=9908 疑问：fastdfs-nginx-module 有啥用 看了整个安装过程之后，到头来还是 nginx 本身直接找到了图片文件目录，fastdfs-nginx-module 到底有啥用？ 前面我们说过，Storage 由很多组构成，每个组又是一个小的集群，在每一个组里边，数据会进行同步，但是如果数据还没同步，这个时候就有请求发来了，该怎么办？此时fastdfs-nginx-module 会帮助我们直接从源 Storage 上获取文件。 安装成功了。 文件访问测试：1http://47.96.141.44/group1/M00/00/00/L2CNLF6QAt6AejqEAADgTCtaXcs207.jpg 实现文件下载 其他配置和文件上传一致 1234567891011121314 @Test public void downloadTest() throws IOException, MyException { // 加载配置文件 ClientGlobal.initByProperties(\"fastdfs-client.properties\"); TrackerClient trackerClient = new TrackerClient(); TrackerServer trackerServer= trackerClient.getConnection(); StorageServer storageServer= null; StorageClient1 storageClient1 = new StorageClient1(trackerServer, storageServer); byte[] bytes = storageClient1.download_file1(\"group1/M00/00/00/L2CNLF6QAt6AejqEAADgTCtaXcs207.jpg\");// 写入新的路径 FileOutputStream outputStream=new FileOutputStream(new File(\"F:\\\\桌面内容\\\\i\\\\2.jpg\")); outputStream.write(bytes); outputStream.close(); } 2.5添加访问令牌，防止盗链现在，任何人都可以访问我们服务器上传文件，这肯定是不行的，这个问题好解决，加一个上传时候的令牌即可。 首先我们在服务端开启令牌校验： 1vi /etc/fdfs/http.conf ![](images\\批注 2020-04-10 164343.png) 配置完成后，记得重启nginx服务端： 123cd /usr/local/nginx/sbin./nginx -s stop./nginx 配置token有效期修改vi /etc/fdfs/http.conf 默认为10分钟 1234# token TTL (time to live), seconds# default value is 600#设置为1800s 即30分钟http.anti_steal.token_ttl = 1800 获取令牌访问12345678910111213141516@Test public void tokenTest() throws UnsupportedEncodingException, NoSuchAlgorithmException, MyException {// 获取时间戳 int ts = (int)Instant.now().getEpochSecond();// 获取token// 注意第一个参数不需要加group1; 时间戳; 令牌 String token = ProtoCommon.getToken(\"M00/00/00/L2CNLF6QLYqAPtyOAADgTCtaXcs276.jpg\", ts, \"FastDFS421192425\"); StringBuffer sb= new StringBuffer(); sb.append(\"http://47.96.141.44\") .append(\"/group1/M00/00/00/L2CNLF6QLYqAPtyOAADgTCtaXcs276.jpg\") .append(\"?token=\") .append(token) .append(\"&amp;ts=\") .append(ts); System.out.println(sb.toString()); } 得到如下地址 http://47.96.141.44/group1/M00/00/00/L2CNLF6QLYqAPtyOAADgTCtaXcs276.jpg?token=18247d981993d006085a519c4fcb668e&amp;ts=1586507960 这里，我们主要是根据 ProtoCommon.getToken 方法来获取令牌，注意这个方法的第一个参数是你要访问的文件 id，注意，这个地址里边不包含 group，千万别搞错了；第二个参数是时间戳，第三个参数是密钥，密钥要和服务端的配置一致。 将生成的字符串拼接，追加到访问路径后面，如：http://192.168.91.128/group1/M00/00/00/wKhbgF5aMteAWy0gAAJkI7-2yGk361.png?token=7e329cc50307000283a3ad3592bb6d32&amp;ts=1582975854。此时访问路径里边如果没有令牌，会访问失败。","link":"/2020/04/17/springboot/FastDFS%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"title":"SpringBoot整合邮件服务","text":"SpringBoot整合邮件服务一、邮件服务简介SMTP(发送邮件) 协议SMTP 的全称是“Simple Mail Transfer Protocol”，即简单邮件传输协议。它是一组用于从源地址到目的地址传输邮件的规范，通过它来控制邮件的中转方式。SMTP 协议属于 TCP/IP 协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。SMTP 服务器就是遵循 SMTP 协议的发送邮件服务器。SMTP 认证，简单地说就是要求必须在提供了账户名和密码之后才可以登录 SMTP 服务器，这就使得那些垃圾邮件的散播者无可乘之机。增加 SMTP 认证的目的是为了使用户避免受到垃圾邮件的侵扰。 POP3(接收邮件)协议​ POP3是Post Office Protocol 3的简称，即邮局协议的第3个版本,它规定怎样将个人计算机连接到Internet的邮件服务器和下载电子邮件的电子协议。它是因特网电子邮件的第一个离线协议标准,POP3允许用户从服务器上把邮件存储到本地主机（即自己的计算机）上,同时删除保存在邮件服务器上的邮件，而POP3服务器则是遵循POP3协议的接收邮件服务器，用来接收电子邮件的。但目前的 POP3 邮件服务器大都可以“只下载邮件，服务器端并不删除”，也就是改进的 POP3 协议。 SMTP 和 POP3 是最初的两个协议，随着邮件的不断发展后来又增加了两个协议： IMAP 协议IMAP全称是Internet Mail Access Protocol，即交互式邮件存取协议，它是跟POP3类似邮件访问标准协议之一。不同的是，开启了IMAP后，您在电子邮件客户端收取的邮件仍然保留在服务器上，同时在客户端上的操作都会反馈到服务器上，如：删除邮件，标记已读等，服务器上的邮件也会做相应的动作。所以无论从浏览器登录邮箱或者客户端软件登录邮箱，看到的邮件以及状态都是一致的。 Mime 协议MIME的英文全称是”Multipurpose Internet Mail Extensions” 多功能Internet 邮件扩充服务，它是一种多用途网际邮件扩充协议，在1992年最早应用于电子邮件系统，但后来也应用到浏览器。MIME意为多目Internet邮件扩展，它设计的最初目的是为了在发送电子邮件时附加多媒体数据，让邮件客户程序能根据其类型进行处理。然而当它被HTTP协议支持之后，它的意义就更为显著了。它使得HTTP传输的不仅是普通的文本，而变得丰富多彩。 二、发送邮件的准备工作申请授权码：以qq邮箱为例 登录qq邮箱–&gt;设置–&gt;账户–&gt;开启POP3/SMTP服务–&gt;验证–&gt;获取授权码 三、发送简单邮件1、pom.xmlspring-boot-starter-mail 123456789101112131415161718192021&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2、properties配置1234567891011121314#指定邮件服务器的地址 这里我们使用qq的smtp服务器发送邮件spring.mail.host=smtp.qq.com# 服务器的端口号修改成465或587；spring.mail.port=587# 邮件发送者的邮件spring.mail.username=421192425@qq.com# 这里使用的为授权码（不能使用邮箱密码）spring.mail.password=eqsdqizwdnenbgif#设置默认编码spring.mail.default-encoding=UTF-8#设置ssl协议spring.mail.properties.mail.smtp.socketFactory.class=javax.net.ssl.SSLSocketFactory#打印发送邮件的日志spring.mail.properties.mail.debug=true 3、发送邮件123456789101112131415161718192021222324252627@SpringBootTestclass MailApplicationTests { @Autowired private JavaMailSender javaMailSender; /** * 发送简单文本邮件 */ @Test void contextLoads() { SimpleMailMessage smm=new SimpleMailMessage();// 谁发的 这里需要和配置文件中的一致 smm.setFrom(\"421192425@qq.com\");// 发给谁 smm.setTo(\"421192425@qq.com\");// 定义主题 smm.setSubject(\"这是一份测试主题\");// 定义发送的日期 smm.setSentDate(new Date());// 发送的内容 smm.setText(\"测试lclcllclcl\");// 发送 javaMailSender.send(smm); }} 四、发送附件1、pom.xml123456789101112131415161718192021&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2、properties配置1234567891011121314#指定邮件服务器的地址 这里我们使用qq的smtp服务器发送邮件spring.mail.host=smtp.qq.com# 服务器的端口号修改成465或587；spring.mail.port=587# 邮件发送者的邮件spring.mail.username=421192425@qq.com# 这里使用的为授权码（不能使用邮箱密码）spring.mail.password=eqsdqizwdnenbgif#设置默认编码spring.mail.default-encoding=UTF-8#设置ssl协议spring.mail.properties.mail.smtp.socketFactory.class=javax.net.ssl.SSLSocketFactory#打印发送邮件的日志spring.mail.properties.mail.debug=true 3、发送邮件12345678910111213141516171819202122232425262728293031@SpringBootTestclass MailApplicationTests { @Autowired private JavaMailSender javaMailSender; /** * 发送附件 * @throws MessagingException */ @Test public void attachmentTest() throws MessagingException {// 创建模拟消息对象 MimeMessage msg = javaMailSender.createMimeMessage();// 传入模拟消息对象; 文件上传类型为true MimeMessageHelper helper = new MimeMessageHelper(msg, true);// 谁发的 这里需要和配置文件中的一致 helper.setFrom(\"421192425@qq.com\");// 发给谁 helper.setTo(\"421192425@qq.com\");// 定义主题 helper.setSubject(\"附件主题\");// 定义发送的日期 helper.setSentDate(new Date());// 发送的内容 helper.setText(\"附件内容哈哈哈---\");// 发送附件// 附件的名称(需要携带扩展名); 附件的地址 helper.addAttachment(\"lc.png\", new File(\"F:\\\\桌面内容\\\\i\\\\1.jpg\")); javaMailSender.send(msg); }} 五、发送图片资源文件1、pom.xml123456789101112131415161718192021&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2、properties配置1234567891011121314#指定邮件服务器的地址 这里我们使用qq的smtp服务器发送邮件spring.mail.host=smtp.qq.com# 服务器的端口号修改成465或587；spring.mail.port=587# 邮件发送者的邮件spring.mail.username=421192425@qq.com# 这里使用的为授权码（不能使用邮箱密码）spring.mail.password=eqsdqizwdnenbgif#设置默认编码spring.mail.default-encoding=UTF-8#设置ssl协议spring.mail.properties.mail.smtp.socketFactory.class=javax.net.ssl.SSLSocketFactory#打印发送邮件的日志spring.mail.properties.mail.debug=true 3、发送邮件12345678910111213141516171819202122232425262728293031323334@SpringBootTestclass MailApplicationTests { @Autowired private JavaMailSender javaMailSender; /** * 发送图片资源邮件 * @throws MessagingException */ @Test public void resourcesImgTest() throws MessagingException { // 创建模拟消息对象 MimeMessage msg = javaMailSender.createMimeMessage();// 传入模拟消息对象; multipalt(多部分)类型为true MimeMessageHelper helper = new MimeMessageHelper(msg, true);// 谁发的 这里需要和配置文件中的一致 helper.setFrom(\"421192425@qq.com\");// 发给谁 helper.setTo(\"421192425@qq.com\");// 定义主题 helper.setSubject(\"图片资源\");// 定义发送的日期 helper.setSentDate(new Date());// 发送的内容 ； cid定义文本id ; 设置发送的内容为html为true helper.setText(\"图片资源---》》这是第一张图片：&lt;img src='cid:p01'/&gt;，这是第二张图片：&lt;img src='cid:p02'/&gt;\",true);// 设置文本id helper.addInline(\"p01\", new FileSystemResource((new File(\"F:\\\\桌面内容\\\\i\\\\1.jpg\"))));// 设置文本id helper.addInline(\"p02\", new FileSystemResource((new File(\"F:\\\\桌面内容\\\\i\\\\2.png\")))); javaMailSender.send(msg); }} 六、使用thymeleaf发送邮件1、pom.xmlspring-boot-starter-thymeleaf spring-boot-starter-mail 12345678910111213141516171819202122232425&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2、properties1234567891011121314#指定邮件服务器的地址 这里我们使用qq的smtp服务器发送邮件spring.mail.host=smtp.qq.com# 服务器的端口号修改成465或587；spring.mail.port=587# 邮件发送者的邮件spring.mail.username=421192425@qq.com# 这里使用的为授权码（不能使用邮箱密码）spring.mail.password=eqsdqizwdnenbgif#设置默认编码spring.mail.default-encoding=UTF-8#设置ssl协议spring.mail.properties.mail.smtp.socketFactory.class=javax.net.ssl.SSLSocketFactory#打印发送邮件的日志spring.mail.properties.mail.debug=true 3、mail.html1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;hello &lt;span th:text=\"${username}\"&gt;&lt;/span&gt;,欢迎加入大家庭！！&lt;table border=\"1\" cellspacing=\"0\" cellpadding=\"0\"&gt; &lt;tr&gt; &lt;td&gt;职位&lt;/td&gt; &lt;td th:text=\"${position}\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;职称&lt;/td&gt; &lt;td th:text=\"${jobLevel}\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;薪水&lt;/td&gt; &lt;td th:text=\"${salary}\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;部门&lt;/td&gt; &lt;td th:text=\"${dep}\"&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;div style=\"color: red;font-size: 30px\"&gt;希望在未来的日子携手共进&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 4、发送邮件12345678910111213141516171819202122232425262728293031323334353637@SpringBootTestclass MailApplicationTests { @Autowired private JavaMailSender javaMailSender; //注入模板引擎 将thymeleaf的一些指令渲染成html @Autowired private TemplateEngine templateEngine; @Test public void thymeleafTemplateTest() throws MessagingException { // 创建模拟消息对象 MimeMessage msg = javaMailSender.createMimeMessage();// 传入模拟消息对象; multipalt(多部分)类型为true MimeMessageHelper helper = new MimeMessageHelper(msg, true);// 谁发的 这里需要和配置文件中的一致 helper.setFrom(\"421192425@qq.com\");// 发给谁 helper.setTo(\"421192425@qq.com\");// 定义主题 helper.setSubject(\"thymeleaf主题\");// 定义发送的日期 helper.setSentDate(new Date());// thymeleaf内容 Context context = new Context(); context.setVariable(\"username\", \"lc\"); context.setVariable(\"position\", \"总经理\"); context.setVariable(\"jobLevel\", \"架构师\"); context.setVariable(\"salary\",\"2000\"); context.setVariable(\"dep\", \"研发部\");// 将thymeleaf和context解析为字符串 String process = templateEngine.process(\"mail.html\", context);// 发送的内容 ； 设置发送的内容为html为true helper.setText(process,true); javaMailSender.send(msg); }} 七、使用freemarker发送邮件1、pom.xmlspring-boot-starter-mail spring-boot-starter-freemarker 12345678910111213141516171819202122232425&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2、properties配置1234567891011121314#指定邮件服务器的地址 这里我们使用qq的smtp服务器发送邮件spring.mail.host=smtp.qq.com# 服务器的端口号修改成465或587；spring.mail.port=587# 邮件发送者的邮件spring.mail.username=421192425@qq.com# 这里使用的为授权码（不能使用邮箱密码）spring.mail.password=eqsdqizwdnenbgif#设置默认编码spring.mail.default-encoding=UTF-8#设置ssl协议spring.mail.properties.mail.smtp.socketFactory.class=javax.net.ssl.SSLSocketFactory#打印发送邮件的日志spring.mail.properties.mail.debug=true 3、mail.ftlh123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;freemarker&lt;/h1&gt;hello &lt;span&gt;${username}&lt;/span&gt;,欢迎加入大家庭！！&lt;table border=\"1\" cellspacing=\"0\" cellpadding=\"0\"&gt; &lt;tr&gt; &lt;td&gt;职位&lt;/td&gt; &lt;td &gt;${position}&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;职称&lt;/td&gt; &lt;td&gt;${jobLevel}&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;薪水&lt;/td&gt; &lt;td&gt;${salary}&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;部门&lt;/td&gt; &lt;td&gt;${dep}&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;div style=\"color: red;font-size: 30px\"&gt;希望在未来的日子携手共进&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 4、发送邮件12345678910111213141516171819202122232425262728293031323334353637@SpringBootTestclass MailApplicationTests { @Autowired private JavaMailSender javaMailSender; @Test public void freemakerTest() throws MessagingException, IOException, TemplateException { // 创建模拟消息对象 MimeMessage msg = javaMailSender.createMimeMessage();// 传入模拟消息对象; multipalt(多部分)类型为true MimeMessageHelper helper = new MimeMessageHelper(msg, true);// 谁发的 这里需要和配置文件中的一致 helper.setFrom(\"421192425@qq.com\");// 发给谁 helper.setTo(\"421192425@qq.com\");// 定义主题 helper.setSubject(\"freeMaiker主题\");// 定义发送的日期 helper.setSentDate(new Date());// 设置freemarker配置版本 Configuration configuration=new Configuration(Configuration.VERSION_2_3_29);// 传入当前对象的类加载器; 所在的基础包路径 configuration.setClassLoaderForTemplateLoading(this.getClass().getClassLoader(), \"templates\"); Template template=configuration.getTemplate(\"mail.ftlh\"); Map&lt;String,Object&gt; map= new HashMap&lt;&gt;(); map.put(\"username\", \"lcccc\"); map.put(\"position\", \"总经理\"); map.put(\"jobLevel\", \"架构师\"); map.put(\"salary\",\"2000\"); map.put(\"dep\", \"研发部\"); StringWriter out=new StringWriter(); template.process(map, out);// 发送的内容 ； 设置发送的内容为html为true helper.setText(out.toString(),true); javaMailSender.send(msg); }}","link":"/2020/04/17/springboot/SpringBoot%E6%95%B4%E5%90%88%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1/"},{"title":"SpringBoot整合WebSocket","text":"SpringBoot整合WebSocket一、springboot实现在线群聊1、pom.xml主要的后端依赖 spring-boot-starter-websocket 前端依赖 sockjs-client jquery stomp-websocket webjars-locator-core 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;websocket1&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;websocket1&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--前端websocket客户端依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;sockjs-client&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--jquery--&gt; &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;stomp-websocket&lt;/artifactId&gt; &lt;version&gt;2.3.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;webjars-locator-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、消息bean123456@Getter@Setterpublic class Message { private String name; private String content;} 3、websocket代理服务器123456789101112131415161718192021222324/** * 实现websocket消息代理人配置器 */@Configuration//开启消息代理@EnableWebSocketMessageBrokerpublic class WebSocketConfig implements WebSocketMessageBrokerConfigurer { @Override public void configureMessageBroker(MessageBrokerRegistry registry) {// 消息代理的前缀 registry.enableSimpleBroker(\"/topic\"); registry.setApplicationDestinationPrefixes(\"/app\"); } /** * 建立连接点 * @param registry */ @Override public void registerStompEndpoints(StompEndpointRegistry registry) { registry.addEndpoint(\"/chat\").withSockJS(); }} 4、消息请求处理controller1234567891011121314@Controllerpublic class GreetingController {// 处理客户端请求消息的路径 //客户端发送消息的路径 /app/hello @MessageMapping(\"/hello\") // 服务器广播的路径(/topic/greetings) 由配置的topic前缀的服务去处理 //客户端订阅消息的路径 /topic/greeting @SendTo(\"/topic/greetings\") public Message greeting(Message message) { return message; }} 5、聊天页面123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;群聊&lt;/title&gt; &lt;script src=\"/webjars/jquery/jquery.min.js\"&gt;&lt;/script&gt; &lt;script src=\"/webjars/sockjs-client/sockjs.min.js\"&gt;&lt;/script&gt; &lt;script src=\"/webjars/stomp-websocket/stomp.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;请输入用户名&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" id=\"name\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=\"button\" id=\"connect\" value=\"连接\"/&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=\"button\" id=\"disconnect\" value=\"断开连接\" disabled=\"disabled\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;!--display:none 此块不会显示--&gt; &lt;div id=\"chat\" style=\"display: none;\"&gt; &lt;table&gt; &lt;tr&gt;请输入聊天内容&lt;/tr&gt; &lt;td&gt;&lt;input type=\"text\" id=\"content\"/&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=\"button\" id=\"send\" value=\"发送\"&gt;&lt;/td&gt; &lt;/table&gt; &lt;div id=\"conversation\"&gt;群聊进行中....&lt;/div&gt; &lt;/div&gt;&lt;script&gt; $(function () { //点击连接 $(\"#connect\").click(function () { connect() }); // 断开连接 $(\"#disconnect\").click(function () { if(stompClient!=null){ //直接断开连接 stompClient.disconnect(); } setConnect(false); }); $(\"#send\").click(function () { stompClient.send('/app/hello',{},JSON.stringify({'name':$(\"#name\").val(),'content':$(\"#content\").val()})) }) }) var stompClient=null; //尝试连接 function connect() { //如果没有输入用户名 直接返回 if(!$(\"#name\").val()){ alert(\"请输入用户名\") return; } //建立连接点 var socket=new SockJS('/chat'); stompClient=Stomp.over(socket); stompClient.connect({},function (success) { //连接成功的回调 //建立连接 （界面的处理） setConnect(true); // 订阅服务器的消息（后端服务服务器广播消息的路径） stompClient.subscribe('/topic/greetings',function (msg) { //服务端的msg的具体消息 在body属性中 //将字符串消息转为json对象 showGreeting(JSON.parse(msg.body)) }) },function () { // 连接失败的回调 }) } //展示消息 function showGreeting(msg) { //向聊天div中追加内容 $(\"#conversation\").append('&lt;div&gt;'+msg.name+\":\"+msg.content+'&lt;/div&gt;') } //建立连接 function setConnect(flag) { //prop() 方法设置或返回被选元素的属性和值。 //如果连接成功 则设置 '连接' 按钮不可用 $(\"#connect\").prop(\"disabled\",flag); //断开连接按钮 可用 $(\"#disconnect\").prop(\"disabled\",!flag); if (flag) { //显示 聊天界面 $(\"#chat\").show(); }else{ $(\"#chat\").hide(); } }&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 二、 springboot实现在线单聊1、pom.xml主要的后端依赖 spring-boot-starter-websocket spring-boot-starter-security 前端依赖 sockjs-client jquery stomp-websocket webjars-locator-core 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;websocket1&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;websocket1&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--前端websocket客户端依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;sockjs-client&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--jquery--&gt; &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;stomp-websocket&lt;/artifactId&gt; &lt;version&gt;2.3.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;webjars-locator-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、消息bean12345678910111213141516@Getter@Setterpublic class Chat { /** * 消息从哪来 */ private String from; /** * 消息内容 */ private String content; /** * 消息发给谁 */ private String to;} 3、websocket代理服务器1234567891011121314151617181920212223242526/** * 实现websocket消息代理人配置器 */@Configuration//开启消息代理@EnableWebSocketMessageBrokerpublic class WebSocketConfig implements WebSocketMessageBrokerConfigurer { @Override public void configureMessageBroker(MessageBrokerRegistry registry) {// 消息代理的前缀// 在这里我们定义 /topic为群聊消息 /queue为单聊消息 registry.enableSimpleBroker(\"/topic\",\"/queue\");// 定义程序的发送目标前缀 registry.setApplicationDestinationPrefixes(\"/app\"); } /** * 建立连接点 * @param registry */ @Override public void registerStompEndpoints(StompEndpointRegistry registry) { registry.addEndpoint(\"/chat\").withSockJS(); }} 4、security配置12345678910111213141516171819202122232425262728293031@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter { @Bean public PasswordEncoder passwordEncoder() { return NoOpPasswordEncoder.getInstance(); } @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.inMemoryAuthentication() .withUser(\"lc\") .password(\"123\") .roles(\"admin\") .and() .withUser(\"zs\") .password(\"123\") .roles(\"user\"); } @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests(). anyRequest().authenticated() .and() .formLogin()// 允许所有登录请求 .permitAll(); }} 5、消息请求处理controller12345678910111213141516171819202122232425262728293031323334353637@Controllerpublic class GreetingController {// // 处理客户端请求消息的路径// @MessageMapping(\"/hello\")//// 服务器广播的路径(/topic/greetings) 由配置的topic前缀的服务去处理// @SendTo(\"/topic/greetings\")// public Message greeting(Message message) {// return message;// } /** * 使用消息发送模板 */ @Autowired private SimpMessagingTemplate simpMessagingTemplate; @MessageMapping(\"/hello\") public void greeting(Message message) {// 直接指定发送的路径和消息 simpMessagingTemplate.convertAndSend(\"/topic/greetings\",message); } /** * 单聊 * @param principal 当前登录的用户信息 * @param chat */ @MessageMapping(\"/chat\") public void chat(Principal principal, Chat chat) { //谁发的消息 （指定发送人） chat.setFrom(principal.getName());// 指定发送人 ，发送的路径 ，发送的消息 simpMessagingTemplate.convertAndSendToUser(chat.getTo(), \"/queue/chat\", chat); }} 6、聊天页面注意： 123456// 注意在单聊是 发送给指定用户，那么websocket服务端自动帮我们加 /user 所以这里我们也要加 /user stompClient.subscribe('/user/queue/chat', function (msg) { //服务端的msg的具体消息 在body属性中 //将字符串消息转为json对象 showGreeting(JSON.parse(msg.body)) }) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;单聊&lt;/title&gt; &lt;script src=\"/webjars/jquery/jquery.min.js\"&gt;&lt;/script&gt; &lt;script src=\"/webjars/sockjs-client/sockjs.min.js\"&gt;&lt;/script&gt; &lt;script src=\"/webjars/stomp-websocket/stomp.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=\"button\" id=\"connect\" value=\"连接\"/&gt;&lt;input type=\"button\" id=\"disconnect\" value=\"断开连接\" disabled=\"disabled\"/&gt;&lt;hr&gt;&lt;table&gt; &lt;tr&gt; &lt;td&gt;消息内容:&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" id=\"content\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;目标用户:&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" id=\"to\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=\"button\" value=\"发送\" id=\"send\"&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;div id=\"chat\" style=\"display: none\"&gt; &lt;div id=\"conversation\"&gt;连接进行中...&lt;/div&gt;&lt;/div&gt;&lt;script&gt; $(function () { //点击连接 $(\"#connect\").click(function () { connect() }); // 断开连接 $(\"#disconnect\").click(function () { if (stompClient != null) { //直接断开连接 stompClient.disconnect(); } setConnect(false); }); //点击发送 $(\"#send\").click(function () { stompClient.send('/app/chat', {}, JSON.stringify({ 'to': $(\"#to\").val(), 'content': $(\"#content\").val() })) }) }) var stompClient = null; //尝试连接 function connect() { // 创建连接点 var socket = new SockJS('/chat'); stompClient = Stomp.over(socket); stompClient.connect({}, function (success) { //连接成功的回调 //建立连接 （界面的处理） setConnect(true); // 订阅服务器的消息 // 注意在单聊是 发送给指定用户，那么websocket服务端自动帮我们加 /user 所以这里我们也要加 /user stompClient.subscribe('/user/queue/chat', function (msg) { //服务端的msg的具体消息 在body属性中 //将字符串消息转为json对象 showGreeting(JSON.parse(msg.body)) }) }, function () { // 连接失败的回调 }) } //展示消息 function showGreeting(msg) { //向聊天div中追加内容 $(\"#conversation\").append('&lt;div&gt;' + msg.from + \":\" + msg.content + '&lt;/div&gt;') } //建立连接 function setConnect(flag) { //prop() 方法设置或返回被选元素的属性和值。 //如果连接成功 则设置 '连接' 按钮不可用 $(\"#connect\").prop(\"disabled\", flag); //断开连接按钮 可用 $(\"#disconnect\").prop(\"disabled\", !flag); if (flag) { //显示 聊天界面 $(\"#chat\").show(); } else { $(\"#chat\").hide(); } }&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2020/04/17/websocket/SpringBoot%E6%95%B4%E5%90%88WebSocket/"},{"title":"Docker的基本操作Linux常用命令","text":"Centos 软件包管理工具 一、RPM：是Red-Hat Package Manager(RPM软件包管理器) 二、Yum（全称为 Yellow dog Updater, Modified）是一个在Fedora和RedHat以及CentOS中的Shell前端软件包管理器。 0、修改docker镜像源 编辑 /etc/docker/daemon.json 12345vi /etc/docker/daemon.json#添加如下网易镜像源{\"registry-mirrors\": [\"http://hub-mirror.c.163.com\"]} 1、docker操作123456yum install docker //安装dockeryum update //更新软件包工具systemctl enable docker //配置开机自启dockersudo systemctl start docker //启动systemctl stop docker //停止dockeryum -y install vim* //安装vim 2、镜像操作1234567docker search tag //从docker hub官网上检索tag指定镜像docker pull tag //下载镜像 tag为安装的软件名称 默认安装latest版本 即最近的docker pull tag:版本号 //安装指定版本号的软件docker images //查看本机安装的镜像docker rmi 镜像Image id //根据镜像id删除指定的镜像rm -rf //递归删除sudo rm -rf /var/lib/docker //删除所有镜像 3、防火墙操作123456systemctl start firewalld //启动防火墙systemctl stop firewalld //关闭防火墙systemctl status firewalld //查看防火墙状态systemctl start firewalld //启动防火墙systemctl disable firewalld //开机禁用防火墙systemctl enable firewalld //开机启用防火墙 4、容器操作123456docker ps //查看运行的容器docker stop id //根据id停止容器docker ps -a //查看所有容器,包括运行和退出的docker rm id/name //s根据id或者名称删除容器docker start id/name //根据id或名称开启容器docker logs name/id //根据容器id或容器名查看日志 5、常见容器安装1、mysql容器 (注意启动版本)123docker pull mysql:3.7 //下载指版本镜像docker run -d -p 3306:3306 --restart=always --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7// -d在后台启动 , -p端口映射 主机端口:映射端口 , --name 容器名称 ，-e 参数 若密码错误： 1234567&lt;1&gt; docker start mysql 进入MySql&lt;2&gt; docker ps -a 查出自己创建的container（容器）的ID&lt;3&gt; docker exec -it 63c9e29aelef bash （每个人创建的container ID都不一样） 执行对应的mysql程序&lt;4&gt; mysql --user=root --password 进入mysql进行登录&lt;5&gt; ALTER USER 'root' IDENTIFIED WITH mysql_native_password BY '1234567'; 设置新的密码quit 退出当前mysql命令行模式exit 退出容器 123456docker run --name mysql03 -v /conf/mysql:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag把主机的/conf/mysql文件夹挂载到 mysqldocker容器的/etc/mysql/conf.d文件夹里面改mysql的配置文件就只需要把mysql配置文件放在自定义的文件夹下（/conf/mysql）docker run -p 3307:3306 --name mysql02 -e MYSQL_ROOT_PASSWORD=123456 -d mysql --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci指定mysql的一些配置参数 2、Rabbitmq安装rabbitmq端口 ：5672 管理界面端口 ：15672 默认账户密码都是 guest 12docker pull rabbitmq:3-management //下载带管理界面的消息队列docker run -d -p 5672:5672 -p 15672:15672 --restart=always --name myrabbitmq 镜像id 修改rabbitmq密码 123docker exec -it fd4f81cdd3e7 bash //进入容器rabbitmqctl list_users //查看所有用户 rabbitmqctl change_password guest 'Newpassword' //修改指定用户密码 常见命令 12345新建用户：rabbitmqctl add_user username passwd删除用户：rabbitmqctl delete_user username改密码: rabbimqctl change_password {username} {newpassword}设置用户角色：rabbitmqctl set_user_tags {username} {tag ...}rabbitmqctl set_permissions -p / username \".*\" \".*\" \".*\" //添加权限 3、redis安装123456789docker pull redis //拉取镜像docker run -d -p 6379:6379 --restart=always --name myredis 镜像名 //创建容器docker exec -it 9a7d1cf2c234 redis-cli -v //查看版本①设置密码 此方法是临时设置的密码 重启服务后失效docker exec -it 9a7d1cf2c234 redis-cli //进入redis管理界面config get requirepass //查看密码config set requirepass 密码 //设置密码docker exec -it 9a7d1cf2c234 redis-cli -a '密码' //带密码进入管理界面 4、jdk安装12345678910111213141516171819202122下载jdk1.8和tomcat8.5 利用sftp传到远程服务器tar -zxvf jdk-8u221-linux-x64.tar.gz //解压jdkmv jdk1.8.0_221 /opt/jdk //移动rm jdk-8u221-linux-x64.tar.gz //安装包vi /etc/profile //进入文件##### 在文件末尾加上环境变量配置JAVA_HOME=/opt/jdk/JAVA_BIN=/opt/jdk/binJRE_HOME=/opt/jdk/jreCLASSPATH=/opt/jdk/jre/lib:/opt/jdk/lib:/opt/jdk/jre/lib/charsets.jarexport JAVA_HOME JAVA_BIN JRE_HOME PATH CLASSPATH#####source /etc/profile //使配置生效vi ~/.bashrc //进入文件##### 在文件默认加上配置export JAVA_HOME=/opt/jdkexport PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar######source ~/.bashrc //使配置生效java -version //查看是否成功 5、tomcat安装①docker常规方法（成功）123docker pull tomcat //拉取镜像docker run -d -p 8080:8080 --name tomcat01 -v /usr/local/dev/docker-tomcat:/usr/local/tomcat/webapps --restart=always tomcat //路径挂载 ，将.war的包放在宿主机/usr/local/dev/docker-tomcat下即可 访问 1http://47.96.141.44:8080/Test1_war/ ②容器打包镜像方法 （失败）123456789101112131415161718192021222324252627282930docker pull centos:7.2.1511 //拉取镜像docker run -i -t -v /root/software/:/mnt/software/ 9aec5c5fe4ba /bin/bash //创建目录并挂载容器## -i：表示以“交互模式”运行容器## -t：表示容器启动后会进入其命令行## -v：表示需要将本地哪个目录挂载到容器中，格式：-v &lt;宿主机目录&gt;:&lt;容器目录&gt;## /bin/bash：一旦容器启动，需要执行的命令，当前使用 \"/bin/bash\", 表示启动后直接进bash shellctrl+d 或者 exit //退出容器docker start thirsty_jepsen //开启容器tar -zxvf apache-tomcat-8.5.46.tar.gz //解压tomcatmv apache-tomcat-8.5.46 /opt/tomcat //移动rm apache-tomcat-8.5.46.tar.gz //删除安装包######编写tomcat启动脚本vi /root/run.sh###### 加入命令#!/bin/bashsource ~/.bashrcsh /opt/tomcat/bin/catalina.sh run######chmod u+x /root/run.sh //设置run.sh 权限###将配置好的容器重新打包为镜像 docker commit 2bd3cf9f4b33 tomcat_jdk_01 //docker commit [容器id] [命名]docker run -d -p 8080:8080 -v /root/webapps/:/opt/tomcat/webapps/ --name tomcat01 tomcat_jdk_01 /root/run.sh 6、nginx安装12341、docker pull nginx2、docker run -d -p 80:80 --restart=always --name nginx01 f949e7d76d63docker run -d -p 3000:80 --name longdbvuejs -v /usr/local/dev/vuelist:/usr/share/nginx/html/ 6617a398219c 7、mongodb安装docker run 命令参数123456789101112131415161718192021222324252627282930313233343536-a, --attach=[] 登录容器（必须是以docker run -d启动的容器） -w, --workdir=\"\" 指定容器的工作目录 -c, --cpu-shares=0 设置容器CPU权重，在CPU共享场景使用 -e, --env=[] 指定环境变量，容器中可以使用该环境变量 -m, --memory=\"\" 指定容器的内存上限 -P, --publish-all=false 指定容器暴露的端口 -p, --publish=[] 指定容器暴露的端口 主机端口:容器端口 -h, --hostname=\"\" 指定容器的主机名 -v, --volume=[] 给容器挂载存储卷，挂载到容器的某个目录 --volumes-from=[] 给容器挂载其他容器上的卷，挂载到容器的某个目录 --cap-add=[] 添加权限，权限清单详见：http://linux.die.net/man/7/capabilities --cap-drop=[] 删除权限，权限清单详见：http://linux.die.net/man/7/capabilities --cidfile=\"\" 运行容器后，在指定文件中写入容器PID值，一种典型的监控系统用法 --cpuset=\"\" 设置容器可以使用哪些CPU，此参数可以用来容器独占CPU --device=[] 添加主机设备给容器，相当于设备直通 --dns=[] 指定容器的dns服务器 --dns-search=[] 指定容器的dns搜索域名，写入到容器的/etc/resolv.conf文件 --entrypoint=\"\" 覆盖image的入口点 --env-file=[] 指定环境变量文件，文件格式为每行一个环境变量 --expose=[] 指定容器暴露的端口，即修改镜像的暴露端口 --link=[] 指定容器间的关联，使用其他容器的IP、env等信息 --lxc-conf=[] 指定容器的配置文件，只有在指定--exec-driver=lxc时使用 --name=\"\" 指定容器名字，后续可以通过名字进行容器管理，links特性需要使用名字 --net=\"bridge\" 容器网络设置: bridge 使用docker daemon指定的网桥 host //容器使用主机的网络 container:NAME_or_ID &gt;//使用其他容器的网路，共享IP和PORT等网络资源 none 容器使用自己的网络（类似--net=bridge),但是不进行配置--privileged=false 指定容器是否为特权容器，特权容器拥有所有的capabilities --restart=\"no\" 指定容器停止后的重启策略: no：容器退出时不重启 on-failure：容器故障退出（返回值非零）时重启 always：容器退出时总是重启 --rm=false 指定容器停止后自动删除容器(不支持以docker run -d启动的容器) --sig-proxy=true 设置由代理接受并处理信号，但是SIGCHLD、SIGSTOP和SIGKILL不能被代理 6、常见问题1、解决ctenOs中docker不能启动问题Job for docker.service failed because the control process exited with error code. Se e “systemctl st 1vi /etc/sysconfig/docker 将文件中的内容 改为 –selinux-enabled=false docker -v 查看版本号 (ctl==&gt;controller) 2、解决Error response from daemon: oci runtime error: container_linux.go:247: starting container processhttps://blog.csdn.net/liqun_super/article/details/88304094 3、查找所有docker 并强制删除https://www.cnblogs.com/OnlyDreams/p/8990350.html 4、sftp和ftp的区别1234567一、适用场景 我们平时习惯了使用ftp来上传下载文件，尤其是很多Linux环境下，我们一般都会通过第三方的SSH工具连接到Linux，但是当我们需要传输文件到Linux服务器当中，很多人习惯用ftp来传输，其实Linux默认是不提供ftp的，需要你额外安装FTP服务器。而且ftp服务器端会占用一定的VPS服务器资源。其实笔者更建议使用sftp代替ftp。 主要因为：一、可以不用额外安装任何服务器端程序(我比较中意这个，哈哈~~，很多公司为了安全性Linux没有外网环境，只有SSH的时候，想传输文件是很悲催的问题)。二、会更省系统资源。三、SFTP使用加密传输认证信息和传输数据，相对来说会更安全。四、也不需要单独配置，对新手来说比较简单(开启SSH默认就开启了SFTP)。二、主要区别 FTP是一种文件传输协议，一般是为了方便数据共享的。包括一个FTP服务器和多个FTP客户端。FTP客户端通过FTP协议在服务器上下载资源。而SFTP协议是在FTP的基础上对数据进行加密，使得传输的数据相对来说更安全。但是这种安全是以牺牲效率为代价的，也就是说SFTP的传输效率比FTP要低(不过现实使用当中，没有发现多大差别)。个人肤浅的认为就是：一；FTP要安装，SFTP不要安装。二；SFTP更安全，但更安全带来副作用就是的效率比FTP要低些。 6、docker官方手册https://docs.docker.com/engine/reference/commandline/docker/可以参考每一个镜像的文档 7、vi 命令12345678:w 保存文件但不退出vi:w file 将修改另外保存到file中，不退出vi:w! 强制保存，不推出vi:wq 保存文件并退出vi:wq! 强制保存文件，并退出viq: 不保存文件，退出vi:q! 不保存文件，强制退出vi:e! 放弃所有修改，从上次保存文件开始再编辑 8、linux中 ~ 和 / 的区别1234567891011~ 是当前用户的目录地址/ 是根目录的地址（一般称呼为root，/ 和 /root/ 是有区别的）/ 也指目录分隔符①当用户是root用户时~ 代表/root/，即根目录下的root目录/ 代表/ ，即根目录②当用户是jack用户时~ 代表/home/jack，即根目录下的home目录下的jack目录/ 代表/ ，即根目录 9、ps/top命令①查看所有用户进程信息1ps aux ②查看包含指定应用的进程12//查询包含apt的进程ps -ef|grep apt ps其他命令参数详解 1234567a：显示现行终端机下的所有进程，包括其他用户（所有用户）的进程； u：显示进程拥有者（当前用户下）、状态、资源占用等的详细信息（注意有“-”和无“-”的区别）； x：显示没有控制终端的进程。通常与 a 这个参数一起使用，可列出较完整信息； -e：显示所有进程； -f：完整输出显示进程之间的父子关系； -l：较长、较详细的将该 PID 的的信息列出； -o：自定义显示的字段； 进程参数详解 123456789101112131415161718192021222324USER 进程的属主；PID 进程的ID；PPID 父进程；%CPU 进程占用的CPU百分比；%MEM 占用内存的百分比；NI 进程的NICE值，数值大，表示较少占用CPU时间；VSZ 进程虚拟大小；RSS 驻留中页的数量；TTY 终端IDSTAT 进程状态（有以下几种） R 运行 S 可中断睡眠 Sleep D 不可中断睡眠 T 停止的进程 Z 僵尸进程 X 死掉的进程 Ss s进程的领导者，父进程 S&lt; &lt;优先级较高的进程 SN N优先级较低的进程 R+ +表示WCHAN 正在等待的进程资源；START 启动进程的时间；TIME 进程消耗CPU的时间；COMMAND 命令的名称和参数； ③根据端口找到指定进程12//根据端口找到该进程netstat -lnp|grep 8080 123456netstat子命令:-t (tcp) 仅显示tcp相关选项-u (udp) 仅显示udp相关选项-n 拒绝显示别名，能显示数字的全部转化为数字-l 仅列出在Listen(监听)的服务状态-p 显示建立相关链接的程序名 ④根据pid关闭进程12//根据PID强制关闭该进程kill -9 28937 ⑤top连续监控进程cpu使用情况top -c 其他用法 12345top //每隔5秒显式所有进程的资源占用情况top -d 2 //每隔2秒显式所有进程的资源占用情况top -c //每隔5秒显式进程的资源占用情况，并显示进程的命令行参数(默认只有进程名)top -p 12345 -p 6789//每隔5秒显示pid是12345和pid是6789的两个进程的资源占用情况top -d 2 -c -p 123456 //每隔2秒显示pid是12345的进程的资源使用情况，并显式该进程启动的命令行参数 11、查看文件内容①、一次加载全部1cat 1.txt ②、查看文件内容 （可翻页 b上一页 f下一页 ）1more 1.txt 12、jar包后台运行方式一：java -jar shareniu.jar特点：当前ssh窗口被锁定，可按CTRL + C打断程序运行，或直接关闭窗口，程序退出 那如何让窗口不锁定？ 方式二：java -jar shareniu.jar &amp;&amp;代表在后台运行。 特定：当前ssh窗口不被锁定，但是当窗口关闭时，程序中止运行。 继续改进，如何让窗口关闭时，程序仍然运行？ 方式三：nohup java -jar shareniu.jar &amp; nohup 意思是不挂断运行命令,当账户退出或终端关闭时,程序仍然运行 当用 nohup 命令执行作业时，缺省情况下该作业的所有输出被重定向到nohup.out的文件中，除非另外指定了输出文件。 结束后台！！！！！ 通过ps aux命令查看进程号PID，然后执行 kill -9 PID 如果是前台进程的话，直接执行 Ctrl+c 就可以终止了指定日志位置： 在vblog.log下 nohup java -jar vblog.jar &gt; vblog.log &amp; 在vhr.log下 nohup java -jar vhr.jar &gt; vhr.log &amp; 14、解决在linux中mysql中不区分大小写的情况问题：可能出现vim无法找到 一、apt-get update 二、apt-get install vim 在配置文件的[mysqld]后添加lower_case_table_names=1 ①.进入docke容器命令： docker exec -it f0b1c8ab3633 /bin/bash （f0b1c8ab3633为CONTAINER ID，请修改为你的CONTAINER ID ） ②.进入mysql目录命令： cd /etc/mysql/mysql.conf.d ③.查看mysql配置文件：命令： ls ④.修改配置文件命令：vim mysqld.cnf 按 i 进入编辑，加入lower_case_table_names=1 按Esc键，输入 :wq 保存退出 ⑤.exit退出容器⑥重启该容器docker stop mysql01 docker start mysql01 15、卸载某项软件或服务①查找包含程序运行的服务ps -ef | grep nginx ②停止服务kill -9 pid ③查询哪里包含nginxwhereis nginx find / -name nginx ④依次删除执行位置目录rm -rf 目录位置","link":"/2020/04/17/shell/Linux-CentOs/"},{"title":"SpringCache 整合redis缓存","text":"Spring Cache 整合redis缓存一、概述SpringCache本身是一个缓存体系的抽象实现，并没有具体的缓存能力，要使用SpringCache还需要配合具体的缓存实现来完成。 虽然如此，但是SpringCache是所有Spring支持的缓存结构的基础，而且所有的缓存的使用最后都要归结于SpringCache，那么一来，要想使用SpringCache，还是要仔细研究一下的。 SpringCache只是定义的一种规范，所有的实现均有redis实现，即我们需要使用其他的缓存只需要替换引用操作的缓存件即可。 二、缓存注解SpringCache缓存功能的实现是依靠下面的这几个注解完成的。 @EnableCaching：开启缓存功能 @Cacheable：定义缓存，用于触发缓存 @CachePut：定义更新缓存，触发缓存更新 @CacheEvict：定义清除缓存，触发缓存清除 @Caching：组合定义多种缓存功能 @CacheConfig：定义公共设置，位于class之上 2.1 @EnableCaching12345678910111213141516171819202122232425@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Import(CachingConfigurationSelector.class)public @interface EnableCaching { // 用于设置使用哪种代理方式，默认为基于接口的JDK动态代理（false）， // 设置为true，则使用基于继承的CGLIB动态代理 boolean proxyTargetClass() default false; // 用于设置切面织入方式(设置面向切面编程的实现方式)， // 默认为使用动态代理的方式织入，当然也可以设置为ASPECTJ的方式来实现AOP AdviceMode mode() default AdviceMode.PROXY; // 用于设置在一个切点存在多个通知的时候各个通知的执行顺序，默认为最低优先级， // 其中数字却大优先级越低，这里默认为最低优先级，int LOWEST_PRECEDENCE = // Integer.MAX_VALUE;，却是整数的最大值 int order() default Ordered.LOWEST_PRECEDENCE;}public enum AdviceMode { PROXY, ASPECTJ}public interface Ordered { int HIGHEST_PRECEDENCE = Integer.MIN_VALUE; int LOWEST_PRECEDENCE = Integer.MAX_VALUE; int getOrder();} 2.2 @Cacheable​ 该注解用于标注于方法之上用于标识该方法的返回结果需要被缓存起来，标注于类之上标识该类中所有方法均需要将结果缓存起来。 ​ 该注解标注的方法每次被调用前都会触发缓存校验，校验指定参数的缓存是否已存在（已发生过相同参数的调用），若存在，直接返回缓存结果，否则执行方法内容，最后将方法执行结果保存到缓存中。 12345678910111213141516171819202122232425262728293031323334353637383940@Target({ElementType.METHOD, ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface Cacheable { // 用于指定缓存名称，与cacheNames()方法效果一致 @AliasFor(\"cacheNames\") String[] value() default {}; // 用于指定缓存名称，与value()方法效果一致 @AliasFor(\"value\") String[] cacheNames() default {}; // 用于使用SPEL手动指定缓存键的组合方式，默认情况使用所有的参数来组合成键，除非自定义了keyGenerator。 // 使用SPEL表达式可以根据上下文环境来获取到指定的数据： // #root.method：用于获取当前方法的Method实例 // #root.target：用于获取当前方法的target实例 // #root.caches：用于获取当前方法关联的缓存 // #root.methodName：用于获取当前方法的名称 // #root.targetClass：用于获取目标类类型 // #root.args[1]：获取当前方法的第二个参数，等同于：#p1和#a1和#argumentName String key() default \"\"; // 自定义键生成器，定义了该方法之后，上面的key方法自动失效，这个键生成器是： // org.springframework.cache.interceptor.KeyGenerator，这是一个函数式接口， // 只有一个generate方法，我们可以通过自定义的逻辑来实现自定义的key生成策略。 String keyGenerator() default \"\"; // 用于设置自定义的cacheManager(缓存管理器),可以自动生成一个cacheResolver // （缓存解析器），这一下面的cacheResolver()方法设置互斥 String cacheManager() default \"\"; // 用于设置一个自定义的缓存解析器 String cacheResolver() default \"\"; // 用于设置执行缓存的条件，如果条件不满足，方法返回的结果就不会被缓存，默认无条件全部缓存。 // 同样使用SPEL来定义条件，可以使用的获取方式同key方法。 String condition() default \"\"; // 这个用于禁止缓存功能，如果设置的条件满足，就不执行缓存结果，与上面的condition不同之处在于， // 该方法执行在当前方法调用结束，结果出来之后，因此，它除了可以使用上面condition所能使用的SPEL // 表达式之外，还可以使用#result来获取方法的执行结果，亦即可以根据结果的不同来决定是否缓存。 String unless() default \"\"; // 设置是否对多个针对同一key执行缓存加载的操作的线程进行同步，默认不同步。这个功能需要明确确定所 // 使用的缓存工具支持该功能，否则不要滥用。 boolean sync() default false;} 2.3 @CachePut该注解用于更新缓存，无论结果是否已经缓存，都会在方法执行结束插入缓存，相当于更新缓存。一般用于更新方法之上。 123456789101112131415161718192021222324@Target({ElementType.METHOD, ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface CachePut { // 同上 @AliasFor(\"cacheNames\") String[] value() default {}; // 同上 @AliasFor(\"value\") String[] cacheNames() default {}; // 同上 String key() default \"\"; // 同上 String keyGenerator() default \"\"; // 同上 String cacheManager() default \"\"; // 同上 String cacheResolver() default \"\"; // 同上 String condition() default \"\"; // 同上 String unless() default \"\";} 2.4 @CacheEvict该注解主要用于删除缓存操作 1234567891011121314151617181920212223242526@Target({ElementType.METHOD, ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface CacheEvict { // 同上 @AliasFor(\"cacheNames\") String[] value() default {}; // 同上 @AliasFor(\"value\") String[] cacheNames() default {}; // 同上 String key() default \"\"; // 同上 String keyGenerator() default \"\"; // 同上 String cacheManager() default \"\"; // 同上 String cacheResolver() default \"\"; // 同上 String condition() default \"\"; // 这个设置用于指定当前缓存名称名下的所有缓存是否全部删除，默认false。 boolean allEntries() default false; // 这个用于指定删除缓存的操作是否在方法调用之前完成，默认为false，表示先调用方法，在执行缓存删除。 boolean beforeInvocation() default false;} 2.5 @Caching这个注解用于组个多个缓存操作，包括针对不用缓存名称的相同操作等，源码： 123456789101112@Target({ElementType.METHOD, ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface Caching { // 用于指定多个缓存设置操作 Cacheable[] cacheable() default {}; // 用于指定多个缓存更新操作 CachePut[] put() default {}; // 用于指定多个缓存失效操作 CacheEvict[] evict() default {};} 用法==&gt; 123456789101112131415161718192021222324@Service@Log4j2public class AnimalService { @Autowired private AnimalRepository animalRepository; //... @Caching( evict = { @CacheEvict(value = \"animalById\", key = \"#id\"), @CacheEvict(value = \"animals\", allEntries = true, beforeInvocation = true) } ) public ResponseEntity&lt;Integer&gt; deleteAnimalById(final int id){ return ResponseEntity.ok(animalRepository.deleteById(id)); } @Cacheable(\"animals\") public ResponseEntity&lt;Page&lt;Animal&gt;&gt; getAnimalPage(final Animal animal, final int pageId, final int pageSize){ Page&lt;Animal&gt; page = new Page&lt;&gt;(); page.setCurrent(pageId); page.setSize(pageSize); return ResponseEntity.ok((Page&lt;Animal&gt;) animalRepository.selectPage(page,packWrapper(animal, WrapperType.QUERY))); } //...} 2.6 @CacheConfig该注解标注于类之上，用于进行一些公共的缓存相关配置。源码为： 12345678910111213@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface CacheConfig { // 设置统一的缓存名，适用于整个类中的方法全部是针对同一缓存名操作的情况 String[] cacheNames() default {}; // 设置统一个键生成器，免去了每个缓存设置中单独设置 String keyGenerator() default \"\"; // 设置统一个自定义缓存管理器 String cacheManager() default \"\"; // 设置统一个自定义缓存解析器 String cacheResolver() default \"\";} 三、基本配置1、pom.xmlspring-boot-starter-security spring-boot-starter-cache spring-boot-starter-data-redis 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;jpa-rest&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;jpa-rest&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、yaml配置1234567891011spring:# redis配置 redis: host: 47.96.141.44 database: 0 password: 你的密码 port: 6379# 配置缓存名称 cache: cache-names: c1 3、实体Bean12345678@Getter@Setter@ToStringpublic class User implements Serializable { private Integer id; private String username; private String address;} 4、开启缓存12345678910@SpringBootApplication//启用缓存@EnableCachingpublic class JpaRestApplication { public static void main(String[] args) { SpringApplication.run(JpaRestApplication.class, args); }} 5、service层①缓存存储： key：指定一个或多个参数作为key12345678910111213141516171819@Servicepublic class UserService {/** * 方法的参数为key * 方法返回的结果为value * * cacheNames配置的缓存名称 * key 只指定某一个参数作为key,或者联合多个参数作为key * @param id * @return */ @Cacheable(cacheNames = \"c1\",key = \"#id+'-'+#name\") public User getUserById(Integer id,String name) { System.out.println(\"getUserId===&gt;&gt;&gt;&gt;\" + id); User u=new User(); u.setId(id); return u; }} 当参数即key相同时，直接从redis中取 测试==&gt; 1234567891011121314@SpringBootTestclass JpaRestApplicationTests { @Autowired private UserService userService; @Test void contextLoads() { User userById = userService.getUserById(1,\"bb\"); User userById1 = userService.getUserById(1,\"bb\"); System.out.println(userById); System.out.println(userById1); }} ②自定义key1234567891011121314@Componentpublic class RedisKeyGenerator implements KeyGenerator { /** * 自定义返回的key 当前定义的key形式为 \" 方法名:所有参数组成的字符串数组 \" * @param o * @param method 当前方法名 * @param objects 方法的参数 * @return */ @Override public Object generate(Object o, Method method, Object... objects) { return method.getName()+\":\"+ Arrays.toString(objects); }} 12345678910111213141516@Servicepublic class UserService { /** * keyGenerator 自定义生成的key 当前引用的配置类为开头字母小写的类名 * @param id * @param name * @return */ @Cacheable(cacheNames = \"c1\",keyGenerator = \"redisKeyGenerator\") public User getUserById1(Integer id,String name,String author) { System.out.println(\"getUserId===&gt;&gt;&gt;&gt;\" + id); User u=new User(); u.setId(id); return u; }} 测试==&gt; 1234567@Testvoid contextLoads1() { User userById = userService.getUserById1(1,\"bb\",\"张三\"); User userById1 = userService.getUserById1(1,\"bb\",\"张三\"); System.out.println(userById); System.out.println(userById1);} ③删除缓存1234567891011121314151617181920@Servicepublic class UserService { @Cacheable(cacheNames = \"c1\") public User getUserById2(Integer id) { System.out.println(\"getUserId===&gt;&gt;&gt;&gt;\" + id); User u=new User(); u.setId(id); return u; } /** * 删除缓存中的内容 * 默认根据方法的参数作为key进行删除 * @param id */ @CacheEvict(cacheNames = \"c1\") public void deleteUserById(Integer id) { System.out.println(\"deleteUserById==&gt;&gt;&gt;&gt;\"+id); }} 测试==&gt; 12345678@Test void contextLoads2() { User userById = userService.getUserById2(1); userService.deleteUserById(1); User userById1 = userService.getUserById2(1); System.out.println(userById); System.out.println(userById1); } ④更新缓存123456789101112@Servicepublic class UserService { /** * 更新缓存中的内容 key: 指定user对象中的id作为键 * @param user * @return */ @CachePut(cacheNames = \"c1\",key = \"#user.id\") public User updateUserById(User user){ return user; }} 测试==&gt; 123456789101112@Test void contextLoads3() { User userById = userService.getUserById2(2); User user = new User(); user.setId(1); user.setUsername(\"张三\"); user.setAddress(\"湖北武汉\"); userService.updateUserById(user); User userById1 = userService.getUserById2(2); System.out.println(userById); System.out.println(userById1); } ⑤定义全局缓存名称@CacheConfig(cacheNames = &quot;c1&quot;) 无需在每个方法上加cacheName 123456789101112131415161718192021@Service@CacheConfig(cacheNames = \"c1\")public class UserService { /** * 方法的参数为key * 方法返回的结果为value * * cacheNames配置的缓存名称 * key 只指定某一个参数作为key,或者联合多个参数作为key * @param id * @return */ @Cacheable(key = \"#id+'-'+#name\") public User getUserById(Integer id,String name) { System.out.println(\"getUserId===&gt;&gt;&gt;&gt;\" + id); User u=new User(); u.setId(id); return u; }}","link":"/2020/04/17/springcache/Spring%20Cache%E6%95%B4%E5%90%88redis/"},{"title":"Git详细使用","text":"一、什么是git？Git是目前世界上最先进的分布式版本控制系统。 工作原理 / 流程： Workspace：工作区Index / Stage：暂存区Repository：仓库区（或本地仓库）Remote：远程仓库 二、SVN与Git的最主要的区别？①SVN​ SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就纳闷了。 ②Git​ Git是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。 三、如何操作1、创建版本库​ 什么是版本库？版本库又名仓库，英文名repository,你可以简单的理解一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改，删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻还可以将文件”还原”。 ① 通过命令 git init 把这个目录变成git可以管理的仓库 ②使用 git add readme.txt 添加指定文件到暂存区里面去。 git add . 添加所有文件到暂存区 ③用命令 git commit 告诉Git，把文件提交到仓库。 git commit -m “描述” 添加修改的描述，以便辨别版本 ④git status 查看是否还有文件未提交 ⑤当修改或增加文件后 重新使用 git status 查看状态 12345678910111213On branch masterChanges not staged for commit: (use \"git add &lt;file&gt;...\" to update what will be committed) (use \"git checkout -- &lt;file&gt;...\" to discard changes in working directory) modified: \"guava\\347\\232\\204\\344\\275\\277\\347\\224\\250.md\" ------&gt;&gt;修改的Untracked files: (use \"git add &lt;file&gt;...\" to include in what will be committed) 1.txt ------&gt;&gt;增加的no changes added to commit (use \"git add\" and/or \"git commit -a\") ⑤git diff 文件名 查看修改的内容 ⑥ 当修改或增加其他文件时 重新添加所有 git add . 重新提交 git commit -m “描述” 2、版本回退例如： 在创建版本库的时候已经添加了1.txt 文件 多次修改1.txt 文件，并add和commit ① 查看历史记录 git log git log命令显示从最近到最远的显示日志 1234567891011121314151617181920212223commit 852772742844a1f7b2fca0211be71985431acc71 (HEAD -&gt; master)Author: louchen97 &lt;421192425@qq.com&gt;Date: Sun Dec 8 14:19:45 2019 +0800 修改1.txt gitcommit 132064dc8f0fc298794a555c5cc3e4c36931c37bAuthor: louchen97 &lt;421192425@qq.com&gt;Date: Sun Dec 8 14:18:57 2019 +0800 修改1.txt 天气commit 5b340f7c2ede9536c7ae42f4b65efde895e697c9Author: louchen97 &lt;421192425@qq.com&gt;Date: Sun Dec 8 14:15:31 2019 +0800 增加1.txt 修改guavacommit 05da67dce6737ccb2d6b526f27a91f43719e27cdAuthor: louchen97 &lt;421192425@qq.com&gt;Date: Sun Dec 8 11:30:22 2019 +0800 第一次 使用 git log –pretty=oneline 简化查看的界面 1234852772742844a1f7b2fca0211be71985431acc71 (HEAD -&gt; master) 修改1.txt git132064dc8f0fc298794a555c5cc3e4c36931c37b 修改1.txt 天气5b340f7c2ede9536c7ae42f4b65efde895e697c9 增加1.txt 修改guava05da67dce6737ccb2d6b526f27a91f43719e27cd 第一次 ②回退版本 回退到上一个版本： git reset –hard HEAD^ 回退到上上个版本：git reset –hard HEAD^^ 回退到前100个版本的话: git reset –hard HEAD~100 依次类推……… ③重新查看文件内容： cat 1.txt ④回退之后 重新 git log 发现回退之前的版本的log会消失 你想反悔了 又想回到回退之前的版本 查看所有的版本(包括已回退)： git reflog 12345132064d (HEAD -&gt; master) HEAD@{0}: reset: moving to HEAD^8527727 HEAD@{1}: commit: 修改1.txt git132064d (HEAD -&gt; master) HEAD@{2}: commit: 修改1.txt 天气5b340f7 HEAD@{3}: commit: 增加1.txt 修改guava05da67d HEAD@{4}: commit (initial): 第一次 根据版本号回退： git reset –hard 8527727 发现又恢复到回退之前的版本 三、理解工作区与暂存区的区别？​ 工作区：就是你在电脑上看到的目录，比如目录下里的文件(.git隐藏目录版本库除外)。或者以后需要再新建的目录文件等等都属于工作区范畴。​ 版本库(Repository)：工作区有一个隐藏目录.git,这个不属于工作区，这是版本库。其中版本库里面存了很多东西，其中最重要的就是stage(暂存区)，还有Git为我们自动创建了第一个分支master,以及指向master的一个指针HEAD。 我们前面说过使用Git提交文件到版本库有两步： 第一步：是使用 git add 把文件添加进去，实际上就是把文件添加到暂存区。 第二步：使用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支上。 四、Git撤销修改和删除文件操作1、撤销操作​ 之前我们提到当修改一个文件时 提交之后发现有问题需要回退 ①提交之后的做法： 第一步：如果我知道要删掉那些内容的话，直接手动更改去掉那些需要的文件，然后add添加到暂存区，最后commit掉。 第二步：我可以按以前的方法直接恢复到上一个版本。使用 git reset –hard HEAD^ ②未提交到暂存区的做法（未提交）： 在这里我们可以使用另一种方法： git checkout – 文件名 把该文件在工作区做的修改全部撤销 解释： 该文件自动修改后，还没有放到暂存区，使用 撤销修改就回到和版本库一模一样的状态。 ③提交到暂存器（未提交）的做法： 例如： 1、修改1.txt 2、add到暂存区 3、再修改1.txt 4、使用 git checkout – 文件名 5、结果会回退到 add到暂存区的版本 注意：git checkout – 1.txt 中的 – 很重要，如果没有 – 的话，那么命令变成创建分支了。2、删除操作①已提交状态 无法使用checkout 恢复 直接在工作区删除此文件 rm 1.txt 然后 git add . 然后 commit -m ‘描述’ ② 未add加到暂存区和未提交 可使用checkout恢复该文件 git checkout – 1.txt 五、远程仓库​ 在了解之前，先注册github账号，由于你的本地Git仓库和github仓库之间的传输是通过SSH加密的，所以需要一点设置：​ 第一步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果有的话，直接跳过此如下命令，如果没有的话，打开命令行，输入如下命令： ssh-keygen -t rsa –C “youremail@example.com” id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 查看github添加 私钥和公钥的方法 https://blog.csdn.net/qq_36150631/article/details/81038485 1、如何添加远程库？​ 现在的情景是：我们已经在本地创建了一个Git仓库后，又想在github创建一个Git仓库，并且希望这两个仓库进行远程同步，这样github的仓库可以作为备份，又可以其他人通过该仓库来协作。 ①在指定的远端仓库添加本机的ssh rsa 公钥 ②新建远端仓库：获取远端的git仓库的路径 ③将工作区添加到远端分支 查看关联的远程仓库信息 git remote ===&gt;&gt; 一般为origin 若为空则首次创建需要创建远端的origin仓库名并关联本地的master分支 git remote add origin https://gitee.com/louchen97/gitttttttt.git git push --set-upstream origin master ​ 把本地库的内容推送到远程，使用 git push命令，实际上是把当前分支master推送到远程。 ​ 由于远程库是空的，我们第一次推送master分支时，加上了 –u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。推送成功后，可以立刻在github页面中看到远程库的内容已经和本地一模一样了 ④提交到远程仓库（master分支） git push origin master 或者 git push https://gitee.com/louchen97/gitttttttt.git master 把本地master分支的最新修改推送到github上了，现在你就拥有了真正的分布式版本库了。 2、如何远程克隆仓库？①新建文件夹 git clone https://gitee.com/louchen97/gitttttttt.git 3、远程仓库的其他操作①删除远程仓库的关联git remote remove ②修改远程仓库的关联第一种：使用 git remote set-url 命令，更新远程仓库的 url git remote set-url origin &lt;newurl&gt; 第二种：先删除之前关联的远程仓库，再来添加新的远程仓库关联 # 删除关联的远程仓库 git remote remove &lt;name&gt; # 添加新的远程仓库关联 git remote add &lt;name&gt; &lt;url&gt; 远程仓库的名称推荐使用默认的名称 origin 。 六、创建与合并分支​ 在 版本回填退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。 1、创建并切换dev分支git checkout -b dev 等价于==&gt;&gt; git branch dev 创建分支 git checkout dev 切换分支 2、查看（所有）分支git branch ===&gt;&gt; 12* dev ====&gt;&gt; 当前分支前面有*号 并且为绿色字样 master 3、在dev分支上添加文件add到暂存器并且commit提交 4、切换到master主分支git checkout master 发现在分支dev添加的文件并没有 5、在master分支下，将分支dev合并到master主分支git merge dev git merge命令用于合并指定分支到当前分支上 这是可以看到主分支中在dev分支下添加的内容 6、删除dev分支git branch -d dev 总结分支操作12345678910111213总结创建与合并分支命令如下：查看分支：git branch创建分支：git branch name切换分支：git checkout name创建+切换分支：git checkout –b name合并某分支到当前分支：git merge name删除分支：git branch –d name 七、如何解决分支冲突？1、发生冲突在master分支和dev分支下都使用同一版本的时候 例如 1.txt 内容： 1增加其他的 ①、在dev分支下 修改1.txt1增加其他的 dev add 并 commit ②、在master主分支下 修改1.txt1增加其他的 master add 并 commit ③、 在master分支下合并dev分支git status 1234567891011121314On branch masterYour branch is ahead of 'origin/master' by 2 commits. (use \"git push\" to publish your local commits)You have unmerged paths. (fix conflicts and run \"git commit\") (use \"git merge --abort\" to abort the merge)Unmerged paths: (use \"git add &lt;file&gt;...\" to mark resolution) both modified: 1.txtno changes added to commit (use \"git add\" and/or \"git commit -a\") 1.txt 结果： 12345&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD增加其他的 master=======增加其他的 dev&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev &lt;&lt;&lt;HEAD是指主分支修改的内容 &gt;&gt;&gt;&gt;&gt;dev 是指dev上修改的内容 ⑤、还原master修改1.txt内容： 1增加其他的 master add 并 commit 因为dev和master合并后是 管理的同一版本的分支 所有文件内容都一致 2、分支策略管理 合并分支后删除分支 会丢掉分支信息​ 通常合并分支时，git一般使用”Fast forward”模式，在这种模式下，删除分支后，会丢掉分支信息，现在我们来使用带参数 –no-ff来禁用”Fast forward”模式。 合并dev分支，使用命令 git merge –no-ff -m “注释” dev ​ 分支策略：首先master主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活，干活一般情况下在新建的dev分支上干活，干完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。 八、bug分支​ 在开发中，会经常碰到bug问题，那么有了bug就需要修复，在Git中，分支是很强大的，每个bug都可以通过一个临时分支来修复，修复完成后，合并分支，然后将临时的分支删除掉。 ​ 比如我在开发中接到一个404 bug时候，我们可以创建一个404分支来修复它，但是，当前的fen分支上的工作还没有提交。比如下： 创建 git checkout -b fen 分支并切换到此分支 修改2.txt文件 但此时因为其他原因不能提交此文件 12345678On branch fenChanges not staged for commit: (use \"git add &lt;file&gt;...\" to update what will be committed) (use \"git checkout -- &lt;file&gt;...\" to discard changes in working directory) modified: 2.txtno changes added to commit (use \"git add\" and/or \"git commit -a\") ​ 并不是我不想提交，而是工作进行到一半时候，我们还无法提交，比如我这个分支bug要2天完成，但是我issue-404 bug需要5个小时内完成。怎么办呢？还好，Git还提供了一个stash功能，可以把当前工作现场 ”隐藏起来”，等以后恢复现场后继续工作。如下： ①、隐藏当前不能提交的分支git stash ②、创建其他分支修复此buggit checkout -b issue-404 修复此文件2.txt add 并 commit ③、master主分支合并issue-404git merge --no-ff -m 'merge修复404' issue-404 ④、删除此修复作用的分支git branch -d issue-404 ⑤、重新切换到dev分支git stash apply 恢复dev工作区 git stash list 查看恢复区 git stash drop 删除恢复区 九、多人协作​ 当你从远程库克隆时候，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且远程库的默认名称是origin。 要查看远程库的信息 使用 git remote 1origin 要查看远程库的详细信息 使用 git remote –v 12origin https://gitee.com/louchen97/gitttttttt.git (fetch) ====&gt;&gt; 抓取origin https://gitee.com/louchen97/gitttttttt.git (push) ====&gt;&gt; 推送 二、推送分支 (项目t1)1、推送master主分支到远端​ 推送分支就是把该分支上所有本地提交到远程库中，推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上 git push origin master 2、推送fen分支到远端git push origin fen 此时远端分支有两个 主分支 master 和 fen 分支 分别对应不同的版本库 master分支是主分支，因此要时刻与远程同步。一些修复bug分支不需要推送到远程去，可以先合并到主分支上，然后把主分支master推送到远程去。 二、抓取分支（新建项目t2）​ 多人协作时，大家都会往master分支上推送各自的修改。现在我们可以模拟另外一个同事，可以在另一台电脑上（注意要把SSH key添加到github上）或者同一台电脑上另外一个目录克隆，新建一个目录名字叫t2 ①、抓取主分支mastergit clone https://gitee.com/louchen97/gitttttttt.git ②、抓取后在master中创建fen把远程的origin的dev分支到本地来，于是可以使用命令创建本地dev分支： git checkout –b fen origin/fen 现在小伙伴们就可以在dev分支上做开发了，开发完成后把dev分支推送到远程库时 此时 本地的 master 对应远端的 master ​ 本地的 fen 对应远端的 fen 在fen分支中修改 后 add 和 commit 推送当前fen分支到远端的fen分支 git push origin fen ③、切换到t1 的fen分支下修改同样文件的内容 add 和 commit git push origin fen 发现： 12345678To https://gitee.com/louchen97/gitttttttt.git ! [rejected] fen -&gt; fen (fetch first)error: failed to push some refs to 'https://gitee.com/louchen97/gitttttttt.git'hint: Updates were rejected because the remote contains work that you dohint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: (e.g., 'git pull ...') before pushing again.hint: See the 'Note about fast-forwards' in 'git push --help' for details. ​ 由上面可知：推送失败，因为我的小伙伴最新提交的和我试图推送的有冲突，解决的办法也很简单，上面已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后在本地合并，解决冲突，再推送。 ④、拉取远端的fen分支，设置本地的fen分支和远端的origin/fen分支链接​ git pull也失败了，原因是没有指定本地fen分支与远程origin/fen分支的链接，根据提示，设置fen和origin/fen的链接：如下： git branch --set-upstream-to=origin/fen fen 这条命名会自动merge 本地和远端的fen分支 但是有冲突： 12345&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADt1添加的内容=======t2添加的内容&gt;&gt;&gt;&gt;&gt;&gt;&gt; d58f1f34d63f02333174f6e4dad45f4ba330b941 修改后重新push 1t1添加的内容 ⑤、切换到t2项目重新 git pull 得到t2和t2在fen分支下的同样内容 总结​ 首先，可以试图用git push origin branch-name推送自己的修改.如果推送失败，则因为远程分支比你的本地更新早，需要先用git pull试图合并。如果合并有冲突，则需要解决冲突，并在本地提交。再用git push origin branch-name推送。 总结一、新建代码库123# 在当前目录新建一个Git代码库$ git init # 新建一个目录，将其初始化为Git代码库$ git init [project-name] # 下载一个项目和它的整个代码历史$ git clone [url] 二、配置123# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot; 三、增加/删除文件12345678# 添加指定文件到暂存区$ git add [file1] [file2] ... # 添加指定目录到暂存区，包括子目录$ git add [dir] # 添加当前目录的所有文件到暂存区$ git add . # 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p # 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file] # 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 四、代码提交1234567# 提交暂存区到仓库区$ git commit -m [message] # 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message] # 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a # 提交时显示所有diff信息$ git commit -v # 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message] # 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 五、分支1234567891011121314# 列出所有本地分支$ git branch # 列出所有远程分支$ git branch -r # 列出所有本地分支和远程分支$ git branch -a # 新建一个分支，但依然停留在当前分支$ git branch [branch-name] # 新建一个分支，并切换到该分支$ git checkout -b [branch] # 新建一个分支，指向指定commit$ git branch [branch] [commit] # 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch] # 切换到指定分支，并更新工作区$ git checkout [branch-name] # 切换到上一个分支$ git checkout - # 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch] # 合并指定分支到当前分支$ git merge [branch] # 选择一个commit，合并进当前分支$ git cherry-pick [commit] # 删除分支$ git branch -d [branch-name] # 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 六、标签123456789# 列出所有tag$ git tag # 新建一个tag在当前commit$ git tag [tag] # 新建一个tag在指定commit$ git tag [tag] [commit] # 删除本地tag$ git tag -d [tag] # 删除远程tag$ git push origin :refs/tags/[tagName] # 查看tag信息$ git show [tag] # 提交指定tag$ git push [remote] [tag] # 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 七、查看信息1234567891011121314151617181920# 显示有变更的文件$ git status # 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat # 搜索提交历史，根据关键词$ git log -S [keyword] # 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s # 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件$ git log [tag] HEAD --grep feature # 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file] # 显示指定文件相关的每一次diff$ git log -p [file] # 显示过去5次提交$ git log -5 --pretty --oneline # 显示所有提交过的用户，按提交次数排序$ git shortlog -sn # 显示指定文件是什么人在什么时间修改过$ git blame [file] # 显示暂存区和工作区的差异$ git diff # 显示暂存区和上一个commit的差异$ git diff --cached [file] # 显示工作区与当前分支最新commit之间的差异$ git diff HEAD # 显示两次提交之间的差异$ git diff [first-branch]...[second-branch] # 显示今天你写了多少行代码$ git diff --shortstat &quot;@{0 day ago}&quot; # 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit] # 显示某次提交时，某个文件的内容$ git show [commit]:[filename] # 显示当前分支的最近几次提交$ git reflog 八、远程同步12345678# 下载远程仓库的所有变动$ git fetch [remote] # 显示所有远程仓库$ git remote -v # 显示某个远程仓库的信息$ git remote show [remote] # 增加一个新的远程仓库，并命名$ git remote add [shortname] [url] # 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch] # 上传本地指定分支到远程仓库$ git push [remote] [branch] # 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 九、撤销1234567891011# 恢复暂存区的指定文件到工作区$ git checkout [file] # 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file] # 恢复暂存区的所有文件到工作区$ git checkout . # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file] # 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit] # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit] # 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit] # 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit] # 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop","link":"/2020/04/17/git/git%E4%BD%BF%E7%94%A8/"},{"title":"mysql基础知识","text":"一、查询操作查询语句执行顺序1234567891011(1)from (3)join (2)on (4)where (5)group by(开始使用select中的别名，后面的语句中都可以使用)(6)avg,sum.... (7)having (8)select (9)distinct (10)order by (10)limit 1、between…and… 用法SELECT * FROM sc where grade BETWEEN 10 and 20; not 用法 表示非 SELECT * FROM sc where not(grade &gt;=10 and grade &lt;=20) 等于号后面不能接查询语句 SELECT * from sc where grade=(SELECT …..) 错误的写法 SELECT * from sc where grade in (SELECT grade from sc) #in后面才能跟结果集 2、exists用法 和 not existsSELECT * FROM b WHERE not EXISTS(SELECT * from a where a.id=b.id); 每次执行一次外部查询 都会执行子查询（会引用外部查询的值）是否返回结果集 查询选修了 1006课程的学生SELECT sname from s where EXISTS(SELECT * from sc where s.sid=sc.sid and cid=’1006’) 查询选修了课程的学生SELECT sname from s where EXISTS(select * from sc WHERE s.sid=sc.sid)1 查询到 退出5 没查询到 查询选修了全部课程的学生SELECT sname from s where not EXISTS(select * from c where not exists(SELECT * from sc where s.sid=sc.sid and c.cid=sc.cid)) 相当于三个for循环嵌套，都匹配返回，不匹配往下循环查找1 1001 空1 1002 不为空1 1003 不为空….1 1006 空遍历完二层后结果集 整体有值则不会返回 1 4 1001 空4 1002 空4 1003 空4 1004 空4 1005 空4 1006 空遍历完二层后结果集 整体为空则会返回 1 3、时间处理 %a 缩写星期名 %b 缩写月名 %c 月，数值 %D 带有英文前缀的月中的天 %d 月的天，数值(00-31) %e 月的天，数值(0-31) %f 微秒 %H 小时 (00-23) %h 小时 (01-12) %I 小时 (01-12) %i 分钟，数值(00-59) %j 年的天 (001-366) %k 小时 (0-23) %l 小时 (1-12) %M 月名 %m 月，数值(00-12) %p AM 或 PM %r 时间，12-小时（hh:mm:ss AM 或 PM） %S 秒(00-59) %s 秒(00-59) %T 时间, 24-小时 (hh:mm:ss) %U 周 (00-53) 星期日是一周的第一天 %u 周 (00-53) 星期一是一周的第一天 %V 周 (01-53) 星期日是一周的第一天，与 %X 使用 %v 周 (01-53) 星期一是一周的第一天，与 %x 使用 %W 星期名 %w 周的天 （0=星期日, 6=星期六） %X 年，其中的星期日是周的第一天，4 位，与 %V 使用 %x 年，其中的星期一是周的第一天，4 位，与 %v 使用 %Y 年，4 位 %y 年，2 位 时间间隔单位 HOUR 小时 MINUTE 分 SECOND 秒 MICROSECOND 毫秒 YEAR 年 MONTH 月 DAY 日 WEEK 周 QUARTER 季 YEAR_MONTH 年和月 DAY_HOUR 日和小时 DAY_MINUTE 日和分钟 DAY_ SECOND 日和秒 HOUR_MINUTE 小时和分 HOUR_SECOND 小时和秒 MINUTE_SECOND 分钟和秒 查询当前日期 2019-05-28SELECT CURDATE() 查询当前时间 13:41:49SELECT CURTIME() 查询当前日期和时间 2019-05-28 13:42:29select sysdate() SELECT NOW();SELECT NOW()+0; #20190528141522 ######查询指定日期属于一年中的第几周 21SELECT week(“2019-05-28 13:42:29”) ######查询指定日期的 年份 2019SELECT YEAR(“2019-05-28 13:42:29”); ######查询指定日期的 月份 5SELECT MONTH(“2019-05-28 13:42:29”);SELECT MONTHNAME(“2019-05-28 13:42:29”); #月份 May ######查询指定日期的 号 28SELECT day(“2019-05-28 13:42:29”);SELECT HOUR(“2019-05-28 13:42:29”); #时 13SELECT minute(“2019-05-28 13:42:29”); #分 42SELECT SECOND(“2019-05-28 13:42:29”) #秒 29 ######格式化日期 2019/05/28 14:05:25SELECT DATE_FORMAT(now(),”%Y/%m/%d %H:%i:%s”) ######日期相隔的天数 第一个日期减第二个日期 (格式必须相同) 符合年月日规范SELECT DATEDIFF(“2019-08-01”,”1997-08-06”) #8030 ######时间相隔 第一个时间减第二个时间 (格式必须相同) 符合时分秒规范SELECT TIMEDIFF(“15:44:44”,”13:04:44”) ######给日期加上指定间隔 INTERVAL 10 YEAR 加十年######给日期减去指定间隔 INTERVAL -10 YEAR 减十年SELECT ADDDATE(“2019-05-28 13:42:29”,INTERVAL -10 SECOND)######给日期加上指定天数 只能加天数 负数表示减SELECT ADDDATE(“2019-05-28 13:42:29”,2); ######给指定日期时间SELECT ADDTIME(“2017-03-03 13:42:29”,”2 1:11:11”); #2017-03-05 14:53:40######加秒SELECT ADDTIME(‘23:59:59’, 55); ######直接对日期任何部分进行操作 加+10小时 -10表示减10小时SELECT “2019-05-28 13:42:29” + INTERVAL 10 SECOND######减10年SELECT “2019-05-28 13:42:29” + INTERVAL -10 year 4、case when ….then… end 用法SELECT stu.sid,stu.sname, max(case when cname=’语文’ then grade ELSE 0 END) as 语文, max(case when cname=’数学’ then grade else 0 END) as 数学, max(case when cname=’英语’ then grade else 0 END) as 英语, avg(grade) 平均分FROM stu LEFT JOIN cs on stu.sid=cs.sid GROUP BY stu.sid,stu.sname; sid sname 语文 数学 英语 平均分 1 张三 86 60 0 73.00002 李四 86 99 100 95.00003 王五 0 0 100 100.00004 赵六 0 96 0 96.00005 田七 0 0 0 查询每个学生的选课成绩 一个陷阱请注意： 在聚合函数中，只能为空或者为null或者只能为数字。 不能出现汉字和字符 否则会出错 select student.sno 学号, student.sname 姓名,max(case when cname=’数据库’ then grade else ‘’ end) as 数据库,max(case when cname=’数学’ then grade else ‘’ end) as 数学,max(case when cname=’信息系统’ then grade else ‘’ end) as 信息系统,max(case when cname=’操作系统’ then grade else ‘’ end) as 操作系统,max(case when cname=’数据结构’ then grade else ‘’ end) as 数据结构,max(case when cname=’数据处理’ then grade else ‘’ end) as 数据处理,max(case when cname=’PASCAL语言’ then grade else ‘’ end) as PASCAL语言from student LEFT JOIN(select * from sc NATURAL join course WHERE sc.cno=course.cno) s onstudent.sno=s.sno GROUP BY student.sno,student.sname; 5、limit和offset的用法1234语句1：select * from student limit 9,4语句2：slect * from student limit 4 offset 9// 语句1和2均返回表student的第10、11、12、13行//语句2中的4表示返回4行，9表示从表的第十行开始 6、ifnull的用法12ifnull(null,&quot;123&quot;); //第一个参数为null 输出123ifnull(&quot;456&quot;,&quot;789&quot;); //第一个参数不为null 输出456 7、mysql事务的使用 (定时执行) 批量插入例子： 123456789101112Begin start transaction; set @timenow=now(); #定义变量#批量插入 记得列之间要对应insert into 表1(column1,column2,……) select column1,column2,…… from 表2;update 表2.....delete 表3.....其他操作.... commit;end 8、some,all,any 的用法any/some:any 可以与=、&gt;、&gt;=、&lt;、&lt;=、&lt;&gt;结合起来使用，分别表示等于、大于、大于等于、小于、小于等于、不等于其中的任何一个数据即返回。 只要有sage小于其中sdept为IS条件的任何一个数据即返回 1select *from student where sage&lt; any(select sage from student where sdept='IS') and sdept&lt;&gt;'IS' all:all可以与=、&gt;、&gt;=、&lt;、&lt;=、&lt;&gt;结合是来使用，分别表示等于、大于、大于等于、小于、小于等于、不等于其中的所有数据。 只要sgae 小于select sage from student中的所有数据即返回 1select *from student where sage&lt;=all(select sage from student) 9、自然连接natural join去掉重复的列 course表： cno cname credit pcno sc表： sno cno grade 1select * from sc natural join course where .... cno sno grade cname credit pcno 10、upper(str) lower(str) ucase(str) lcase(str)12SELECT upper('chINese'), lower('chINese'); # CHINESE chineseSELECT ucase('chINese'), lcase('chINese'); # CHINESE chinese 11、datetime和timestamp区别1、占用空间 类型 占据字节 表示形式 datetime 8 字节 yyyy-mm-dd hh:mm:ss timestamp 4 字节 yyyy-mm-dd hh:mm:ss 2、表示范围 类型 表示范围 datetime ‘1000-01-01 00:00:00.000000’ to ‘9999-12-31 23:59:59.999999’ timestamp ‘1970-01-01 00:00:01.000000’ to ‘2038-01-19 03:14:07.999999’ 3、时区123timestamp 只占 4 个字节，而且是以utc的格式储存， 它会自动检索当前时区并进行转换。datetime以 8 个字节储存，不会进行时区的检索. 也就是说，对于timestamp来说，如果储存时的时区和检索时的时区不一样，那么拿出来的数据也不一样。对于datetime来说，存什么拿到的就是什么。 4、mysql自动处理的形式1234//下面都是 MySQL 允许的形式，MySQL 会自动处理2016-10-01 20:48:592016#10#01 20/48/5920161001204859 5、使用场景12345如果在时间上要超过Linux时间的，或者服务器时区不一样的就建议选择 datetime。如果是想要使用自动插入时间或者自动更新时间功能的，可以使用timestamp。如果只是想表示年、日期、时间的还可以使用 year、 date、 time，它们分别占据 1、3、3 字节，而datetime就是它们的集合。 6、根据当前时间戳更新当我们创建字段时，勾选根据当前时间戳更新 时，字段类型为datatime或者timestamp 类型时。 修改(只有更新)数据时会自动更新该字段为当前系统时间 12、is not null, is null , &lt;&gt; ,!=12345678910在mysql中，筛选非空的时候经常会用到is not null和!=null，这两种方法单从字面上来看感觉是差不多的，其实如果去运行一下试试的话差别会很大！为什么会出现这种情况呢？null 表示什么也不是， 不能=、&gt;、&lt; … 所有的判断，结果都是false，所有只能用 is null进行判断。默认情况下，推荐使用 IS NOT NULL去判断，因为SQL默认情况下对！= Null的判断会永远返回0行，但没有语法错误。如果你一定想要使用！= Null来判断，需要加上这个语句：set ANSI_NULLS off这时你会发现IS NOT NULL 和 != null 是等效的一个字段如果设为“NULL”，表示如果这个字段的值为空时，自动插入一个“NULL”值。一个字段如果设为“NOT NULL”，表示如果这个字段的值为空时，不自动插入“NULL”值（任其无值）。所以，设为“NULL”的意思反而是“不能无值”（由MYSQL自动赋“NULL”值），而设为“NOT NULL”是“可以无值” 13、decimal(P,D) P是表示有效数字数(从左边第一个非0开始)的精度。 P范围为1〜65。 D是表示小数点后的位数。 D的范围是0~30。MySQL要求D小于或等于(&lt;=)P。 12amount ``DECIMAL``(6,2); amount列最多可以存储6位数字，小数位数为2位; 因此，amount列的范围是从-9999.99到9999.99。 1column_name DECIMAL(P) 等于 column_name DECIMAL(P,0); 在这种情况下，列不包含小数部分或小数点。 1column_name DECIMAL; 在这种情况下，P的默认值为10。 注意：当数值在其取值范围之内，小数位多了，则四舍五入后直接截断多出的小数位。 若数值在其取值范围之外，则直接报Out of range value错误。 14、decimal与之java中对应的BigDecimal一、构造BigDecimal 对象常用方法 123BigDecimal BigDecimal(double d); //不允许使用BigDecimal BigDecimal(String s); //常用,推荐使用static BigDecimal valueOf(double d); //常用,推荐使用 二、常用方法该对象进行操作会生成新的对象 123BigDecimal decimal=new BigDecimal(\"23.23123\");BigDecimal add = decimal.add(new BigDecimal(\"23123.11\"));System.out.println(add); 注意 1. double 参数的构造方法,不允许使用!!!!因为它不能精确的得到相应的值，值会变大; 2. String 构造方法是完全可预知的: 写入 new BigDecimal(“0.1”) 将创建一个 BigDecimal,它正好等于预期的0.1; 因此,通常建议优先使用 String 构造方法; 3. 静态方法 valueOf(double val) 内部实现,仍是将 double 类型转为 String 类型; 这通常是将 double(或float)转化为 BigDecimal 的首选方法; 15、concat的使用连接多个字符串的作用 concat(str1,str2,str3…..) 1concat('%',\"张三\",'%') 一般得到模糊查询的作用 1%张三% 16、union和union all区别列名的要相同 123select * from Table1 union #去除重复select * from Table2 123select * from Table1 union all #不会去除重复select * from Table2 17、replace into 有则更新，无则新增replace into表示插入替换数据，需求表中有PrimaryKey，或者unique索引，如果数据库已经存在数据，则用新数据替换，如果没有数据效果则和insert into一样； 1.如果发现表中已经有此行数据（根据主键或者唯一索引判断）则先删除此行数据，然后插入新的数据。 2. 否则，直接插入新数据。 https://www.jb51.net/article/158125.htm 1replace into tbl_name(col_name, ...) values(...) 相当于： 1if not exists (select 1 from t where id = 1) insert into t(id, update_time) values(1, getdate()) else update t set update_time = getdate() where id = 1； 关于执行影响的行数： ①：假如表中的一个旧记录与一个用于PRIMARY KEY或一个UNIQUE索引的新记录具有相同的值，则在新记录被插入之前，旧记录被删除。 返回影响行数2 ②：假如不存在即没有与一个用于PRIMARY KEY或一个UNIQUE索引的新记录具有相同的值，即直接插入，此时相当于一个普通插入操作。 返回影响行数1 18、xml中大于小于号的表示 &amp;lt; &lt; 小于号 &amp;gt; &gt; 大于号 &amp;amp; &amp; 和 &amp;apos; ‘ 单引号 &amp;quot; “ 双引号 还有一种方法是将判断条件放到一个声明中，即 例如： AND = #{startTime,jdbcType=DATE} ]]> AND","link":"/2020/04/17/sql/Mysql/"},{"title":"SpringBoot整合SpringSecurity","text":"SpringBoot整合SpringSecurity一、SpringSecurity初体验Spring Security 是 Spring 家族中的一个安全管理框架，实际上，在 Spring Boot 出现之前，Spring Security 就已经发展了多年了，但是使用的并不多，安全管理这个领域，一直是 Shiro 的天下。 相对于 Shiro，在 SSM/SSH 中整合 Spring Security 都是比较麻烦的操作，所以，Spring Security 虽然功能比 Shiro 强大，但是使用反而没有 Shiro 多（Shiro 虽然功能没有 Spring Security 多，但是对于大部分项目而言，Shiro 也够用了）。 自从有了 Spring Boot 之后，Spring Boot 对于 Spring Security 提供了 自动化配置方案，可以零配置使用 Spring Security。 因此，一般来说，常见的安全管理技术栈的组合是这样的： SSM + Shiro Spring Boot/Spring Cloud + Spring Security 注意，这只是一个推荐的组合而已，如果单纯从技术上来说，无论怎么组合，都是可以运行的。 1、pom.xmlspring-boot-starter-security 12345678910111213141516171819202122&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2、controller12345678@RestControllerpublic class UserController { @GetMapping(\"/hello\") public String hello(){ return \"hello lc\"; }} 3、默认进入security登录页面在SpringSecurity中，已经对所有接口进行保护。所以首次请求时需要用户名和密码 ，密码由springSecurity动态生成。 用户名： user 密码： Using generated security password: 14404948-b30c-4cf3-8d02-cbb79779ffab 二、 手动配置用户名密码任选其一即可 在我们的yaml配置中，我们的面不需要加密 1、yaml配置用户名密码123456789spring: security: user:# 配置用户名 name: louchen# 配置密码 password: 你的密码# 配置角色 roles: admin 2、配置文件配置用户名密码123456789101112131415161718192021222324@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter {// spring5开始 security中使用配置文件的设置用户密码的必须要加密// 所有这里我们设置密码不加密// 配置密码编码器 @Bean PasswordEncoder passwordEncoder() {// 此方法已过期（这里我们只是测试实验） return NoOpPasswordEncoder.getInstance(); }// 认证管理 @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception {// 在内存中的认证 auth.inMemoryAuthentication()// 设置多个用户名,密码,角色 .withUser(\"lc\").password(\"123456\").roles(\"admin\") .and() .withUser(\"zs\").password(\"123\").roles(\"user\"); }} 三、配置HttpSecurity(拦截规则)1、基本配置①、controller12345678910111213141516171819@RestControllerpublic class UserController { @GetMapping(\"/hello\") public String hello(){ return \"hello lc\"; } @GetMapping(\"/admin/hello\") public String admin(){ return \"hello admin\"; } @GetMapping(\"/user/hello\") public String user(){ return \"hello user\"; }} ②、securityConfig12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter {// spring5开始 security中使用配置文件的设置用户密码的必须要加密// 所有这里我们设置密码不加密// 配置密码编码器 @Bean PasswordEncoder passwordEncoder() {// 此方法已过期（这里我们只是测试实验） return NoOpPasswordEncoder.getInstance(); }// 认证管理 @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception {// 在内存中的认证 auth.inMemoryAuthentication()// 设置多个用户名,密码,角色 .withUser(\"lc\").password(\"123456\").roles(\"admin\") .and() .withUser(\"zs\").password(\"123\").roles(\"user\"); } @Override protected void configure(HttpSecurity http) throws Exception {// 开启授权请求 http.authorizeRequests()// 路径匹配 满足/admin/**路径的 必须要有admin角色 .antMatchers(\"/admin/**\").hasRole(\"admin\")// 路径匹配 满足/user/**路径的 必须要有其中的一个角色即可访问// .antMatchers(\"/user/**\").hasAnyRole(\"admin\",\"user\")// 另一种写法==&gt; 必须要有其中的一个角色即可访问 .antMatchers(\"/user/**\").access(\"hasAnyRole('admin','user')\")// 路径匹配 满足/manager/**路径规则的 必须要同时拥有admin和manager角色 .antMatchers(\"/manager/**\").access(\"hasRole('admin') and hasRole('manager')\")// 其他的请求只要认证即可访问 .anyRequest().authenticated() .and()// 开启表单登录 .formLogin() //处理表单登录的路径 //通过该路径登录的用户名和密码再去请求接口就不会有登录页面的出现,若直接走其他接口则会进入登录页面 //注意这里为post请求 .loginProcessingUrl(\"/doLogin\")// 跟登录有关的接口 直接运行访问 .permitAll() .and()// 关闭crsf攻击（跨站请求伪造）,便于我们测试 .csrf().disable(); }} 2、登录表单的详细配置①、Usercontroller1234567891011121314151617181920212223@RestControllerpublic class UserController {// 登录即可访问 @GetMapping(\"/hello\") public String hello(){ return \"hello lc\"; }// 模拟admin接口 @GetMapping(\"/admin/hello\") public String admin(){ return \"hello admin\"; }// 模拟user接口 @GetMapping(\"/user/hello\") public String user(){ return \"hello user\"; } } ②、LoginController1234//若前后端不分离，设置默认登录成功的路径 我们只需要跳转到主页连接即可(注意:这里的请求只支持post)// .successForwardUrl(\"/index111\")// 若前后端不分离 设置默认登录成功的路径 我们只需要跳转到主页链接即可（注意：这里的请求只支持get）// .defaultSuccessUrl(\"/index111\",true) 123456789101112131415@Controllerpublic class LoginController { //模拟登录成功后跳转的页面 @GetMapping(\"/index111\") public String toIndex() { return \"index11\"; }// 模拟登录的页面 @GetMapping(\"/login\") public String logon() { return \"login\"; }} ③、登录页login.html12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;登录&lt;/h1&gt;&lt;form action=\"/doLogin\" method=\"post\"&gt; &lt;div&gt; 用户名:&lt;input type=\"text\" name=\"uname\" placeholder=\"请输入用户名\"&gt;&lt;/div&gt; &lt;div&gt; 密码:&lt;input type=\"text\" name=\"passwd\" placeholder=\"请输入密码\"&gt;&lt;/div&gt; &lt;div&gt;&lt;input type=\"submit\" value=\"登录\"&gt;&lt;/div&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; ④、主页index11.html12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;主页！！！！&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; ③、SecurityConfig123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter {// spring5开始 security中使用配置文件的设置用户密码的必须要加密// 所有这里我们设置密码不加密// 配置密码编码器 @Bean PasswordEncoder passwordEncoder() {// 此方法已过期（这里我们只是测试实验） return NoOpPasswordEncoder.getInstance(); }// 认证管理 @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception {// 在内存中的认证 auth.inMemoryAuthentication()// 设置多个用户名,密码,角色 .withUser(\"lc\").password(\"123456\").roles(\"admin\") .and() .withUser(\"zs\").password(\"123\").roles(\"user\"); } @Override protected void configure(HttpSecurity http) throws Exception {// 开启授权请求 http.authorizeRequests()// 路径匹配 满足/admin/**路径的 必须要有admin角色 .antMatchers(\"/admin/**\").hasRole(\"admin\")// 路径匹配 满足/user/**路径的 必须要有其中的一个角色即可访问// .antMatchers(\"/user/**\").hasAnyRole(\"admin\",\"user\")// 另一种写法==&gt; 必须要有其中的一个角色即可访问 .antMatchers(\"/user/**\").access(\"hasAnyRole('admin','user')\")// 路径匹配 满足/manager/**路径规则的 必须要同时拥有admin和manager角色 .antMatchers(\"/manager/**\").access(\"hasRole('admin') and hasRole('manager')\")// 其他的请求只要认证即可访问 .anyRequest().authenticated() .and()// 开启表单登录 .formLogin() //处理表单登录的路径 //通过该路径登录的用户名和密码再去请求接口就不会有登录页面的出现,若直接走其他接口则会进入登录页面 //注意这里为post请求 .loginProcessingUrl(\"/doLogin\")// 自定义跳转到的登录页的路径（默认登录页失效）// 在前后端分离的情况下 我们只需要返回json即可 .loginPage(\"/login\")// 设置自定义的登录的用户名的key的名称 .usernameParameter(\"uname\")// 设置自定义的登录的密码的key的名称 .passwordParameter(\"passwd\")// 若前后端不分离，设置默认登录成功的路径 我们只需要跳转到主页连接即可(注意:这里的请求只支持post)// .successForwardUrl(\"/index111\")// 若前后端不分离 设置默认登录成功的路径 我们只需要跳转到主页链接即可（注意：这里的请求只支持get）// .defaultSuccessUrl(\"/index111\",true)// 登录成功的的自定义处理// 若前后端分离 则我们只需要处理是否登录成功返回相应的json即可 .successHandler(new AuthenticationSuccessHandler() {// Authentication用户登录的信息 @Override public void onAuthenticationSuccess(HttpServletRequest req, HttpServletResponse res, Authentication authentication) throws IOException, ServletException {// 设置响应头类型 res.setContentType(\"application/json;charset=utf-8\");// 获取打印输出流 PrintWriter printWriter=res.getWriter();// 响应自定义的数据 Map&lt;String,Object&gt; map=new HashMap&lt;&gt;();// 自定义状态码 map.put(\"status\", 200);// 登录的信息// map.put(\"msg\", authentication.getPrincipal()); //\"msg\": { // \"password\": null, // \"username\": \"lc\", // \"authorities\": [ // { // \"authority\": \"ROLE_admin\" // } // ], // \"accountNonExpired\": true, // \"accountNonLocked\": true, // \"credentialsNonExpired\": true, // \"enabled\": true // },// map.put(\"msg1\", authentication.getDetails()); // \"msg1\": { // \"remoteAddress\": \"0:0:0:0:0:0:0:1\", // \"sessionId\": null // },// map.put(\"msg2\", authentication.getAuthorities()); // \"msg2\": [ // { // \"authority\": \"ROLE_admin\" // } // ],// map.put(\"msg3\", authentication.getCredentials()); //\"msg3\": null,// map.put(\"msg4\", authentication.isAuthenticated()); //\"msg4\": true,// 将map转为json字符串 printWriter.write(new ObjectMapper().writeValueAsString(map)); printWriter.flush(); printWriter.close(); } })// 同理，前后端不分离进入登录失败的处理路径（支持post）// .failureForwardUrl(\"/error\")// 前后端分离 进入登录失败的自定义处理 .failureHandler(new AuthenticationFailureHandler() {// AuthenticationException 验证异常的信息 @Override public void onAuthenticationFailure(HttpServletRequest req, HttpServletResponse res, AuthenticationException e) throws IOException, ServletException {// 设置响应头类型 res.setContentType(\"application/json;charset=utf-8\");// 获取打印输出流 PrintWriter printWriter=res.getWriter();// 响应自定义的数据 Map&lt;String,Object&gt; map=new HashMap&lt;&gt;();// 自定义状态码 map.put(\"status\", 401);// 找到错误的类型 设置错误信息// Credentials 证书 凭证 if(e instanceof LockedException){ map.put(\"msg\", \"账户被锁定，登录失败\"); }else if(e instanceof BadCredentialsException){ map.put(\"msg\", \"用户名或密码输入错误，登录失败！\"); }else if(e instanceof DisabledException){ map.put(\"msg\", \"账号被禁用，登录失败！\"); }else if(e instanceof AccountExpiredException){ map.put(\"msg\", \"账户过期，登录失败！\"); }else if(e instanceof CredentialsExpiredException){ map.put(\"msg\", \"密码过期，登录失败！\"); }else{ map.put(\"msg\", \"登录失败！\"); }// 将map转为json字符串 printWriter.write(new ObjectMapper().writeValueAsString(map)); printWriter.flush(); printWriter.close(); } })// 跟登录有关的接口 直接运行访问 .permitAll() .and()// 关闭crsf攻击（跨站请求伪造）,便于我们测试 .csrf().disable(); }} 3、注销登录配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter {// spring5开始 security中使用配置文件的设置用户密码的必须要加密// 所有这里我们设置密码不加密// 配置密码编码器 @Bean PasswordEncoder passwordEncoder() {// 此方法已过期（这里我们只是测试实验） return NoOpPasswordEncoder.getInstance(); }// 认证管理 @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception {// 在内存中的认证 auth.inMemoryAuthentication()// 设置多个用户名,密码,角色 .withUser(\"lc\").password(\"123456\").roles(\"admin\") .and() .withUser(\"zs\").password(\"123\").roles(\"user\"); } @Override protected void configure(HttpSecurity http) throws Exception {// 开启授权请求 http.authorizeRequests()// 路径匹配 满足/admin/**路径的 必须要有admin角色 .antMatchers(\"/admin/**\").hasRole(\"admin\")// 路径匹配 满足/user/**路径的 必须要有其中的一个角色即可访问// .antMatchers(\"/user/**\").hasAnyRole(\"admin\",\"user\")// 另一种写法==&gt; 必须要有其中的一个角色即可访问 .antMatchers(\"/user/**\").access(\"hasAnyRole('admin','user')\")// 路径匹配 满足/manager/**路径规则的 必须要同时拥有admin和manager角色 .antMatchers(\"/manager/**\").access(\"hasRole('admin') and hasRole('manager')\")// 其他的请求只要认证即可访问 .anyRequest().authenticated() .and()// 开启表单登录 .formLogin() //处理表单登录的路径 //通过该路径登录的用户名和密码再去请求接口就不会有登录页面的出现,若直接走其他接口则会进入登录页面 //注意这里为post请求 .loginProcessingUrl(\"/doLogin\")// 自定义跳转到的登录页的路径（默认登录页失效）// 在前后端分离的情况下 我们只需要返回json即可 .loginPage(\"/login\")// 设置自定义的登录的用户名的key的名称 .usernameParameter(\"uname\")// 设置自定义的登录的密码的key的名称 .passwordParameter(\"passwd\")// 若前后端不分离，设置默认登录成功的路径 我们只需要跳转到主页连接即可(注意:这里的请求只支持post)// .successForwardUrl(\"/index111\")// 若前后端不分离 设置默认登录成功的路径 我们只需要跳转到主页链接即可（注意：这里的请求只支持get）// .defaultSuccessUrl(\"/index111\",true)// 登录成功的的自定义处理// 若前后端分离 则我们只需要处理是否登录成功返回相应的json即可 .successHandler(new AuthenticationSuccessHandler() {// Authentication报错用户登录的信息 @Override public void onAuthenticationSuccess(HttpServletRequest req, HttpServletResponse res, Authentication authentication) throws IOException, ServletException {// 设置响应头类型 res.setContentType(\"application/json;charset=utf-8\");// 获取打印输出流 PrintWriter printWriter=res.getWriter();// 响应自定义的数据 Map&lt;String,Object&gt; map=new HashMap&lt;&gt;();// 自定义状态码 map.put(\"status\", 200);// 登录的信息 map.put(\"msg\", authentication.getPrincipal()); //\"msg\": { // \"password\": null, // \"username\": \"lc\", // \"authorities\": [ // { // \"authority\": \"ROLE_admin\" // } // ], // \"accountNonExpired\": true, // \"accountNonLocked\": true, // \"credentialsNonExpired\": true, // \"enabled\": true // },// map.put(\"msg1\", authentication.getDetails()); // \"msg1\": { // \"remoteAddress\": \"0:0:0:0:0:0:0:1\", // \"sessionId\": null // },// map.put(\"msg2\", authentication.getAuthorities()); // \"msg2\": [ // { // \"authority\": \"ROLE_admin\" // } // ],// map.put(\"msg3\", authentication.getCredentials()); //\"msg3\": null,// map.put(\"msg4\", authentication.isAuthenticated()); //\"msg4\": true,// 将map转为json字符串 printWriter.write(new ObjectMapper().writeValueAsString(map)); printWriter.flush(); printWriter.close(); } })// 同理，前后端不分离进入登录失败的处理路径（支持post）// .failureForwardUrl(\"/error\")// 前后端分离 进入登录失败的自定义处理 .failureHandler(new AuthenticationFailureHandler() {// AuthenticationException 验证异常的信息 @Override public void onAuthenticationFailure(HttpServletRequest req, HttpServletResponse res, AuthenticationException e) throws IOException, ServletException {// 设置响应头类型 res.setContentType(\"application/json;charset=utf-8\");// 获取打印输出流 PrintWriter printWriter=res.getWriter();// 响应自定义的数据 Map&lt;String,Object&gt; map=new HashMap&lt;&gt;();// 自定义状态码 map.put(\"status\", 401);// 找到错误的类型 设置错误信息// Credentials 证书 凭证 if(e instanceof LockedException){ map.put(\"msg\", \"账户被锁定，登录失败\"); }else if(e instanceof BadCredentialsException){ map.put(\"msg\", \"用户名或密码输入错误，登录失败！\"); }else if(e instanceof DisabledException){ map.put(\"msg\", \"账号被禁用，登录失败！\"); }else if(e instanceof AccountExpiredException){ map.put(\"msg\", \"账户过期，登录失败！\"); }else if(e instanceof CredentialsExpiredException){ map.put(\"msg\", \"密码过期，登录失败！\"); }else{ map.put(\"msg\", \"登录失败！\"); }// 将map转为json字符串 printWriter.write(new ObjectMapper().writeValueAsString(map)); printWriter.flush(); printWriter.close(); } })// 跟登录有关的接口 直接运行访问 .permitAll() .and() .logout()// 定义注销的路径 .logoutUrl(\"/logout\")// 自定义注销的处理 .logoutSuccessHandler(new LogoutSuccessHandler() {// authentication 登录用户的信息 @Override public void onLogoutSuccess(HttpServletRequest req, HttpServletResponse res, Authentication authentication) throws IOException, ServletException { // 设置响应头类型 res.setContentType(\"application/json;charset=utf-8\");// 获取打印输出流 PrintWriter printWriter=res.getWriter();// 响应自定义的数据 Map&lt;String,Object&gt; map=new HashMap&lt;&gt;();// 自定义状态码 map.put(\"status\", 200); map.put(\"msg\", \"注销登录成功！\");// 将map转为json字符串 printWriter.write(new ObjectMapper().writeValueAsString(map)); printWriter.flush(); printWriter.close(); } }) .and()// 关闭crsf攻击（跨站请求伪造）,便于我们测试 .csrf().disable(); }} 三、多个httpSecurity配置1、controller123456789101112131415161718192021@RestControllerpublic class UserController {// 登录即可访问 @GetMapping(\"/hello\") public String hello(){ return \"hello lc\"; }// 模拟admin接口 @GetMapping(\"/admin/hello\") public String admin(){ return \"hello admin\"; }// 模拟user接口 @GetMapping(\"/user/hello\") public String user(){ return \"hello user\"; }} 2、SecurityConfig注意： httpSecurity.antMatcher(&quot;/admin/**&quot;).authorizeRequests().anyRequest().hasRole(&quot;admin&quot;) 只是对/admin/\\的形式的路径进行拦截，而不是所有路径** 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Configurationpublic class MultipleHttpSecurity { @Bean PasswordEncoder passwordEncoder() { return NoOpPasswordEncoder.getInstance(); } /** * 认证管理 * @param auth 这里相当于注入 AuthenticationManagerBuilder对象 * @throws Exception */ @Autowired protected void configure(AuthenticationManagerBuilder auth) throws Exception {// 在内存中的认证 auth.inMemoryAuthentication()// 设置多个用户名,密码,角色 .withUser(\"lc\").password(\"111\").roles(\"admin\") .and() .withUser(\"zs\").password(\"222\").roles(\"user\"); } @Configuration// 数字越小优先级越高 @Order(1) public static class AdminSecurityConfig extends WebSecurityConfigurerAdapter{ @Override protected void configure(HttpSecurity httpSecurity) throws Exception {// 表示当前httpsecurity只拦截 /admin/** 路径，并且需要admin角色 httpSecurity.antMatcher(\"/admin/**\").authorizeRequests().anyRequest().hasRole(\"admin\"); } } @Configuration public static class OtherSecurityConfig extends WebSecurityConfigurerAdapter{ @Override protected void configure(HttpSecurity httpSecurity) throws Exception {// 开启授权请求，所有的请求都需要认证即可访问// 这里经过上面的admin的请求后 再拦截其他的所有请求 httpSecurity.authorizeRequests().anyRequest().authenticated() .and() .formLogin() .loginProcessingUrl(\"/doLogin\") .permitAll() .and() .csrf().disable(); } } } 四、BCryptPasswordEncoder密码加密​ spring security中的BCryptPasswordEncoder方法采用SHA-256 +随机盐+密钥对密码进行加密。SHA系列是Hash算法，不是加密算法，使用加密算法意味着可以解密（这个与编码/解码一样），但是采用Hash处理，其过程是不可逆的。 （1）加密(encode)：注册用户时，使用SHA-256+随机盐+密钥把用户输入的密码进行hash处理，得到密码的hash值，然后将其存入数据库中。 （2）密码匹配(matches)：用户登录时，密码匹配阶段并没有进行密码解密（因为密码经过Hash处理，是不可逆的），而是使用相同的算法把用户输入的密码进行hash处理，得到密码的hash值，然后将其与从数据库中查询到的密码hash值进行比较。如果两者相同，说明用户输入的密码正确。 这正是为什么处理密码时要用hash算法，而不用加密算法。因为这样处理即使数据库泄漏，黑客也很难破解密码（破解密码只能用彩虹表）。 12345678910111213141516171819202122232425262728293031@SpringBootTestclass JpaRestApplicationTests { @Test void Test1(){// 可定义循环迭代的强度（默认为10） BCryptPasswordEncoder bCryptPasswordEncoder=new BCryptPasswordEncoder(); String encode=\"\"; for (int i = 0; i &lt; 10; i++) { //加密 encode = bCryptPasswordEncoder.encode(\"111\"); System.out.println(encode); }// 解密// 验证加密的和原密码是否匹配 boolean matches = bCryptPasswordEncoder.matches(\"111\", encode); System.out.println(matches); // 我们可以看到每次加密的密码都不一致 //$2a$10$4f0bp6uBiLdt2mfZcL4ITuolV7C1wNSAvmC5DCkQQ/wIbf0N4aiYu //$2a$10$3J7jUw/4d5tIJc.36e/SMOf3g3SWjFwYnBnc5q90F9jsHkbbfrbWO //$2a$10$oDbDEQonfNF3VccU9rw2u.PCEYgPz7sdEA/Zk3vlhq7nnA6zFptUq //$2a$10$h5mGJ1JleyKqJ0cXThgiv.D6tXWtsJovWCGn3lRC2VKzyHWBrrnSS //$2a$10$005mvGASGZVRgNzm2upYsOXTCgwZPhxhHsJQM50DFE9PTW0GR3hY. //$2a$10$gVbxdtiMstQESB0/EBbZq.4rPWHpgq20AUK.Jlq4xUE.g3jPGa5Mq //$2a$10$HWUDxz8SZYorijp05yeJH.JdkF8Jm.y2/rVnAXEXObprxeBWZYRfa //$2a$10$rpslaqYmHY9VCXY6U94nNO69rzwU34vDDFudW/APYFgLb3oVeVNu6 //$2a$10$7o41f4IV/uNwPmDKd4Rl/ehdPY5FT5uCvt1aofXwqwWTdkOQK/9L. //$2a$10$6NfXSvvKtzpgdjskRhoiMeqq9xTaWsCS7FdDr/I1I3Iy4IeT0tuta } 修改securityconfig配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@Configurationpublic class MultipleHttpSecurity {// 这里我们使用BCryptPasswordEncoder加密 @Bean PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); } /** * 认证管理 * @param auth 这里相当于注入 AuthenticationManagerBuilder对象 * @throws Exception */ @Autowired protected void configure(AuthenticationManagerBuilder auth) throws Exception {// 在内存中的认证 auth.inMemoryAuthentication()// 设置多个用户名,密码,角色 .withUser(\"lc\").password(\"111\").roles(\"admin\") .and() .withUser(\"zs\").password(\"$2a$10$4f0bp6uBiLdt2mfZcL4ITuolV7C1wNSAvmC5DCkQQ/wIbf0N4aiYu\").roles(\"user\"); } @Configuration// 数字越小优先级越高 @Order(1) public static class AdminSecurityConfig extends WebSecurityConfigurerAdapter{ @Override protected void configure(HttpSecurity httpSecurity) throws Exception {// 表示当前httpsecurity只拦截 /admin/** 路径，并且需要admin角色 httpSecurity.antMatcher(\"/admin/**\").authorizeRequests().anyRequest().hasRole(\"admin\"); } } @Configuration public static class OtherSecurityConfig extends WebSecurityConfigurerAdapter{ @Override protected void configure(HttpSecurity httpSecurity) throws Exception {// 开启授权请求，所有的请求都需要认证即可访问// 这里经过上面的admin的请求后 再拦截其他的所有请求 httpSecurity.authorizeRequests().anyRequest().authenticated() .and() .formLogin() .loginProcessingUrl(\"/doLogin\") .permitAll() .and() .csrf().disable(); } }} 五、方法安全管控1、注解详解​ spring security默认禁用注解，要想开启注解，需要在继承WebSecurityConfigurerAdapter的类上加@EnableGlobalMethodSecurity注解，并在该类中将AuthenticationManager定义为bean。 这里springSecurity默认禁用所有方法保护的注解@EnableGlobalMethodSecurity(prePostEnabled = true,securedEnabled = true) prePostEnabled开启 @PreAuthorize和@PostAuthorize 注解securedEnabled 开启@Secured注解 @EnableGlobalMethodSecurity启用注解1、@PreAuthorize在方法执行前判断，可以调用方法参数，主要利用Java8的参数名反射特性，如果没用Java8也可以使用spring security的@P标注参数，或者Spring Data的@Param标注参数。 123//判断用户是否为当前登录用户或拥有ROLE_ADMIN权限@PreAuthorize(\"#userId == authentication.principal.userId or hasAuthority(‘ADMIN’)\")public void changePassword(@P(\"userId\") long userId ){} 2、@PostAuthorize在方法执行后判断，可以调用参数。如果EL为false，虽然方法已经执行完了也可能会回滚，EL变量returnObject表示返回的对象。 3、@Secured只支持字符串形式,且必须要加上前缀ROLE_ 是否有权限访问 2、基本配置①、securityConfig1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@Configuration//这里springSecurity默认禁用所有方法保护的注解//prePostEnabled开启 @PreAuthorize和@PostAuthorize 注解//securedEnabled 开启@Secured注解@EnableGlobalMethodSecurity(prePostEnabled = true,securedEnabled = true)public class MultipleHttpSecurity {// 这里我们使用BCryptPasswordEncoder加密 @Bean PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); } /** * 认证管理 * @param auth 这里相当于注入 AuthenticationManagerBuilder对象 * @throws Exception */ @Autowired protected void configure(AuthenticationManagerBuilder auth) throws Exception {// 在内存中的认证 auth.inMemoryAuthentication()// 设置多个用户名,密码,角色 .withUser(\"lc\").password(\"$2a$10$4f0bp6uBiLdt2mfZcL4ITuolV7C1wNSAvmC5DCkQQ/wIbf0N4aiYu\").roles(\"admin\") .and() .withUser(\"zs\").password(\"$2a$10$4f0bp6uBiLdt2mfZcL4ITuolV7C1wNSAvmC5DCkQQ/wIbf0N4aiYu\").roles(\"user\"); } @Configuration// 数字越小优先级越高 @Order(1) public static class AdminSecurityConfig extends WebSecurityConfigurerAdapter{ @Override protected void configure(HttpSecurity httpSecurity) throws Exception {// 表示当前httpsecurity只拦截 /admin/** 路径，并且需要admin角色 httpSecurity.antMatcher(\"/admin/**\").authorizeRequests().anyRequest().hasRole(\"admin\"); } } @Configuration public static class OtherSecurityConfig extends WebSecurityConfigurerAdapter{ @Override protected void configure(HttpSecurity httpSecurity) throws Exception {// 开启授权请求，所有的请求都需要认证即可访问// 这里经过上面的admin的请求后 再拦截其他的所有请求 httpSecurity.authorizeRequests().anyRequest().authenticated() .and() .formLogin() .loginProcessingUrl(\"/doLogin\") .permitAll() .and() .csrf().disable(); } }} ②、userService123456789101112131415161718192021222324252627282930313233@Servicepublic class UserService { /** * 方法进入前 验证是否有admin角色 * @return */ @PreAuthorize(\"hasRole('admin')\") //同时要有admin和user角色// @PreAuthorize(\"hasRole('admin') and hasRole('user')\") public String admin() { return \"hello admin\"; } /** * 是否有user角色 * @return */ @Secured(\"ROLE_user\") public String user() { return \"hello user\"; } /** * 方法进入前 验证是否有admin或者user角色 * @return */ @PreAuthorize(\"hasAnyRole('admin','user')\") public String hello(){ return \"hello evenyone\"; }} ③、controller123456789101112131415161718@RestControllerpublic class UserController {// 登录即可访问 @GetMapping(\"/hello\") public String hello(){ return \"hello lc\"; }// 模拟admin接口 @GetMapping(\"/admin/hello\") public String admin(){ return \"hello admin\"; }// 模拟user上接口 @GetMapping(\"/user/hello\") public String user(){ return \"hello user\"; }} 六、基于数据库的认证1、sql1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859SET FOREIGN_KEY_CHECKS=0;-- ------------------------------ Table structure for role-- ----------------------------DROP TABLE IF EXISTS `role`;CREATE TABLE `role` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(32) DEFAULT NULL, `nameZh` varchar(32) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;-- ------------------------------ Records of role-- ----------------------------INSERT INTO `role` VALUES ('1', 'dba', '数据库管理员');INSERT INTO `role` VALUES ('2', 'admin', '系统管理员');INSERT INTO `role` VALUES ('3', 'user', '用户');-- ------------------------------ Table structure for user-- ----------------------------DROP TABLE IF EXISTS `user`;CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(32) DEFAULT NULL, `password` varchar(255) DEFAULT NULL, `enabled` tinyint(1) DEFAULT NULL, `locked` tinyint(1) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;-- ------------------------------ Records of user 密码123-- ----------------------------INSERT INTO `user` VALUES ('1', 'root', '$2a$10$RMuFXGQ5AtH4wOvkUqyvuecpqUSeoxZYqilXzbz50dceRsga.WYiq', '1', '0');INSERT INTO `user` VALUES ('2', 'admin', '$2a$10$RMuFXGQ5AtH4wOvkUqyvuecpqUSeoxZYqilXzbz50dceRsga.WYiq', '1', '0');INSERT INTO `user` VALUES ('3', 'sang', '$2a$10$RMuFXGQ5AtH4wOvkUqyvuecpqUSeoxZYqilXzbz50dceRsga.WYiq', '1', '0');-- ------------------------------ Table structure for user_role-- ----------------------------DROP TABLE IF EXISTS `user_role`;CREATE TABLE `user_role` ( `id` int(11) NOT NULL AUTO_INCREMENT, `uid` int(11) DEFAULT NULL, `rid` int(11) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;-- ------------------------------ Records of user_role-- ----------------------------INSERT INTO `user_role` VALUES ('1', '1', '1');INSERT INTO `user_role` VALUES ('2', '1', '2');INSERT INTO `user_role` VALUES ('3', '2', '2');INSERT INTO `user_role` VALUES ('4', '3', '3');SET FOREIGN_KEY_CHECKS=1; 2、pom.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.lc&lt;/groupId&gt; &lt;artifactId&gt;security-db&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;security-db&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.18&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.27&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 3、实体这里提供的UserDetails只是一种规范 123456789101112131415public interface UserDetails extends Serializable { Collection&lt;? extends GrantedAuthority&gt; getAuthorities(); String getPassword(); String getUsername(); boolean isAccountNonExpired(); boolean isAccountNonLocked(); boolean isCredentialsNonExpired(); boolean isEnabled();} ①user 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118public class User implements UserDetails { private Integer id; private String username; private String password; /** * 是否启用 */ private Boolean enabled; /** * 是否锁定 */ private Boolean locked; /** * 一个用户可以包含多个角色 */ private List&lt;Role&gt; roles; public Integer getId() { return id; } public User setId(Integer id) { this.id = id; return this; } public User setUsername(String username) { this.username = username; return this; } public User setPassword(String password) { this.password = password; return this; } public User setEnabled(Boolean enabled) { this.enabled = enabled; return this; } public User setLocked(Boolean locked) { this.locked = locked; return this; } public List&lt;Role&gt; getRoles() { return roles; } public User setRoles(List&lt;Role&gt; roles) { this.roles = roles; return this; } @Override public String getPassword(){ return password; } @Override public String getUsername() { return username; } /** * 返回用户的所有角色 * @return */ @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() { List&lt;SimpleGrantedAuthority&gt; authorities=new ArrayList&lt;&gt;();// 将数据中查询的角色信息查出并传入springsecurity for (Role role : roles) {// 注意若数据中的角色名没有以ROLE_开头，则需要在这动态赋予。否则则不需要 authorities.add(new SimpleGrantedAuthority(\"ROLE_\" + role.getName())); } return authorities; } /** * 账户是否没有未过期 * @return */ @Override public boolean isAccountNonExpired() { return true; } /** * 账户是否未锁定 相当于locked的get方法 * @return */ @Override public boolean isAccountNonLocked() { //这里的数据库中为0，则这里的locked为false; 因为这里问是否未被锁定，所以这里要取反 return !locked; } /** * 凭证(密码)是否未过期 * @return */ @Override public boolean isCredentialsNonExpired() { return true; } /** * 是否可用 相当于enabled的get方法 * @return */ @Override public boolean isEnabled() { return enabled; }} ②role 12345678@Setter@Getter@ToStringpublic class Role { private Integer id; private String name; private String nameZh;} 5、mapper①接口 1234567public interface UserMapper { User loadUserByUsername(String username); //根据用户id查询所有该用户对应的角色 List&lt;Role&gt; getUserRolesById(Integer id);} ②xml 12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" &gt;&lt;mapper namespace=\"com.lc.securitydb.mapper.UserMapper\"&gt; &lt;select id=\"loadUserByUsername\" resultType=\"com.lc.securitydb.bean.User\"&gt; select * from user where username=#{username}; &lt;/select&gt; &lt;select id=\"getUserRolesById\" resultType=\"com.lc.securitydb.bean.Role\"&gt; select * from role where id in(select rid from user_role where uid=#{id}) &lt;/select&gt;&lt;/mapper&gt; 6、service同理，这里我们提供UserDetailsService是一种规范 123public interface UserDetailsService { UserDetails loadUserByUsername(String var1) throws UsernameNotFoundException;} 1234567891011121314151617181920212223@Servicepublic class UserService implements UserDetailsService { @Autowired private UserMapper userMapper; /** * 根据用户名查询用户 这里我们只需要根据用户名查出即可 后面的密码结果系统会去比对 * @param username 登录时的用户名 * @return * @throws UsernameNotFoundException */ @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException { User user=userMapper.loadUserByUsername(username); if (user == null) { throw new UsernameNotFoundException(\"用户不存在\"); }// 查询用户角色 user.setRoles(userMapper.getUserRolesById(user.getId())); return user; }} 7、config①mybatis配置1234@Configuration@MapperScan(basePackages = \"com.lc.securitydb.mapper\")public class MybatisConfig {} ②security配置123456789101112131415161718192021222324252627282930313233343536373839@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter { @Autowired private UserService userService; /** * 进行用户名和密码的配置管理 * @param auth * @throws Exception */ @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.userDetailsService(userService); } /** * 加密器 * @return */ @Bean public BCryptPasswordEncoder bCryptPasswordEncoder() { return new BCryptPasswordEncoder(); } @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers(\"/admin/**\").hasRole(\"admin\") .antMatchers(\"/dba/**\").hasRole(\"dba\") .antMatchers(\"/user/**\").hasRole(\"user\") .anyRequest().authenticated() .and() .formLogin() .permitAll() .and() .csrf().disable(); }} 8、yaml123456spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/securitytest?useUnicode=true&amp;characterEncoding=utf-8 username: root password: 123456 9、controller12345678910111213141516171819202122232425262728293031323334353637383940@RestControllerpublic class HelloController { /** * 登录即可 访问 * @return */ @GetMapping(\"/hello\") public String hello() { return \"hello security\"; } /** * 角色dba访问 * @return */ @GetMapping(\"/dba/hello\") public String dba() { return \"hello dba\"; } /** * 角色admin访问 * @return */ @GetMapping(\"/admin/hello\") public String admin() { return \"hello admin\"; } /** * 角色user访问 * @return */ @GetMapping(\"/user/hello\") public String user() { return \"hello user\"; }} 七、SpringSecurity中的继承关系1、版本化的配置差异①SpringBoot2.0.8(含)之前的写法角色之间的继承关系用 空格 分开 1234567@Bean RoleHierarchy roleHierarchy() { RoleHierarchyImpl roleHierarchy = new RoleHierarchyImpl(); String hierarchy = \"ROLE_dba &gt; ROLE_admin ROLE_admin &gt; ROLE_user\"; roleHierarchy.setHierarchy(hierarchy); return roleHierarchy; } ②SpringBoot2.0.8之后的版本角色之前的继承用 \\n 分开 1234567@Beanpublic RoleHierarchy roleHierarchy() { RoleHierarchyImpl roleHierarchy = new RoleHierarchyImpl(); String hierarchy = \"ROLE_dba &gt; ROLE_admin \\n ROLE_admin &gt; ROLE_user\"; roleHierarchy.setHierarchy(hierarchy); return roleHierarchy;} 拥有dba角色可以访问admin有关的接口，拥有admin角色可以访问user有关的接口，user只能访问自己有关的接口，所以dba可以访问admin和user有关的接口，admin可以访问user的有关接口 2、注意的几个地方：①注意角色前要加 ROLE_ 前缀 ②角色和角色之间的定义 &gt; 前后要加空格 , \\n 前后也要加空格 3、基本配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter { @Autowired private UserService userService; /** * 进行用户名和密码的配置管理 * * @param auth * @throws Exception */ @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.userDetailsService(userService); } /** * 加密器 * * @return */ @Bean public BCryptPasswordEncoder bCryptPasswordEncoder() { return new BCryptPasswordEncoder(); } @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers(\"/admin/**\").hasRole(\"admin\") .antMatchers(\"/dba/**\").hasRole(\"dba\") .antMatchers(\"/user/**\").hasRole(\"user\") .anyRequest().authenticated() .and() .formLogin() .permitAll() .and() .csrf().disable(); } @Bean public RoleHierarchy roleHierarchy() { RoleHierarchyImpl roleHierarchy = new RoleHierarchyImpl(); String hierarchy = \"ROLE_dba &gt; ROLE_admin \\n ROLE_admin &gt; ROLE_user\"; roleHierarchy.setHierarchy(hierarchy); return roleHierarchy; }} 八、动态配置权限1、sql菜单表，菜单角色表，用户表，角色表，用户角色表 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980CREATE TABLE `menu` ( `id` int(11) NOT NULL AUTO_INCREMENT, `pattern` varchar(100) NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4;-- ------------------------------ Records of menu-- ----------------------------INSERT INTO `menu` VALUES ('1', '/dba/**');INSERT INTO `menu` VALUES ('2', '/admin/**');INSERT INTO `menu` VALUES ('3', '/user/**');CREATE TABLE `menu_role` ( `id` int(11) NOT NULL AUTO_INCREMENT, `mid` int(11) DEFAULT NULL, `rid` int(11) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4;-- ------------------------------ Records of menu_role-- ----------------------------INSERT INTO `menu_role` VALUES ('1', '1', '1');INSERT INTO `menu_role` VALUES ('2', '2', '2');INSERT INTO `menu_role` VALUES ('3', '3', '3');CREATE TABLE `role` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(32) DEFAULT NULL, `nameZh` varchar(32) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;-- ------------------------------ Records of role-- ----------------------------INSERT INTO `role` VALUES ('1', 'dba', '数据库管理员');INSERT INTO `role` VALUES ('2', 'admin', '系统管理员');INSERT INTO `role` VALUES ('3', 'user', '用户');-- ------------------------------ Table structure for user-- ----------------------------DROP TABLE IF EXISTS `user`;CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(32) DEFAULT NULL, `password` varchar(255) DEFAULT NULL, `enabled` tinyint(1) DEFAULT NULL, `locked` tinyint(1) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;-- ------------------------------ Records of user 密码123-- ----------------------------INSERT INTO `user` VALUES ('1', 'root', '$2a$10$RMuFXGQ5AtH4wOvkUqyvuecpqUSeoxZYqilXzbz50dceRsga.WYiq', '1', '0');INSERT INTO `user` VALUES ('2', 'admin', '$2a$10$RMuFXGQ5AtH4wOvkUqyvuecpqUSeoxZYqilXzbz50dceRsga.WYiq', '1', '0');INSERT INTO `user` VALUES ('3', 'sang', '$2a$10$RMuFXGQ5AtH4wOvkUqyvuecpqUSeoxZYqilXzbz50dceRsga.WYiq', '1', '0');-- ------------------------------ Table structure for user_role-- ----------------------------DROP TABLE IF EXISTS `user_role`;CREATE TABLE `user_role` ( `id` int(11) NOT NULL AUTO_INCREMENT, `uid` int(11) DEFAULT NULL, `rid` int(11) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;-- ------------------------------ Records of user_role-- ----------------------------INSERT INTO `user_role` VALUES ('1', '1', '1');INSERT INTO `user_role` VALUES ('2', '1', '2');INSERT INTO `user_role` VALUES ('3', '2', '2');INSERT INTO `user_role` VALUES ('4', '3', '3');SET FOREIGN_KEY_CHECKS=1; 2、pom.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;security-dynamic&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;security-dynamic&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.18&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;version&gt;5.1.27&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 3、yaml配置123456spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/securitydy?useUnicode=true&amp;characterEncoding=UTF-8 username: root password: 123456 4、实体配置menu==&gt; 12345678910111213141516@Getter@Setter@ToStringpublic class Menu { private Integer id; /** * 访问此菜单的路径 */ private String pattern; /** * 访问此此单需要的角色 */ private List&lt;Role&gt; roles;} role==&gt; 12345678@Getter@Setter@ToStringpublic class Role { private Integer id; private String name; private String nameZh;} user==&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public class User implements UserDetails { private Integer id; private String username; private String password; private Boolean enabled; private Boolean locked; private List&lt;Role&gt; roles; public List&lt;Role&gt; getRoles() { return roles; } public User setRoles(List&lt;Role&gt; roles) { this.roles = roles; return this; } public Integer getId() { return id; } public User setId(Integer id) { this.id = id; return this; } public User setUsername(String username) { this.username = username; return this; } public User setPassword(String password) { this.password = password; return this; } public User setEnabled(Boolean enabled) { this.enabled = enabled; return this; } public User setLocked(Boolean locked) { this.locked = locked; return this; } @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() { List&lt;SimpleGrantedAuthority&gt; authorities=new ArrayList&lt;&gt;(); for (Role role : roles) {// 此时这里我们不需要加ROLE_前缀 因为数据库中我们的角色名已经加好了前缀 authorities.add(new SimpleGrantedAuthority(role.getName())); } return authorities; } @Override public String getPassword() { return password; } @Override public String getUsername() { return username; } @Override public boolean isAccountNonExpired() { return true; } @Override public boolean isAccountNonLocked() { return !locked; } @Override public boolean isCredentialsNonExpired() { return true; } @Override public boolean isEnabled() { return enabled; }} 5、mapper123public interface MenuMapper { List&lt;Menu&gt; getAllMenus();} 1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" &gt;&lt;mapper namespace=\"org.lc.securitydynamic.mapper.MenuMapper\"&gt; &lt;resultMap id=\"BaseResultMap\" type=\"org.lc.securitydynamic.bean.Menu\"&gt; &lt;id property=\"id\" column=\"id\"/&gt; &lt;result property=\"pattern\" column=\"pattern\"/&gt; &lt;collection property=\"roles\" ofType=\"org.lc.securitydynamic.bean.Role\"&gt; &lt;id property=\"id\" column=\"rid\"/&gt; &lt;result property=\"name\" column=\"rname\"/&gt; &lt;result property=\"nameZh\" column=\"rnameZh\"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=\"getAllMenus\" resultMap=\"BaseResultMap\"&gt; SELECT menu.*, role.id rid, role. NAME rname, role.nameZh rnameZh FROM menu LEFT JOIN menu_role mr ON menu.id = mr.mid LEFT JOIN role ON mr.rid = role.id &lt;/select&gt;&lt;/mapper&gt; 123456public interface UserMapper { User getUserByUsername(String username); List&lt;Role&gt; getRolesByUserId(Integer id);} 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" &gt;&lt;mapper namespace=\"org.lc.securitydynamic.mapper.UserMapper\"&gt; &lt;select id=\"getUserByUsername\" resultType=\"org.lc.securitydynamic.bean.User\"&gt; select * from user where username=#{username} &lt;/select&gt; &lt;select id=\"getRolesByUserId\" resultType=\"org.lc.securitydynamic.bean.Role\"&gt; select * from role where id in(select rid from user_role where uid=#{id}) &lt;/select&gt;&lt;/mapper&gt; 6、service12345678910@Servicepublic class MenuService { @Autowired private MenuMapper menuMapper; public List&lt;Menu&gt; getAllMenus() { return menuMapper.getAllMenus(); }} 12345678910111213141516@Servicepublic class UserService implements UserDetailsService { @Autowired private UserMapper userMapper; @Override public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException { User user= userMapper.getUserByUsername(s); if (user == null) { throw new UsernameNotFoundException(\"用户不存在\"); } user.setRoles(userMapper.getRolesByUserId(user.getId())); return user; }} 7、controller12345678910111213141516171819202122232425262728293031323334353637383940@RestControllerpublic class HelloController { /** * 登录即可访问 * @return */ @GetMapping(\"/hello\") public String hello() { return \"hello security\"; } /** * 模拟 dba角色 * @return */ @GetMapping(\"/dba/hello\") public String dba() { return \"hello dba\"; } /** * 模拟admin角色 * @return */ @GetMapping(\"/admin/hello\") public String admin() { return \"hello admin\"; } /** * 模拟user角色 * @return */ @GetMapping(\"/user/hello\") public String user() { return \"hello user\"; }} 8、核心配置①mybati配置1234@Configuration@MapperScan(basePackages = \"org.lc.securitydynamic.mapper\")public class MybatisConfig {} ②过滤回调配置(筛选请求需要的角色)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263@Componentpublic class MyFilterInvocation implements FilterInvocationSecurityMetadataSource { /** * 匹配ant风格的路径 使用AntPathMatcher类比较两个路径是否匹配 */ AntPathMatcher antPathMatcher=new AntPathMatcher(); @Autowired private MenuService menuService; /** * 这里每一次请求就会查询一遍表 和遍历一遍集合，我们可以放入redis缓存中 * * 根据请求的地址 分析 出需要的角色 * @param o 实际上是一个FilterInvocation对象 请求的相关信息 * @return 返回需要的角色 * @throws IllegalArgumentException */ @Override public Collection&lt;ConfigAttribute&gt; getAttributes(Object o) throws IllegalArgumentException {// 获取当前请求的url String requestUrl = ((FilterInvocation) o).getRequestUrl();// 获取数据库中每个菜单请求对应的访问路径即角色信息 List&lt;Menu&gt; allMenus = menuService.getAllMenus();// 遍历数据库中的菜单 for (Menu menu : allMenus) {// 判断数据库中的菜单路径 是否 和请求的路径匹配 if (antPathMatcher.match(menu.getPattern(), requestUrl)) {// 若匹配 获取该路径下的对应的所有角色信息 List&lt;Role&gt; roles = menu.getRoles();// 定义存放角色的字符串 并指定和list中相同的长度 String[] allRoleList=new String[roles.size()];// 遍历该角色集合 for (int i = 0; i &lt; roles.size(); i++) {// 存放到字符串数组中 allRoleList[i] = roles.get(i).getName(); }// 返回该匹配的请求路径下的所有角色信息 return SecurityConfig.createList(allRoleList); } }// 如果请求的路径没有和数据库中的路径匹配 则返回自定义的角色（这里，我们只作为一个标识，后期根据标识再去处理） return SecurityConfig.createList(\"ROLE_login\"); } @Override public Collection&lt;ConfigAttribute&gt; getAllConfigAttributes() { return null; } /** * 是否支持这种方式 返回true即可 * @param aClass * @return */ @Override public boolean supports(Class&lt;?&gt; aClass) { return true; }} ③存储决定管理器(比对登录用户的角色)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package org.lc.securitydynamic.config;import org.springframework.security.access.AccessDecisionManager;import org.springframework.security.access.AccessDeniedException;import org.springframework.security.access.ConfigAttribute;import org.springframework.security.authentication.AnonymousAuthenticationToken;import org.springframework.security.authentication.InsufficientAuthenticationException;import org.springframework.security.core.Authentication;import org.springframework.security.core.GrantedAuthority;import org.springframework.stereotype.Component;import java.util.Collection;/** * @BelongsProject: security-dynamic * @BelongsPackage: org.lc.securitydynamic.config * @Author: lc * @CreateTime: 2020-03-29 00:19 * @Description: */@Componentpublic class MyAccessDecisionManager implements AccessDecisionManager { /** * @param authentication 当前登录用户的信息 * @param o 当前的请求对象（相当于FilterInvocation对象） * @param collection 我们自定义的FilterInvocationSecurityMetadataSource的返回匹配路径需要的角色对象 * @throws AccessDeniedException * @throws InsufficientAuthenticationException */ @Override public void decide(Authentication authentication, Object o, Collection&lt;ConfigAttribute&gt; collection) throws AccessDeniedException, InsufficientAuthenticationException {// 这里考虑 未登录先直接抛出异常*************** if (authentication instanceof AnonymousAuthenticationToken) { throw new AccessDeniedException(\"未登录,非法请求\"); }// 遍历该请求路径下需要的角色对象 for (ConfigAttribute configAttribute : collection) {// 如果没有任何路径匹配（我们之前定义的没有任何路径能够匹配上，自定义返回的角色） if (\"ROLE_login\".equals(configAttribute.getAttribute())) {// 若登录状态为匿名用户（未登录） 直接抛异常 if (authentication instanceof AnonymousAuthenticationToken) { //RememberMeAuthenticationToken (org.springframework.security.authentication) //TestingAuthenticationToken (org.springframework.security.authentication)// 匿名用户的登录 //AnonymousAuthenticationToken (org.springframework.security.authentication) //RunAsUserToken (org.springframework.security.access.intercept)// 已经进行用户名和密码的登录 //UsernamePasswordAuthenticationToken (org.springframework.security.authentication) //PreAuthenticatedAuthenticationToken (org.springframework.security.web.authentication.preauth) throw new AccessDeniedException(\"非法请求\"); }else{// 已经登录 但是没有匹配数据库中的路径// 可能只要登录即可访问// 直接退出角色寻找 return; } }// 当前登录用户具备的角色 Collection&lt;? extends GrantedAuthority&gt; authorities = authentication.getAuthorities();// 遍历用户具备的角色 for (GrantedAuthority authority : authorities) {// 如果当前登录用户的角色和 该路径下的数据库的角色匹配 if (authority.getAuthority().equals(configAttribute.getAttribute())) {// 直接返回 return; } } }// 若路径匹配但是 没有找到相应的角色 抛出异常 throw new AccessDeniedException(\"权限不足，非法请求\"); } /** * 是否支持这种方式 true * @param configAttribute * @return */ @Override public boolean supports(ConfigAttribute configAttribute) { return true; } /** * 是否支持这种方式 true * @param aClass * @return */ @Override public boolean supports(Class&lt;?&gt; aClass) { return true; }} ④security配置1234567891011121314151617181920212223242526272829303132333435363738394041424344@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter { @Autowired private UserService userService; @Autowired private MyFilterInvocation myFilterInvocation; @Autowired private MyAccessDecisionManager myAccessDecisionManager; @Bean BCryptPasswordEncoder bCryptPasswordEncoder() { return new BCryptPasswordEncoder(); } @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.userDetailsService(userService); } @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests()// 定义请求之前的处理器 .withObjectPostProcessor(new ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() { @Override public &lt;O extends FilterSecurityInterceptor&gt; O postProcess(O o) {// 设置自定义拦截请求需要的角色 o.setSecurityMetadataSource(myFilterInvocation);// 设置自定义角色比对管理器 o.setAccessDecisionManager(myAccessDecisionManager); return o; } }) .and() .formLogin() .permitAll() .and() .csrf().disable(); }} 9 、执行流程分析①首先拦截所有请求通过过滤回调配置文件处理(MyFilterInvocation)，获得当前请求的路径（String requestUrl = ((FilterInvocation) o).getRequestUrl();） ②查找所有的请求路径所需的角色信息，遍历该路径信息，如果找到与请求向匹配的路径，则返回该路径所需要的全部角色信息。若没有匹配上，则返回一个标识角色代表没有匹配上（return SecurityConfig.createList(“ROLE_login”)） ③来到角色比对管理器（MyAccessDecisionManager），首先我们可以直接判断用户是否登录，若未登录，直接抛出非法请求异常（throw new AccessDeniedException(“未登录,请求非法”)）。若进入登录状态验证后，遍历返回的该路径下需要的角色信息，若匹配到我们自定义的标识角色，则代表未匹配路径，则直接返回（代表该路径不需要角色，登录即可访问）。否则代表匹配上指定的路径，那么遍历当前用户登录的角色信息，查看数据库路径下的角色信息是否和当前用户登录所有的角色信息匹配，若匹配到，直接返回。遍历完之后，还没有符合的条件，直接抛出异常。","link":"/2020/04/17/springsecurity/Spring-Security%E9%85%8D%E7%BD%AE/"},{"title":"springboot基本配置","text":"一、springboot基本配置1234567#设置端口server.port=8081#设置上下文路径 (即请求包含的前缀)server.servlet.context-path=/lc#配置内嵌的tomcat编码server.tomcat.uri-encoding=UTF-8#还可以配置其他jetty相关的属性 12345678910111213141516171819&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;!--排除内部的tomcat--&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!--排除tomcat服务器后，使用jetty服务器--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 1、关于springboot启动类1234567@SpringBootApplicationpublic class TomcatApplication { public static void main(String[] args) { SpringApplication.run(TomcatApplication.class, args); }} @SpringBootApplication===&gt; 1234567891011@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan( excludeFilters = {@Filter( type = FilterType.CUSTOM, classes = {TypeExcludeFilter.class}), @Filter( type = FilterType.CUSTOM, classes = {AutoConfigurationExcludeFilter.class})}) ①@ComponentScan12@Service,@Repository,@Component,@Controller用来定义一个bean.@ComponentScan注解就是用来自动扫描被这些注解标识的类，最终生成ioc容器里的bean．可以通过设置@ComponentScan(basePackages，includeFilters，excludeFilters)属性来动态确定自动扫描范围，类型以及不扫描的类型． 默认情况下:它扫描所有类型，并且扫描范围是@ComponentScan注解所在配置类包及子包的类 ②@SpringBootConfiguration1这个注解的作用与@Configuration作用相同，都是用来声明当前类是一个配置类．可以通过＠Bean注解生成IOC容器管理的bean. ③@EnableAutoConfiguration12@EnableAutoConfiguration是springboot实现自动化配置的核心注解，通过这个注解把spring应用所需的bean注入容器中．@EnableAutoConfiguration源码通过@Import注入了一个ImportSelector的实现类AutoConfigurationImportSelector,这个ImportSelector最终实现根据我们的配置，动态加载所需的bean. 2、maven中的 parent1234567891011121314 &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.2.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 这里查看源我们可以发现，它自动帮我们定义了一系列的引用的版本号。我们去引用其他依赖时，不需要定义额外的版本号（这里的依赖必须是org.springframework.boot中，否则还是要加版本号） 3、花里胡哨的banner在resources下添加banner.txt http://patorjk.com/software/taag http://www.network-science.de/ascii/ 123456789101112131415161718192021////////////////////////////////////////////////////////////////////// _ooOoo_ //// o8888888o //// 88&quot; . &quot;88 //// (| ^_^ |) //// O\\ = /O //// ____/`---'\\____ //// .' \\\\| |// `. //// / \\\\||| : |||// \\ //// / _||||| -:- |||||- \\ //// | | \\\\\\ - /// | | //// | \\_| ''\\---/'' | | //// \\ .-\\__ `-` ___/-. / //// ___`. .' /--.--\\ `. . ___ //// .&quot;&quot; '&lt; `.___\\_&lt;|&gt;_/___.' &gt;'&quot;&quot;. //// | | : `- \\`.;`\\ _ /`;.`/ - ` : | | //// \\ \\ `-. \\_ __\\ /__ _/ .-` / / //// ========`-.____`-.___\\_____/___.-`____.-'======== //// `=---=' //// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ //// 佛祖保佑 永不宕机 永无BUG // 禁用banner 123456789@SpringBootApplicationpublic class TomcatApplication { public static void main(String[] args) { SpringApplicationBuilder builder = new SpringApplicationBuilder(TomcatApplication.class); SpringApplication build = builder.build(); build.setBannerMode(Banner.Mode.OFF); build.run(args); }} 4、单元测试添加123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;!--只会在测试时使用 不会被打包--&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; test主文件： 12345678@RunWith(SpringRunner.class)//启动类@SpringBootTest(classes = JDBCTemplateApplication.class))public class PropertyApplicationTests { @Test public void contextLoads(){ }} 5、自定义属性配置及加载properties①@PropertySource(“classpath:person.properties”)导入properties文件 ②@ConfigurationProperties(prefix = “person”)定义前缀person ③@Value(“${name:xxx}”)属性上加@value可不用定义该属性的get,set方法，否则要加get,set方法 定义实体对应的properties文件中的属性 定义默认值：xxx 配置实体,定义为组件： 1234567891011121314@Component@PropertySource(\"classpath:person.properties\")@ConfigurationProperties(prefix = \"person\")public class Person { @Value(\"${name:xxx}\") private String name; private Integer age; private String gender; //getter... //setter... //toString...} properties文件==&gt; 123person.name=张三person.age=10person.gender=男 使用==&gt; 注入即用: 12345678910@RunWith(SpringRunner.class)@SpringBootTestpublic class PropertyApplicationTests { @Autowired private Person person; @Test public void contextLoads(){ System.out.println(person); }} 6、yaml/yml配置注意：在yaml中，最好不要写大写的属性名称，大写前面加字母前加 - 后转小写 1、yaml是配置是有序的，properties是无序的 2、自定义的yaml目前暂不支持使用注解的方式注入到springboot项目中 3、注意每个属性的冒号： 后需要加一个空格 注入集合字符串，注入集合对象123456789101112131415161718192021server: port: 8081 servlet: context-path: /lcredis: port: 6379# 注入集合字符串 hosts: - 192.169.22.33 - 192.169.22.34 - 192.169.22.35 - 192.169.22.36 - 192.169.22.37# 注入集合对象 redisList: #一个 -组 代表一个对象 - port: 6379 host: 192.168.22.38 - port: 6379 host: 192.168.22.39 1234567public class Redis { private Integer port; private String host; //getter... //setter... //toString...} 12345678910@Component@ConfigurationProperties(prefix = \"redis\")public class RedisCluster { private Integer port; private List&lt;String&gt; hosts; private List&lt;Redis&gt; redisList; //getter... //setter... //toString...} 7、多环境的yaml/properties配置我们可以定义诸如：application-xxx.yaml application-test.yaml application-dev.yaml application-prod.yaml 多种环境的配置，在application.yaml中激活即可: 1spring.profiles.active=prod 会覆盖application.yaml中本身内容 8、访问static下的所有资源(html)1234567891011121314151617&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;includes&gt; &lt;include&gt;**/**&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 二、springboot整合视图层框架1、整合Freemarker依赖==&gt; 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;&lt;/dependency&gt; 123456789public class User { private String id; private String username; private String password; private String address; //getter //setter //toString} 1234567891011121314151617@Controllerpublic class UserController { @GetMapping(\"/user\") public String user(Model model) { List&lt;User&gt; list = new ArrayList&lt;&gt;(); for (int i = 1; i &lt; 6; i++) { User user=new User(); user.setId(i+\"\"); user.setUsername(\"cl\"+i); user.setPassword(\"123456\"); user.setAddress(\"pengx\"); list.add(user); } model.addAttribute(\"users\", list); return \"user\"; }} 模板引擎==&gt; 注意：此文件的后缀为 .ftlh 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;用户信息&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table border=\"1\" cellspacing=\"0\"&gt; &lt;tr&gt; &lt;td&gt;编号&lt;/td&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;地址&lt;/td&gt; &lt;/tr&gt; &lt;#list users as u&gt; &lt;tr&gt; &lt;td&gt;${u.id}&lt;/td&gt; &lt;td&gt;${u.username}&lt;/td&gt; &lt;td&gt;${u.password}&lt;/td&gt; &lt;td&gt;${u.address}&lt;/td&gt; &lt;/tr&gt; &lt;/#list&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; yaml配置==&gt; 12345678spring: freemarker: #自定义模板文件的加载位置 template-loader-path: classpath:/templates #是否开启缓存 cache: false #上下文类型 content-type: text/html 更多属性的更改参考 FreeMarkerProperties中的默认配置 12345678910public class FreeMarkerProperties extends AbstractTemplateViewResolverProperties { public static final String DEFAULT_TEMPLATE_LOADER_PATH = \"classpath:/templates/\"; public static final String DEFAULT_PREFIX = \"\"; public static final String DEFAULT_SUFFIX = \".ftlh\"; private Map&lt;String, String&gt; settings = new HashMap(); private String[] templateLoaderPath = new String[]{\"classpath:/templates/\"}; private boolean preferFileSystemAccess = true; //..... //.....} 2、整合thymeleaf1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 12345678910111213141516171819@Controllerpublic class UserController { @GetMapping(\"/user\") public String user(Model model) { List&lt;User&gt; list = new ArrayList&lt;&gt;(); for (int i = 1; i &lt; 6; i++) { User user=new User(); user.setId(i+\"\"); user.setUsername(\"cl\"+i); user.setPassword(\"123456\"); user.setAddress(\"pengx\"); list.add(user); } model.addAttribute(\"users\", list); return \"User\"; }} 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;用户信息&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table border=\"1\" cellspacing=\"0\"&gt; &lt;tr&gt; &lt;td&gt;编号&lt;/td&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;地址&lt;/td&gt; &lt;/tr&gt; &lt;tr th:each=\"user :${users}\"&gt; &lt;td th:text=\"${user.id}\"&gt;&lt;/td&gt; &lt;td th:text=\"${user.username}\"&gt;&lt;/td&gt; &lt;td th:text=\"${user.password}\"&gt;&lt;/td&gt; &lt;td th:text=\"${user.address}\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 更多配置请看源码 ThymeleafProperties: 1234567891011121314151617181920public class ThymeleafProperties { private static final Charset DEFAULT_ENCODING; public static final String DEFAULT_PREFIX = \"classpath:/templates/\"; public static final String DEFAULT_SUFFIX = \".html\"; private boolean checkTemplate = true; private boolean checkTemplateLocation = true; private String prefix = \"classpath:/templates/\"; private String suffix = \".html\"; private String mode = \"HTML\"; private Charset encoding; private boolean cache; private Integer templateResolverOrder; private String[] viewNames; private String[] excludedViewNames; private boolean enableSpringElCompiler; private boolean renderHiddenMarkersBeforeCheckboxes; private boolean enabled; private final ThymeleafProperties.Servlet servlet; private final ThymeleafProperties.Reactive reactive;} 3、整合jsp①pom.xml123456789&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt; ②配置视图解析器 WebMvcConfigurer在src/main/webapp/page/...... 增加webapp文件夹，并指定存放jsp的位置 1234567@Configurationpublic class WebMvcConfig implements WebMvcConfigurer { @Override public void configureViewResolvers(ViewResolverRegistry registry) { registry.jsp(\"/page/\", \".jsp\"); }} ③控制器1234567891011121314151617@Controllerpublic class UserController { @GetMapping(\"/user\") public String user(Model model) { List&lt;User&gt; list = new ArrayList&lt;&gt;(); for (int i = 1; i &lt; 6; i++) { User user=new User(); user.setId(i+\"\"); user.setUsername(\"cl\"+i); user.setPassword(\"123456\"); user.setAddress(\"pengx\"); list.add(user); } model.addAttribute(\"users\", list); return \"User\"; }} ④视图12345678910111213141516171819202122232425&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table border=\"1\" cellspacing=\"0\"&gt; &lt;tr&gt; &lt;td&gt;编号&lt;/td&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;地址&lt;/td&gt; &lt;/tr&gt; &lt;c:forEach var=\"user\" items=\"${users}\"&gt; &lt;tr&gt; &lt;td&gt;${user.id}&lt;/td&gt; &lt;td&gt;${user.username}&lt;/td&gt; &lt;td&gt;${user.password}&lt;/td&gt; &lt;td&gt;${user.address}&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 三、springboot整合web开发1、HttpMessageConverter注：以下例子只是实体响应日期类型的格式转换 (1)功能①将服务端返回的对象序列化成JOSN字符串 ②将前端传来的JSON字符串反序列化成java对象 (2)Jackson和Gson自动化配置和手动配置所有的JSON生成都离不开HttpMessageConverter SpringMvc自动配置了Jackson和Gson的HttpMessageConverter, springboot对此做了自动化配置 ①Jacksonspring-boot-starter-web中默认使用的是jsckson 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 方式一：自动配置==&gt; 如果我们没有配置MappingJackson2HttpMessageConverter，则springboot帮我们自动配置 org.springframework.boot.autoconfigure.http.JacksonHttpMessageConvertersConfiguration==&gt; 12345678@Bean @ConditionalOnMissingBean( value = {MappingJackson2HttpMessageConverter.class}, ignoredType = {\"org.springframework.hateoas.server.mvc.TypeConstrainedMappingJackson2HttpMessageConverter\", \"org.springframework.data.rest.webmvc.alps.AlpsJsonHttpMessageConverter\"} ) MappingJackson2HttpMessageConverter mappingJackson2HttpMessageConverter(ObjectMapper objectMapper) { return new MappingJackson2HttpMessageConverter(objectMapper); } 手动配置==&gt; 如果我们配置了MappingJackson2HttpMessageConverter类,则自动配置失效 WebMvcConfig.java: 1234567891011@Configurationpublic class WebMvcConfig { @Bean public MappingJackson2HttpMessageConverter mappingJackson2HttpMessageConverter() { MappingJackson2HttpMessageConverter converter=new MappingJackson2HttpMessageConverter(); ObjectMapper mapper=new ObjectMapper(); mapper.setDateFormat(new SimpleDateFormat(\"yyyy-MM-dd\")); converter.setObjectMapper(mapper); return converter;` }} 方式二：自动配置==&gt; org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration 123456@Bean @Primary @ConditionalOnMissingBean ObjectMapper jacksonObjectMapper(Jackson2ObjectMapperBuilder builder) { return builder.createXmlMapper(false).build(); } 手动配置==&gt; 配置ObjectMapper使其自动配置失效 WebMvcConfig.java: 123456789@Configurationpublic class WebMvcConfig { @Bean public ObjectMapper objectMapper(){ ObjectMapper mapper=new ObjectMapper(); mapper.setDateFormat(new SimpleDateFormat(\"yyyy-MM-dd\")); return mapper; }} ②Gson排除spring-boot-starter-web中原有的jackson。 新增gson依赖 方式一：123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-json&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt;&lt;/dependency&gt; 自动配置：==&gt; 同理，如果我们没有配置HttpMessageConverter，则springboot帮我们自动配置 org.springframework.boot.autoconfigure.http.GsonHttpMessageConvertersConfiguration==&gt; 1234567@Bean @ConditionalOnMissingBean GsonHttpMessageConverter gsonHttpMessageConverter(Gson gson) { GsonHttpMessageConverter converter = new GsonHttpMessageConverter(); converter.setGson(gson); return converter; } 手动配置：==&gt; 123456789@Configurationpublic class WebMvcConfig { @Bean GsonHttpMessageConverter gsonHttpMessageConverter() { GsonHttpMessageConverter converter = new GsonHttpMessageConverter(); converter.setGson(new GsonBuilder().setDateFormat(\"yyyy-MM-dd\").create()); return converter; }} 方式二：自动配置==&gt; org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration==&gt; 12345@Bean @ConditionalOnMissingBean public Gson gson(GsonBuilder gsonBuilder) { return gsonBuilder.create(); } 手动配置==&gt; 1234567@Configurationpublic class WebMvcConfig { @Bean Gson gson() { return new GsonBuilder().setDateFormat(\"yyyy-MM-dd\").create(); }} (3)fastjson手动配置12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-json&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.58&lt;/version&gt; &lt;/dependency&gt; 1234567891011@Configurationpublic class WebMvcConfig { @Bean FastJsonHttpMessageConverter fastJsonHttpMessageConverter() { FastJsonHttpMessageConverter converter=new FastJsonHttpMessageConverter(); FastJsonConfig fastJsonConfig=new FastJsonConfig(); fastJsonConfig.setDateFormat(\"yyyy-MM-dd\"); converter.setFastJsonConfig(fastJsonConfig); return converter; }} 2、springboot静态资源管理(1)默认的自动配置在源码中，我们可以看出，springboot帮我们自动做了一些配置 org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfigurati==&gt; 12345678910111213141516public void addResourceHandlers(ResourceHandlerRegistry registry) { if (!this.resourceProperties.isAddMappings()) { logger.debug(\"Default resource handling disabled\"); } else { Duration cachePeriod = this.resourceProperties.getCache().getPeriod(); CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl(); if (!registry.hasMappingForPattern(\"/webjars/**\")) { this.customizeResourceHandlerRegistration(registry.addResourceHandler(new String[]{\"/webjars/**\"}).addResourceLocations(new String[]{\"classpath:/META-INF/resources/webjars/\"}).setCachePeriod(this.getSeconds(cachePeriod)).setCacheControl(cacheControl)); } String staticPathPattern = this.mvcProperties.getStaticPathPattern(); if (!registry.hasMappingForPattern(staticPathPattern)) { this.customizeResourceHandlerRegistration(registry.addResourceHandler(new String[]{staticPathPattern}).addResourceLocations(WebMvcAutoConfiguration.getResourceLocations(this.resourceProperties.getStaticLocations())).setCachePeriod(this.getSeconds(cachePeriod)).setCacheControl(cacheControl)); } } } org.springframework.boot.autoconfigure.web.ResourceProperties==&gt; 1private static final String[] CLASSPATH_RESOURCE_LOCATIONS = new String[]{\"classpath:/META-INF/resources/\", \"classpath:/resources/\", \"classpath:/static/\", \"classpath:/public/\"}; 我们可以发现，springboot帮我们配置了一些静态资源的处理路径，按照顺序依次在resources文件夹下查找静态资源文件 classpath:/META-INF/resources/“ classpath:/resources/ classpath:/static/ classpath:/public/ 注意：在请求的时候我们就可以省略定义的文件夹名了 (2)自定义访问目录①yaml配置12345678910spring: resources: #静态资源的位置 static-locations: classpath:/lc/ mvc: #静态资源的请求规则 #不配置规则（任意规则）# static-path-pattern: /** #请求静态资源时必须加 /hh/ 前缀再加文件夹或者文件路径 static-path-pattern: /hh/** ②配置文件配置addResourceHandler(&quot;/**&quot;) 静态资源请求规则 addResourceLocations(&quot;classpath:/lc/&quot;) 静态资源位置 1234567@Configurationpublic class WebMvcConfig implements WebMvcConfigurer { @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { registry.addResourceHandler(\"/**\").addResourceLocations(\"classpath:/lc/\"); }} 例如：–resources ​ –lc ​ –java ​ –hello.js 无访问规则：==&gt; 访问路径为 http://localhost:8080/java/hello.js 有访问规则（/hh/**）==&gt; 访问路径为 http://localhost:8080/hh/java/hello.js 3、springBoot实现文件上传（1）form形式在springboot中我们直接使用MultipartFile接口中的org.springframework.web.multipart.support.StandardMultipartHttpServletRequest.StandardMultipartFile实现类 自动配置==&gt; org.springframework.boot.autoconfigure.web.servlet.MultipartProperties==&gt; 12345678910111213141516171819@ConfigurationProperties( prefix = \"spring.servlet.multipart\", ignoreUnknownFields = false)public class MultipartProperties { //是否开启上传 private boolean enabled = true; //临时存储位置 private String location; //上传大小限制 private DataSize maxFileSize = DataSize.ofMegabytes(1L); //上传文件（多个）总大小 private DataSize maxRequestSize = DataSize.ofMegabytes(10L); //文件上传的阈值（上传多少文件时，不能往内存中写，需要转换处理） private DataSize fileSizeThreshold = DataSize.ofBytes(0L); private boolean resolveLazily = false; //...... //......} 12345spring: servlet: multipart:# 定义文件的上传大小限制 这里需要大写KB max-file-size: 1KB ①单文件123456789101112131415161718192021222324252627282930313233@RestControllerpublic class FileUploadController { SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"/yyyy/MM/dd/\"); @PostMapping(\"/upload\") public String hello(MultipartFile file, HttpServletRequest req) { String format = simpleDateFormat.format(new Date());// 自定义：获取上传的文件的真正路径/img/yyyy/MM/dd/ String realPath = req.getServletContext().getRealPath(\"/img\") + format; File folder = new File(realPath);// 若定义的文件夹不存在 if (!folder.exists()) {// 创建该文件夹 folder.mkdirs(); }// 获得上传的文件名称 String oldName = file.getOriginalFilename();// 截图文件的后缀，并加上生成的uuid作为文件名 String newName = UUID.randomUUID().toString() + oldName.substring(oldName.lastIndexOf(\".\")); try {// 文件转换 上传到内存中// 重新定义其文件路径 及 文件名 file.transferTo(new File(folder, newName));// 返回路径：协议://服务器名称:端口/img//yyyy/MM/dd/+新的文件名 String url = req.getScheme() + \"://\" + req.getServerName() + \":\" + req.getServerPort() + \"/img\" + format + newName;// 返回该url return url; } catch (IOException e) { } return \"error\"; }} 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"file\" name=\"file\"/&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; ②多文件注意：这里的files为一个数组，为前端的 的name名称。 若有多个input标签，则只需要在后端请求参数上多加个MultipartFile file1,MultipartFile file2即可 123456789101112131415161718192021222324252627282930 @PostMapping(\"/uploads\") public String uploads(MultipartFile[] files, HttpServletRequest req) { String format = simpleDateFormat.format(new Date());// 自定义：获取上传的文件的真正路径/img/yyyy/MM/dd/ String realPath = req.getServletContext().getRealPath(\"/img\") + format; File folder = new File(realPath);// 若定义的文件夹不存在 if (!folder.exists()) {// 创建该文件夹 folder.mkdirs(); } //循环遍历存储 for (MultipartFile file : files) {// 获得上传的文件名称 String oldName = file.getOriginalFilename();// 截图文件的后缀，并加上生成的uuid作为文件名 String newName = UUID.randomUUID().toString() + oldName.substring(oldName.lastIndexOf(\".\")); try {// 文件转换 上传到内存中 // 重新定义其文件路径 及 文件名 file.transferTo(new File(folder, newName));// 返回路径：协议://服务器名称:端口/img//yyyy/MM/dd/+新的文件名 String url = req.getScheme() + \"://\" + req.getServerName() + \":\" + req.getServerPort() + \"/img\" + format + newName;// 输出该url System.out.println(url); } catch (IOException e) { } } return \"success\"; } 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"/uploads\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"file\" name=\"files\" multiple/&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; （2）ajax形式①单文件后端和form单文件上传一致 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"jquery-3.4.1.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"result\"&gt;&lt;/div&gt; &lt;input type=\"file\" id=\"file\"/&gt; &lt;input type=\"button\" value=\"提交\" onclick=\"upload()\"&gt; &lt;script type=\"text/javascript\"&gt; function upload() { //获取第一个文件 （这是个数组，可以多文件上传） var file = $(\"#file\")[0].files[0]; var formData = new FormData(); formData.append(\"file\", file); $.ajax({ type: \"post\", url: \"/upload\", //使数据不做处理 processData:false, //不要设置Content-Type请求头 contentType:false, data:formData, success:function (msg) { $(\"#result\").text(msg) } }) } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ②多文件后端和form 多文件上传一致 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"jquery-3.4.1.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"result\"&gt;&lt;/div&gt; &lt;input type=\"file\" id=\"file1\"/&gt; &lt;input type=\"file\" id=\"file2\"/&gt; &lt;input type=\"button\" value=\"提交\" onclick=\"upload()\"&gt; &lt;script type=\"text/javascript\"&gt; function upload() { var formData = new FormData(); //获取第一个文件 （这是个数组，可以多文件上传） var file1 = $(\"#file1\")[0].files[0]; var file2 = $(\"#file2\")[0].files[0]; formData.append(\"files\", file1); formData.append(\"files\", file2); $.ajax({ type: \"post\", url: \"/uploads\", //使数据不做处理 processData:false, //不要设置Content-Type请求头 contentType:false, data:formData, success:function (msg) { $(\"#result\").text(msg) } }) } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4、@ControllerAdvice的使用(1)全局异常处理@RestControllerAdvice ==&gt; 12@ControllerAdvice@ResponseBody @ExceptionHandler 指定拦截的异常类型 若有返回值，则直接返回定义的异常bean即可，加上@RestControllerAdvice ①无返回值12345678910111213@ControllerAdvicepublic class CustomExceptionHandler {// @ExceptionHandler拦截指定异常// 这里我们可以返回任意值，或者不返回。 @ExceptionHandler(MaxUploadSizeExceededException.class) public void uploadFileException(MaxUploadSizeExceededException e, HttpServletResponse res) throws IOException { res.setContentType(\"text/html;charset=utf-8\"); PrintWriter printWriter = res.getWriter(); printWriter.write(\"文件大小超出限制！\"); printWriter.flush(); printWriter.close(); }} ②返回视图这里我们用的thymeleaf 1234567891011@ControllerAdvicepublic class CustomExceptionHandler { // 定义返回的视图 @ExceptionHandler(MaxUploadSizeExceededException.class) public ModelAndView uploadFileException(MaxUploadSizeExceededException e){ //新建视图并设定名称 ModelAndView modelAndView =new ModelAndView(\"exception\"); modelAndView.addObject(\"error\", \"文件大小超出限制！\"); return modelAndView; }} ③常用形式 返回自定义bean123456789101112131415@RestControllerAdvicepublic class GlobalExceptionHandler { private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);// 处理SQLException该异常的方法 @ExceptionHandler(SQLException.class) public ResponseBean sqlException(SQLException e){ //判断是否为其类和及其子类 if(e instanceof MySQLIntegrityConstraintViolationException){ return ResponseBean.error(\"该数据有关联的数据，操作失败！\"); } logger.error(e.getMessage()); return ResponseBean.error(\"数据库操作异常，操作失败！\"); }} (2)预设全局数据12345678910@ControllerAdvicepublic class GlobalData { @ModelAttribute(value = \"info\") public Map&lt;String, Object&gt; mydata() { Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"name\", \"louchen\"); map.put(\"address\", \"www.louchen.top\"); return map; }} 1234567891011121314@RestControllerpublic class UserController { @GetMapping(\"/hello\") public String hello(Model model) { //转为map集合 Map&lt;String,Object&gt; map = model.asMap();// 获取所有的key Set&lt;String&gt; keySet = map.keySet(); for (String key : keySet) { System.out.println(\"key:\"+map.get(key)); } return \"success\"; }} 这里的map集合中===&gt; key为 @ModelAttribute(value = “info”)中的value值 value为定义在map中的所有值 1key:{address=www.louchen.top, name=louchen} (3)请求参数预处理当遇到参数需要处理的时候，例如多个对象的重复属性等其他情况 12345678public class Cat { private String id; private String name; private Integer age; //getter //setter //toString} 12345public class Doctor { private String id; private String name; private Integer age;} 12345678910111213141516@ControllerAdvicepublic class InitData { @InitBinder(\"doctor\") public void initDoctor(WebDataBinder binder){ //参数请求的时候的需要加的前缀 binder.setFieldDefaultPrefix(\"doc.\"); } @InitBinder(\"cat\") public void initCat(WebDataBinder binder){ //参数请求的时候的需要加的前缀 binder.setFieldDefaultPrefix(\"cat.\"); }} 123456789@RestControllerpublic class InitDataController { @PostMapping(\"/add\") //这里的@ModelAttribute中为@InitBinder中绑定的值 public void addDocAndCat(@ModelAttribute(\"doctor\")Doctor doctor, @ModelAttribute(\"cat\")Cat cat){ System.out.println(doctor.toString()); System.out.println(cat.toString()); }} 请求参数：post： http://localhost:8080/add doc.id ==&gt; doc.name ==&gt; doc.age ==&gt; cat.id ==&gt; cat.name ==&gt; cat.age ==&gt; 5、自定义错误页面(1)错误页面模板加载顺序在springboot中，程序发生错误的时候会自动寻找自动配置的错误页面 –resources ​ –static ​ –error ===&gt;404.html,4xx.html,500.html,5xx.html ​ –templates ​ –error ===&gt;404.html,4xx.html,500.html,5xx.html 在此目录下: 按照全匹配的优先规则依次从动态页面templates/error下寻找，再从静态页面static/error下寻找 在按照模糊匹配的优先规则依次从动态页面templates/error下寻找，再从静态页面static/error下寻找 (2)自定义异常数据自动配置==&gt; org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration==&gt; 12345678@Bean @ConditionalOnMissingBean( value = {ErrorAttributes.class}, search = SearchStrategy.CURRENT ) public DefaultErrorAttributes errorAttributes() { return new DefaultErrorAttributes(this.serverProperties.getError().isIncludeException()); } 手动配置==&gt; 123456789@Componentpublic class MyErrorAttribute extends DefaultErrorAttributes { @Override public Map&lt;String, Object&gt; getErrorAttributes(WebRequest webRequest, boolean includeStackTrace) { Map&lt;String, Object&gt; errorAttributes = super.getErrorAttributes(webRequest, includeStackTrace); errorAttributes.put(\"myerror\", \"自定义的异常信息\"); return errorAttributes; }} 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table border=\"1\" cellspacing=\"0\"&gt; &lt;tr&gt; &lt;td&gt;path&lt;/td&gt; &lt;td th:text=\"${path}\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;timestamp&lt;/td&gt; &lt;td th:text=\"${timestamp}\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;message&lt;/td&gt; &lt;td th:text=\"${message}\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;error&lt;/td&gt; &lt;td th:text=\"${error}\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;path&lt;/td&gt; &lt;td th:text=\"${path}\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;status&lt;/td&gt; &lt;td th:text=\"${status}\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;myerror&lt;/td&gt; &lt;td th:text=\"${myerror}\"&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; path /111 timestamp Mon Mar 16 21:31:50 GMT+08:00 2020 message No message available error Not Found path /111 status 404 myerror 自定义的异常信息 (3)自定义异常视图自动配置==&gt; org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration==&gt; 123456@Bean @ConditionalOnBean({DispatcherServlet.class}) @ConditionalOnMissingBean({ErrorViewResolver.class}) DefaultErrorViewResolver conventionErrorViewResolver() { return new DefaultErrorViewResolver(this.applicationContext, this.resourceProperties); } 手动配置==&gt; 注意：这里的视图名称在templates文件夹下的任意目录即可 1234567891011121314151617@Componentpublic class MyErrorViewResolver extends DefaultErrorViewResolver { public MyErrorViewResolver(ApplicationContext applicationContext, ResourceProperties resourceProperties) { super(applicationContext, resourceProperties); } @Override public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model) { ModelAndView modelAndView = super.resolveErrorView(request, status, model); //视图的名称 modelAndView.setViewName(\"lc.html\"); modelAndView.addObject(model);// 该Map&lt;String, Object&gt; model不可修改。// 如果我们新增其他的属性 我们可以遍历此map数据取出，然后定义新的map放进ModelAndView中 return modelAndView; }} 视图模板内容和上面的一致 6、springboot跨域问题https://segmentfault.com/a/1190000019550329?utm_source=tag-newest (1)背景​ Same Origin Policy，译为“同源策略”。它是对于客户端脚本（尤其是JavaScript）的重要安全度量标准，其目的在于防止某个文档或者脚本从多个不同“origin”（源）装载。它认为自任何站点装载的信赖内容是不安全的。当被浏览器半信半疑的脚本运行在沙箱时，它们应该只被允许访问来自同一站点的资源，而不是那些来自其它站点可能怀有恶意的资源。​ 注：具有相同的Origin，也即是拥有相同的协议、主机地址以及端口。一旦这三项数据中有一项不同，那么该资源就将被认为是从不同的Origin得来的，进而不被允许访问。 (2)CORS简介​ CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨源(协议 + 域名 + 端口)服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。CORS需要浏览器和服务器同时支持。它的通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX/Fetch通信没有差别，代码完全一样。浏览器一旦发现请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。​ 因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。 浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。 简答请求（HEAD、GET、POST）：不需要试探请求 非简单请求（DELETE,PUT）：Request Method: OPTIONS 需要进行一次试探请求。在正式通信之前，增加一次OPTIONS查询请求，称为”预检”请求（preflight）。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。 详解响应头： Access-Control-Allow-Origin 该字段必填。它的值要么是请求时Origin字段的具体值，要么是一个*，表示接受任意域名的请求。 Access-Control-Allow-Methods该字段必填。它的值是逗号分隔的一个具体的字符串或者*，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。 Access-Control-Expose-Headers该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。 Access-Control-Allow-Credentials该字段可选。它的值是一个布尔值，表示是否允许发送Cookie.默认情况下，不发生Cookie，即：false。对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json，这个值只能设为true。如果服务器不要浏览器发送Cookie，删除该字段即可。 Access-Control-Max-Age该字段可选，用来指定本次预检请求的有效期，单位为秒。在有效期间，不用发出另一条预检请求。 顺便提一下，如果在开发中，发现每次发起请求都是两条，一次OPTIONS，一次正常请求，注意是每次，那么就需要配置Access-Control-Max-Age，避免每次都发出预检请求。 (3)实现跨域的方法①最小粒度的cors控制，精确到单个请求级别。@CrossOrigin(&quot;*&quot;) 允许所有请求 @CrossOrigin(&quot;http:localhost:8080&quot;) 只允许http:localhost:8080 123456789@RestControllerpublic class CORSController { @CrossOrigin(\"*\") @GetMapping(\"/doget\") public String doGet(){ return \"doGet\"; }} 从@CrossOrigin注解中==&gt; 该注解可以用于方法上和类上，用于类上，所有该类下的请求都支持该跨域请求。用于方法上，只有该请求支持跨域 123456@Target({ElementType.TYPE, ElementType.METHOD})@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface CrossOrigin { //....} ②全局配置1234567891011121314151617@Configurationpublic class WebMvcConfig implements WebMvcConfigurer { @Override public void addCorsMappings(CorsRegistry registry) {// 哪些请求能够跨域(所有) registry.addMapping(\"/**\")// 哪些域能够访问(所有) .allowedOrigins(\"*\")// 哪些请求头(所有) .allowedHeaders(\"*\")// 允许的请求方法类型(所有) .allowedMethods(\"*\")// 会首先发送一个探测请求(若探测许可,即发送真正的请求，否则返回请求失败)// 设定发送探测请求的时间间隔(30s，单位秒) .maxAge(30); }} 1234567891011@RestControllerpublic class CORSController { @GetMapping(\"/doget\") public String doGet(){ return \"doGet\"; } @PutMapping(\"/dopost\") public String doPut(){ return \"doPut\"; }} 另一个域的请求视图==&gt; 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;CORS&lt;/title&gt; &lt;script src=\"jquery-3.4.1.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"result\"&gt;&lt;/div&gt; &lt;input type=\"button\" value=\"GET\" onclick=\"getData()\"&gt; &lt;input type=\"button\" value=\"PUT\" onclick=\"putData()\"&gt; &lt;script&gt; function getData() { $.get('http://localhost:8081/doget',function (msg) { $(\"#result\").text(msg); }) } function putData() { $.ajax({ type:'PUT', url:'http://localhost:8081/dopost', success:function (msg) { $(\"#result\").text(msg); } }) } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;d ③过滤器形式配置1234567891011121314@WebFilter(filterName = \"CorsFilter \")@Configurationpublic class CorsFilter implements Filter { @Override public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException { HttpServletResponse response = (HttpServletResponse) res; response.setHeader(\"Access-Control-Allow-Origin\",\"*\"); response.setHeader(\"Access-Control-Allow-Credentials\", \"true\"); response.setHeader(\"Access-Control-Allow-Methods\", \"POST, GET, PATCH, DELETE, PUT\"); response.setHeader(\"Access-Control-Max-Age\", \"3600\"); response.setHeader(\"Access-Control-Allow-Headers\", \"Origin, X-Requested-With, Content-Type, Accept\"); chain.doFilter(req, res); }} 7、springboot加载xml配置文件resources==&gt; 12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean class=\"org.lc.xml.controller.HelloController\" id=\"sayHello\"&gt;&lt;/bean&gt;&lt;/beans&gt; 12345@Configuration//加载bean.xml配置文件，注入到spring容器中@ImportResource(locations = \"classpath:beans.xml\")public class WebMvcConfig {} 12345public class HelloController { public String sayHello() { return \"say hello\"; }} Test==&gt; 1234567891011@RunWith(SpringRunner.class)@SpringBootTestpublic class XmlTest { @Autowired private HelloController helloController; @Test public void Test1() { String s = helloController.sayHello(); System.out.println(s); }} 9、springboot中使用拦截器定义拦截执行的方法（内容）==&gt; 1234567891011121314151617public class MyInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\"执行之前\"); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\"执行中\"); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(\"执行后\"); }} 注入容器中，并添加新的拦截器==&gt; 12345678910111213@Configurationpublic class WebMvcConfig implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { //添加拦截器，拦截所有请求 registry.addInterceptor(myInterceptor()).addPathPatterns(\"/**\"); } @Bean MyInterceptor myInterceptor(){ return new MyInterceptor(); }} 使用更多配置==&gt; org.springframework.web.servlet.config.annotation.InterceptorRegistration==&gt; 12345678910public class InterceptorRegistration { private final HandlerInterceptor interceptor; private final List&lt;String&gt; includePatterns = new ArrayList(); private final List&lt;String&gt; excludePatterns = new ArrayList(); @Nullable private PathMatcher pathMatcher; private int order = 0; //...... //......} 10、springboot实现系统启动任务注意：两种接口可混用，不冲突 (1)实现CommandLineRunner接口@order(100) 的使用： 默认为最大值2^31-1，即int的范围。 默认最大值表示优先级最低，即执行的顺序 值越大优先级越低，反之值越小优先级越高 1234567891011121314@Component@Order(100)public class MyCommondLineRunnerOne implements CommandLineRunner { /** * 获得启动程序的初始参数 * @param args * @throws Exception */ @Override public void run(String... args) throws Exception { System.out.println(\"MyCommondLineRunnerOne==&gt;&gt;\"+Arrays.toString(args)); }} 1234567891011121314@Component@Order(99)public class MyCommondLineRunnerTwo implements CommandLineRunner { /** * 获得启动程序的初始参数 * @param args * @throws Exception */ @Override public void run(String... args) throws Exception { System.out.println(\"MyCommondLineRunnerTwo==&gt;&gt;\"+Arrays.toString(args)); }} 添加启动参数：①在主程序中,写死即可 123456789@SpringBootApplicationpublic class XmlApplication { public static void main(String[] args) { args=new String[]{ \"org.lc\",\"louchen\" }; SpringApplication.run(XmlApplication.class,args); }} ==&gt; 12MyCommondLineRunnerTwo==&gt;&gt;[org.lc, louchen]MyCommondLineRunnerOne==&gt;&gt;[org.lc, louchen] ②在idea启动的时候配置参数 Edit Configurations =&gt;Environment=&gt;Program agruments 添加参数即可： aaa bbb ==&gt; 12MyCommondLineRunnerTwo==&gt;&gt;[aaa, bbb]MyCommondLineRunnerOne==&gt;&gt;[aaa, bbb] ③以jar包的方式加入启动参数 注意参数之间的空格 java -jar xml-1.0-SNAPSHOT.jar ccc ddd ==&gt; 12MyCommondLineRunnerTwo==&gt;&gt;[ccc, ddd]MyCommondLineRunnerOne==&gt;&gt;[ccc, ddd] (2)实现ApplicationRunner接口123456789101112131415161718192021@Component@Order(102)public class MyApplicationRunnerOne implements ApplicationRunner { @Override public void run(ApplicationArguments args) throws Exception { //获取所有的值 String[] sourceArgs = args.getSourceArgs(); System.out.println(Arrays.toString(sourceArgs)); //获取所有没有键的数据 List&lt;String&gt; nonOptionArgs = args.getNonOptionArgs(); System.out.println(nonOptionArgs); //获取所有的键值对 Set&lt;String&gt; optionNames = args.getOptionNames(); //通过键获取值 //args.getOptionValues(optionName) for (String optionName : optionNames) { System.out.println(optionName+\":\"+args.getOptionValues(optionName)); } System.out.println(\"-------------------MyApplicationRunnerOne------------------------------\"); }} 123456789101112131415161718192021@Component@Order(101)public class MyApplicationRunnerTwo implements ApplicationRunner { @Override public void run(ApplicationArguments args) throws Exception { //获取所有的值 String[] sourceArgs = args.getSourceArgs(); System.out.println(Arrays.toString(sourceArgs)); //获取所有没有键的数据 List&lt;String&gt; nonOptionArgs = args.getNonOptionArgs(); System.out.println(nonOptionArgs); //获取所有的键值对 Set&lt;String&gt; optionNames = args.getOptionNames(); //通过键获取值 //args.getOptionValues(optionName) for (String optionName : optionNames) { System.out.println(optionName+\":\"+args.getOptionValues(optionName)); } System.out.println(\"-------------------MyApplicationRunnerTwo------------------------------\"); }} 添加启动参数：这里我们只采用jar的形式添加参数，其他的方式和上面类似 注意：键值对的参数要 在前面加两个 - java -jar xml-1.0-SNAPSHOT.jar --name=louchen --address=hubei 张三 李四 ==&gt; 12345678910[--name=louchen, --address=hubei, 张三, 李四][张三, 李四]address:[hubei]name:[louchen]-------------------MyApplicationRunnerTwo------------------------------[--name=louchen, --address=hubei, 张三, 李四][张三, 李四]address:[hubei]name:[louchen]-------------------MyApplicationRunnerOne------------------------------ 11、springboot中的restful请求类型https://www.jianshu.com/p/4981911d5e15 @RequestBody与@RequestParam作用与GET,POST,DELETE,PUT请求上不同 加上@RequestBody的参数注解必须以application/json形式传输参数 一个请求体中的所以数据只在被@RequestBody标记中的有效 加上@RequestParam的参数注解必须以url的形式传输参数 (1)GET请求（默认url传参）①无@RequestBody因为GET请求无请求体，所有传输的参数必须以url形式传输参数 请求形式：localhost:8080/hello/?id=1&amp;name=张三&amp;uid=1001 123456789@RestControllerpublic class UserController { @GetMapping(\"/hello\") public User sayGet(User user,String uid) { System.out.println(user); System.out.println(\"uid:\"+uid); return user; }} ②有@RequestBody没有声明在@RequestBody中的参数必须以url形式传参 声明在@RequestBody中的参数必须以请求体的形式传输 请求形式：content-type:application/json localhost:8080/hello/?uid=1001 1234{ \"id\":2, \"name\":\"李四\"} 1234567@GetMapping(\"/hello\") public User sayGet(@RequestBody User user,@RequestParam(\"uid\") String uid) { System.out.println(user); System.out.println(\"uid:\"+uid); return user; }} (2)POST请求(默认x-www-form-urlencoded)①有@RequestBody被@RequestBody标记必须以json的形式传参 没有被@RequestBody标记必须以url的形式传参 请求形式：content-type:application/json localhost:8080/hello/?uid=222 12345{ \"id\":2, \"name\":\"李四\" } 1234567 @PostMapping(\"/hello\") public User sayPost(@RequestBody User user,@RequestParam(\"uid\") String uid){ System.out.println(user); System.out.println(\"uid:\"+uid); return user; }} ②无@RequestBody默认类型content-type:x-www-form-urlencoded 这种类型只是将参数编码放在url地址栏中 所以请求参数放在url中也可以，当是编码content-type:x-www-form-urlencoded过后再放更合理 key value id 3 name 王五 uid 1000 请求参数：:localhost:8080/hello 1234567@PostMapping(\"/hello\") public User sayPost(User user, @RequestParam(\"uid\")String uid){ System.out.println(user); System.out.println(\"uid:\"+uid); return user; }} (3)PUT请求(默认x-www-form-urlencoded)①有@RequestBody请求类型：content-type:application/json 和POST请求方式一致，被标记的参数只能以application/json参数传递，非标记的以url形式传输参数 ②无@RequestBody请求类型：content-type:x-www-form-urlencoded 与POST请求方式一致，只能以x-www-form-urlencoded形式传参。 所以参数编码后放入url地址栏中。 (4)DELETE请求(默认x-www-form-urlencoded)①有@RequestBody请求类型content-type:application/json 和POST请求方式一致，被标记的参数只能以application/json参数传递，非标记的以url形式传输参数 ②无@RequestBody请求类型content-type:x-www-form-urlencoded 与POST请求方式一致，只能以x-www-form-urlencoded形式传参。 所以参数编码后放入url地址栏中。 (5)总结①从content-type方面：form-data、x-www-form-urlencoded：不可以用@RequestBody。可以用@RequestParam。这种请求类型只是将参数编码放入url地址栏中 application/json：json字符串部分可以用@RequestBody；url中的?后面参数可以用@RequestParam。 ②从注解方面@RequestBody 1234(@RequestBody Map map)(@RequestBody Object object)application/json时候可用form-data、x-www-form-urlencoded时候不可用 @RequestParam 12(@RequestParam Map map)application/json时候，json字符串部分不可用，url中的?后面添加参数即可用 12(@RequestParam Object object)不管application/json、form-data、x-www-form-urlencoded都不可用 12、springboot整合servlet,filter,lister(web基础组件)定义servlet==&gt; 12345678910111213// 映射/myservlet请求@WebServlet(urlPatterns = \"/myservlet\")public class MyServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"myServlet\"); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { super.doPost(req, resp); }} 定义过滤器==&gt; 123456789//过滤拦截所有请求@WebFilter(urlPatterns = \"/*\")public class MyFilter implements Filter { @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(\"myFilter\"); filterChain.doFilter(servletRequest, servletResponse); }} 定义监听器==&gt; 123456789101112131415//标记此类为监听器//根据监听器的不同类型实现不同的监听器的接口//实现请求的监听器@WebListenerpublic class MyRequestListener implements ServletRequestListener { @Override public void requestDestroyed(ServletRequestEvent sre) { System.out.println(\"requestListenerDestroyed\"); } @Override public void requestInitialized(ServletRequestEvent sre) { System.out.println(\"requestListenerInitialized\"); }} 扫描servlet,listener,filter @ServletComponentScan(basePackages = &quot;org.lc.xml.servlet&quot;) 扫描指定包下servlet组件 12345678@SpringBootApplication//扫描所有的servlet,filter,listener@ServletComponentScan(basePackages = \"org.lc.xml.servlet\")public class XmlApplication { public static void main(String[] args) { SpringApplication.run(XmlApplication.class,args); }} 请求路径：http://localhost:8080/myservlet 输出顺序: ServletRequestListener监听器请求初始化=&gt; 过滤器执行==&gt; Servlet执行=&gt; ServletRequestListener监听器请求销毁 1234requestListenerInitializedmyFiltermyServletrequestListenerDestroyed 当有springboot中的拦截器时： 注意:这里的拦截器只对controller中的请求有效，对servlet中定义的请求无效 1234567891011121314151617public class MyInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\"执行之前\"); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\"执行中\"); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(\"执行后\"); }} 123456789101112@Configurationpublic class WebMvcConfig implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(myInterceptor()).addPathPatterns(\"/**\"); } @Bean MyInterceptor myInterceptor(){ return new MyInterceptor(); }} srtvlet请求:http://localhost:8080/myservlet 1234requestListenerInitializedmyFiltermyServletrequestListenerDestroyed controller请求：http://localhost:8080/say 请求结果==&gt; 123456requestListenerInitializedmyFilter执行之前执行中执行后requestListenerDestroyed 12345678@RestControllerpublic class UserController { @GetMapping(\"/say\") public String sayHello(){ return \"say hello\"; }} 13、springboot中的路径映射当我们只需要返回一个页面时，通常做法,使用控制器返回一个页面（这里使用thmeleaf模板引擎） 1234567@Controllerpublic class LoginController { @GetMapping(\"/login\") public String loginView() { return \"login\"; }} 这里我们摒弃上面的这个做法： 只需要实现WebMvcConfigurer接口即可 123456789@Configurationpublic class WebMvcConfig implements WebMvcConfigurer { @Override public void addViewControllers(ViewControllerRegistry registry) { //添加请求的路径 响应的视图名称 registry.addViewController(\"/login\").setViewName(\"login\"); registry.addViewController(\"/register\").setViewName(\"register\"); }} 14、springboot中使用类型转换器其中S代表需要转换的参数类型 T代表要转成的目标参数类型 12345@FunctionalInterfacepublic interface Converter&lt;S, T&gt; { @Nullable T convert(S var1);} 实现转换器接口==&gt; 1234567891011121314151617@Componentpublic class DateConventer implements Converter&lt;String, Date&gt; { private SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd\"); @Override public Date convert(String s) { if (s != null &amp;&amp; !s.equals(\"\")) { try { return simpleDateFormat.parse(s); } catch (ParseException e) { e.printStackTrace(); } } return null; }} 1234567@RestControllerpublic class LoginController { @GetMapping(\"/birthday\") public void sayHello(Date date) { System.out.println(date); }} 请求：http://localhost:8080/birthday/?date=2019-01-01 15、springboot使用AOP1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt; 1234567891011@Servicepublic class EmpService { public String getAllEmp(){ System.out.println(\"getAllEmp--service\"); return \"查询所有成功\"; } public String deleteEmpById(Integer id){ System.out.println(\"deleteEmpById--service\"); return \"修改成功\"; }} 1234567891011121314151617@RestControllerpublic class EmpController { @Autowired private EmpService empService; @GetMapping(\"/allEmp\") public String getAllEmp(){ String allEmp = empService.getAllEmp(); System.out.println(allEmp); return \"getAllEmp--controller\"; } @DeleteMapping(\"/delEmp\") public String deleteEmp(){ String s = empService.deleteEmpById(12); System.out.println(s); return \"deleteEmp--controller\"; }} 定义切面文件==&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495@Component//定义类为切面(切点和通知的结合)@Aspectpublic class AopLogger { /** * 定义切点表达式 用来确定哪些类需要代理 * 切点表达式定义：==&gt; * ①方法的可见性 如public，protected；（可省略） （不可用*表示，但是可省略） * ②方法的返回类型 如int，void等；（*代表任意类型） * ③方法所在类的全包名，如com.spring.Aspect； * ④所在类的全名；（*代表该包下的所有类） * ⑤所在类的方法全名 （*代表该类下的所有方法） * ⑥方法的个数 （..代表0个或多个） */ @Pointcut(\"execution(public * org.lc.xml.service.*.*(..))\") public void pc1(){ }// 定义通知// 即对拦截的方法的处理方式（时机） /** * 定义前置通知（代理的方法执行之前的通知） * @param joinPoint JoinPoint对象封装了SpringAop中切面方法的信息, * 在切面方法中添加JoinPoint参数,就可以获取到封装了该方法信息的JoinPoint对象. */ @Before(\"pc1()\") public void before(JoinPoint joinPoint) { String name = joinPoint.getSignature().getName(); System.out.println(\"前置通知执行的方法:\"+name); } /** * 定义后置通知（代理方法执行之后执行的通知） * @param joinPoint */ @After(\"pc1()\") public void after(JoinPoint joinPoint) { String name = joinPoint.getSignature().getName(); System.out.println(\"后置通知执行的方法:\"+name); } /** * 定义返回通知（方法执行完毕执行的通知） * @param joinPoint * @param result 该代理的方法的返回值 * 在注解上的returning = \"result\"则只会匹配只有返回值的方法 */ @AfterReturning(value = \"pc1()\", returning = \"result\") public void afterReturning(JoinPoint joinPoint, Object result) { String name = joinPoint.getSignature().getName(); System.out.println(\"返回通知执行的方法:\"+name+\",该代理方法的返回值为:\"+result); } /** * 定义异常通知（方法执行异常之后的通知） * @param joinPoint * @param e */ @AfterThrowing(value = \"pc1()\",throwing = \"e\") public void afterThrowing(JoinPoint joinPoint,Exception e) { String name = joinPoint.getSignature().getName(); System.out.println(\"异常通知执行的方法:\"+name+\",该方法的异常为:\"+e.getMessage()); } /** * 定义环绕通知 (可同时使用上面的四种通知) * proceedingJoinPoint.proceed();代表执行代理的该方法 */ @Around(value = \"pc1()\") public Object around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable { //调用该方法之前的处理的代码（相当于前置通知） System.out.println(\"------前置通知-around\"); Object proceed = null; try { proceed = proceedingJoinPoint.proceed(); //注意这里的后置通知只是在环绕通知中代理方法的返回之前提前处理了 // 实际在@After是在@AfterReturning之前执行的 //使用该proceed变量，对其进行处理的代码。（相当于返回通知） System.out.println(\"-------返回通知-around\"); } catch (Throwable throwable) { //对异常处理的代码（相当于异常通知） System.out.println(\"------异常通知-around\"); throwable.printStackTrace(); }// 注意：这里的后置通知只是在环绕通知中代理方法的返回之前提前处理了// 实际在@After是在@AfterReturning之前执行的 //调用该方法之后之后处理的代码（相当于后置通知） System.out.println(\"-------后置通知---around\"); //该返回语句执新之前的所有代码 都是未正真正执行的。 return proceed; }} 执行的结果为==&gt; 12345678------前置通知-around前置通知执行的方法:getAllEmpgetAllEmp--service-------返回通知-around-------后置通知---around后置通知执行的方法:getAllEmp返回通知执行的方法:getAllEmp,该代理方法的返回值为:查询所有成功查询所有成功 总结执行的顺序==&gt; 123456789101112@Around先进入环绕通知==&gt;处理环绕通知proceed = proceedingJoinPoint.proceed()方法之前的代码（相当于前置通知）@After进入前置通知@Around处进入环绕通知proceed = proceedingJoinPoint.proceed()方法之后的代码（相当于后置通知和返回通知）若出现异常则直接执行@Around中catch的代码（相当于异常通知）@After进入后置通知@AfterReturning进入返回通知 16、springboot自定义欢迎页这里我们使用thmeleaf 1234567@Controllerpublic class IndexController { @GetMapping(\"/index\") public String index() { return \"index\"; }} 默认启动服务器：localhost:8080 首先访问static中的index.html页面 再访问templates中的index.html页面 17、springboot自定义favicon.icohttps://tool.lu/favicon/ 将favicon.ico放在resources下或static下即可 static下的优先级高于resources 当出现无法访问图标的时候： 12345678910@Configurationpublic class WebMvcConfig implements WebMvcConfigurer { @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { //放在resources下 registry.addResourceHandler(\"/favicon.ico\").addResourceLocations(\"classpath:/\"); //放在static下 //registry.addResourceHandler(\"/favicon.ico\").addResourceLocations(\"classpath:/static/\"); }} 18、springboot排除自动配置排除不需要的自动配置(所有自动配置全部失效) 123456@SpringBootApplication(exclude = WebMvcAutoConfiguration.class)public class XmlApplication { public static void main(String[] args) { SpringApplication.run(XmlApplication.class,args); }} 或者==&gt; 123spring: autoconfigure: exclude: org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration 注解①@ResponseBody响应json数据 ②@RestController@Controller@ResponseBody ③@JsonFormat(pattern = “yyyy-MM-dd”,timezone = “GMT+8”)④@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)注解@JsonFormat主要是后台到前台的时间格式的转换 注解@DataFormAT主要是前后到后台的时间格式的转换 123@DateTimeFormat(pattern = \"yyyy-MM-dd\") @JsonFormat(pattern = \"yyyy-MM-dd\",timezone = \"GMT+8\") private Date birthday; ⑤@configuration和@component的区别总结：@configuration+@Bean（注入的单例） @component+@Bean（注入的多例） https://blog.csdn.net/long476964/article/details/80626930 @Configuration是随容器启动开始加载的,始终存在的单例模式。 @Component中的bean使用一次即实例化一次 @configuration使用cglid动态代理==&gt; 12345678910111213@Configurationpublic class MyBeanConfig { @Bean public Country country(){ return new Country(); } @Bean public UserInfo userInfo(){ return new UserInfo(country()); }} 直接调用 country() 方法返回的是同一个实例 @Component 注解并没有通过 cglib 来代理@Bean 方法的调用==&gt; 12345678910111213@Componentpublic class MyBeanConfig { @Bean public Country country(){ return new Country(); } @Bean public UserInfo userInfo(){ return new UserInfo(country()); }} 每次调用country(),每次都会创建一个实例 ⑥@PropertySource(“classpath:person.properties”)导入properties文件 ⑦@ImportResource(locations = “classpath:beans.xml”)导入配置的xml文件 ⑧@Bean @scope(“singleton”)在Spring中，bean可以被定义为两种模式：prototype（多例）和singleton（单例） singleton（单例）：只有一个共享的实例存在，所有对这个bean的请求都会返回这个唯一的实例。 prototype（多例）：对这个bean的每次请求都会创建一个新的bean实例，类似于new。 Spring bean 默认是单例模式。 123456789101112131415161718191.singleton单例模式, 全局有且仅有一个实例2.prototype原型模式， 每次获取Bean的时候会有一个新的实例3.request request表示该针对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP request内有效，4.session session作用域表示该针对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP session内有效5.global sessionglobal session作用域类似于标准的HTTP Session作用域，不过它仅仅在基于portlet的web应用中才有意义。Portlet规范定义了全局Session的概念，它被所有构成某个 portlet web应用的各种不同的portlet所共享。在global session作用域中定义的bean被限定于全局portlet Session的生命周期范围内。如果你在web中使用global session作用域来标识bean，那么web会自动当成session类型来使用。 ⑨容器的单例和多例@Component注解默认实例化的对象是单例，如果想声明成多例对象可以使用@Scope(“prototype”) @Repository默认单例 @Service默认单例 @Controller默认多例 ⑩@order(100)默认为最大值2^31-1，即int的范围。 默认最大值表示优先级最低，即执行的顺序 值越大优先级越低，反之值越小优先级越高 ⑪@RequestBody @RequestParam@RequestBody==&gt; 顾明思意，请求必须是以请求体的形式接受参数 @RequestParam==&gt; 以url传参 ⑫import(configuration.class)导入java的配置文件 被@Configuration标记的文件 ⑬@ConfigurationProperties(prefix = “person”)yaml,properties文件属性配置注入 ⑭@Configuration详解https://www.cnblogs.com/duanxz/p/7493276.html 从Spring3.0，@Configuration用于定义配置类，可替换xml配置文件，被注解的类内部包含有一个或多个被@Bean注解的方法，这些方法将会被AnnotationConfigApplicationContext或AnnotationConfigWebApplicationContext类进行扫描，并用于构建bean定义，初始化Spring容器。 注意：@Configuration注解的配置类有如下要求： @Configuration不可以是final类型； @Configuration不可以是匿名类； 嵌套的configuration必须是静态类。 一、用@Configuration加载spring1.1、@Configuration配置spring并启动spring容器1.2、@Configuration启动容器+@Bean注册Bean1.3、@Configuration启动容器+@Component注册Bean1.4、使用 AnnotationConfigApplicationContext 注册 AppContext 类的两种方法**1.5、配置Web应用程序(web.xml中配置AnnotationConfigApplicationContext)** 二、组合多个配置类2.1、在@configuration中引入spring的xml配置文件2.2、在@configuration中引入其它注解配置2.3、@configuration嵌套（嵌套的Configuration必须是静态类）三、@EnableXXX注解四、@Profile逻辑组配置五、使用外部变量 @ConditionalOnProperty(name = “swagger.enable”, havingValue = “true”)@ConditionalOnProperty来控制Configuration是否生效 通过其两个属性name以及havingValue来实现的，其中name用来从application.properties中读取某个属性值。如果该值为空，则返回false;如果值不为空，则将该值与havingValue指定的值进行比较，如果一样则返回true;否则返回false。如果返回值为false，则该configuration不生效；为true则生效。 1swagger.enable=true","link":"/2020/04/17/springboot/springboot%E5%9F%BA%E7%A1%80%E6%95%B4%E5%90%88%E9%85%8D%E7%BD%AE/"},{"title":"Redis的Scan命令","text":"Redis的ScanRedis中有一个经典的问题，在巨大的数据量的情况下，做类似于查找符合某种规则的Key的信息，这里就有两种方式，一是keys命令，简单粗暴，由于Redis单线程这一特性，keys命令是以阻塞的方式执行的，keys是以遍历的方式实现的复杂度是 O(n），Redis库中的key越多，查找实现代价越大，产生的阻塞时间越长。二是scan命令，以非阻塞的方式实现key值的查找，绝大多数情况下是可以替代keys命令的，可选性更强 keys的缺点： 1、没有limit，我们只能一次性获取所有符合条件的key，如果结果有上百万条，那么等待你的就是“无穷无尽”的字符串输出。 2、keys命令是遍历算法，时间复杂度是O(N)。如我们刚才所说，这个命令非常容易导致Redis服务卡顿。因此，我们要尽量避免在生产环境使用该命令。 scan的优点： scan命令的时间复杂度虽然也是O(N)，但它是分次进行的，不会阻塞线程。 scan命令提供了limit参数，可以控制每次返回结果的最大条数。 一、Scan的简单介绍scan 实际上是 keys 的一个升级版。可以用 keys 来查询 key，在查询的过程中，可以使用通配符。keys 虽然用着还算方便，但是没有分页 功能。同时因为 Redis 是单线程，所以 key 的执行会比较消耗时间，特别是当数据量大的时候，影响整 个程序的运行。为了解决 keys 存在的问题，从 Redis2.8 中开始，引入了 scan。scan 具备 keys 的功能，但是不会阻塞线程，而且可以控制每次返回的结果数。 二、基本用法1、数据准备先准备一千条测试数据 jedis测试工具： pom.xml 1234567&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; CallWithJedis 123public interface CallWithJedis { void call(Jedis jedis);} Redis 1234567891011121314151617181920212223242526272829303132public class Redis { private JedisPool jedisPool; public Redis() {// 连接池配置对象 GenericObjectPoolConfig config=new GenericObjectPoolConfig();// 连接池最大空闲数 config.setMaxIdle(300);// 最大连接数 config.setMaxTotal(1000);// 连接最大等待时间（毫秒）。-1表示无限制 config.setMaxWaitMillis(30000);// 在空闲时检查有效性 config.setTestOnBorrow(true); /** * 1、连接池配置 * 2、redis地址 * 3、端口 * 4、超时时间 * 5、密码 */ jedisPool = new JedisPool(config, \"主机\",6379,30000,\"密码\"); } public void execute(CallWithJedis callWithJedis) { try (Jedis jedis=jedisPool.getResource()) { callWithJedis.call (jedis); } }} 12345678910public class ScanTest { public static void main(String[] args) { Redis redis=new Redis(); redis.execute(jedis -&gt; { for (int i = 0; i &lt; 1000; i++) { jedis.set(\"k\" + i, \"v\" + i); } }); }} scan 命令一共提供了三个参数，第一个 cursor，第二个参数是 key，第三个参数是 limit。 cursor 实际上是指一维数组的位置索引，limit 则是遍历的一维数组个数（所以每次返回的数据大小可 能不确定）。 2、scan命令使用SCAN命令是一个基于游标的迭代器。这意味着命令每次被调用都需要使用上一次这个调用返回的游标作为该次调用的游标参数，以此来延续之前的迭代过程。 https://www.cnblogs.com/wy123/p/10955153.html cursor ：游标，遍历的起始位置，一般从0开始 MATCH ：模糊匹配的键 COUNT : COUNT是指本次遍历时, 要遍历多少个元素（不指定count,默认只遍历10个） SCAN cursor [MATCH pattern] [COUNT count] 123456789101112scan 0 match k8* count 100 1) \"360\"2) 1) \"k832\" 2) \"k806\" 3) \"k89\" 4) \"k80\" 5) \"k856\" 6) \"k870\" 7) \"k805\" 8) \"k809\" 9) \"k858\" 注意：上面返回的1)中的360表示下次游标遍历的起始位置 当游标输出为0时，即遍历完毕，回到起始位置 三、基本原理https://www.jianshu.com/p/be15dc89a3e8 1、Redis的结构Redis使用了Hash表作为底层实现，原因不外乎高效且实现简单。说到Hash表，很多Java程序员第一反应就是HashMap。没错，Redis底层key的存储结构就是类似于HashMap那样数组+链表的结构。其中第一维的数组大小为2n(n&gt;=0)。每次扩容数组长度扩大一倍。 scan命令就是对这个一维数组进行遍历。每次返回的游标值也都是这个数组的索引。limit参数表示遍历多少个数组的元素，将这些元素下挂接的符合条件的结果都返回。因为每个元素下挂接的链表大小不同，所以每次返回的结果数量也就不同。 2、scan的遍历顺序首先加入下面的key 1234127.0.0.1:6379&gt; keys *1) \"db_number\"2) \"key1\"3) \"myKey\" 遍历key 123456789101112127.0.0.1:6379&gt; scan 0 MATCH * COUNT 11) \"2\"2) 1) \"db_number\"127.0.0.1:6379&gt; scan 2 MATCH * COUNT 11) \"1\"2) 1) \"myKey\"127.0.0.1:6379&gt; scan 1 MATCH * COUNT 11) \"3\"2) 1) \"key1\"127.0.0.1:6379&gt; scan 3 MATCH * COUNT 11) \"0\"2) (empty list or set) 在遍历的过程中，大家发现游标的顺序是 0 2 1 3，从十进制来看好像没有规律，但是从转为二进制， 则是有规律的：00-&gt;10-&gt;01-&gt;11这种规律就是高位进1，传统的二进制加法，是从右往左加，这里是从左往右加。实际上，在 Redis 中，它的具体计算流程给是这样： 将要计算的数字反转 给反转后的数字加 1 再反转 那么为什么不是按照 0、1、2、3、4…这样的顺序遍历呢？因为主要考虑到两个问题： 字典扩容 字典缩容 假如我们将要访问 110 时，发生了扩容，此时 scan 就会从 0110 开始遍历，之前已经被遍历过的元素 就不会被重复遍历了。假如我们将要访问 110 时，发生缩容，此时 scan 就会从 10 开始遍历，这个时候，也会遍历到 010， 但是 010 之前的不会再被遍历了。所以，在发生缩容的时候，可能返回重复的元素 四、Scan的其他指令scan 是一系列的指令，除了遍历所有的 key 之外，也可以遍历某一个类型的 key，对应的命令有： zscan–&gt;zset hscan–&gt;hash sscan–&gt;set 用法和scan一致","link":"/2020/04/30/redis/Redis%E4%B9%8BScan/"},{"title":"Redis实现GEO地理位置","text":"Redis之GEORedis3.2 开始提供了 GEO 模块。该模块也使用了 GeoHash 算法。 一、GEOHash算法核心思想：GeoHash 是一种地址编码方法，使用这种方式，能够将二维的空间经纬度数据编码成一个 一维字符串。 以经过伦敦格林尼治天文台旧址的经线为 0 度经线，向东就是东经，向西就是西经。如果我们将西经定 义负，经度的范围就是 [-180,180]。 纬度北纬 90 度到南纬 90 度，如果我们将南纬定义负，则纬度的范围就是 [-90,90]。 接下来，以本初子午线和赤道为界，我们可以将地球上的点分配到一个二维坐标中： GeoHash 算法就是基于这样的思想，划分的次数越多，区域越多，每个区域中的面积就更小了，精确 度就会提高。GeoHash 具体算法：以北京天安门广场为例（39.9053908600,116.3980007200）： ①.纬度的范围在 (-90,90) 之间，中间值为 0，对于 39.9053908600 值落在 (0,90),因此得到的值为 1 ②.(0,90) 的中间值为 45，39.9053908600 落在 (0,45) 之间，因此得到一个 0 ③.(0,45) 的中间值为 22.5，39.9053908600 落在 (22.5,45)之间，因此得到一个 1 ④. …. 这样，我们得到的纬度二进制是 101 按照同样的步骤，我们可以算出来经度的二进制是 110 接下来将经纬度合并（经度占偶数位，纬度占奇数位）：111001 按照 Base32 （0-9,b-z,去掉 a i l 0）对合并后的二进制数据进行编码，编码的时候，先将二进制转换为 十进制，然后进行编码。 将编码得到的字符串，可以拿去 geohash.org 网站上解析。 GeoHash 特点：1、用一个字符串表示经纬度 2、 GeoHash 表示的是一个区域，而不是一个点。 3、编码格式有规律，例如一个地址编码之后的格式是 123，另一个地址编码之后的格式是 123456， 从字符串上就可以看出来，123456 处于 123 之中。 经纬度查询：http://www.gpsspg.com/maps.htm 二、GEO在Redis中的使用1、添加地址longitude:经度 latitude:纬度 geoadd [key] [longitude] [latitude] [member] 12geoadd city 121.4737000000 31.2303700000 shanghai ##添加上海的位置geoadd city 114.3052500000 30.5927600000 wuhan ##添加武汉位置 2、查看两个地址之间的距离unit: 默认为 m(米)，可选为 m , km , ft (英尺)，mi(英里) geodist [key] [member1] [member2] [unit] 123geoadd city shanghai wuhan km \"687.6116\" 3、获取元素的位置geopos [key] [member...] 1234geopos city shanghai1) 1) \"121.4736977219581604\" 2) \"31.23036910904709629\" 4、获取元素hash值geohash [key] [member...] 123geohash city wuhan1) \"wt3q114x9r0\" 通过解析的哈希地址，我们可以查看其定位 http://geohash.org/wt3q114x9r0 30.59276 114.30525 5、查看附近的地址(通过成员)key:指定key member:以该地点为中心 radius:距离该中心的半径距离 unit:距离单位 withcoord:经纬度 withhash：hash值 withdist:半径距离 count:显示的数量 asc/desc:升序或者降序 georadiusbymeber [key] [member] [radius] [unit] [withcoord] [withhash] [withdist] [Count count] [asc|desc] 123456789101112131415161718#查询以武汉为中心，距离武汉3000km的3个地点（包括武汉本身），并且显示经纬度，hash值，半径距离，结果以距离的降序排列GEORADIUSBYMEMBER city wuhan 3000 km withcoord withhash withdist count 3 desc1) 1) \"beijing\" 2) \"1049.6601\" 3) (integer) 4069152897912916 4) 1) \"116.49902611970901489\" 2) \"39.85915559490933191\"2) 1) \"guangzhou\" 2) \"858.8102\" 3) (integer) 4046518432493551 4) 1) \"113.35693091154098511\" 2) \"22.91792342803383775\"3) 1) \"jinan\" 2) \"703.7194\" 3) (integer) 4065887515903236 4) 1) \"117.15820580720901489\" 2) \"36.45663716057446635\" 6、查看附件的地址(通过经纬度)GEORADIUSBYMEMBER city wuhan 3000 km withcoord withhash withdist count 3 desc 把上面的wuhan元素替换成经经纬度即可： GEORADIUS city 114.3052500000 30.5927600000 3000 km withcoord withhash withdist count 3 desc","link":"/2020/04/30/redis/Redis%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AEGEO/"},{"title":"Redis通信协议","text":"Redis通信协议Redis 通信使用了文本协议，文本协议比较费流量，但是 Redis 作者认为数据库的瓶颈不在于网络流 量，而在于内部逻辑，所以采用了这样一个费流量的文本协议。这个文本协议叫做 Redis Serialization Protocol，简称 RESP。 Redis 协议将传输的数据结构分为 5 种小单元，单元结束时，加上回车换行符 \\r\\n。 单行字符串以 + 开始，例如 +javaboy.org\\r\\n 多行字符串以$ 开始，后面加上字符串长度，例如 $11\\r\\njavaboy.org\\r\\n 整数值以: 开始，例如 :1024\\r\\n 错误消息以 - 开始 数组以 * 开始，后面加上数组长度。 需要注意的是，如果是客户端连接服务端，只能使用第 5 种 一、修改redis.conf配置文件为了方便客户端连接 Redis，我们关闭 Redis 种的保护模式(在 redis.conf 文件中) 注释无需密码 1#requirepass xxx 关闭保护模式 1protected-mode no 二、自定义redis客户端操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110package org.lc.resp;import org.omg.CORBA.PUBLIC_MEMBER;import java.io.IOException;import java.net.Socket;import java.util.Scanner;import java.util.logging.Level;/** * @BelongsProject: resp * @BelongsPackage: org.lc.resp * @Author: lc * @CreateTime: 2020-05-01 12:07 * @Description: */public class LcRedisClient { private Socket socket; public LcRedisClient() { try { socket = new Socket(\"主机\", 6379); } catch (IOException e) { e.printStackTrace(); System.out.println(\"Redis连接失败\"); } } /** * 定义set命令，该命令为数组形式[set,key,value] * @param key * @param value * @return */ public String set(String key, String value) throws IOException { StringBuilder sb=new StringBuilder();// 该数组命令的长度为3 sb.append(\"*3\") .append(\"\\r\\n\")// 插入多行字符串 .append(\"$\")// 并设置字符串长度 .append(\"set\".length()) .append(\"\\r\\n\") .append(\"set\") .append(\"\\r\\n\")// 插入多行字符串 .append(\"$\")// 传入key的长度 若为中文则需要使用byte数组获取长度 .append(key.getBytes().length) .append(\"\\r\\n\") .append(key) .append(\"\\r\\n\")// 插入多行字符串 .append(\"$\")// 设置长度 .append(value.getBytes().length) .append(\"\\r\\n\") .append(value) .append(\"\\r\\n\"); System.out.println(sb.toString());// 写入socket socket.getOutputStream().write(sb.toString().getBytes()); byte[] buf = new byte[1024];// 得到socket服务端返回的数据 socket.getInputStream().read(buf);// 返回服务端的数据 return new String(buf); } /** * 定义get命令 [get key] * @param key * @return */ public String get(String key) throws IOException { StringBuilder sb=new StringBuilder();// 定义数组命令数组长度 sb.append(\"*2\") .append(\"\\r\\n\") .append(\"$\") .append(\"get\".length()) .append(\"\\r\\n\") .append(\"get\") .append(\"\\r\\n\") .append(\"$\") .append(key.getBytes().length) .append(\"\\r\\n\") .append(key) .append(\"\\r\\n\"); System.out.println(sb.toString()); socket.getOutputStream().write(sb.toString().getBytes()); byte[] but = new byte[1024]; socket.getInputStream().read(but); return new String(but); } public static void main(String[] args) { LcRedisClient redisClient=new LcRedisClient(); try {// String set = redisClient.set(\"k1\", \"louchen\");// System.out.println(set); String s = redisClient.get(\"k1\"); Systedm.out.println(s); } catch (IOException e) { e.printStackTrace(); } }} 输出结果分析： set操作 1234567891011*3$3set$2k1$7louchen//以上为在stringbuilder拼接的命令+OK//以上为服务端输出的结果 get操作 1234567891011*2$3get$2k1//以上为在stringbuilder拼接的命令$7louchen//get操作返回两个命令。$7表示返回多行字符串并指定长度","link":"/2020/05/01/redis/Redis%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"},{"title":"Redis单线程怎样处理高并发？","text":"Redis单线程怎样处理高并发？一、阻塞IO和非阻塞IO怎样理解阻塞IO,非阻塞IO,同步和异步 ：https://www.zhihu.com/question/19732473 Java 在 JDK1.4 中引入 NIO，但是也有很多人在使用阻塞 IO，这两种 IO 有什么区别？ 在阻塞模式下，如果你从数据流中读取不到指定大小的数据两，IO 就会阻塞。比如已知会有 10 个字节 发送过来，但是我目前只收到 4 个，还剩六个，此时就会发生阻塞。如果是非阻塞模式，虽然此时只收 到 4 个字节，但是读到 4 个字节就会立即返回，不会傻傻等着，等另外 6 个字节来的时候，再去继续读 取。 所以阻塞 IO 性能低于 非阻塞 IO。 如果有一个 Web 服务器，使用阻塞 IO 来处理请求，那么每一个请求都需要开启一个新的线程；但是如 果使用了非阻塞 IO，基本上一个小小线程池就够用了，因为不会发生阻塞，每一个线程都能够高效利 用。 二、Redis的线程模型首先一点，Redis 是单线程。单线程如何解决高并发问题的？实际上，能够处理高并发的单线程应用不仅仅是 Redis，除了 Redis 之外，还有 NodeJS、Nginx 等等 也是单线程。 Redis 虽然是单线程，但是运行很快，主要有如下几方面原因： Redis 中的所有数据都是基于内存的，所有的计算也都是内存级别的计算，所以快。 Redis 是单线程的，所以有一些时间复杂度高的指令，可能会导致 Redis 卡顿，例如 keys。 Redis 在处理并发的客户端连接时，使用了非阻塞 IO 在使用非阻塞 IO 时，有一个问题，就是线程如何知道剩下的数据来了？ https://www.jianshu.com/p/6a6845464770 这里就涉及到一个新的概念叫做多路复用，本质上就是一个事件轮询 API。 Redis 会给每一个客户端指令通过队列来排队进行顺序处理。 Redis 做出响应时，也会有一个响应的队列。","link":"/2020/05/01/redis/Redis%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%A4%84%E7%90%86%E9%AB%98%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"多数据源","slug":"多数据源","link":"/tags/%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"ActiveMQ","slug":"ActiveMQ","link":"/tags/ActiveMQ/"},{"name":"消息服务","slug":"消息服务","link":"/tags/%E6%B6%88%E6%81%AF%E6%9C%8D%E5%8A%A1/"},{"name":"MongoDB","slug":"MongoDB","link":"/tags/MongoDB/"},{"name":"Maven","slug":"Maven","link":"/tags/Maven/"},{"name":"Spring Boot","slug":"Spring-Boot","link":"/tags/Spring-Boot/"},{"name":"Session","slug":"Session","link":"/tags/Session/"},{"name":"Redis","slug":"Redis","link":"/tags/Redis/"},{"name":"IDEA","slug":"IDEA","link":"/tags/IDEA/"},{"name":"SpringBoot","slug":"SpringBoot","link":"/tags/SpringBoot/"},{"name":"Spring Security","slug":"Spring-Security","link":"/tags/Spring-Security/"},{"name":"RESTful","slug":"RESTful","link":"/tags/RESTful/"},{"name":"Shiro","slug":"Shiro","link":"/tags/Shiro/"},{"name":"WebSocket","slug":"WebSocket","link":"/tags/WebSocket/"},{"name":"Nginx","slug":"Nginx","link":"/tags/Nginx/"},{"name":"JAR","slug":"JAR","link":"/tags/JAR/"},{"name":"WAR","slug":"WAR","link":"/tags/WAR/"},{"name":"Swagger2","slug":"Swagger2","link":"/tags/Swagger2/"},{"name":"OAuth2","slug":"OAuth2","link":"/tags/OAuth2/"},{"name":"JWT","slug":"JWT","link":"/tags/JWT/"},{"name":"Quartz","slug":"Quartz","link":"/tags/Quartz/"},{"name":"定时任务","slug":"定时任务","link":"/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"},{"name":"Ehcache","slug":"Ehcache","link":"/tags/Ehcache/"},{"name":"RabbitMQ","slug":"RabbitMQ","link":"/tags/RabbitMQ/"},{"name":"FastDFS","slug":"FastDFS","link":"/tags/FastDFS/"},{"name":"邮件服务","slug":"邮件服务","link":"/tags/%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"MySql","slug":"MySql","link":"/tags/MySql/"}],"categories":[{"name":"Spring Boot","slug":"Spring-Boot","link":"/categories/Spring-Boot/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"项目构建部署","slug":"项目构建部署","link":"/categories/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E9%83%A8%E7%BD%B2/"},{"name":"Redis","slug":"Redis","link":"/categories/Redis/"},{"name":"IDEA","slug":"IDEA","link":"/categories/IDEA/"},{"name":"SpringBoot","slug":"SpringBoot","link":"/categories/SpringBoot/"},{"name":"Spring Security","slug":"Spring-Security","link":"/categories/Spring-Security/"},{"name":"Windows","slug":"Windows","link":"/categories/Windows/"},{"name":"Nginx","slug":"Nginx","link":"/categories/Nginx/"},{"name":"Spring Cache","slug":"Spring-Cache","link":"/categories/Spring-Cache/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"数据库","slug":"数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}]}