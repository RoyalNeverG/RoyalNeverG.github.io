{"pages":[{"title":"关于我","text":"渣渣二本毕业，希望通过写文章的方式，提高自己的技能！","link":"/about/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"SpringBoot整合ActiveMQ","text":"SpringBoot整合ActiveMQ一、安装ActiveMQ这里我们采用docker安装 1、搜索镜像docker search activemq 2、拉取镜像 docker pull webcenter/activemq 3、初始化容器61616 为通信端口 8161 为管理界面 docker run -d --name activemq01 -p 61616:61616 -p 8161:8161 webcenter/activemq 4、访问activemqxxx.xxx.xxx.xxx:8161 默认用户名和密码为 admin/admin 二、springboot整合ActiveMQ1、pom.xmlspring-boot-starter-activemq 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;activemq&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;activemq&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-activemq&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、实体消息bean12345678910111213@Getter@Setter@ToStringpublic class Message implements Serializable { /** * 发送的消息内容 */ private String content; /** * 发送的日期 */ private Date sendDate;} 3、队列配置1234567891011@Configurationpublic class QueueConfig { /** * 新建队列 * @return */ @Bean Queue queue() { return new ActiveMQQueue(\"hello.lc\"); }} 4、jms配置 1234567891011121314151617181920212223242526272829303132@Componentpublic class JmsComponent { /** * jms(java messgae service(java消息服务) )消息模板 */ @Autowired JmsMessagingTemplate jmsMessagingTemplate; @Autowired Queue queue; /** * 生产者 * @param message */ public void send(Message message) { //发送的目的地(指定队列) ; 发送的消息对象 jmsMessagingTemplate.convertAndSend(this.queue,message); } /** * 消费者 * JmsListener监听消息队列 destination 指定队列的名称 * @param message */ @JmsListener(destination = \"hello.lc\") public void receive(Message message){ System.out.println(message); }} 4、properties配置1234567#activemq代理的urlspring.activemq.broker-url=tcp://47.96.141.44:61616#发送消息时可为字符串或者一个对象。若为一个对象，则需要设为true#信任所有的包 如果传输的对象是Obeject 这里必须加上这句或者指定信任的包 否则会导致对象序列化失败spring.activemq.packages.trust-all=truespring.activemq.user=adminspring.activemq.password=admin 5、测试使用12345678910111213141516@SpringBootTestclass ActivemqApplicationTests { //默认注入单例 @Autowired JmsComponent jmsComponent; @Test void contextLoads() { Message message = new Message(); message.setContent(\"hello lc\"); message.setSendDate(new Date()); jmsComponent.send(message); }}","link":"/2020/07/24/mq/SpringBoot%E6%95%B4%E5%90%88ActiveMQ/"},{"title":"springboot实现session共享","text":"一、springboot实现session共享注意①redis的配置和springSecutiy的引入 1、基本配置①pom.xml spring-session-data-redis spring-boot-starter-data-redis spring-boot-starter-security 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;redis&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--spring session 与redis应用基本环境配置,需要开启redis后才可以使用，不然启动Spring boot会报错 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; ②yaml配置12345678910111213spring: redis:# 主机 host: 47.96.141.44# 默认使用的数据库（第一个） database: 0 port: 6379 password: 你的密码# 配置lettuce连接池的相关属性#需要设置启动的服务器server: port: 8080 ③控制器123456789101112131415161718@RestControllerpublic class UserController { // 这个必须配置启动的服务器 @Value(\"${server.port:8080}\") Integer port; @GetMapping(\"/set\") public String set(HttpSession httpSession){ httpSession.setAttribute(\"name\", \"lcc\"); return String.valueOf(port); } @GetMapping(\"/get\") public String get(HttpSession httpSession) { return (String) httpSession.getAttribute(\"name\")+port; }} ④模拟两个服务器启动分别启动两个不同端口的jar包==&gt; 服务器1==&gt; java -jar redis-1.0-SNAPSHOT.jar --server.port=8080 服务器2==&gt; java -jar redis-1.0-SNAPSHOT.jar --server.port=8081 请求8080的set接口：http://localhost:8080/set 设置session值 请求8081的get接口：http://localhost:8081/get 得到session值 结论:==&gt; 这时我们发现请求的服务1的接口输入user用户名和密码后，再去请求服务器2的接口后无需输入user和密码， 因为此时redis中，已经帮我们存取了session的详细对象。即操作的为同一个session。 2、使用nginx服务器很简单，进入 Nginx 的安装目录的 conf 目录下（默认是在 /usr/local/nginx/conf），编辑 nginx.conf 文件: 在这段配置中： upstream 表示配置上游服务器 javaboy.org 表示服务器集群的名字，这个可以随意取名字 upstream 里边配置的是一个个的单独服务 weight 表示服务的权重，意味者将有多少比例的请求从 Nginx 上转发到该服务上 location 中的 proxy_pass 表示请求转发的地址，/ 表示拦截到所有的请求，转发转发到刚刚配置好的服务集群中 proxy_redirect 表示设置当发生重定向请求时，nginx 自动修正响应头数据（默认是 Tomcat 返回重定向，此时重定向的地址是 Tomcat 的地址，我们需要将之修改使之成为 Nginx 的地址）。 配置完成后，将本地的 Spring Boot 打包好的 jar 上传到 Linux ，然后在 Linux 上分别启动两个 Spring Boot 实例： 12nohup java -jar sessionshare-0.0.1-SNAPSHOT.jar --server.port=8080 &amp;nohup java -jar sessionshare-0.0.1-SNAPSHOT.jar --server.port=8081 &amp; 其中 nohup 表示当终端关闭时，Spring Boot 不要停止运行 &amp; 表示让 Spring Boot 在后台启动 配置完成后，重启 Nginx： 1/usr/local/nginx/sbin/nginx -s reload Nginx 启动成功后，我们首先手动清除 Redis 上的数据，然后访问 192.168.66.128/set 表示向 session 中保存数据，这个请求首先会到达 Nginx 上，再由 Nginx 转发给某一个 Spring Boot 实例： 如上，表示端口为 8081 的 Spring Boot 处理了这个 /set 请求，再访问 /get 请求： 可以看到，/get 请求是被端口为 8080 的服务所处理的。","link":"/2020/07/24/nosql/springboot%E5%AE%9E%E7%8E%B0session%E5%85%B1%E4%BA%AB/"},{"title":"IDEA快捷键详解","text":"一、idea快捷键1234567891011121314151617181920212223242526272829303132333435363738394041ctrl + D 赋值ctrl + y 删除该行ctrl + / 单行注释ctrl +shift +/ 多行注释ctrl +alt +T 快速插入包围的代码 try catch if whilectrl + alt +v 快速生成返回类型ctrl + alt +L 整理代码格式ctrl+shift+F10 执行代码ctrl+shift+alt+N 搜索类ctrl+F12 查看当前类下的所有方法ctrl+alt+b 查看所有实现或继承该接口的类ctrl+o 查看可重写该类 方法ctrl+h 查看该类的继承数关系ctrl+w 按照范围由小到大选择代码区域ctrl+f9 重新编译ctrl+N 全局查找ctrl+shift+N 查找ctrl+F 当前文件查询ctrl+R 查找替换ctrl+E 弹出最近使用的文件ctrl+F4 关闭当前窗口ctrl+alt+shift+u 展示树状图类的继承关系ctrl+insert 复制选中的内容ctrl+shift 粘贴选中的内容ctrl+shift+u 将选中的单词全部转为大写/小写Ctrl+shift+enter 整理当前行代码格式/结束当前语句/加分号ctrl+j 插入代码模板shift+enter 换行shift 搜索全局文件shift + F6 选中文件和文件夹 修改名称shift+alt 鼠标点击多出，生成多个光标alt+Enter 快速导包alt+/ 代码提示alt+insert 快速插入属性，tostring 构造函数alt+insert 选中文件夹，快速创建一个文件alt+E 打开最近的文件选中项目+F4 //查看项目结构配置选中文件夹+F6 //移动文件夹到别的目录 二、代码多选和多选换行：多选换行：按住alt键选中多行，再按shift后回车。可多选换行。三、强制刷新浏览器12CTRL+F5 //强制刷新浏览器（清除缓存保留的js和css,等）CTRL+sift+del //快捷键 清除浏览器cookie和session 四、定义代码片段1、定义list后缀补全片段①File–&gt;Setting–&gt;Editor–&gt;General–&gt;Postfix Completion ②点击＋号–&gt;选择java–&gt;输入key为list–&gt;选择java1.8及以上(Minimum language level:8-lambdas,type annotations etc) ③定义表达式： 1List&lt;$EXPR$&gt; $END$ =new ArrayList&lt;&gt;(); ④使用： 1集合类型.list 2、定义mapper.xml模板①File–&gt;New–&gt;Edit File Templates–&gt;默认在Files下 ②点击+号–&gt;输入Name为模板名称–&gt;Extension为文件扩展类型 ③定义模板内容： 123456&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" &gt;&lt;mapper namespace=\"#[[$Title$]]#\"&gt; &lt;/mapper&gt; ④勾选√ Enabled Live Templates (启用激活模板) 3、定义单元测试片段①ctrl+j–&gt;点击灯泡–&gt; 或者 File–&gt;Setting–&gt;Editor–&gt;Live Templates ②点击+号–&gt;自定义一个组(Template Group)/直接定义一个片段(Live Tempalte)–&gt;在Abbreviation输入片段名称–&gt;输入描述 ③定义代码片段： $name$ :变量输入的位置 $END$: 光标最后的停留位置 1234@Testpublic void $name$Test(){ $END$} ④点击Define ， 勾选只在java中使用","link":"/2020/07/24/other/idea%E4%BD%BF%E7%94%A8/"},{"title":"springboot整合MongoDB","text":"springboot整合MongoDB一、docker安装mongodb1、拉取最近的镜像docker pull 2、初始化mongo容器 -d 后台运行 -p 端口映射 –name 容器名称 –restar docker每次重启后，该容器也启动 -e 参数设置 初始化用户名为root 密码为你的密码 docker run -d -p 27017:27017 --name mongo01 --restart=always -e MONGO_INITDB_ROOT_USERNAME=root -e MONGO_INITDB_ROOT_PASSWORD=你的密码 mongo 3、每个数据库有独立的账号和密码①进入容器docker exec -it 容器id bash ②进入mongomongo ③切换到admin数据库use admin ④添加用户操作的对应数据库db.createUser({user:&quot;admin&quot;,pwd:&quot;xiiasdfiik34&quot;,roles:[{role: 'root', db: 'admin'}]}) ⑤ 验证db.auth('admin', 'xiiasdfiik34') // 返回1 就是认证成功 二、使用MongoRepository1、pom.xmlspring-boot-starter-data-mongodb 1234567891011121314151617181920212223&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2、yaml配置1234567891011spring: data: mongodb: # mongodb每个库都有自己的认证方式 authentication-database: lc username: root password: 你的密码 port: 27017 database: lc uri: mongodb://root:你的密码@47.96.141.44:27017/lc# host: 47.96.141.44 3、实体12345678@Getter@Setter@ToStringpublic class Book { private Integer id; private String name; private String author;} 4、dao接口123456789101112131415/** * 继承MongoRepository * 第一个参数为 操作的实体 * 第二个参数为 操作的主键类型 */public interface BookDao extends MongoRepository&lt;Book,Integer&gt; { /** * 和jap一致 遵循方法名称的表达式进行查询 * @param name * @return */ List&lt;Book&gt; findBooksByNameContaining(String name);} 5、测试使用12345678910111213141516171819202122232425262728@RunWith(SpringRunner.class)@SpringBootTest(classes = RedisApplication.class)public class mongoTest { @Autowired private BookDao bookDao; //插入一条数据 @Test public void Test1() { Book b = new Book(); b.setId(3); b.setName(\"红楼梦\"); b.setAuthor(\"曹雪芹\"); bookDao.insert(b); } @Test public void Test2() { //查询所有 List&lt;Book&gt; all = bookDao.findAll(); System.out.println(all); //查询包含书名称为 “红” 的book //这里满足名称表达式 和jpa类似 List&lt;Book&gt; list = bookDao.findBooksByNameContaining(\"红\"); System.out.println(list); }} 三、使用MongoTemplate1、pom.xml和上面配置一致 2、yaml配置和上面配置一致 3、实体和上面配置一致 4、直接使用（和RedisTmeplate类似）12345678910111213141516171819202122@RunWith(SpringRunner.class)@SpringBootTest(classes = RedisApplication.class)public class mongoTest { @Autowired private MongoTemplate mongoTemplatel; @Test public void Test3() { Book book = new Book(); book.setId(4); book.setName(\"水浒传\"); book.setAuthor(\"施耐庵\"); //插入数据 mongoTemplatel.insert(book); //查询所有 List&lt;Book&gt; all = mongoTemplatel.findAll(Book.class); System.out.println(all); }}","link":"/2020/07/24/nosql/springboot%E6%95%B4%E5%90%88mongodb/"},{"title":"SpringBoot整合Redis","text":"一、docker中安装redis1、镜像安装与容器创建12docker pull redis //拉取镜像docker run -d -p 6379:6379 --restart=always --name myredis 镜像名 //创建容器 2、查看redis版本docker exec -it 9a7d1cf2c234 redis-cli -v //查看版本 3、修改redis密码（临时，重启失效）①进入redis管理页面不带密码进入（进入后需验证）==&gt; docker exec -it 9a7d1cf2c234 redis-cli //进入redis管理界面 带密码进入（进入后无需验证）==&gt; docker exec -it 9a7d1cf2c234 redis-cli -a '密码' //带密码进入管理界面 ②查询密码config get requirepass //查看密码(初始为空) ③设置密码config set reuqirepass 密码 //设置密码 ④验证密码auth 密码 //验证密码才能够进行查询密码和设置密码等操作 4、永久设置密码（需要修改配置文件）二、springboot整合Redis注意：①在Springboot 2.1.5及之后使用redis必须引入springSecurity ②redis5及之后远程访问连接必须要设置密码 ③使用jedis和lettuce客户端连接redis服务器的区别：使用jedis：当多线程使用同一个连接时，是线程不安全的。所以要使用连接池，为每个jedis实例分配一个连接。 Jedis在实现上是直接连接的redis server，如果在多线程环境下是非线程安全的，这个时候只有使用连接池，为每个Jedis实例增加物理连接 使用Lettuce：当多线程使用同一连接实例时，是线程安全的 Lettuce的连接是基于Netty的，连接实例（StatefulRedisConnection）可以在多个线程间并发访问，应为StatefulRedisConnection是线程安全的，所以一个连接实例（StatefulRedisConnection）就可以满足多线程环境下的并发访问，当然这个也是可伸缩的设计，一个连接实例不够的情况也可以按需增加连接实例。 1、基于lettuce底层的redis配置引入SpringSecurity后，SpringSecurity帮我们生成一个密码 在我们第一个请求redis会要求输入账号密码 用户名为:uers 密码为：Using generated security password: 648dcfaa-ce97-459d-a6d4-b02f73532f89 pom.xmlspring-boot-starter-data-redis spring-boot-starter-security 123456789101112131415161718192021222324252627282930&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; yaml配置123456789spring: redis:# 主机 host: 47.96.141.44# 默认使用的数据库（第一个） database: 0 port: 6379 password: 你的密码# 配置lettuce连接池的相关属性 controller1234567891011121314151617181920@RestControllerpublic class HelloController { @Autowired StringRedisTemplate stringRedisTemplate; @GetMapping(\"/set\") public void set(){ ValueOperations&lt;String, String&gt; ops = stringRedisTemplate.opsForValue(); ops.set(\"lc\", \"louchen.top\"); } @GetMapping(\"/get\") public void get() { ValueOperations&lt;String, String&gt; ops = stringRedisTemplate.opsForValue(); System.out.println(ops.get(\"lc\")); }} 自动配置详解org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration=&gt; 123456789101112131415161718192021222324252627282930@Configuration( proxyBeanMethods = false)@ConditionalOnClass({RedisOperations.class})@EnableConfigurationProperties({RedisProperties.class})@Import({LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class})public class RedisAutoConfiguration { public RedisAutoConfiguration() { } @Bean @ConditionalOnMissingBean( name = {\"redisTemplate\"} ) //操作健值为对象的redistemplate public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException { RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate(); template.setConnectionFactory(redisConnectionFactory); return template; } @Bean @ConditionalOnMissingBean //主要操作健值为字符串的对象 public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException { StringRedisTemplate template = new StringRedisTemplate(); template.setConnectionFactory(redisConnectionFactory); return template; }}","link":"/2020/07/24/nosql/springboot%E6%95%B4%E5%90%88redis/"},{"title":"Maven基础知识","text":"1、dependencyManagement和dependencies的区别 123456789101112131415161718192021222324 &lt;!--定义父版本--&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;!--如果没有指定版本 则使用父版本 否则使用指定的版本--&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--json格式工具--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; ①定义 123 在Maven中dependencyManagement的作用其实相当于一个对所依赖jar包进行版本管理的管理器。 在dependencyManagement下申明的dependencies，Maven并不会去实际下载所依赖的jar包，而是 在dependencyManagement中用一个Map记录了jar的三维坐标。 ②jar的版本1234567 这个是一个重要的概念，也是dependencyManagement独有的特色。 1：如果dependencies里的dependency自己没有声明version元素，那么maven就 会倒dependencyManagement里面去找有没有对该artifactId和groupId进行过版本声明，如果有，就继承它，如果没有就会报错，告诉你必须为dependency声明一个version 2：如果dependencies中的dependency声明了version，那么无论dependencyManagement中有无对该jar的version声明，都以dependency里的version为准。 2、maven 常用命令(工具)①clean1清除项目中编译文件和本地仓库中已打包的文件 ②compile1编译项目中的java文件，并存放在项目的编译目录（根据不同的配置，编译目录也不一样） ③test1运行项目中的测试用例文件，如果测试用例未通过，也会打包失败，另，这里的test过程可以在pom中通过配置跳过 ④package123依次执行了clean、resources、compile、testResources、testCompile、test、jar(打包)等７个阶段。package命令完成了项目编译、单元测试、打包功能，但没有把打好的可执行jar包（war包或其它形式的包）布署到本地maven仓库和远程maven私服仓库 ⑤install123依次执行了clean、resources、compile、testResources、testCompile、test、jar(打包)、install等8个阶段install命令完成了项目编译、单元测试、打包功能，同时把打好的可执行jar包（war包或其它形式的包）布署到本地maven仓库，但没有布署到远程maven私服仓库 ⑥deploy123依次执行了clean、resources、compile、testResources、testCompile、test、jar(打包)、install、deploy等９个阶段。deploy命令完成了项目编译、单元测试、打包功能，同时把打好的可执行jar包（war包或其它形式的包）布署到本地maven仓库和远程maven私服仓库 3、dependency中scope的用法 compile，缺省值，适用于所有阶段，会随着项目一起发布。 provided，类似compile，期望JDK、容器或使用者会提供这个依赖。如servlet.jar。 runtime，只在运行时使用，如JDBC驱动，适用运行和测试阶段。 test，只在测试时使用，用于编译和运行测试代码。不会随项目发布。 system，类似provided，需要显式提供包含依赖的jar，Maven不会在Repository中查找它。 123456&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.20&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 依赖范围控制哪些依赖在哪些classpath 中可用，哪些依赖包含在一个应用中。让我们详细看一下每一种范围： ① compile （编译范围）compile是默认的范围；如果没有提供一个范围，那该依赖的范围就是编译范围。编译范围依赖在所有的classpath 中可用，同时它们也会被打包。 ②provided （已提供范围）provided 依赖只有在当JDK 或者一个容器已提供该依赖之后才使用。例如， 如果你开发了一个web 应用，你可能在编译 classpath 中需要可用的Servlet API 来编译一个servlet，但是你不会想要在打包好的WAR 中包含这个Servlet API；这个Servlet API JAR 由你的应用服务器或者servlet 容器提供。已提供范围的依赖在编译classpath （不是运行时）可用。它们不是传递性的，也不会被打包。 ③runtime （运行时范围）runtime 依赖在运行和测试系统的时候需要，但在编译的时候不需要。比如，你可能在编译的时候只需要JDBC API JAR，而只有在运行的时候才需要JDBC驱动实现。 ④test （测试范围）test范围依赖 在一般的编译和运行时都不需要，它们只有在测试编译和测试运行阶段可用。 ⑤system （系统范围）system范围依赖与provided 类似，但是你必须显式的提供一个对于本地系统中JAR 文件的路径。这么做是为了允许基于本地对象编译，而这些对象是系统类库的一部分。这样的构件应该是一直可用的，Maven 也不会在仓库中去寻找它。如果你将一个依赖范围设置成系统范围，你必须同时提供一个 systemPath 元素。注意该范围是不推荐使用的（你应该一直尽量去从公共或定制的 Maven 仓库中引用依赖）。 4、指定maven编译 Compiler插件编译时和编译后运行的JVM版本12345678910111213&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;8&lt;/source&gt; &lt;target&gt;8&lt;/target&gt; &lt;encoding&gt;utf-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 5、idea创建项目Group: 会作为包名的前一部分 Artifact: 会作为包的最后一部分 例如：Group：com.mybatis ​ Artifact: spring-boot-lc-mybatis 然后设置项目名 随便设置，不会影响项目内容 最后生成的项目： 12&lt;groupId&gt;com.mybatis&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-lc-mybatis&lt;/artifactId&gt; 生成的包名： com.mybatis.springbootlcmybatis 6、Maven 中 SHAPSHOT 和 RELEASE 版本的区别？1、Snapshot版本代表不稳定、尚处于开发中的版本 2、Release版本则代表稳定的版本","link":"/2020/07/24/projectBuildAndDev/Maven%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"SpringBoot应用监控可视化","text":"SpringBoot应用监控可视化Spring Boot Admin监控系统SBA则是基于Actuator更加进化了一步，其是一个针对Actuator接口进行UI美化封装的监控工具。 一、创建服务端1.pom.xmlspring-boot-admin-starter-server 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;admin&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;admin&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-boot-admin.version&gt;2.2.1&lt;/spring-boot-admin.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-starter-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-dependencies&lt;/artifactId&gt; &lt;version&gt;${spring-boot-admin.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、启用Spring Boot Admin12345678@SpringBootApplication//开启admin服务@EnableAdminServerpublic class AdminApplication { public static void main(String[] args) { SpringApplication.run(AdminApplication.class, args); }} 3、访问监控页面 localhost:8080/index.html ![](F:\\桌面内容\\springboot2\\springboot应用监控\\images\\批注 2020-04-08 210708.png) 二、创建client(监控的Spring Boot应用)1、pom.xmlspring-boot-admin-starter-client spring-boot-starter-actuator 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;client&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;client&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-boot-admin.version&gt;2.2.1&lt;/spring-boot-admin.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-starter-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-dependencies&lt;/artifactId&gt; &lt;version&gt;${spring-boot-admin.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、配置客户端的一些信息12345#暴露所有端口信息management.endpoints.web.exposure.include=*server.port=8081#声明该客户端的url地址spring.boot.admin.client.url=http://localhost:8080 3、启动该程序三、访问服务端监控页面 localhost:8080/index.html ![](F:\\桌面内容\\springboot2\\springboot应用监控\\images\\批注 2020-04-08 211142.png)","link":"/2020/07/24/projectcontrol/SpringBoot%E5%BA%94%E7%94%A8%E7%9B%91%E6%8E%A7%E5%8F%AF%E8%A7%86%E5%8C%96/"},{"title":"SpringBoot邮件监控报警","text":"SpringBoot邮件监控报警但我们要用SBA(Spring-Boot-Admin)实现应用的监控并实时了解应用的上下线时，我们可以使用邮件报警的方式 一、服务端配置1、pom.xmlspring-boot-admin-starter-server spring-boot-starter-mail 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;admin&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;admin&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-boot-admin.version&gt;2.2.1&lt;/spring-boot-admin.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-starter-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-dependencies&lt;/artifactId&gt; &lt;version&gt;${spring-boot-admin.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、properties配置12345678910111213141516171819202122#指定邮件服务器的地址 这里我们使用qq的smtp服务器发送邮件spring.mail.host=smtp.qq.com# 服务器的端口号修改成465或587；spring.mail.port=587# 邮件发送者的邮件spring.mail.username=421192425@qq.com# 这里使用的为授权码（不能使用邮箱密码）spring.mail.password=eqsdqizwdnenbgif#设置默认编码spring.mail.default-encoding=UTF-8#设置ssl协议spring.mail.properties.mail.smtp.socketFactory.class=javax.net.ssl.SSLSocketFactory#打印发送邮件的日志spring.mail.properties.mail.debug=true#邮件发送给谁spring.boot.admin.notify.mail.to=421192425@qq.com#谁发的spring.boot.admin.notify.mail.from=421192425@qq.com#忽略的事件（这里没有配置，则应用的上线和下线都要发送邮件）spring.boot.admin.notify.mail.ignore-changes= 3、开启admin服务12345678@SpringBootApplication//开启admin服务@EnableAdminServerpublic class AdminApplication { public static void main(String[] args) { SpringApplication.run(AdminApplication.class, args); }} 二、客户端配置(监控的应用)1、pom.xmlspring-boot-starter-actuator spring-boot-admin-starter-client 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;client&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;client&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-boot-admin.version&gt;2.2.1&lt;/spring-boot-admin.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-starter-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-dependencies&lt;/artifactId&gt; &lt;version&gt;${spring-boot-admin.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、客户端信息配置12345#暴露所有端口信息management.endpoints.web.exposure.include=*server.port=8081#声明该客户端的url地址spring.boot.admin.client.url=http://localhost:8080 3、启动应用三、应用上下线邮件提示1、上线邮件模板spring-boot-application (65685b0ef8f8) is UPInstance 65685b0ef8f8 changed status from UNKNOWN to UP Status DetailsRegistrationService Url http://LAPTOP-LJJM9R29:8081/Health Url http://LAPTOP-LJJM9R29:8081/actuator/healthManagement Url http://LAPTOP-LJJM9R29:8081/actuator 2、下线邮件模板spring-boot-application (65685b0ef8f8) is OFFLINEInstance 65685b0ef8f8 changed status from UP to OFFLINE Status Detailsexceptionio.netty.channel.AbstractChannel$AnnotatedConnectExceptionmessageConnection refused: no further information: LAPTOP-LJJM9R29/169.254.1.137:8081RegistrationService Url http://LAPTOP-LJJM9R29:8081/Health Url http://LAPTOP-LJJM9R29:8081/actuator/healthManagement Url http://LAPTOP-LJJM9R29:8081/actuator","link":"/2020/07/24/projectcontrol/SpringBoot%E9%82%AE%E4%BB%B6%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6/"},{"title":"Redis中的HyperLogLog","text":"Redis中的HyperLogLog一、HyperLogLog：1、特点高级不精确去重的数据结构.(一般是超过一百个就开始不准确了)占用空间小(一个键最多12k,可以计算2^64个元素)没有contains操作 因此有些他就支持不了,拓展到 布隆过滤器 适用于一个热点页面的去重访问次数.不适合单个用户的数据统计 2、背景一般我们评估一个网站的访问量，有几个主要的参数： pv，Page View，网页的浏览量 uv，User View，访问的用户 一般来说，pv 或者 uv 的统计，可以自己来做，也可以借助一些第三方的工具，比如 cnzz，友盟 等。 如果自己实现，pv 比较简单，可以直接通过 Redis 计数器就能实现。但是 uv 就不一样，uv 涉及到另外一个问题，去重。 我们首先需要在前端给每一个用户生成一个唯一 id，无论是登录用户还是未登录用户，都要有一个唯一 id，这个 id 伴随着请求一起到达后端，在后端我们通过 set 集合中的 sadd 命令来存储这个 id，最后通过 scard 统计集合大小，进而得出 uv 数据。 如果是千万级别的 UV，需要的存储空间就非常惊人。而且，像 UV 统计这种，一般也不需要特别精确，800w 的 uv 和 803w 的 uv，其实差别不大。所以，我们要介绍今天的主角—HyperLogLog Redis 中提供的 HyperLogLog 就是专门用来解决这个问题的，HyperLogLog 提供了一套不怎么精确但是够用的去重方案，会有误差，官方给出的误差数据是 0.81%，这个精确度，统计 UV 够用了。 二、在Redis中的基本命令1、pfadd用来添加记录，类似于 sadd ，添加过程中，重复的记录会自动去重。 element：用户的标识 pfadd [key] [element...] 2、pfcount统计一个或多个key的值的个数。取并集（去重），这种操作不会改变原key的大小 pfcount [key] [key...] 12345pfadd k1 u1 u2 u3 u4pfcount k1 #==&gt; 4pfadd k2 u4 u5pfcount k2 #==&gt; 2pfcount k1 k2 #===&gt; 5 3、pfmerge合并多个key到某一个key中，会去重。会改变目标key的大小 destkey :目标key sourcekey 源key pfmerge destkey sourcekey [sourcekey...] 1234pfcount uv #==&gt; 994pfadd u1 aa bb #==&gt;添加不在uv的两个值 aa bbpfmerge u1 uv #==&gt;合并uv到u1中pfcount u1 #==&gt; 996 三、通过java代码来模拟大数据量的用户访问先准备连接redis代码 1234567891011121314151617181920212223242526272829303132public class Redis { private JedisPool jedisPool; public Redis() {// 连接池配置对象 GenericObjectPoolConfig config=new GenericObjectPoolConfig();// 连接池最大空闲数 config.setMaxIdle(300);// 最大连接数 config.setMaxTotal(1000);// 连接最大等待时间（毫秒）。-1表示无限制 config.setMaxWaitMillis(30000);// 在空闲时检查有效性 config.setTestOnBorrow(true); /** * 1、连接池配置 * 2、redis地址 * 3、端口 * 4、超时时间 * 5、密码 */ jedisPool = new JedisPool(config, \"主机\",6379,30000,\"你的密码\"); } public void execute(CallWithJedis callWithJedis) { try (Jedis jedis=jedisPool.getResource()) { callWithJedis.call(jedis); } }} 123public interface CallWithJedis { void call(Jedis jedis);} 1234567891011121314public class HyperLogLogTest { public static void main(String[] args) { Redis redis = new Redis(); redis.execute(jedis -&gt; { for (int i = 0; i &lt; 1000; i++) {// 理论上我们累加的为1001次 jedis.pfadd(\"uv\", \"u\"+i,\"u\"+(i+1)); } long uv = jedis.pfcount(\"uv\"); //实际输出 994 System.out.println(uv); }); }} 理论值是 1001，实际打印出来 994，有误差，但是在可以接受的范围内。","link":"/2020/07/24/redis/Redis%E4%B9%8BHyperLogLog/"},{"title":"Redis的Scan命令","text":"Redis的ScanRedis中有一个经典的问题，在巨大的数据量的情况下，做类似于查找符合某种规则的Key的信息，这里就有两种方式，一是keys命令，简单粗暴，由于Redis单线程这一特性，keys命令是以阻塞的方式执行的，keys是以遍历的方式实现的复杂度是 O(n），Redis库中的key越多，查找实现代价越大，产生的阻塞时间越长。二是scan命令，以非阻塞的方式实现key值的查找，绝大多数情况下是可以替代keys命令的，可选性更强 keys的缺点： 1、没有limit，我们只能一次性获取所有符合条件的key，如果结果有上百万条，那么等待你的就是“无穷无尽”的字符串输出。 2、keys命令是遍历算法，时间复杂度是O(N)。如我们刚才所说，这个命令非常容易导致Redis服务卡顿。因此，我们要尽量避免在生产环境使用该命令。 scan的优点： scan命令的时间复杂度虽然也是O(N)，但它是分次进行的，不会阻塞线程。 scan命令提供了limit参数，可以控制每次返回结果的最大条数。 一、Scan的简单介绍scan 实际上是 keys 的一个升级版。可以用 keys 来查询 key，在查询的过程中，可以使用通配符。keys 虽然用着还算方便，但是没有分页 功能。同时因为 Redis 是单线程，所以 key 的执行会比较消耗时间，特别是当数据量大的时候，影响整 个程序的运行。为了解决 keys 存在的问题，从 Redis2.8 中开始，引入了 scan。scan 具备 keys 的功能，但是不会阻塞线程，而且可以控制每次返回的结果数。 二、基本用法1、数据准备先准备一千条测试数据 jedis测试工具： pom.xml 1234567&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; CallWithJedis 123public interface CallWithJedis { void call(Jedis jedis);} Redis 1234567891011121314151617181920212223242526272829303132public class Redis { private JedisPool jedisPool; public Redis() {// 连接池配置对象 GenericObjectPoolConfig config=new GenericObjectPoolConfig();// 连接池最大空闲数 config.setMaxIdle(300);// 最大连接数 config.setMaxTotal(1000);// 连接最大等待时间（毫秒）。-1表示无限制 config.setMaxWaitMillis(30000);// 在空闲时检查有效性 config.setTestOnBorrow(true); /** * 1、连接池配置 * 2、redis地址 * 3、端口 * 4、超时时间 * 5、密码 */ jedisPool = new JedisPool(config, \"主机\",6379,30000,\"密码\"); } public void execute(CallWithJedis callWithJedis) { try (Jedis jedis=jedisPool.getResource()) { callWithJedis.call (jedis); } }} 12345678910public class ScanTest { public static void main(String[] args) { Redis redis=new Redis(); redis.execute(jedis -&gt; { for (int i = 0; i &lt; 1000; i++) { jedis.set(\"k\" + i, \"v\" + i); } }); }} scan 命令一共提供了三个参数，第一个 cursor，第二个参数是 key，第三个参数是 limit。 cursor 实际上是指一维数组的位置索引，limit 则是遍历的一维数组个数（所以每次返回的数据大小可 能不确定）。 2、scan命令使用SCAN命令是一个基于游标的迭代器。这意味着命令每次被调用都需要使用上一次这个调用返回的游标作为该次调用的游标参数，以此来延续之前的迭代过程。 https://www.cnblogs.com/wy123/p/10955153.html cursor ：游标，遍历的起始位置，一般从0开始 MATCH ：模糊匹配的键 COUNT : COUNT是指本次遍历时, 要遍历多少个元素（不指定count,默认只遍历10个） SCAN cursor [MATCH pattern] [COUNT count] 123456789101112scan 0 match k8* count 100 1) \"360\"2) 1) \"k832\" 2) \"k806\" 3) \"k89\" 4) \"k80\" 5) \"k856\" 6) \"k870\" 7) \"k805\" 8) \"k809\" 9) \"k858\" 注意：上面返回的1)中的360表示下次游标遍历的起始位置 当游标输出为0时，即遍历完毕，回到起始位置 三、基本原理https://www.jianshu.com/p/be15dc89a3e8 1、Redis的结构Redis使用了Hash表作为底层实现，原因不外乎高效且实现简单。说到Hash表，很多Java程序员第一反应就是HashMap。没错，Redis底层key的存储结构就是类似于HashMap那样数组+链表的结构。其中第一维的数组大小为2n(n&gt;=0)。每次扩容数组长度扩大一倍。 scan命令就是对这个一维数组进行遍历。每次返回的游标值也都是这个数组的索引。limit参数表示遍历多少个数组的元素，将这些元素下挂接的符合条件的结果都返回。因为每个元素下挂接的链表大小不同，所以每次返回的结果数量也就不同。 2、scan的遍历顺序首先加入下面的key 1234127.0.0.1:6379&gt; keys *1) \"db_number\"2) \"key1\"3) \"myKey\" 遍历key 123456789101112127.0.0.1:6379&gt; scan 0 MATCH * COUNT 11) \"2\"2) 1) \"db_number\"127.0.0.1:6379&gt; scan 2 MATCH * COUNT 11) \"1\"2) 1) \"myKey\"127.0.0.1:6379&gt; scan 1 MATCH * COUNT 11) \"3\"2) 1) \"key1\"127.0.0.1:6379&gt; scan 3 MATCH * COUNT 11) \"0\"2) (empty list or set) 在遍历的过程中，大家发现游标的顺序是 0 2 1 3，从十进制来看好像没有规律，但是从转为二进制， 则是有规律的：00-&gt;10-&gt;01-&gt;11这种规律就是高位进1，传统的二进制加法，是从右往左加，这里是从左往右加。实际上，在 Redis 中，它的具体计算流程给是这样： 将要计算的数字反转 给反转后的数字加 1 再反转 那么为什么不是按照 0、1、2、3、4…这样的顺序遍历呢？因为主要考虑到两个问题： 字典扩容 字典缩容 假如我们将要访问 110 时，发生了扩容，此时 scan 就会从 0110 开始遍历，之前已经被遍历过的元素 就不会被重复遍历了。假如我们将要访问 110 时，发生缩容，此时 scan 就会从 10 开始遍历，这个时候，也会遍历到 010， 但是 010 之前的不会再被遍历了。所以，在发生缩容的时候，可能返回重复的元素 四、Scan的其他指令scan 是一系列的指令，除了遍历所有的 key 之外，也可以遍历某一个类型的 key，对应的命令有： zscan–&gt;zset hscan–&gt;hash sscan–&gt;set 用法和scan一致","link":"/2020/07/24/redis/Redis%E4%B9%8BScan/"},{"title":"Redis位图的操作","text":"Redis位图的操作一、基本介绍​ 用户一年的签到记录，如果你用 string 类型来存储，那你需要 365 个 key/value，操作起来麻烦。通过位图可以有效的简化这个操作。 它的统计很简单： 01111000111 ​ 每天的记录占一个位，365 天就是 365 个位，大概 46 个字节，这样可以有效的节省存储空间，如果有一天想要统计用户一共签到了多少天，统计 1 的个数即可。 对于位图的操作，可以直接操作对应的字符串（get/set），可以直接操作位（getbit/setbit）. 二、基本操作1、零存整取存储的方式以二进制形式，取出的方式以字符串 例如：存储字符串Java 字符 ASCII 十进制 J 74 01001010 a 97 01100001 v 118 01110110 在redis中使用set [key] [offset] [value]的形式设置当前字母的bit位，设置1的位置即可，0无需设置 修改 key 对应的 value 在 offset(偏移) 处的 bit 值 设置J set name 1 1 set name 4 1 set name 6 1 设置a set name 9 1 set name 10 1 set name 15 1 设置v set name 17 1 set name 18 1 set name 19 1 set name 21 1 set name 22 1 设置a set name 25 1 set name 26 1 set name 31 1 取出字符串: 1get name #==&gt; \"Java\" 2、整存零取存一个字符串进去，但是通过位操作获取字符串 设置值： 1set k1 louchen.top 此时字符串一共有11*8位=88个二进制字符 获取二进制位： key 对应的 value 在 offset 处的 bit 值。 getbit [key] [offset] 1234getbit k1 0getbit k1 1......getbit k1 87 三、统计1、bitcount统计二进制中1的个数 注意：这里的start和end表示字符的起始（包含start,end），而不是bit位的起始 bitcount [key] [start] [end] 2、bitpos统计在0或1第一次出现的位置 bit ：0或1 start/end: 字符出现的位置(包含start，end),不是bit位的起始 bitpos [key] [bit] [start] [end] 四、Bit批处理在 Redis 3.2 之后，新加了一个功能叫做 bitfiled ，可以对 bit 进行批量操作。 1、bitfield单个获取BITFIELD name get u4 0 表示获取 name 中的位，从 0 开始获取，获取 4 个位，返回一个无符号数字。 u 表示无符号数字 i 表示有符号数字，有符号的话，第一个符号就表示符号位，1 表示是一个负数。 BITFIELD name get u4 0 即 0100 ==&gt; 6 BITFIELD name get i4 0 即0100 ==&gt; 6 bitfield name get u4 1 即 1001==&gt;9 bitfield name get i4 1 即 1001 ，首位为1那么这个二进制位负数 ，则 -8+1=-7 批量获取：bitfield name get u4 1 get i4 1 get u4 0 get i4 0 2、setfieldbitfield name set u8 8 98 表示从第8位开始获取8个无符号二进制位大小的数替换为98 此时的Java==&gt;Jbva 3、incrby对指定范围进行自增操作，自增操作可能会出现溢出，既可能是向上溢出，也可能是向下溢出。Redis 中对于溢出的处理方案是折返。 8位无符号数 255 加 1 溢出变为 0；8 位有符号数 127，加 1 变为 - 128. 默认的的溢出策略： 在Jbva基础上操作 bitfield name incrby u2 6 1 设置第6位开始，将2个bit位后面加1 ，即10 加1，得 11 ==&gt; 01001011 get name ==&gt; &quot;Kbva&quot; bitfield name incrby u2 6 1 还是从第六位开始，在两个bit位后面加1，即 11 加 1，溢出。 则将这两位全部置为0 ==&gt; 01001000 get name ==&gt; &quot;Hbva&quot; 修改默认的溢出策略： 在我们对Hbva基础上操作 H: 010010 00 fail策略： bitfield name overflow fail incrby u2 6 1 执行上述命令三次 get name ==&gt; &quot;Kbva&quot; 此时K: 010010 11 再次执行 bitfield name overflow fail incrby u2 6 1 1) (nil) 操作失败！ 此时的值还是为 “Kbva” sat策略 bitfield name overflow fail incrby u2 6 1 无论执行多少次，值还是不会变。保持原来的最大或最小值 1) (integer) 3","link":"/2020/07/24/redis/Redis%E4%BD%8D%E5%9B%BE%E6%93%8D%E4%BD%9C/"},{"title":"Redis实现GEO地理位置","text":"Redis之GEORedis3.2 开始提供了 GEO 模块。该模块也使用了 GeoHash 算法。 一、GEOHash算法核心思想：GeoHash 是一种地址编码方法，使用这种方式，能够将二维的空间经纬度数据编码成一个 一维字符串。 以经过伦敦格林尼治天文台旧址的经线为 0 度经线，向东就是东经，向西就是西经。如果我们将西经定 义负，经度的范围就是 [-180,180]。 纬度北纬 90 度到南纬 90 度，如果我们将南纬定义负，则纬度的范围就是 [-90,90]。 接下来，以本初子午线和赤道为界，我们可以将地球上的点分配到一个二维坐标中： GeoHash 算法就是基于这样的思想，划分的次数越多，区域越多，每个区域中的面积就更小了，精确 度就会提高。GeoHash 具体算法：以北京天安门广场为例（39.9053908600,116.3980007200）： ①.纬度的范围在 (-90,90) 之间，中间值为 0，对于 39.9053908600 值落在 (0,90),因此得到的值为 1 ②.(0,90) 的中间值为 45，39.9053908600 落在 (0,45) 之间，因此得到一个 0 ③.(0,45) 的中间值为 22.5，39.9053908600 落在 (22.5,45)之间，因此得到一个 1 ④. …. 这样，我们得到的纬度二进制是 101 按照同样的步骤，我们可以算出来经度的二进制是 110 接下来将经纬度合并（经度占偶数位，纬度占奇数位）：111001 按照 Base32 （0-9,b-z,去掉 a i l 0）对合并后的二进制数据进行编码，编码的时候，先将二进制转换为 十进制，然后进行编码。 将编码得到的字符串，可以拿去 geohash.org 网站上解析。 GeoHash 特点：1、用一个字符串表示经纬度 2、 GeoHash 表示的是一个区域，而不是一个点。 3、编码格式有规律，例如一个地址编码之后的格式是 123，另一个地址编码之后的格式是 123456， 从字符串上就可以看出来，123456 处于 123 之中。 经纬度查询：http://www.gpsspg.com/maps.htm 二、GEO在Redis中的使用1、添加地址longitude:经度 latitude:纬度 geoadd [key] [longitude] [latitude] [member] 12geoadd city 121.4737000000 31.2303700000 shanghai ##添加上海的位置geoadd city 114.3052500000 30.5927600000 wuhan ##添加武汉位置 2、查看两个地址之间的距离unit: 默认为 m(米)，可选为 m , km , ft (英尺)，mi(英里) geodist [key] [member1] [member2] [unit] 123geoadd city shanghai wuhan km \"687.6116\" 3、获取元素的位置geopos [key] [member...] 1234geopos city shanghai1) 1) \"121.4736977219581604\" 2) \"31.23036910904709629\" 4、获取元素hash值geohash [key] [member...] 123geohash city wuhan1) \"wt3q114x9r0\" 通过解析的哈希地址，我们可以查看其定位 http://geohash.org/wt3q114x9r0 30.59276 114.30525 5、查看附近的地址(通过成员)key:指定key member:以该地点为中心 radius:距离该中心的半径距离 unit:距离单位 withcoord:经纬度 withhash：hash值 withdist:半径距离 count:显示的数量 asc/desc:升序或者降序 georadiusbymeber [key] [member] [radius] [unit] [withcoord] [withhash] [withdist] [Count count] [asc|desc] 123456789101112131415161718#查询以武汉为中心，距离武汉3000km的3个地点（包括武汉本身），并且显示经纬度，hash值，半径距离，结果以距离的降序排列GEORADIUSBYMEMBER city wuhan 3000 km withcoord withhash withdist count 3 desc1) 1) \"beijing\" 2) \"1049.6601\" 3) (integer) 4069152897912916 4) 1) \"116.49902611970901489\" 2) \"39.85915559490933191\"2) 1) \"guangzhou\" 2) \"858.8102\" 3) (integer) 4046518432493551 4) 1) \"113.35693091154098511\" 2) \"22.91792342803383775\"3) 1) \"jinan\" 2) \"703.7194\" 3) (integer) 4065887515903236 4) 1) \"117.15820580720901489\" 2) \"36.45663716057446635\" 6、查看附件的地址(通过经纬度)GEORADIUSBYMEMBER city wuhan 3000 km withcoord withhash withdist count 3 desc 把上面的wuhan元素替换成经经纬度即可： GEORADIUS city 114.3052500000 30.5927600000 3000 km withcoord withhash withdist count 3 desc","link":"/2020/07/24/redis/Redis%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AEGEO/"},{"title":"Redis单线程怎样处理高并发？","text":"Redis单线程怎样处理高并发？一、阻塞IO和非阻塞IO怎样理解阻塞IO,非阻塞IO,同步和异步 ：https://www.zhihu.com/question/19732473 Java 在 JDK1.4 中引入 NIO，但是也有很多人在使用阻塞 IO，这两种 IO 有什么区别？ 在阻塞模式下，如果你从数据流中读取不到指定大小的数据两，IO 就会阻塞。比如已知会有 10 个字节 发送过来，但是我目前只收到 4 个，还剩六个，此时就会发生阻塞。如果是非阻塞模式，虽然此时只收 到 4 个字节，但是读到 4 个字节就会立即返回，不会傻傻等着，等另外 6 个字节来的时候，再去继续读 取。 所以阻塞 IO 性能低于 非阻塞 IO。 如果有一个 Web 服务器，使用阻塞 IO 来处理请求，那么每一个请求都需要开启一个新的线程；但是如 果使用了非阻塞 IO，基本上一个小小线程池就够用了，因为不会发生阻塞，每一个线程都能够高效利 用。 二、Redis的线程模型首先一点，Redis 是单线程。单线程如何解决高并发问题的？实际上，能够处理高并发的单线程应用不仅仅是 Redis，除了 Redis 之外，还有 NodeJS、Nginx 等等 也是单线程。 Redis 虽然是单线程，但是运行很快，主要有如下几方面原因： Redis 中的所有数据都是基于内存的，所有的计算也都是内存级别的计算，所以快。 Redis 是单线程的，所以有一些时间复杂度高的指令，可能会导致 Redis 卡顿，例如 keys。 Redis 在处理并发的客户端连接时，使用了非阻塞 IO 在使用非阻塞 IO 时，有一个问题，就是线程如何知道剩下的数据来了？ https://www.jianshu.com/p/6a6845464770 这里就涉及到一个新的概念叫做多路复用，本质上就是一个事件轮询 API。 Redis 会给每一个客户端指令通过队列来排队进行顺序处理。 Redis 做出响应时，也会有一个响应的队列。","link":"/2020/07/24/redis/Redis%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%A4%84%E7%90%86%E9%AB%98%E5%B9%B6%E5%8F%91/"},{"title":"Redis正确安装的几种姿势","text":"Redis正确安装的几种姿势一、在线体验RedisRedis官网 http://try.redis.io/ ####二、直接编译安装 1、准备gcc环境 基于c++1yum install gcc-c++ 2、下载安装Redis12345678910#下载安装包wget http://download.redis.io/releases/redis-5.0.8.tar.gz#解压tar -zxvf redis-5.0.8.tar.gz #切换到解压目录cd redis-5.0.8#编译make#安装make install 3、启动Redis1redis-server redis.conf 4、后台启动Redis1234#修改安装目录下的 redis.conf文件daemonize no 变更为: daemonize yes #保存退出，再次启动redis-server redis.conf 5、关闭redis①redis-cli shutdown②kill -9 ‘pid’12#搜索到该进程 强行关闭ps -ef|grep redis 6、redis外网访问并设置永久密码修改redis.conf文件 12345bind 127.0.0.1注释掉，即变更为：#bind 127.0.0.1#去掉保护模式(有密码时无需设置)protected-mode yes 修改为 protected-mode no #设置永久密码(默认无需密码)#requirepass footbared 修改为 requirepass 自己的密码 7、进入命令行1redis-cli -a '密码' 三、docker安装(推荐方式)1、镜像安装与容器创建1234//拉取镜像docker pull redis//创建容器 --requirepass 123 设置密码123docker run -d -p 6379:6379 --restart=always --name myredis 镜像名 --requirepass 123 2、查看redis版本docker exec -it 9a7d1cf2c234 redis-cli -v //查看版本 3、修改redis密码（临时，重启失效）①进入redis管理页面不带密码进入（进入后需验证）==&gt; docker exec -it 9a7d1cf2c234 redis-cli //进入redis管理界面 带密码进入（进入后无需验证）==&gt; docker exec -it 9a7d1cf2c234 redis-cli -a '密码' //带密码进入管理界面 ②查询密码config get requirepass //查看密码(初始为空) ③设置密码config set requirepass 密码 //设置密码 ④验证密码auth 密码 //验证密码才能够进行查询密码和设置密码等操作 4、redis-cli连接docker上的redis①宿主机上的客户端(redis-cli)连接docker中的服务端1redis-cli -a '密码' ②进入docker容器中操作服务端1docker exec -it 9a7d1cf2c234 redis-cli 四、直接安装centos:1yum insatll redis ubuntu:1apt-get install redis mac:1brew install redis","link":"/2020/07/24/redis/Redis%E5%AE%89%E8%A3%85%E6%96%B9%E5%BC%8F/"},{"title":"Jedis和Letture客户端连接Redis","text":"Jedis和Letture客户端连接Redis一、JedisJedis官网地址： https://github.com/xetorthio/jedis 基本配置使用①、pom.xml1234567&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt; ②、简单的配置12345678910111213141516171819public class MyJedis { public static void main(String[] args) {// 1、构造一个jedis对象，并设置端口（默认6379） Jedis jedis=new Jedis(\"47.96.141.44\",6379);// 2、密码验证 jedis.auth(\"你的密码\");// 3、测试是否连接成功 String ping = jedis.ping();// 输出pong 表示连接成功 System.out.println(ping);// 在jedis中，操作键值的方法和在Redis命令行中的api完成一致。这里不再过多赘述// jedis.set()// jedis.zadd()// jedis.hset()// jedis.lpush()// jedis.sadd() }} ②、连接池配置在实际应用中，Jedis 实例我们一般都是通过连接池来获取，由于 Jedis 对象不是线城安全的，所以，当我们使用 Jedis 对象时，从连接池获取 Jedis，使用完成之后，再还给连接池。 12345678910111213141516171819 public static void main(String[] args) { Jedis jedis=null;// 1、构造一个jedis连接池 JedisPool pool = new JedisPool(\"47.96.141.44\", 6379);// 2、从连接池中获取一个jedis连接 jedis = pool.getResource(); try {// 3、jedis测试连接操作 String ping = jedis.ping(); System.out.println(ping); } catch (Exception e) { e.printStackTrace(); } finally {// 4、归还连接 if (jedis!=null) { jedis.close(); } } } try语法糖的使用： 这里我们使用一个语法糖，只是一种简写的方式，编译最后其实还是转为try-catch-finally的形式 1234567891011public static void main(String[] args) {// 1、构造一个jedis连接池 JedisPool pool = new JedisPool(\"47.96.141.44\", 6379);// 2、从连接池中获取一个jedis连接 try(Jedis jedis = pool.getResource()){// 认证密码 jedis.auth(\"你的密码\"); String ping=jedis.ping(); System.out.println(ping); } } 最后的编译的文件 1234567891011121314151617181920212223242526public static void main(String[] args) { JedisPool pool = new JedisPool(\"47.96.141.44\", 6379); Jedis jedis = pool.getResource(); Throwable var3 = null; try { jedis.auth(\"你的密码\"); String ping = jedis.ping(); System.out.println(ping); } catch (Throwable var12) { var3 = var12; throw var12; } finally { if (jedis != null) { if (var3 != null) { try { jedis.close(); } catch (Throwable var11) { var3.addSuppressed(var11); } } else { jedis.close(); } } } } ③、对连接池的改进，实现强约束 CallWithJedis 123public interface CallWithJedis { void call(Jedis jedis);} Redis 12345678910111213141516171819202122232425262728293031public class Redis { private JedisPool jedisPool; public Redis() {// 连接池配置对象 GenericObjectPoolConfig config=new GenericObjectPoolConfig();// 连接池最大空闲数 config.setMaxIdle(300);// 最大连接数 config.setMaxTotal(1000);// 连接最大等待时间（毫秒）。-1表示无限制 config.setMaxWaitMillis(30000);// 在空闲时检查有效性 config.setTestOnBorrow(true); /** * 1、连接池配置 * 2、redis地址 * 3、端口 * 4、超时时间 * 5、密码 */ jedisPool = new JedisPool(config, \"47.96.141.44\",6379,30000,\"你的密码\"); } public void execute(CallWithJedis callWithJedis) { try (Jedis jedis=jedisPool.getResource()) { callWithJedis.call(jedis); } }} 测试使用： 1234567891011public class JedisPoolUtil { public static void main(String[] args) {// 初始化连接池 Redis redis=new Redis();// 完成jedis的获取，并执行实现 redis.execute(jedis -&gt; { String ping = jedis.ping(); System.out.println(ping); }); }} 二、Lettureletture官网地址：https://github.com/lettuce-io/lettuce-core 基本配置使用①、pom.xml12345&lt;dependency&gt; &lt;groupId&gt;io.lettuce&lt;/groupId&gt; &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt; &lt;version&gt;5.1.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; ②、使用1234567891011public class LettuceTest { public static void main(String[] args) {// 注意这里的redis密码可以写在url地址中 RedisClient redisClient = RedisClient.create(\"redis://你的密码@47.96.141.44\"); StatefulRedisConnection&lt;String, String&gt; connect = redisClient.connect(); RedisCommands&lt;String, String&gt; sync = connect.sync(); sync.set(\"name\", \"lc\"); String s = sync.get(\"name\"); System.out.println(s); }} 三、Jedis和Lettuce的比较共同点：Lettuce和Jedis的定位都是Redis的cilent,所以他们当然可以直接连接redis server 不同点：①应用场景Jedis：是Redis的Java实现客户端，提供了比较全面的Redis命令的支持。使用阻塞的I/O，且其方法调用都是同步的，程序流需要等到sockets处理完I/O才能执行，不支持异步。Jedis客户端实例不是线程安全的，所以需要通过连接池来使用Jedis。 Lettuce：高级Redis客户端，用于线程安全同步，异步和响应使用，支持集群，Sentinel，管道和编码器。 基于Netty框架的事件驱动的通信层，其方法调用是异步的。Lettuce的API是线程安全的，所以可以操作单个Lettuce连接来完成各种操作。主要在一些分布式缓存框架上使用比较多。 ②线程安全Jedis：在实现上是直接连接的Redis Server，如果在多线程环境下是非线程安全的。每个线程都去拿自己的 Jedis 实例，当连接数量增多时，资源消耗阶梯式增大，连接成本就较高了。 解决方式: 使用连接池，为每个Jedis实例增加物理连接 Lettuce： Lettuce的连接是基于Netty的，连接实例（StatefulRedisConnection）可以在多个线程间并发访问，应为StatefulRedisConnection是线程安全的，所以一个连接实例（StatefulRedisConnection）就可以满足多线程环境下的并发访问，当然这个也是可伸缩的设计，一个连接实例不够的情况也可以按需增加连接实例。 总结1、Jedis 在实现的过程中是直接连接 Redis 的，在多个线程之间共享一个 Jedis 实例，这是线程不安全的，如果想在多线程场景下使用 Jedis，就得使用连接池，这样，每个线程都有自己的 Jedis 实例。 2、Lettuce 基于目前很火的 Netty NIO 框架来构建，所以克服了 Jedis 中线程不安全的问题，Lettuce 支持同步、异步 以及 响应式调用，多个线程可以共享一个连接实例。","link":"/2020/07/24/redis/Redis%E7%9A%84java%E5%AE%A2%E6%88%B7%E7%AB%AF/"},{"title":"Redis通信协议","text":"Redis通信协议Redis 通信使用了文本协议，文本协议比较费流量，但是 Redis 作者认为数据库的瓶颈不在于网络流 量，而在于内部逻辑，所以采用了这样一个费流量的文本协议。这个文本协议叫做 Redis Serialization Protocol，简称 RESP。 Redis 协议将传输的数据结构分为 5 种小单元，单元结束时，加上回车换行符 \\r\\n。 单行字符串以 + 开始，例如 +javaboy.org\\r\\n 多行字符串以$ 开始，后面加上字符串长度，例如 $11\\r\\njavaboy.org\\r\\n 整数值以: 开始，例如 :1024\\r\\n 错误消息以 - 开始 数组以 * 开始，后面加上数组长度。 需要注意的是，如果是客户端连接服务端，只能使用第 5 种 一、修改redis.conf配置文件为了方便客户端连接 Redis，我们关闭 Redis 种的保护模式(在 redis.conf 文件中) 注释无需密码 1#requirepass xxx 关闭保护模式 1protected-mode no 二、自定义redis客户端操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110package org.lc.resp;import org.omg.CORBA.PUBLIC_MEMBER;import java.io.IOException;import java.net.Socket;import java.util.Scanner;import java.util.logging.Level;/** * @BelongsProject: resp * @BelongsPackage: org.lc.resp * @Author: lc * @CreateTime: 2020-05-01 12:07 * @Description: */public class LcRedisClient { private Socket socket; public LcRedisClient() { try { socket = new Socket(\"主机\", 6379); } catch (IOException e) { e.printStackTrace(); System.out.println(\"Redis连接失败\"); } } /** * 定义set命令，该命令为数组形式[set,key,value] * @param key * @param value * @return */ public String set(String key, String value) throws IOException { StringBuilder sb=new StringBuilder();// 该数组命令的长度为3 sb.append(\"*3\") .append(\"\\r\\n\")// 插入多行字符串 .append(\"$\")// 并设置字符串长度 .append(\"set\".length()) .append(\"\\r\\n\") .append(\"set\") .append(\"\\r\\n\")// 插入多行字符串 .append(\"$\")// 传入key的长度 若为中文则需要使用byte数组获取长度 .append(key.getBytes().length) .append(\"\\r\\n\") .append(key) .append(\"\\r\\n\")// 插入多行字符串 .append(\"$\")// 设置长度 .append(value.getBytes().length) .append(\"\\r\\n\") .append(value) .append(\"\\r\\n\"); System.out.println(sb.toString());// 写入socket socket.getOutputStream().write(sb.toString().getBytes()); byte[] buf = new byte[1024];// 得到socket服务端返回的数据 socket.getInputStream().read(buf);// 返回服务端的数据 return new String(buf); } /** * 定义get命令 [get key] * @param key * @return */ public String get(String key) throws IOException { StringBuilder sb=new StringBuilder();// 定义数组命令数组长度 sb.append(\"*2\") .append(\"\\r\\n\") .append(\"$\") .append(\"get\".length()) .append(\"\\r\\n\") .append(\"get\") .append(\"\\r\\n\") .append(\"$\") .append(key.getBytes().length) .append(\"\\r\\n\") .append(key) .append(\"\\r\\n\"); System.out.println(sb.toString()); socket.getOutputStream().write(sb.toString().getBytes()); byte[] but = new byte[1024]; socket.getInputStream().read(but); return new String(but); } public static void main(String[] args) { LcRedisClient redisClient=new LcRedisClient(); try {// String set = redisClient.set(\"k1\", \"louchen\");// System.out.println(set); String s = redisClient.get(\"k1\"); Systedm.out.println(s); } catch (IOException e) { e.printStackTrace(); } }} 输出结果分析： set操作 1234567891011*3$3set$2k1$7louchen//以上为在stringbuilder拼接的命令+OK//以上为服务端输出的结果 get操作 1234567891011*2$3get$2k1//以上为在stringbuilder拼接的命令$7louchen//get操作返回两个命令。$7表示返回多行字符串并指定长度","link":"/2020/07/24/redis/Redis%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"},{"title":"sprinboot与mongodb构建restful风格","text":"sprinboot与mongodb构建restful风格所有的请求模式和jpa构建的restful一致 1、pom.xmlspring-boot-starter-data-rest spring-boot-starter-data-mongodb 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;jpa-rest&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;jpa-rest&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-rest&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、实体bean12345678@Setter@Getter@ToStringpublic class Book { private Integer id; private String name; private String author;} 3、dao接口配置123public interface BookDao extends MongoRepository&lt;Book,Integer&gt; {} 4、yaml配置1234567891011spring: data: mongodb: # mongodb每个库都有自己的认证方式 authentication-database: lc username: root password: 你的密码 port: 27017 database: lc uri: mongodb://root:你的密码@47.96.141.44:27017/lc# host: 47.96. 5、接口测试1、添加数据post: http://localhost:8080/books 123456789101112{ \"name\": \"曹雪芹\", \"author\": \"红楼梦\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/books/1\" }, \"book\": { \"href\": \"http://localhost:8080/books/1\" } }} 2、查询所有get: http://localhost:8080/books 123456789101112131415161718192021222324252627282930313233{ \"_embedded\": { \"books\": [ { \"name\": \"曹雪芹\", \"author\": \"红楼梦\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/books/1\" }, \"book\": { \"href\": \"http://localhost:8080/books/1\" } } } ] }, \"_links\": { \"self\": { \"href\": \"http://localhost:8080/books{?page,size,sort}\", \"templated\": true }, \"profile\": { \"href\": \"http://localhost:8080/profile/books\" } }, \"page\": { \"size\": 20, \"totalElements\": 1, \"totalPages\": 1, \"number\": 0 }}","link":"/2020/07/24/restful/mongodb%E6%9E%84%E5%BB%BArestful%E9%A3%8E%E6%A0%BC/"},{"title":"是否担心配置文件被盗获取密码？","text":"SpringBoot配置文件加密​ 当我们在发布项目部署的时候，是否会发现配置文件被暴露在环境中，且配置文件里面的密码为明文，这样非常不安全。 例如： 123456789101112spring: datasource: driver-class-name: com.mysql.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource username: root #明文 不安全 password: 123456 redis: database: 0 #明文 不安全 password: 123456 port: 6379 这是我们需要一个加密组件jasypt-spring-boot 一、引入组件依赖123456&lt;!--配置文件加密--&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.ulisesbocchio&lt;/groupId&gt; &lt;artifactId&gt;jasypt-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt;&lt;/dependency&gt; 二、加入加密密钥(盐)我们在application.yaml中加入以下配置 123jasypt: encryptor: password: louchen 可以理解为jasypt会使用这个自定义加密密钥，对配置文件里的重要项进行加密。 三、加密测试使主配置类实现CommandLineRunner接口,在启动程序时输出指定内容 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@SpringBootApplicationpublic class VrhApplication implements CommandLineRunner { @Autowired private ApplicationContext appCtx @Autowired private StringEncryptor stringEncryptor; public static void main(String[] args) { SpringApplication.run(VrhApplication.class, args); } @Override public void run(String... args) throws Exception { //读取配置文件 Environment environment = appCtx.getBean(Environment.class); // 首先获取配置文件里的原始明文信息 String mysqlOriginPswd = environment.getProperty(\"spring.datasource.password\"); String redisOriginPswd = environment.getProperty(\"spring.redis.password\"); String mysqlencrypt = encrypt(mysqlOriginPswd); System.out.println(\"加密:\"+mysqlOriginPswd+\"&gt;&gt;&gt;&gt;&gt;密文:\"+ mysqlencrypt); System.out.println(\"解密:&gt;&gt;&gt;&gt;&gt;明文:\"+decrypt(mysqlencrypt)); System.out.println(\"----------------\"); String redisencrypt = encrypt(redisOriginPswd); System.out.println(\"加密:\"+mysqlOriginPswd+\"&gt;&gt;&gt;&gt;&gt;密文:\"+ redisencrypt); System.out.println(\"解密:&gt;&gt;&gt;&gt;&gt;明文:\"+decrypt(redisencrypt)); } /** * 加密 * @param orginPws 明文 * @return */ private String encrypt(String orginPws){ return stringEncryptor.encrypt(orginPws); } /** *解密 * @param depryptPwd 密文 * @return */ private String decrypt(String depryptPwd){ return stringEncryptor.decrypt(depryptPwd); }} 四、修改配置文件替换明文123456789101112spring: datasource: driver-class-name: com.mysql.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource username: root #替换的密文 password: ENC(HRdQoZQEkagFOmHEFP3+FAPHasQJoxHmgezz559eMnBhGj2W1nj) redis: database: 0 #替换的密文 password: ENC(YJvMXx9L4h3dr3gPFr+lm1wA1WGTordEGSDhymm8YtnN43yReAp5udGy662) port: 6379 这里我们可以看出。在代码中使用时，jasypt-spring-boot组件会自动将ENC()语法包裹的配置项加密字段自动解密，数据得以还原。 五、加密密钥为什么在ENC()中，可以更改吗？自定义加密前缀12345jasypt: encryptor: property: prefix: lc( suffix: ) 再次修改application.yaml文件 123456789101112spring: datasource: driver-class-name: com.mysql.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource username: root #替换的密文 password: lc(HRdQoZQEkagFOmHEFP3+FAPHasQJoxHmgezz559eMnBhGj2W1nj) redis: database: 0 #替换的密文 password: lc(YJvMXx9L4h3dr3gPFr+lm1wA1WGTordEGSDhymm8YtnN43yReAp5udGy662) port: 6379 六、担心jasypt.encryptor.password设置的盐被泄露？我们的加密密钥放在配置application.yaml中难免有些不安全，这时我们可以使用自定义加密器 使用自定义加密器我们自自定义一个加密器配置类即可 123456789101112131415161718192021222324@Configurationpublic class ConfigEncryptBean { @Bean public StringEncryptor lcEncryptBean() { PooledPBEStringEncryptor encryptor=new PooledPBEStringEncryptor(); SimpleStringPBEConfig config=new SimpleStringPBEConfig();// 设置盐 config.setPassword(\"louchen\");// 设置加密算法 config.setAlgorithm(\"PBEWITHHMACSHA512ANDAES_256\");// 迭代次数 config.setKeyObtentionIterations(\"1000\");// 池的大小 config.setPoolSize(\"1\"); config.setProviderName(\"SunJCE\"); config.setSaltGeneratorClassName(\"org.jasypt.salt.RandomSaltGenerator\"); config.setIvGeneratorClassName(\"org.jasypt.iv.RandomIvGenerator\"); config.setStringOutputType(\"base64\"); encryptor.setConfig(config); return encryptor; }} 注意：上面bean的名字默认为方法名。我们可以使用@Bean注解更改bean的名称· 更改application.yaml 1234567# 加密配置jasypt: encryptor: property: prefix: lc( suffix: ) bean: lcEncryptBean 这是我们的密钥盐就在bean中，比较安全的防止别人获取盐 七、其他密钥设置方式方式一：直接作为程序启动时的命令行参数来带入 java -jar yourproject.jar --jasypt.encryptor.password=louchen 方式二：直接作为程序启动时的应用环境变量来带入 java -Djasypt.encryptor.password=louchen -jar yourproject.jar 方式三：甚至可以作为系统环境变量的方式来带入 比方说，我们提前设置好系统环境变量JASYPT_ENCRYPTOR_PASSWORD = louchen，则直接在Spring Boot的项目配置文件中做如下配置即可： jasypt.encryptor.password=${JASYPT_ENCRYPTOR_PASSWORD:} 这时候也会安全得多。","link":"/2020/07/24/springboot/SpringBoot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86/"},{"title":"springboot开发者工具及单元测试","text":"springboot开发者工具及单元测试一、使用devtools热部署1、idea与eclipse运行和编译的区别:①eclipse没有自动保存的功能，所有我们在使用eclipse时，保存之后，eclipse就进行编译了，点击运行就直接运行了，所以启动时，eclipse相对较快 ②idea是点击运行的时候，才进行编译，然后运行的。 2、使用热部署后，我们只需要点击编译，项目即重新编译运行。3、热部署默认只会对类的修改进行重新编译，对静态资源无效①配置静态资源的热部署任选一种即可 1234567spring: devtools: restart:# 包含能够热部署的位置 （需要从src下进行配置） additional-paths: src/main/resources/static# 排除默认配置中不能热部署的位置# exclude: classpath:/static/** pom.xmlspring-boot-devtools 123456789101112131415161718192021222324252627&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;!--只在运行时有效--&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;!--防止devtools传递到其他模块 即修改该类时，引用该模块的不需要动态更新--&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 4、使用liveReload插件动态更新静态资源google下载liveReload插件 这里我们禁用了只要修改文件就自动编译。而是我们修改之后去手动点击编译。 修改静态文件后==&gt; 点击编译==&gt;点击浏览器liveReload即可动态刷新页面 禁止自动更新页面: 1234spring: devtools: livereload: enabled: false 5、禁用热部署（如果pom中有此依赖）1234spring: devtools: restart: enabled: false 或者==&gt; 123456789@SpringBootApplicationpublic class JpaRestApplication { public static void main(String[] args) { System.setProperty(\"spring.devtools.restart.enabled\", \"false\"); SpringApplication.run(JpaRestApplication.class, args); }} 6、使用触发文件进行重启1234spring: devtools: restart: trigger-file: .trigger-file 在resources下新建一个名为.trigger-file.txt的文件==&gt; 当类修改时，编译不会重启，修改.trigger-file.txt ，再点击编译 ，即可重启 当类没有修改时，编译不会重启，修改.trigger-file.txt，再点击编译，也不会重启 7、使用全局触发文件当我们使用微服务的时候，只要引用了该修改的模块的都重新加载 在我们当前用户下新建一个 .spring-boot-devtools.properties 文件==&gt; 1spring.devtools.restart.trigger-file=.trigger-file 在resources下新建一个 .trigger-file 文件==&gt; 修改此内容则全局更新引用了该模块的内容 二、springboot中使用单元测试1、基本配置①pom.xml12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; ②Test@RunWith(SpringRunner.class): 使用junit4测试 @SpringBootTest(classes = JpaRestApplication.class) ： 找到主程序 在springboot我们可以省略指定主程序，springboo自动帮我们寻找主程序 @SpringBootTest即可 123456789101112@RunWith(SpringRunner.class)@SpringBootTest(classes = JpaRestApplication.class)class JpaRestApplicationTests { @Autowired private BookService bookService; @Test void contextLoads() { bookService.hello(); }} 2、对接口进行测试①使用MockMVcbean==&gt; 12345678@Setter@Getter@ToStringpublic class Book { private Integer id; private String name; private String author;} controller==&gt; 12345678910111213@RestControllerpublic class HelloController { @GetMapping(\"/hello\") public String hello(String name){ return \"hello\"+name; } @PostMapping(\"/book\") public Book addBook(@RequestBody Book book) { return book; }} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465@RunWith(SpringRunner.class)@SpringBootTest(classes = JpaRestApplication.class)//开启MockMvc自动配置@AutoConfigureMockMvcclass JpaRestApplicationTests { @Autowired WebApplicationContext webApplicationContext; @Autowired MockMvc mockMvc;// 每次只需test方法之前 初始化MockMvc @Before public void before() { mockMvc = MockMvcBuilders.webAppContextSetup(webApplicationContext).build(); } @Test void test1() throws Exception { MvcResult mvcResult = mockMvc.perform(// get请求地址 MockMvcRequestBuilders.get(\"/hello\") //请求头类型 .contentType(MediaType.APPLICATION_FORM_URLENCODED)// 请求参数 .param(\"name\", \"lccc\"))// 期望的结果 .andExpect(MockMvcResultMatchers.status().isOk())// 对结果的处理 打印 .andDo(MockMvcResultHandlers.print())// 返回该对象 .andReturn();// 从结果的响应 打印 System.out.println(mvcResult.getResponse().getContentAsString()); } @Test void test2() throws Exception { Book book=new Book(); book.setId(1); book.setAuthor(\"罗贯中\"); book.setName(\"三国演义\"); //对象转为字符串形式的json String s = new ObjectMapper().writeValueAsString(book); MvcResult mvcResult = mockMvc.perform( //post请求 MockMvcRequestBuilders.post(\"/book\")// 设置请求头类型 .contentType(MediaType.APPLICATION_JSON)// 内容 .content(s))// 期望的目标 .andExpect(MockMvcResultMatchers.status().isOk())// 返回结果 .andReturn(); MockHttpServletResponse response = mvcResult.getResponse();// 设置编码 response.setCharacterEncoding(\"UTF-8\"); System.out.println(response.getContentAsString()); }} ②使用RestTemplate此方法不需要开启主程序 他默认帮我们启动了一个servlet为已定义的端口 123456789101112131415161718@RunWith(SpringRunner.class)//使用环境中确定的端口@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.DEFINED_PORT)class TestTemplate { @Autowired private TestRestTemplate restTemplate; @Test public void test() { /**\"/hello?name={1}\" 请求的地址 * String.class 响应的类型 * \"lcccc\" 参数 */ String lcccc = restTemplate.getForObject(\"/hello?name={1}\", String.class, \"lcccc\"); System.out.println(lcccc); }} 3、json测试……","link":"/2020/07/24/springboot/springboot%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"},{"title":"Spring-Security使用JSON登录","text":"SpringSecurity 整合JSON登录1、pom.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;springsecurity-json&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;springsecurity-json&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、yaml配置临时的用户名密码配置 12345spring: security: user: name: lc password: 123 3、核心配置①自定义认证过滤器在这里我们只是扩展UsernamePasswordAuthenticationFilter的attemptAuthentication获得用户名和参数的规则 123456789101112131415161718192021222324252627282930313233343536373839public class MyAuthenticationFilter extends UsernamePasswordAuthenticationFilter { @Override public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {// 若为非post请求 if (!request.getMethod().equals(\"POST\")) { throw new AuthenticationServiceException(\"Authentication method not supported: \" + request.getMethod()); }// 如果是以json形式的登录方式 if (request.getContentType().equals(MediaType.APPLICATION_JSON_VALUE)) {// 有body的才有流，能够用流去解析 。get和delete没有流 String username = null; String password = null; try {// 从请求流中获取 参数对象 Map&lt;String,String&gt; map = new ObjectMapper().readValue(request.getInputStream(), Map.class); username = map.get(\"username\"); password = map.get(\"password\"); } catch (IOException e) { e.printStackTrace(); } if (username == null) { username = \"\"; } if (password == null) { password = \"\"; } username = username.trim(); UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(username, password); this.setDetails(request, authRequest); return this.getAuthenticationManager().authenticate(authRequest); }// 以key value形式 return super.attemptAuthentication(request, response); }} ②Security配置123456789101112131415161718192021222324252627282930313233343536@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .anyRequest().authenticated() .and()// 登录相关的都运行访问（这里的是默认的登录页） .formLogin().permitAll() .and() .csrf().disable(); http.addFilterAt(myAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class); } @Bean MyAuthenticationFilter myAuthenticationFilter() throws Exception { MyAuthenticationFilter filter = new MyAuthenticationFilter();// 自定义登录成功的处理方法 filter.setAuthenticationSuccessHandler(new AuthenticationSuccessHandler(){ @Override public void onAuthenticationSuccess(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication) throws IOException, ServletException { PrintWriter printWriter=httpServletResponse.getWriter(); httpServletResponse.setContentType(\"text/html\"); printWriter.write(\"hello\"); printWriter.flush(); printWriter.close(); } });// 失败的处理方法 //....... filter.setAuthenticationManager(authenticationManagerBean()); return filter; }} 4、controller12345678910@RestControllerpublic class HelloController { @GetMapping(\"/hello\") public String hello() { return \"hello securtiy\"; }} 5、接口请求测试经过以上的扩展配置，可同时支持post的key-value形式的请求登录和json形式的请求登录 ①key-value形式POST: http://localhost:8080/login content-type: x-www-form-urlencoded 请求参数==&gt; key:username value: lc key:password value:123 ②json形式POST: http://localhost:8080/login content-type: application/json 请求参数==&gt; 1234{ \"username\":\"lc\", \"password\":\"123\"}","link":"/2020/07/24/springsecurity/Spring-Security%E4%BD%BF%E7%94%A8JSON%E7%99%BB%E5%BD%95/"},{"title":"SpringSecurity项目使用总结","text":"SpringSecurity项目使用总结一、在SpringSecurity中获取和设置的登录用户信息在任何地方获取和设置用户登录信息 直接注入Authentication对象 通过getPrincipal()获取用户信息 1234@GetMapping(\"/hr/info\")public Hr getCurrentHr(Authentication authentication) { return ((Hr) authentication.getPrincipal());} SecurityContextHolder.getContext().getAuthentication() 是一个静态方法，也就是利用这个方法，我们可以随时随地拿到用户信息（需要注意 ThreadLocal 的限制），即当前获取的不能为其他线程或子线程，必须为当前的本地线程 获取用户信息： 1Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); 设置用户信息： authResult为Authentication对象 SecurityContextHolder.getContext().setAuthentication(authResult); 123456 @PutMapping(\"/hr/info\")//这里直接注入Authentication public ResponseBean updateHr(@RequestBody Hr hr,Authentication authentication){ SecurityContextHolder.getContext().setAuthentication(new UsernamePasswordAuthenticationToken(hr,authentication.getCredentials(),authentication.getAuthorities())); } 二、SpringSecurity登录流程","link":"/2020/07/24/springsecurity/SpringSecurity%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98/"},{"title":"WebSocket和Socket初识","text":"一、WebSocket和Socket的区别​ 由计算机网络知识我们可以知道，软件通信有七层结构，下三层结构偏向与数据通信，上三层更偏向于数据处理，中间的传输层则是连接上三层与下三层之间的桥梁，每一层都做不同的工作，上层协议依赖与下层协议。基于这个通信结构的概念。 1、Socket 其实并不是一个协议，是应用层与 TCP/IP 协议族通信的中间软件抽象层，它是一组接口。当两台主机通信时，让 Socket 去组织数据，以符合指定的协议。TCP 连接则更依靠于底层的 IP 协议，IP 协议的连接则依赖于链路层等更低层次。 2、WebSocket 则是一个典型的应用层协议。 总的来说：Socket 是传输控制层协议，WebSocket 是应用层协议。 二、什么是WebSocket​ WebSocket是一种在单个TCP连接上进行全双工通信的协议。WebSocket通信协议于2011年被IETF定为标准RFC 6455，并由RFC7936补充规范。WebSocket API也被W3C定为标准。 ​ WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。—-百度百科 WebSocket 是独立的、创建在 TCP 上的协议。 Websocket 通过HTTP/1.1 协议的101状态码进行握手。 为了创建Websocket连接，需要通过浏览器发出请求，之后服务器进行回应，这个过程通常称为“握手” 1、什么是全双工通信和半双工通信？①单工通信 ​ 单工通信，是指消息只能单方向传输的工作方式，只能有一个方向的通信而没有反方向的交互； ​ 在单工通信中，通信的信道是单向的，发送端与接收端也是固定的，即发送端只能发送信息，不能接收信息；接收端只能接收信息，不能发送信息，基于这种情况，数据信号从一端传送到另外一端，信号流是单方向的；举例：电视、广播 ②半双工通信 ​ 半双工通信是指数据可以沿两个方向传送，但同一时刻一个半双工总线结构信道只允许单方向传送，因此又被称为双向交替通信 ​ 半双工通信可以实现双向的通信，但不能在两个方向上同时进行，必须轮流交替地进行， ​ 在这种工作方式下，发送端可以转变为接收端；相应地，接收端也可以转变为发送端。但是在同一个时刻，信息只能在一个方向上传输，因此也可以将半双工通信理解为一种切换方向的单工通信；举例：对讲机 ③全双工通信 ​ 全双工通信称为双向同时通信，即通信的双方可以同时发送和接收信息的信息交互方式； ​ 全双工通信是指在通信的任意时刻，线路上存在A到B和B到A的双向信号传输，全双工通信允许数据同时在两个方向上传输，又称为双向同时通信，即通信的双方可以同时发送和接收数据， ​ 在全双工方式下，通信系统的每一端都设置了发送器和接收器，因此，能控制数据同时在两个方向上传送；举例：电话通讯 三、为什么需要WebSocket？​ 初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？ ​ 答案很简单，因为 HTTP 协议有一个缺陷：通信只能由客户端发起。 举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。 ​ 这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用”轮询”：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。 ​ 现在，很多网站为了实现推送技术，所用的技术都是 Ajax 轮询。轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。 ​ 轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。因此，工程师们一直在思考，有没有更好的方法。WebSocket 就是这样发明的。 ​ HTML5 定义的 WebSocket 协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。 ​ WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。 它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。 其他特点包括： （1）建立在 TCP 协议之上，服务器端的实现比较容易。 （2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。 （3）数据格式比较轻量，性能开销小，通信高效。 （4）可以发送文本，也可以发送二进制数据。 （5）没有同源限制，客户端可以与任意服务器通信。 （6）协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。 1ws://example.com:80/some/path 四、webSocket实例​ 为了建立一个 WebSocket 连接，客户端浏览器首先要向服务器发起一个 HTTP 请求，这个请求和通常的 HTTP 请求不同，包含了一些附加头信息，其中附加头信息”Upgrade: WebSocket”表明这是一个申请协议升级的 HTTP 请求，服务器端解析这些附加的头信息然后产生应答信息返回给客户端，客户端和服务器端的 WebSocket 连接就建立起来了，双方就可以通过这个连接通道自由的传递信息，并且这个连接会持续存在直到客户端或者服务器端的某一方主动的关闭连接。","link":"/2020/07/24/websocket/WebSocket%E7%AE%80%E4%BB%8B/"},{"title":"Springboot整合Shiro","text":"Springboot整合Shiro拦截器介绍 https://www.jianshu.com/p/54b573c7b4db https://blog.csdn.net/fenglixiong123/article/details/77119857 一、整合Shiro1、pom.xml shiro-spring shiro-web 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;springboot-shiro&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;springboot-shiro&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-web&lt;/artifactId&gt; &lt;version&gt;1.4.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.4.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、Realm配置12345678910111213141516public class MyRealm extends AuthorizingRealm { @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) { return null; } @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException { String username = (String) authenticationToken.getPrincipal(); if (\"lc\".equals(username)) { return new SimpleAuthenticationInfo(username, \"123\", getName()); } return null; }} 3、shiro配置123456789101112131415161718192021222324@Configurationpublic class ShrioConfig { @Bean Realm realm() { TextConfigurationRealm realm =new TextConfigurationRealm();// 设置用户和角色 realm.setUserDefinitions(\"lc=123,user \\n admin=123,admin\");// 设置角色权限 realm.setRoleDefinitions(\"admin=read,write \\n user=read\"); return realm; } @Bean ShiroFilterChainDefinition shiroFilterChainDefinition() { DefaultShiroFilterChainDefinition definition=new DefaultShiroFilterChainDefinition(); definition.addPathDefinition(\"/doLogin\", \"anon\"); definition.addPathDefinition(\"/**\", \"authc\"); return definition; }} 4、controller123456789101112131415161718192021222324252627@RestControllerpublic class LoginController { @GetMapping(\"/hello\") public String hello() { return \"hello shiro\"; } @GetMapping(\"/login\") public String login() { return \"please login!\"; } @PostMapping(\"/doLogin\") public void doLogin(String username,String password) { Subject subject = SecurityUtils.getSubject(); try { subject.login(new UsernamePasswordToken(username, password)); System.out.println(\"登录成功！\"); } catch (AuthenticationException e) { System.out.println(); System.out.println(\"登录失败！\"+e.getMessage()); } }} 二、spring-boot-starter 整合shrio1、pom.xmlshiro-spring-boot-web-starter 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;springbootstarter-shiro&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;springbootstarter-shiro&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring-boot-web-starter&lt;/artifactId&gt; &lt;version&gt;1.4.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、yaml配置1234567891011121314shiro: enabled: true unauthorizedUrl: /unauthorizedUrl web: enabled: true successUrl: /success loginUrl: /login # 就是每次请求是否支持把sessionid放在cookie中或者通过url携带sessionid# sessionManager:# 是否允许通过url实现会话跟踪# sessionIdUrlRewritingEnabled: true# 是否允许放在cookie中# sessionIdCookieEnabled: true 3、shiro配置123456789101112131415161718192021@Configurationpublic class ShrioConfig { @Bean Realm realm() { TextConfigurationRealm realm =new TextConfigurationRealm();// 设置用户和角色 realm.setUserDefinitions(\"lc=123,user \\n admin=123,admin\");// 设置角色权限 realm.setRoleDefinitions(\"admin=read,write \\n user=read\"); return realm; } @Bean ShiroFilterChainDefinition shiroFilterChainDefinition() { DefaultShiroFilterChainDefinition definition=new DefaultShiroFilterChainDefinition(); definition.addPathDefinition(\"/doLogin\", \"anon\"); definition.addPathDefinition(\"/**\", \"authc\"); return definition; }} 4、controller配置1234567891011121314151617181920212223242526@RestControllerpublic class LoginController { @GetMapping(\"/hello\") public String hello() { return \"hello shiro\"; } @GetMapping(\"/login\") public String login() { return \"please login!\"; } @PostMapping(\"/doLogin\") public void doLogin(String username,String password) { Subject subject = SecurityUtils.getSubject(); try { subject.login(new UsernamePasswordToken(username, password)); System.out.println(\"登录成功！\"); } catch (AuthenticationException e) { System.out.println(); System.out.println(\"登录失败！\"+e.getMessage()); } }}","link":"/2020/07/24/springsecurity/SpringBoot%E6%95%B4%E5%90%88Shiro/"},{"title":"Java注解基础","text":"一、什么是注解(Annotation)​ Java注解又称Java标注，是Java语言5.0版本开始支持加入源代码的特殊语法元数据。为我们在代码中添加信息提供了一种形式化的方法，使我们可以在稍后某个时刻非常方便的使用这些数据。​ Java语言中的类、方法、变量、参数和包等都可以被标注。和Javadoc不同，Java标注可以通过反射获取注解内容。在编译器生成类文件时，注解可以被嵌入到字节码中。Java虚拟机可以保留注解内容，在运行时可以获取到注解内容。 二、内置注解java 定义了一套注解，共有 7 个，3 个在 java.lang 中，剩下 4 个在 java.lang.annotation 中。 @Override: 限定重写父类方法, 该注解只能用于方法 @Deprecated: 用于表示所修饰的元素(类, 方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择 @SuppressWarnings: 抑制编译器警告 1、作用在代码的注解是 @Override - 检查该方法是否是重写方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。 @Deprecated - 标记过时方法。如果使用该方法，会报编译警告。 @SuppressWarnings - 指示编译器去忽略注解中声明的警告。 2、作用在其他注解的注解(或者说元注解)是: @Retention - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。 @Documented - 标记这些注解是否包含在用户文档中。 @Target - 标记这个注解应该是哪种 Java 成员。 @Inherited - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类) 3、从 Java 7 开始，额外添加了 3 个注解: @SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。 @FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。 @Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次。 三、元注解1、@Retention@Retention annotation指定标记注释的存储方式： RetentionPolicy.SOURCE - 标记的注释仅保留在源级别中，并由编译器忽略。 RetentionPolicy.CLASS - 标记的注释在编译时由编译器保留，即会生成class文件，但是不会加载到内存中。默认行为。 RetentionPolicy.RUNTIME - 标记的注释由JVM保留，会生成class文件，也会加载到内存中，可由反射获取。 2、@Documented@Documented 注释表明，无论何时使用指定的注释，都应使用Javadoc工具记录这些元素。（默认情况下，注释不包含在Javadoc中。）有关更多信息，请参阅 Javadoc工具页面。 3、@Target@Target 注释标记另一个注释，以限制可以应用注释的Java元素类型。目标注释指定以下元素类型之一作为其值 ElementType.TYPE 可以应用于类的任何元素。 ElementType.FIELD 可以应用于字段或属性。 ElementType.METHOD 可以应用于方法级注释。 ElementType.PARAMETER 可以应用于方法的参数。 ElementType.CONSTRUCTOR 可以应用于构造函数。 ElementType.LOCAL_VARIABLE 可以应用于局部变量。 ElementType.ANNOTATION_TYPE 可以应用于注释类型。 ElementType.PACKAGE 可以应用于包声明。 ElementType.TYPE_PARAMETER 表示该注解能写在类型变量的声明语 句中（如：泛型声明） ElementType.TYPE_USE 表示该注解能写在使用类型的任何语句中。如：变量修饰，异常修饰 4、@Inherited@Inherited 注释表明注释类型可以从超类继承。当用户查询注释类型并且该类没有此类型的注释时，将查询类的超类以获取注释类型（默认情况下不是这样）。此注解仅适用于类声明。 5、@RepeatableRepeatable Java SE 8中引入的，@Repeatable注释表明标记的注释可以多次应用于相同的声明或类型使用(即可以重复在同一个类、方法、属性等上使用)。 123456789@Inherited@Documented//用于类和方法上@Target({ElementType.TYPE,ElementType.METHOD})//运行时可获取@Retention(RetentionPolicy.RUNTIME)public @interface MyAnnotations { MyAnnotaion[] value();} 123456789101112@Inherited@Documented//用于类和方法上@Target({ElementType.TYPE, ElementType.METHOD})//运行时可获取@Retention(RetentionPolicy.RUNTIME)//声明当前注解为可重复注解@Repeatable(value = MyAnnotations.class)public @interface MyAnnotaion { //属性名value 属性类型String 默认值 hi String value() default \"hi\";} 1234567//jdk1.8之前使用多个相同注解的方式//@MyAnnotations({@MyAnnotaion(value = \"haha\"),@MyAnnotaion(value = \"xixi\")})//jdk.18之后使用重复注解的方式@MyAnnotaion(\"haha\")@MyAnnotaion(\"xixi\")public class Pserson {} 四、基本使用https://www.jianshu.com/p/a7bedc771204 1、使用于属性上123456@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface MyField { String descirption(); int length() default 2;} 123456public class Person { @MyField(descirption = \"姓名\",length = 20) private String name; @MyField(descirption = \"年龄\") private int age;} 12345678910111213141516171819public class Main { public static void main(String[] args) { //得到应用于注解上的Class类 Class personClass = Person.class; //获取运行时类的所有字段 Field[] declaredFields = personClass.getDeclaredFields(); for (Field field : declaredFields) { //判断该属性上是否有指定的注解 if (field.isAnnotationPresent(MyField.class)) { //获取当前属性的注解对象 MyField annotation = field.getAnnotation(MyField.class); //获得注解信息 //name,姓名,20 //age,年龄,2 System.out.println(field.getName()+\",\"+annotation.descirption()+\",\"+annotation.length()); } } }} 2、使用于类上12345@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)public @interface MyClass { String description();} 123@MyClass(description = \"人\")public class Person {} 1234567891011public class Main { public static void main(String[] args) { Class personClass = Person.class; //判断当前类是否有MyClass注解 if (personClass.isAnnotationPresent(MyClass.class)) { MyClass annotation = (MyClass) personClass.getAnnotation(MyClass.class); //人 System.out.println(annotation.description()); } }} 3、使用于方法上12345@Target(ElementType.METHOD)@Retention(RetentionPolicy.RUNTIME)public @interface MyMethod { String description();} 1234567891011public class Person{ @MyMethod(description = \"打招呼方法...\") public void say() { System.out.println(\"hello...\"); } @MyMethod(description = \"获取密码方法...\") public String getPassword() { return \"123456\"; }} 12345678910111213public class Main { public static void main(String[] args) throws IllegalAccessException, InstantiationException, InvocationTargetException { Class personClass = Person.class; Person person = ((Person) personClass.newInstance()); Method[] declaredMethods = personClass.getMethods(); for (Method method : declaredMethods) { if (method.isAnnotationPresent(MyMethod.class)) { MyMethod annotation = method.getAnnotation(MyMethod.class); System.out.println(method.invoke(person)+\"---\"+annotation.description()); } } }} 123hello...null---打招呼方法...123456---获取密码方法...","link":"/2020/07/24/javase/Java%E6%B3%A8%E8%A7%A3/"},{"title":"springboot整合JDBCTemplate及多数据源","text":"springboot整合JDBCTemplate源码分析==&gt; 当我们没有配置任何jdbcTemplate时，springboot自动为我们创建了一个jdbctemplate 当我们配置了jdbctemplate时候，自动配置失效 org.springframework.boot.autoconfigure.jdbc.JdbcTemplateConfiguration==&gt; 123456789101112131415161718192021@Configuration( proxyBeanMethods = false)@ConditionalOnMissingBean({JdbcOperations.class})class JdbcTemplateConfiguration { JdbcTemplateConfiguration() { } @Bean @Primary JdbcTemplate jdbcTemplate(DataSource dataSource, JdbcProperties properties) { JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); Template template = properties.getTemplate(); jdbcTemplate.setFetchSize(template.getFetchSize()); jdbcTemplate.setMaxRows(template.getMaxRows()); if (template.getQueryTimeout() != null) { jdbcTemplate.setQueryTimeout((int)template.getQueryTimeout().getSeconds()); } return jdbcTemplate; }} 12345678910111213public class JdbcTemplate extends JdbcAccessor implements JdbcOperations { private static final String RETURN_RESULT_SET_PREFIX = \"#result-set-\"; private static final String RETURN_UPDATE_COUNT_PREFIX = \"#update-count-\"; private boolean ignoreWarnings = true; private int fetchSize = -1; private int maxRows = -1; private int queryTimeout = -1; private boolean skipResultsProcessing = false; private boolean skipUndeclaredResults = false; private boolean resultsMapCaseInsensitive = false; //**** //****} 单数据源配置：pom.xml 1234567891011121314151617181920212223242526272829303132&lt;dependencies&gt; &lt;!-- test --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;!--只会在测试时使用 不会被打包--&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--jdbctemplate操作--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--阿里的starter--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.18&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;!--只会在项目运行和测试时有效 不会随着项目一起打包发布--&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;version&gt;5.1.27&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 12345678910111213spring:# 数据源配置 datasource:#数据源类型 type: com.alibaba.druid.pool.DruidDataSource# 驱动类 driver-class-name: com.mysql.jdbc.Driver# 数据库地址 url: jdbc:mysql://127.0.0.1:3306/test# 用户名 username: root# 密码 password: 123456 12345678public class User { private Integer id; private String username; private String address; //settter //getter //toStr·ing} 123456CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(20) DEFAULT NULL, `address` varchar(50) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8mb4; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960@Servicepublic class UserService { @Autowired private JdbcTemplate jdbcTemplate; /** * 添加操作 * @param user * @return */ public Integer addUser(User user){ return jdbcTemplate.update(\"insert into user(username,address) values(?,?)\", user.getUsername(), user.getAddress()); } /** * 删除操作 * @param integer * @return */ public Integer deleteUser(Integer integer) { return jdbcTemplate.update(\"delete from user where id =?\", integer); } /** * 更新操作 * @param user * @return */ public Integer updateUser(User user) { return jdbcTemplate.update(\"update user set address=? where id=?\", user.getAddress(), user.getId()); } /** * 获取所有 并传递参数 * 一般属性名和数据库字段名不一致时手动设置值 * @return */ public List&lt;User&gt; getAllUser(User user){ return jdbcTemplate.query(\"select * from user where address =?\",new Object[]{user.getAddress()}, new RowMapper&lt;User&gt;() { @Override public User mapRow(ResultSet resultSet, int i) throws SQLException { User user=new User(); user.setId(resultSet.getInt(\"id\")); user.setUsername(resultSet.getString(\"username\")); user.setAddress(resultSet.getString(\"address\")); return user; } }); } /** * 属性名和数据库字段名一致的情况 * @param user * @return */ public List&lt;User&gt; getAllUserSameArgs(User user){ return jdbcTemplate.query(\"select * from user where address =?\", new Object[]{user.getAddress()}, new BeanPropertyRowMapper&lt;&gt;(User.class)); }} 测试使用： 123456789101112131415161718192021222324252627282930313233@SpringBootTest(classes = JDBCTemplateApplication.class)@RunWith(SpringRunner.class)public class JDBCTemplateTest { @Autowired private UserService userService; @Test public void test01() { User user=new User(); user.setUsername(\"张三\").setAddress(\"湖北孝感\"); Integer integer = userService.addUser(user); System.out.println(integer); } @Test public void test02() { Integer integer = userService.deleteUser(1); System.out.println(integer); } @Test public void test03() { Integer integer = userService.updateUser(new User().setId(1).setAddress(\"上海\")); System.out.println(integer); } @Test public void test04() { List&lt;User&gt; allUser = userService.getAllUserSameArgs(new User().setAddress(\"武汉\")); System.out.println(allUser); }} 多数据源配置：pom.xml和单数据源一致 这里注意，在yaml文件中，属性名的字母不要写大写，大写字母前加 - 后转小写 12345678910111213141516171819#配置多数据后，所有的数据源自动配置将会失效spring:#数据源1 datasourceone: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver #传输时 使用统一的utf-8编码 url: jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=UTF-8 username: root password: 123456#数据源2 datasourcetwo: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver #传输时 使用统一的utf-8编码 url: jdbc:mysql://47.96.141.44:3306/test?useUnicode=true&amp;characterEncoding=UTF-8 username: root password: xxxxxxx 数据源配置注入==&gt; 1234567891011121314151617@Configurationpublic class DataSourceConfig { @Bean //配置前缀和yaml中的属性对应，完成属性的安全注入 @ConfigurationProperties(prefix = \"spring.datasourceone\") public DataSource dataSourceOne(){ return DruidDataSourceBuilder.create().build(); } @Bean @ConfigurationProperties(prefix = \"spring.datasourcetwo\") public DataSource dataSourceTwo(){ return DruidDataSourceBuilder.create().build(); }} jdbcTemplate配置==&gt; @Autowired 默认按照类型进行注入``（多个或者找不到报错） @Qualifier 按照名称进行配置 一般是结合起来使用==&gt; 如： @Qualifier(“dataSourceOne”)@Autowiredprivate DataSource dataSourceOne @Resource 默认直接按照名称进行注入 （可同时指定name和type一起查找注入，也可都省略）注意@Resource不能存在于方法的参数上 如： @Resource(name = “dataSourceTwo”) DataSource dataSourceTwo; 123456789101112131415@Configurationpublic class JDBCTemplateConfig { @Bean public JdbcTemplate jdbcTemplateOne(@Qualifier(\"dataSourceOne\")DataSource dataSource){ return new JdbcTemplate(dataSource); } @Resource(name = \"dataSourceTwo\")DataSource dataSource; @Bean public JdbcTemplate jdbcTemplateTwo(){ return new JdbcTemplate(dataSource); }} 这里数据库的结构和实体两个数据源中的保持一致 先从数据源一查询一个用户，再把该用户插入另一个数据源==&gt; 12345678910111213141516171819202122@Servicepublic class UserToUserService { @Qualifier(\"jdbcTemplateOne\") @Autowired private JdbcTemplate jdbcTemplateOne; @Qualifier(\"jdbcTemplateTwo\") @Autowired private JdbcTemplate jdbcTemplateTwo; public Integer userToAddUser(User user) { List&lt;User&gt; list= jdbcTemplateOne.query(\"select * from user where id =?\", new Object[]{user.getId()}, new BeanPropertyRowMapper&lt;&gt;(User.class)); if(list!=null&amp;&amp;!list.isEmpty()&amp;&amp;list.size()==1){ User resUser = list.get(0); int update = jdbcTemplateTwo.update(\"insert into user(id,username,address) values (?,?,?)\", resUser.getId(), resUser.getUsername(), resUser.getAddress()); if(update==1){ return 1; } } return 0; }} 注意：当我们有多个数据源和多个jdbcTemplate配置的时候，我们在注入jdbctemplate的时候必须加限定名，即哪个jdbctemplate。 1234567@Servicepublic class UserService { @Qualifier(\"jdbcTemplateTwo\") @Autowired private JdbcTemplate jdbcTemplate;} 否则需要在数据源和jdbctemplate配置上加默认配置 即注解@Primary 1234567891011121314151617@Configurationpublic class DataSourceConfig { @Primary @Bean @ConfigurationProperties(prefix = \"spring.datasourceone\") public DataSource dataSourceOne(){ return DruidDataSourceBuilder.create().build(); } @Bean @ConfigurationProperties(prefix = \"spring.datasourcetwo\") public DataSource dataSourceTwo(){ return DruidDataSourceBuilder.create().build(); }} 1234567891011121314151617@Configurationpublic class JDBCTemplateConfig { @Primary @Bean public JdbcTemplate jdbcTemplateOne(@Qualifier(\"dataSourceOne\")DataSource dataSource){ return new JdbcTemplate(dataSource); } @Resource(name = \"dataSourceTwo\")DataSource dataSource; @Bean public JdbcTemplate jdbcTemplateTwo(){ return new JdbcTemplate(dataSource); }} 我们在使用时，直接注入即可（默认注入标记的默认数据源） 12345@Servicepublic class UserService { @Autowired private JdbcTemplate jdbcTemplate;} 注解@Autowired 默认按照类型进行注入（多个或者找不到报错） @Qualifier 按照名称进行配置 一般是结合起来使用==&gt; 如： @Qualifier(“dataSourceOne”)@Autowiredprivate DataSource dataSourceOne @Resource 默认直接按照名称进行注入 （可同时指定name和type一起查找注入，也可都省略）注意@Resource不能存在于方法的参数上 如： @Resource(name = “dataSourceTwo”)DataSource dataSourceTwo; @Primary当有多个配置文件时 标记为默认的注入配置","link":"/2020/07/24/multipledatasource/%E6%95%B4%E5%90%88JDBCTemplate%E5%8F%8A%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90/"},{"title":"Java泛型知识梳理","text":"java泛型详解一、概述：​ 泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。 ​ 泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。 二、 特性 123456789101112public static void main(String[] args) { List&lt;String&gt; stringArrayList = new ArrayList&lt;String&gt;(); List&lt;Integer&gt; integerArrayList = new ArrayList&lt;Integer&gt;(); //class java.util.ArrayList Class classStringArrayList = stringArrayList.getClass(); //class java.util.ArrayList Class classIntegerArrayList = integerArrayList.getClass(); if(classStringArrayList.equals(classIntegerArrayList)){ System.out.println(\"类型相同\"); }} 我们可以通过以上结果发现类型相同。在编译之后程序会采取去泛型化的措施。也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。 对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。 三、泛型的使用3.1泛型类声明形式： 123Class 类名称&lt;T,E,V...&gt;{ } 12345678910111213141516/** * 声明泛型参数类型必须在类后面声明。 * @param &lt;T&gt; 泛型参数T的类型 */public class Generics&lt;T&gt; { private T key; public Generics(T key) { this.key=key; } public T getKey() { return key; }} 使用： 12345678910111213141516171819202122232425/** * 声明泛型参数类型必须在类后面声明。 * @param &lt;T&gt; 泛型参数T的类型 */public class Generics&lt;T&gt; { private T key; public Generics(T key) { this.key=key; } public T getKey() { return key; } public static void main(String[] args) { Generics g1 = new Generics(2); Generics g2 = new Generics(\"hello\"); Generics g3 = new Generics(false); System.out.println(g1.getKey()); //2 System.out.println(g2.getKey()); //hello System.out.println(g3.getKey()); //false }} 如果不传入泛型类型实参的话，在泛型类中使用泛型的方法或成员变量定义的类型可以为任何的类型。 注意： 泛型的类型参数只能是类类型，不能是简单类型。 不能对确切的泛型类型使用instanceof操作。如下面的操作是非法的，编译时会出错。 12if(ex_num instanceof Generic&lt;Number&gt;){ } 3.2泛型接口泛型接口与泛型类的定义及使用基本相同。泛型接口常被用在各种类的生产器中 123public interface Generator&lt;T&gt; { T next();} ①实现泛型接口,未传入泛型实参：必须同时在实现类和接口类上同时声明T 123456public class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt; { @Override public T next() { return null; }} ②实现泛型接口,传入泛型实参接口类上声明实参类型String 123456public class FruitGenerator implements Generator&lt;String&gt; { @Override public String next() { return null; }} 3.3泛型通配符/泛型上下界①泛型通配符&lt;?&gt;反例： 123456789101112public class Generics&lt;T&gt; { private T key; public Generics(T key) { this.key=key; } public T getKey() { return key; }} 12345678910public class Test { public static void main(String[] args) { Generics&lt;Integer&gt; i = new Generics&lt;Integer&gt;(10); showKeyValue(i); //报错 } static void showKeyValue(Generics&lt;Number&gt; obj) { System.out.println(\"泛型值:\"+obj.getKey()); }} 尽管Integer继承Number，但是在泛型中同一种泛型T可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是不兼容的。 要使能够实现Number下的子类的泛型也能传入：Generics&lt;? extends Number&gt; obj 12345678910public class Test { public static void main(String[] args) { Generics&lt;Integer&gt; i = new Generics&lt;&gt;(10); showKeyValue(i); } static void showKeyValue(Generics&lt;? extends Number&gt; obj) { System.out.println(\"泛型值:\"+obj.getKey()); }} 类型通配符一般是使用 ?代替具体的类型实参，注意了，此处 ? 是类型实参，而不是类型形参 。 实际参数：String,Double,Integer... 形式参数：T,E,V... 当操作类型时，不需要使用类型的具体功能时，只使用Object类中的功能。那么可以用 ? 通配符来表未知类型。 ②泛型上下界&lt;? extends T&gt;：12345678910//泛型类public class Generics&lt;T extends Number&gt; { void showKeyValue(Generics&lt;T&gt; obj) { } //泛型方法 泛型方法独立于类，所以要重新声明泛型类型 public &lt;T extends Number&gt; T showKeyName(Generics&lt;T&gt; container,T t){ return t; }} ③泛型&lt;? extends T &gt;与 &lt;? super T&gt;区别https://www.jianshu.com/p/597a4ac3c6fa https://blog.csdn.net/lzufeng/article/details/83589665?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1 &lt;? extends T&gt;：不能存操作，只能取操作(T作为返回值) ，这叫get原则 &lt;? super T&gt;: 可以存(存T的子类)操作，取操作只能是用Object类型来接收,这叫put原则 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657class Human extends Animal {}class Coder extends Human {}class Fish extends Animal {}class Shark extends Fish {}class Carp extends Fish {}class Boat&lt;T&gt; { private T item; public Boat(T t) { item = t; } public void set(T t) { this.item=t; } public T get() { return item; }}public class Animal { public static void main(String[] args) {// &lt;? extends Fish&gt; 满足是Fish的子类 Boat&lt;? extends Fish&gt; fishBoat2 = new Boat&lt;Shark&gt;(new Shark()); //传的时候不确定，因为Fish的子类不确定。所有编译器不让 存操作// fishBoat2.set(new Shark()); //报错 //取出的时候，直接有父类Fish代替，因为传的任何类型都是Fish的子类。 Fish fish = fishBoat2.get();//-----------------------------------------------------------------------------------//----------------------------------------------------------------------------------- // &lt;? super Fish&gt; 满足是Fish的父类 Boat&lt;? super Fish&gt; fishBoat3=new Boat&lt;Animal&gt;(new Animal()); //存的时候，只能存Fish的子类。当然没问题。 fishBoat3.set(new Shark()); fishBoat3.set(new Carp()); //如果存的父类，父类有多个。所以编译器不让存父类的操作，可以存子类的操作// fishBoat3.set(new Animal()); //报错 //取的时候,取的是父类，父类不确定，所有只能用Object来接收返回值// Shark object = fishBoat3.get(); //报错 Object object = fishBoat3.get(); }} 3.4泛型方法泛型类： 是在实例化类的时候指明泛型的具体类型； 泛型方法： 是在调用方法的时候指明泛型的具体类型 。 ①声明泛型方法： 只有在方法中定义的泛型才能算是泛型方法，否则不算。即在方法中有 &lt;T,E....&gt; 泛型方法的类型只需在方法中定义即可 类中声明的泛型和方法中声明的泛型相互独立。无论名称是否相同。互不影响 12345public class Generics{ public &lt;T,E&gt; E getkey(E eKey,T tKey) { return eKey; }} 例如： 12345678910111213141516171819202122232425262728public class Generics&lt;T&gt; { private T key; public Generics(T key) { this.key=key; } //非泛型方法 public void showkey(T genericObj){ } //非泛型方法 public T getKey() { return key; } //非泛型方法 public void showKeyValue1(Generics&lt;Number&gt; obj){ } //非泛型方法 public void showKeyValue2(Generics&lt;?&gt; obj){ }// -------------------------------------------- //泛型方法// 只要在方法中声明&lt;T,K...&gt;泛型类型即为泛型方法，否则不是。 public &lt;T,K&gt; K showKeyName(Generics&lt;T&gt; container,K k){ return k; }} ②类中的泛型方法：123456789101112131415161718public class Fruit { @Override public String toString() { return \"fruit\"; }}class Apple extends Fruit{ @Override public String toString() { return \"apple\"; }}class Person{ @Override public String toString() { return \"Person\"; }} 1234567891011121314151617181920212223242526272829303132public class Generics&lt;T&gt; { //非泛型方法 public void show_1(T t){ System.out.println(t.toString()); } //泛型方法 泛型E独立于类中声明的泛型 public &lt;E&gt; void show_3(E t){ System.out.println(t.toString()); } //泛型方法 泛型T独立于类中声明的泛型T public &lt;T&gt; void show_2(T t){ System.out.println(t.toString()); } public static void main(String[] args) { Apple apple=new Apple(); Person person=new Person(); Generics&lt;Fruit&gt; fruitGenerics=new Generics&lt;&gt;(); fruitGenerics.show_1(apple); //编译失败 因为在类中声明的泛型为实参确定之后，传入的必须为该类型// fruitGenerics.show_1(person); //在方法声明的泛型会重新定义，这个泛型T是全新的泛型。尽管泛型名字一样。方法中声明的泛型独立于类中声明的泛型 fruitGenerics.show_2(apple); fruitGenerics.show_2(person); //在方法声明的泛型会重新定义，这个泛型T是全新的泛型。尽管泛型名字一样。方法中声明的泛型独立于类中声明的泛型 fruitGenerics.show_3(apple); fruitGenerics.show_3(person); }} ③泛型方法与可变参数12345678public &lt;T&gt; void printMsg( T... args){ for(T t : args){ System.out.println(t); }}//调用printMsg(\"111\",222,\"aaaa\",\"2323.4\",55.55); ④静态方法与泛型静态方法无法访问类上定义的泛型；如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上。 12345678910111213public class Generics&lt;T&gt; { /** * 静态方法使用泛型必须在方法中定义泛型，在类上定义无效 * @param t * @param &lt;T&gt; */ public static &lt;T&gt; void show(T t){ } static &lt;T&gt; void showKeyValue(Generics&lt;T&gt; obj) { }} ⑤ 泛型方法总结泛型方法能使方法独立于类而产生变化，即方法上定义的泛型独立于类上的泛型 无论何时，如果你能做到，你就该尽量使用泛型方法。也就是说，如果使用泛型方法将整个类泛型化，那么就应该使用泛型方法。另外对于一个static的方法而已，无法访问泛型类型的参数。所以如果static方法要使用泛型能力，就必须使其成为泛型方法。","link":"/2020/07/24/javase/%E6%B3%9B%E5%9E%8B/"},{"title":"Java代理模式详解","text":"一、静态代理 代理类和目标对象的类都是在编译期间确定下来的叫静态代理。 静态代理模式在不改变目标对象的前提下，实现了对目标对象的功能扩展。 因为代理对象需要与目标对象实现一样的接口,所以会有很多代理类,类太多.同时,一旦接口增加方法,目标对象与代理对象都要维护. 1、代理模式和装饰模式的区别①目标对象的行为抽象 吃饭行为： 1234public interface IEat { void eat();} 读书行为： 1234public interface IStudy { void readBook();} ②创建目标对象1234567891011public class Child implements IEat,IStudy{ @Override public void eat() { System.out.println(\"The child is eating...\"); } @Override public void readBook() { System.out.println(\"I am reading\"); }} ③创建代理对象1)父母代理(帮孩子做饭)123456789101112131415public class Parent implements IEat { private Child child; public Parent(Child child) { this.child = child; } @Override public void eat() { //由代理类调用实际对象中的方法。代理类可以在其中加入其他操作 System.out.println(\"parents cook..\"); child.eat(); System.out.println(\"parents wash dishes \"); }} 2)学校代理(教孩子识字,读书)123456789101112131415public class School implements IStudy{ private Child child; public School(Child child) { this.child = child; } @Override public void readBook() { System.out.println(\"school teach words\"); child.readBook(); System.out.println(\"school teach write\"); }} ④创建目标对象的扩展类(装饰)孩子长大了，能够自己学会认字，自己做饭，则需要对功能扩展。但是此时不需要任何代理，自己本身去实现扩展的功能即可，本质还是一个孩子。 12345678910111213141516171819202122public class ChildWrapper implements IEat,IStudy { private Child child; public ChildWrapper(Child child) { this.child = child; } @Override public void eat() { System.out.println(\"self cook...\"); child.eat(); System.out.println(\"self wash dishes...\"); } @Override public void readBook() { System.out.println(\"self start read book...\"); child.readBook(); System.out.println(\"self finish reading....\"); }} ⑤结果1)代理模式1234567891011//1、代理模式//1、创建目标对象Child child=new Child();//2、创建代理类并传入实际操作的目标对象 (父类帮孩子做饭，孩子本身不会完成这件事，所以需要父母代理类)Parent parent = new Parent(child);//同理孩子本身不会完成读书这件事，所以需要学校代理类School school = new School(child);//3、调用代理方法//由代理对象调用，并可以加入自己的额外的功能parent.eat();school.readBook(); 父母的代理结果： 123parents cook..The child is eating...parents wash dishes 学校的代理结果： 123school teach wordsI am readingschool teach write 2)装饰模式1234567//2、装饰模式(扩展)//创建其目标对象Child child1=new Child();//对目标对象的扩展功能，本质还是目标对象ChildWrapper childWrapper = new ChildWrapper(child);childWrapper.eat();childWrapper.readBook(); 1234567self cook...The child is eating...self wash dishes... self start read book...I am readingself finish reading.... 孩子有吃饭和学习俩件任务，父母作为代理类之一，只能指导吃饭；学校作为代理类之一，只能指导学习。 对于某些独立自主的孩子（装饰类），它可能学习更加主动，吃完饭会主动收拾碗筷，但这些本来就是它原有功能的加强，它的本质仍然是孩子，依然可以享受父母、学校的代理帮助。 ⑥结论代理，偏重因自己无法完成或自己无需关心，需要他人干涉事件流程，更多的是对对象的控制。 装饰，偏重对原对象功能的扩展，扩展后的对象仍是是对象本身。 代理模式：注重对对象某一功能的流程把控和辅助。它可以控制对象做某些事，重心是为了借用对象的功能完成某一流程，而非对象功能如何。 装饰模式：注重对对象功能的扩展，它不关心外界如何调用，只注重对对象功能的加强，装饰后还是对象本身。 对于代理类，如何调用对象的某一功能是思考重点，而不需要兼顾对象的所有功能； 对于装饰类，如何扩展对象的某一功能是思考重点，同时也需要兼顾对象的其它功能，因为再怎么装饰，本质也是对象本身，要担负起对象应有的职责。 https://www.jianshu.com/p/c06a686dae39 二、JDK动态代理 代理对象不需要实现目标对象的接口。 代理对象的生成,是利用JDK的API,动态的在内存中构建代理对象(需要我们指定创建代理对象/目标对象实现的接口的类型) 代理对象不需要实现接口,但是目标对象一定要实现接口,否则不能用动态代理 动态代理也叫做:JDK代理,接口代理 Proxy中的newProxyInstance方法 12345678910/** * 获取代理对象 * @param loader 获取目标对象的类加载器。指定当前目标对象使用类加载器,获取加载器的方法是固定的 * @param interfaces 目标对象实现的接口的类型,使用泛型方式确认类型 * @param h 回调方法处理器。事件处理,执行目标对象的方法时,会触发事件处理器的方法,会把当前执行目标对象的方法作为参数传入 * @return 返回代理对象 */public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h){} 回调处理器InvocationHandler中的invoke方法 123456789101112public interface InvocationHandler { /** * 回调方法处理器 * @param proxy 代指当前代理对象 由jdk调用，我们无需操作 * @param method 当前要执行目标对象的方法 * @param args 方法的实际参数 * @return 返回方法的结果 * @throws Throwable */ public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;} 1、目标对象抽象接口 12345public interface IUserDao { void save(String id); String getUser();} 2、目标对象类1234567891011public class UserDao implements IUserDao { @Override public void save(String id) { System.out.println(\"存储学生学号:\"+id); } @Override public String getUser() { return \"我是张三\"; }} 3、代理工厂(获取代理对象)12345678910111213141516171819202122232425262728293031323334public class ProxyFactory { //被代理对象(目标对象) private Object object; //传入目标对象 public ProxyFactory(Object object) { this.object = object; } //获取代理对象 public Object getProxyInstance() { //利用反射获取代理对象 return Proxy.newProxyInstance(object.getClass().getClassLoader(), object.getClass().getInterfaces(), new InvocationHandler() { //回调方法。相当于代理对象中对目标对象的方法调用 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { //回调方法之前执行的代码 System.out.println(\"transcation start...\"); //回调当前目标对象执行的方法 //object 当前目标对象 //args 当前目标方法执行时传入的参数 //有值则返回，无则返回null Object invokeValue = method.invoke(object, args); //回调方法之后执行的代码 System.out.println(\"-----\"+invokeValue); System.out.println(\"transcation ending...\"); //返回方法的执行结果 return invokeValue; } }); }} 4、测试1234567891011121314public class Main { public static void main(String[] args) { //创建代理工厂并传入目标对象 ProxyFactory proxyFactory = new ProxyFactory(new UserDao()); //获取代理对象(注意这里的对象必须为接口对象) IUserDao proxyInstance = (IUserDao) proxyFactory.getProxyInstance(); //调用代理对象中的方法 proxyInstance.save(\"1001\"); //若代理对象中的方法有返回值则返回此值。 String user = proxyInstance.getUser(); //我是张三 System.out.println(user); }} 123456789transcation start...存储学生学号:1001-----nulltranscation ending... transcation start...-----我是张三transcation ending...我是张三 三、Cglib代理上面的静态代理和动态代理模式都是要求目标对象是实现一个接口的目标对象,但是有时候目标对象只是一个单独的对象,并没有实现任何的接口,这个时候就可以使用以目标对象子类的方式类实现代理,这种方法就叫做:Cglib代理 Cglib代理,也叫作子类代理,它是在内存中构建一个子类对象从而实现对目标对象功能的扩展. JDK的动态代理有一个限制,就是使用动态代理的对象必须实现一个或多个接口,如果想代理没有实现接口的类,就可以使用Cglib实现. Cglib是一个强大的高性能的代码生成包,它可以在运行期扩展java类与实现java接口.它广泛的被许多AOP的框架使用,例如Spring AOP和synaop,为他们提供方法的interception(拦截) Cglib包的底层是通过使用一个小而块的字节码处理框架ASM来转换字节码并生成新的类.不鼓励直接使用ASM,因为它要求你必须对JVM内部结构包括class文件的格式和指令集都很熟悉. Cglib子类代理实现方法:1.需要引入cglib的jar文件,但是Spring的核心包中已经包括了Cglib功能,所以直接引入pring-core-3.2.5.jar即可. 12345&lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;2.2.2&lt;/version&gt;&lt;/dependency&gt; 2.引入功能包后,就可以在内存中动态构建子类3.代理的类不能为final,否则报错4.目标对象的方法如果为final/static,那么就不会被拦截,即不会执行目标对象额外的业务方法. 在Spring的AOP编程中: 如果加入容器的目标对象有实现接口,用JDK代理 如果目标对象没有实现接口,用Cglib代理 1、目标对象类12345678public class UserDao { public void save(String id) { System.out.println(\"存储学生学号:\"+id); } public String getUser() { return \"我是张三\"; }} 2、代理工厂(基于目标对象的子类代理)12345678910111213141516171819202122232425262728293031public class ProxyFactory implements MethodInterceptor { //目标对象 private Object object; //传入目标对象 public ProxyFactory(Object object) { this.object = object; } //获取代理对象 public Object getProxyInstance() { //1、工具类 Enhancer enhancer=new Enhancer(); //2、设置父类 enhancer.setSuperclass(object.getClass()); //3、设置回调函数(当前代理工厂) enhancer.setCallback(this); //4、创建子类(子类代理) return enhancer.create(); } @Override public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable { System.out.println(\"开始事务...\"); //回调的方法 Object invokeValue = method.invoke(object, args); System.out.println(\"----\"+invokeValue); System.out.println(\"事务结束...\"); return invokeValue; }} 3、测试1234567891011public class Main { public static void main(String[] args) { //创建代理工厂并传入目标对象 ProxyFactory proxyFactory = new ProxyFactory(new UserDao()); //获取代理对象(基于目标对象的子类代理) UserDao userDao = (UserDao) proxyFactory.getProxyInstance(); userDao.save(\"019321\"); String user = userDao.getUser(); System.out.println(user); }} 参考：https://www.cnblogs.com/cenyu/p/6289209.html","link":"/2020/07/24/javase/Java%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/"},{"title":"springboot整合Mybatis及多数据源","text":"springboot整合Mybatis注意：1、mapper映射文件存放位置：①存放在java文件夹中当mapper映射文件存放的位置在src/mian/java中，即和mapper接口文件位置一致时。由于maven编译时会忽略配置xml文件，所以我们需要手动配置过滤其java文件夹下的xml文件即resource下的xml 12345678910111213&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; ②存放在resources下放在同一目录结构==&gt; 放在resources下的文件夹要和接口中的文件夹目录结构一致。 注意：这里新建包名要一个一个建，不要想java目录中的结果一样，直接把所有的包名写在一起。 例如：接口目录 src/main/org/lc/mybatis/mapper/xxxx.java mappes映射文件目录 resources/org/lc/mybatis/mapper/xxxx.mapper 放在不同目录结构==&gt; 例如：resources/mapper/mybatis01/xxxx.mapper 则需要在yaml中重新指定mappe映射位置： 1234567891011spring: datasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=UTF-8 username: root password: 123456mybatis: #映射resources资源目录下的mapper文件夹下的任意目录下的xml文件 mapper-locations: classpath:/mapper/**/*.xml 2、@Mapper @MapperScan(s）@Mapper 扫描单个mapper接口 @MapperScans({ ​ @MapperScan(), ​ @MapperScan() }) @MapperScan() 扫描指定包下的所有mapper接口，多数据源时，则需要指定对应的sqlSessionFactoryRef，sqlSessionTemplateRef 1234 @MapperScan(basePackages = \"org.lc.mybatis.mapper.mapper1\",sqlSessionFactoryRef = \"sqlSessionFactoryOne\",sqlSessionTemplateRef = \"sqlSessionTemplateOne\")@Configurationpublic class MybatisConfig {} 单数据源配置:pom.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;mybatis&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.18&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;version&gt;5.1.27&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt;&lt;/project&gt; 1234567spring: datasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=UTF-8 username: root password: 123456 Lombok插件的使用:==&gt; 生成getter setter及 tostring 12345678@Getter@Setter@ToStringpublic class User { private Integer id; private String username; private String address;} *@Mapper *扫描mapper注入容器中 1234@Mapperpublic interface UserMapper { List&lt;User&gt; getAllUser();} 1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" &gt;&lt;mapper namespace=\"org.lc.mybatis.mapper.UserMapper\"&gt; &lt;select id=\"getAllUser\" resultType=\"org.lc.mybatis.bean.User\"&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 使用==&gt; 123456789101112@SpringBootTestclass MybatisApplicationTests { @Autowired private UserMapper userMapper; @Test void contextLoads() { List&lt;User&gt; allUser = userMapper.getAllUser(); System.out.println(allUser); }} 多数据源配置:1234567891011121314spring: datasourceone: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=UTF-8 username: root password: 123456 datasourcetwo: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://47.96.141.44:3306/test?useUnicode=true&amp;characterEncoding=UTF-8 username: root password: xxxx 数据源属性注入==&gt; 12345678910111213141516@Configurationpublic class DataSourceConfig { @ConfigurationProperties(\"spring.datasourceone\") @Bean public DataSource dataSourceOne(){ return DruidDataSourceBuilder.create().build(); } @ConfigurationProperties(\"spring.datasourcetwo\") @Bean public DataSource dataSourceTwo(){ return DruidDataSourceBuilder.create().build(); }} SqlSessionFactory与SqlSessionTemplate配置==&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768@MapperScans({ //数据源一的对应的mapper接口位置 @MapperScan(basePackages = \"org.lc.mybatis.mapper.mapper1\",sqlSessionFactoryRef = \"sqlSessionFactoryOne\",sqlSessionTemplateRef = \"sqlSessionTemplateOne\"), //数据源二的对应的mapper接口位置 @MapperScan(basePackages = \"org.lc.mybatis.mapper.mapper2\",sqlSessionFactoryRef =\"sqlSessionFactoryTwo\",sqlSessionTemplateRef = \"sqlSessionTemplatelTwo\")})@Configurationpublic class MybatisConfig { /** * 数据源一注入 */ @Qualifier(\"dataSourceOne\") @Autowired DataSource dataSourceOne; /** * 数据源二注入 */ @Resource(name = \"dataSourceTwo\") DataSource dataSourceTwo; /** * SqlSessionFactory 属性配置 * @return */ @Bean public SqlSessionFactory sqlSessionFactoryOne(){ SqlSessionFactoryBean sqlSessionFactoryBean=new SqlSessionFactoryBean(); sqlSessionFactoryBean.setDataSource(dataSourceOne); try { //配置在resources下的自定义mapper文件位置 sqlSessionFactoryBean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(\"classpath:mapper/mybatis01/**/*.xml\")); return sqlSessionFactoryBean.getObject(); } catch (Exception e) { e.printStackTrace(); } return null; } /** * SqlSessionTemplate 一模板操作配置 * @return */ @Bean public SqlSessionTemplate sqlSessionTemplateOne(){ return new SqlSessionTemplate(sqlSessionFactoryOne()); } @Bean public SqlSessionFactory sqlSessionFactoryTwo(){ SqlSessionFactoryBean sqlSessionFactoryBean=new SqlSessionFactoryBean(); sqlSessionFactoryBean.setDataSource(dataSourceTwo); try { //配置在resources下的自定义mapper文件位置 sqlSessionFactoryBean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(\"classpath:mapper/mybatis02/**/*.xml\")); return sqlSessionFactoryBean.getObject(); } catch (Exception e) { e.printStackTrace(); } return null; } @Bean public SqlSessionTemplate sqlSessionTemplatelTwo(){ return new SqlSessionTemplate(sqlSessionFactoryTwo()); }} 同理=&gt; ①当mapper.xml在java文件夹下，则不需要配置mapper.xml的位置 ②当mapper.xml在resources自定义的文件夹下，则需要配置mapper.xml的位置 12//配置在resources下的自定义mapper文件位置 sqlSessionFactoryBean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(\"classpath:mapper/mybatis02/**/*.xml\") 因为多数据源的关系，所以所有在yaml的基本mybatis的配置失效，需要重新在SqlSessionFactory配置","link":"/2020/07/24/multipledatasource/%E6%95%B4%E5%90%88MyBatis%E5%8F%8A%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90/"},{"title":"JAR包和WAR包","text":"JAR包和WAR包一、JAR包1、简介JAR（Java Archive，Java 归档文件）是与平台无关的文件格式，它允许将许多文件组合成一个压缩文件。JavaSE程序可以打包成Jar包(J其实可以理解为Java了)。 JAR 文件格式以流行的 ZIP 文件格式为基础。与 ZIP 文件不同的是，JAR 文件不仅用于压缩和发布，而且还用于部署和封装库、组件和插件程序，并可被像编译器和 JVM 这样的工具直接使用。在 JAR 中包含特殊的文件，如 manifests 和部署描述符，用来指示工具如何处理特定的 JAR。 简单来说，jar包就是别人已经写好的一些类，然后对这些类进行打包。可以将这些jar包引入到你的项目中，可以直接使用这些jar包中的类和属性，这些jar包一般放在lib目录下。 2、Spring Boot 可执行 jarSpring Boot 中默认打包成的 jar 叫做 可执行 jar，这种 jar 不同于普通的 jar，普通的 jar 不可以通过 java -jar xxx.jar 命令执行，普通的 jar 主要是被其他应用依赖，Spring Boot 打成的 jar 可以执行，但是不可以被其他的应用所依赖，即使强制依赖，也无法获取里边的类。但是可执行 jar 并不是 Spring Boot 独有的，Java 工程本身就可以打包成可执行 jar 。 我们在springboot项目中可以看到一个默认的插件配置 spring-boot-maven-plugin这个打包插件存在 5 个方面的功能，从插件命令就可以看出： 五个功能分别是： build-info：生成项目的构建信息文件 build-info.properties repackage：这个是默认 goal，在 mvn package 执行之后，这个命令再次打包生成可执行的 jar，同时将 mvn package 生成的 jar 重命名为 *.origin run：这个可以用来运行 Spring Boot 应用 start：这个在 mvn integration-test 阶段，进行 Spring Boot 应用生命周期的管理 stop：这个在 mvn integration-test 阶段，进行 Spring Boot 应用生命周期的管理 这里功能，默认情况下使用就是 repackage 功能，其他功能要使用，则需要开发者显式配置。 3、打包repackage 功能的 作用，就是在打包的时候，多做一点额外的事情： 首先 mvn package 命令 对项目进行打包，打成一个 jar，这个 jar 就是一个普通的 jar，可以被其他项目依赖，但是不可以被执行 repackage命令，对第一步 打包成的jar进行再次打包，将之打成一个 可执行jar，通过将第一步打成的jar重命名为*.original` 文件 可执行jar(不能作为依赖):代码是存在 于 BOOT-INF/classes/ 目录下，另外，还有一个 META-INF 的目录，该目录下有一个 MANIFEST.MF 文件，打开该文件，内容如下： 12345678910Manifest-Version: 1.0Implementation-Title: adminImplementation-Version: 0.0.1-SNAPSHOTStart-Class: org.lc.admin.AdminApplicationSpring-Boot-Classes: BOOT-INF/classes/Spring-Boot-Lib: BOOT-INF/lib/Build-Jdk-Spec: 1.8Spring-Boot-Version: 2.2.5.RELEASECreated-By: Maven Archiver 3.4.0Main-Class: org.springframework.boot.loader.JarLauncher 可以看到，这里定义了一个 Start-Class，这就是可执行 jar 的入口类，Spring-Boot-Classes 表示我们自己代码编译后的位置，Spring-Boot-Lib 则表示项目依赖的 jar 的位置。 换句话说，如果自己要打一个可执行 jar 包的话，除了添加相关依赖之外，还需要配置 META-INF/MANIFEST.MF 文件。 不可执行jar(只能作为依赖)：这是可执行 jar 的结构，那么不可执行 jar 的结构呢？ 我们首先将默认的后缀 .original 除去，然后给文件重命名，重命名完成，进行解压： 解压后可以看到，不可执行 jar 根目录就相当于我们的 classpath，解压之后，直接就能看到我们的代码，它也有 META-INF/MANIFEST.MF 文件，但是文件中没有定义启动类等。 12345Manifest-Version: 1.0Implementation-Title: adminImplementation-Version: 0.0.1-SNAPSHOTBuild-Jdk-Spec: 1.8Created-By: Maven Archiver 3.4.0 注意这个不可以执行 jar 也没有将项目的依赖打包进来。 从这里我们就可以看出，两个 jar ，虽然都是 jar 包，但是内部结构是完全不同的，因此一个可以直接执行，另一个则可以被其他项目依赖。 4、一次打包两个 jar（自定义可执行jar名称）一般来说，Spring Boot 直接打包成可执行 jar 就可以了，不建议将 Spring Boot 作为普通的 jar 被其他的项目所依赖。如果有这种需求，建议将被依赖的部分，单独抽出来做一个普通的 Maven 项目，然后在 Spring Boot 中引用这个 Maven 项目。 如果非要将 Spring Boot 打包成一个普通 jar 被其他项目依赖，技术上来说，也是可以的，给 spring-boot-maven-plugin 插件添加如下配置： 1234567891011&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;classifier&gt;exec&lt;/classifier&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 配置的 classifier 表示可执行 jar 的名字，配置了这个之后，在插件执行 repackage 命令时，就不会给 mvn package 所打成的 jar 重命名了，所以，打包后的 jar 如下： ![](F:\\桌面内容\\springboot2\\项目构建与部署与Maven使用\\images\\批注 2020-04-08 231513.png) 第一个jar可被其他项目依赖的jar 第二个jar则表示是一个可执行jar(自定义可执行jar名) 二、WAR包1、简介war是一个可以直接运行的web模块，通常用于网站，打成包部署到容器中。以Tomcat来说，将war包放置在其\\webapps\\目录下，然后启动Tomcat，这个包就会自动解压，就相当于发布了。 war包是Sun提出的一种web应用程序格式，与jar类似，是很多文件的压缩包。war包中的文件按照一定目录结构来组织。根据其根目录下包含有html和jsp文件，或者包含有这两种文件的目录，另外还有WEB-INF目录。通常在WEB-INF目录下含有一个web.xml文件和一个classes目录，web.xml是这个应用的配置文件，而classes目录下则包含编译好的servlet类和jsp，或者servlet所依赖的其他类（如JavaBean）。通常这些所依赖的类也可以打包成jar包放在WEB-INF下的lib目录下。 简单来说，war包是JavaWeb程序打的包，war包里面包括写的代码编译成的class文件，依赖的包，配置文件，所有的网站页面，包括html，jsp等等。一个war包可以理解为是一个web项目，里面是项目的所有东西。 区别：WAR文件代表了一个Web应用程序，JAR是类的归档文件 2、部署war包到Tomcat1）. 我这里工作中一般是开发打war包给测试，比如说现在测试拿到一个war包，名字叫test.war。 2）. 打开Tomcat的安装路径 ，假设是“D:\\Tomcat\\apache-tomcat-7.0.68”，然后进入到 webapps文件夹中，把 test.war放到 webapps文件夹。 3）. 启动Tomcat。 如果不需要更改配置文件：到这一步就可以了。 在浏览器输入“http:localhost:tomcat_port/test即可打开test项目的 index.jsp页面（port是自己的端口号）。如果test项目没有index.jsp页面，那就需要打开其他相应的页面。 如果需要更改配置文件： 4）. 关闭 Tomcat。 5）. 删除 test.war文件（如果在tomcat启动的状态下删去war包，解压好的文件夹也会被一并删除，所以需要在解压后停止tomcat， 然后删掉war包，这时再启动。这时项目文件夹就会被认为不是war解压而来。）。 6）. 由于刚刚启动过Tomcat，Tomcat会自动解压缩test.war为 test文件夹。所以我们在webapps下面可以看到test文件夹。打开test文件夹更改配置文件即可。 7）. 更新完配置之后，启动Tomcat。 8）. 浏览器打开即可。","link":"/2020/07/24/projectBuildAndDev/Jar%E5%8C%85%E4%B8%8EWar%E5%8C%85/"},{"title":"SpringBoot和Nginx实现gzip压缩","text":"SpringBoot和Nginx实现gzip压缩前后端分离项目如果做成 SPA（单页面）的形式，就必然面临一个首屏加载的问题，因为默认情况下首页文件比较大，可能超过 1 MB，进而带来首页加载很慢的问题。所以我们要通过优化，来提高首页的加载速度。 问题的解决，一般来说有这样几种思路： UI 组件按需加载 路由懒加载 组件重复打包 gzip 这些加载方式中，UI 组件按需加载和 gzip 是两种比较常用的方案，另外两种优化方式则要结合具体的项目，看看是否具备相关条件。 一、ElementUI按需加载1.1 问题不做任何优化，我们一般是在 main.js 中按照如下方式来引入 ElementUI 的： 即一次加载全部组件 123import ElementUI from 'element-ui';import 'element-ui/lib/theme-chalk/index.css';Vue.use(ElementUI,{size:'small'}); 这样做，没有用上的组件必然会造成资源的浪费 通过如下命令对项目生成 report.html 用来帮助我们分析包内容： 1vue-cli-service build --report 访问 report.html即可查看个文件的占用情况 ![](F:\\桌面内容\\springboot2\\项目构建与部署与Maven使用\\images\\批注 2020-04-12 193314.png) 1.2解决办法只在开发环境使用 -D 1npm install babel-plugin-component -D 这时会生成一个babel.config.js文件，修改其内容： 1234567891011121314151617181920module.exports = { presets: [ '@vue/cli-plugin-babel/preset', [ '@babel/preset-env', { modules: false } ] ], plugins: [ [ \"component\", { \"libraryName\": \"element-ui\", \"styleLibraryName\": \"theme-chalk\" } ] ]} 然后修改main.js，将elementUI组件按需导入 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import { Button, Input, Table, TableColumn, Dialog, Card, Container, Footer, Icon, Select, Form, Tag, Tree, Pagination, Badge, Loading, Message, MessageBox, Menu, Tabs, TabPane, Breadcrumb, BreadcrumbItem, Dropdown, Steps, Tooltip, Popover, Collapse, FormItem, Checkbox, Header, DropdownMenu, DropdownItem, Aside, Main, MenuItem, Submenu, Option, Col, Row, Upload, Radio, DatePicker, RadioGroup, CollapseItem, Switch} from 'element-ui';//注册组件Vue.prototype.$ELEMENT = {size: 'small', zIndex: 3000};Vue.use(Switch);Vue.use(CollapseItem);Vue.use(Radio);Vue.use(RadioGroup);Vue.use(DatePicker);Vue.use(Upload);Vue.use(Row);Vue.use(Col);Vue.use(Option);Vue.use(Submenu);Vue.use(MenuItem);Vue.use(Header);Vue.use(DropdownMenu);Vue.use(DropdownItem);Vue.use(Aside);Vue.use(Main);Vue.use(Checkbox);Vue.use(FormItem);Vue.use(Collapse);Vue.use(Popover);Vue.use(Menu);Vue.use(Tabs);Vue.use(TabPane);Vue.use(Breadcrumb);Vue.use(BreadcrumbItem);Vue.use(Dropdown);Vue.use(Steps);Vue.use(Tooltip);Vue.use(Tree);Vue.use(Pagination);Vue.use(Badge);Vue.use(Loading);Vue.use(Button);Vue.use(Input);Vue.use(Table);Vue.use(Footer);Vue.use(TableColumn);Vue.use(Dialog);Vue.use(Card);Vue.use(Container);Vue.use(Icon);Vue.use(Select);Vue.use(Form);Vue.use(Tag);Vue.prototype.$alert = MessageBox.alertVue.prototype.$confirm = MessageBox.confirm 这里的代码倒是不难，有两个需要注意的地方： MessageBox 的引入方式和其他组件不太一样，需要注意。 给组件统一定制 size 和 zIndex 的方式有所变化。 其他具体不同的引入和注册方式查看 ElementUI官网：https://element.faas.ele.me/#/zh-CN/component/quickstart 再次执行 vue-cli-service build --report ，查看打包结果，发现相比上次文件大小减少不小 二、gzip我们可以下上面的基础上，使用gzip继续压缩 2.1服务端配置压缩前端编译打包后拷贝到后端，直接部署后端项目即可 这里我们在springboot的application.yaml中 1234server:# 当前端项目在static目录下 则开启压缩 compression: enabled: true 配置完成后，重启后端项目，访问项目首页，如下，可以看到文件基本上都被压缩了： 我们任意点开一个js文件： ![](F:\\桌面内容\\springboot2\\项目构建与部署与Maven使用\\images\\批注 2020-04-12 194559.png) 我们发现响应头已经有gzip的信息，即该文件已被压缩。 2.2 Nginx的动态压缩和静态压缩 Nginx 动态压缩，静态文件还是普通文件，前端在Nginx部署上的文件时普通文件，当请求来了Nginx再压缩，然后将压缩文件返回给前端，交由前端再解压回显。 Nginx 静态压缩，前端提前把文件压缩成 .gz 格式，然后部署在Nginx，此时Nginx是压缩文件，请求来了，Nginx直接将该文件返回即可。 2.2.1 Nginx动态压缩动态压缩 Vue 还是使用普通的打包编译后的文件，将前端编译打包后的文件拷贝到 Nginx 的 html 目录下，然后访问 nginx： 确保 nginx 运行成功后，接下来对 nginx 进行配置： 1234gzip on; # 开启 gzipgzip_min_length 2k;# 超过 2kb 进行压缩gzip_disable msie6; # ie6 不适用 gzipgzip_types text/css application/javascript text/javascript image/jpeg image/png image/gif; # 需要处理的文件 配置完成后，重启 Nginx： 1/usr/lcoal/nginx/sbin/nginx -s reload 启动成功后，再去访问前端页面，就可以看到压缩效果了。 直接访问ip 2.2.2 Nginx静态压缩上面的动态压缩有一个问题，就是每次请求响应的时候都要压缩，其实都是相同的文件，总是压缩有点浪费资源。 我们可以提前将文件压缩好，就保存在服务端，需要用的时候直接返回，就会方便很多。 这需要我们首先在前端安装压缩插件： 1npm install compression-webpack-plugin -D 安装成功之后，接下来在 vue.config.js 中进行配置： 1234567891011121314151617181920212223242526//插件导入const CompressionPlugin = require(\"compression-webpack-plugin\");module.exports={ // 前端服务器的地址信息 devServer:{ host:'localhost', //前端地址 port:8080, //前端端口 proxy:proxyObj }, //静态压缩配置 configureWebpack: config =&gt; { if (process.env.NODE_ENV === 'production') { return { plugins: [ new CompressionPlugin({ test: /\\.js$|\\.html$|\\.css/, //超过1kb即压缩 threshold: 1024, //压缩后是否删除源文件 deleteOriginalAssets: false }) ] } } }} 配置完成后，再次执行打包命令 vue-cli-service build。这次打包完成后，我们可以在 js 目录下看到 .gz 文件，如下：我们发现超过1kb的文件即被压缩 ![](F:\\桌面内容\\springboot2\\项目构建与部署与Maven使用\\images\\批注 2020-04-12 201221.png) 接下来将文件上传到 Nginx 服务器，然后对 Nginx 重新进行编译打包。想让 Nginx 返回已经压缩好的文件，需要用到 Nginx 中的 http_gzip_static_module 模块，这个模块可以发送以 .gz 作为文件扩展名的预压缩文件，所以我们要对 Nginx 重新进行编译打包： 123./configure --with-http_gzip_static_module 或者 /root/nginx-1.8.1/configure --with-http_gzip_static_modulemakemake install 然后在 Nginx 配置文件中开启 gzip_static，如下： 12gzip_static on;#动态压缩的其他配置注释 注意，开启了 gzip_static 后，gzip_types 就失效了，所以也没必要配置这个属性了。 配置完成后，重启 Nginx，再去访问，查看浏览器日志，就会发现 gzip 已经生效了。 注意： 静态压缩返回的 gzip 压缩文件都是提前准备好的，没有 .gz 格式的文件就会自动返回原文件。这是一种和动态压缩不同的响应策略。动态压缩是根据 Nginx 中的配置，超过配置的大小就会自动进行压缩。 好了，这一波操作下来，首屏加载速度提高了 5 倍左右。","link":"/2020/07/24/projectBuildAndDev/Springboot%E5%92%8CNginx%E5%AE%9E%E7%8E%B0gzip%E5%8E%8B%E7%BC%A9/"},{"title":"Redis","text":"Redis之布隆过滤器 (Bloom Filter)一、布隆过滤器的应用场景场景1：推送不同消息我们用 HyperLogLog 来估计一个数，有偏差但是也够用。HyperLogLog 主要提供两个方法： pfadd pfcount ​ 但是 HyperLogLog 没有判断是否包含的方法，例如 pfexists 、pfcontains 等。没有这样的方法存在，但是我们有这样的业务需求。 ​ 例如刷今日头条，推送的内容有相似的，但是没有重复的。这就涉及到如何在推送的时候去重？ ​ 解决方案很多，例如将用户的浏览历史记录下来，然后每次推送时去比较该条消息是否已经给用户推送了。但是这种方式效率极低，不推荐。 所以这里我们使用布隆过滤器以今日头条为例，假设我们将用户的浏览记录用 B 表示，A 表示用户没有浏览的新闻，现在要给用户推送消息，先去 B 里边判断这条消息是否已经推送过，如果判断结果说没推送过（B 里边没有这条记录），那就一定没有推送过。如果判断结果说有推送过（B 里边也有可能没有这条消息），这个时候该条消息就不会推送给用户，导致用户错过该条消息，当然这是概率极低的。 场景2：缓存穿透(查不存在的数据)描述：缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。 ​ 我们经常会把一部分数据放在Redis等缓存，比如产品详情。这样有查询请求进来，我们可以根据产品Id直接去缓存中取数据，而不用读取数据库，这是提升性能最简单，最普遍，也是最有效的做法。一般的查询请求流程是这样的：先查缓存，有缓存的话直接返回，如果缓存中没有，再去数据库查询，然后再把数据库取出来的数据放入缓存，一切看起来很美好。但是如果现在有大量请求进来，而且都在请求一个不存在的产品Id，会发生什么？既然产品Id都不存在，那么肯定没有缓存，没有缓存，那么大量的请求都怼到数据库，数据库的压力一下子就上来了，还有可能把数据库打死。虽然有很多办法都可以解决这问题，但是我们的主角是“布隆过滤器”，没错，“布隆过滤器”就可以解决（缓解）缓存穿透问题。 题外话：1、缓存击穿(并发查同一条数据)​ 缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力 2、缓存雪崩 缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。 二、什么是布隆过滤器？布隆过滤器是一个叫“布隆”的人提出的，它本身是一个很长的二进制向量，既然是二进制的向量，那么显而易见的，存放的不是0，就是1。 Bloom Filter 专门用来解决我们上面所说的去重问题的，使用 Bloom Filter 不会像使用缓存那么浪费空间。当然，他也存在一个小小问题，就是不太精确。 Bloom Filter 相当于是一个不太精确的 set 集合，我们可以利用它里边的 contains 方法去判断某一个对象是否存在，但是需要注意，这个判断不是特别精确。一般来说，通过 contains 判断某个值不存在，那就一定不存在，但是判断某个值存在的话，则他可能不存在。 三、Bloom Filter实现原理每一个布隆过滤器，在 Redis 中都对应了一个大型的bit位数组以及几(3)个不同的 hash 函数。 如果我们要映射一个值到布隆过滤器中，首先根据几个不同的hash函数给元素(存储对象)生成多个哈希值，拿到这些哈希值后分别对位数组长度进行取模(取余)运算得到一个位置，将位数组中对应的位置设置为1。这样就完成元素的添加操作。 取模：a= c%bit数组长度 就是取余的过程 ​ 例如针对值 “baidu” 和三个不同的哈希函数分别生成了哈希值 ：1、4、7，取模为：1，4, 7 ​ 例如针对值“zhihu”和三个不同的哈希函数分别生成了哈希值：1，4，9 ,取模为：1 ，4，9 则上图转换如下： 当判断元素是否存在时，依然先对元素进行 hash 运算，将运算的结果和位数组取模，然后去对应的位置查看是否有相应的数据，如果有，表示元素可能存在（因为这个有数据的地方也可能是其他元素存进来的），如果没有表示元素一定不存在。 可以看出，仅仅从布隆过滤器本身而言，根本没有存放完整的数据，只是运用一系列随机映射函数计算出位置，然后填充二进制向量。 这有什么用呢？比如现在再给你一个数据，你要判断这个数据是否重复，你怎么做？ 你只需利用上面的三种固定的计算方式，计算出这个数据占据哪些格子，然后看看这些格子里面放置的是否都是1，如果有一个格子不为1，那么就代表这个数字不在其中。这很好理解吧，比如现在又给你了刚才你添加进去的数据，你通过三种固定的计算方式，算出的结果肯定和上面的是一模一样的，也是占据了布隆过滤器“1”，“4”，“9”三个格子。 但是有一个问题需要注意，如果这些格子里面放置的都是1，不一定代表给定的数据一定重复，也许其他数据经过三种固定的计算方式算出来的结果也是相同的。这也很好理解吧，比如我们需要判断对象是否相等，是不可以仅仅判断他们的哈希值是否相等的。 也就是说布隆过滤器只能判断数据是否一定不存在，而无法判断数据是否一定存在。 Bloom Filter 中，误判的概率和位数组的大小有很大关系，位数组越大，误判概率越小，当然占用的存储空间越大；位数组越小，误判概率越大，当然占用的存储空间就小。 按理来说，介绍完了新增、查询的流程，就要介绍删除的流程了，但是很遗憾的是布隆过滤器是很难做到删除数据的，为什么？你想想，比如你要删除刚才给你的数据，你把“1”，“4”，“9”三个格子都改成了0，但是可能其他的数据也映射到了“1”，“4”，“9”三个格子啊，这不就乱套了吗？ 四、Bloom Filter的优缺点： 优点：由于存放的不是完整的数据，所以占用的内存很少，而且新增，查询速度够快； 缺点： 随着数据的增加，误判率随之增加；无法做到删除数据；只能判断数据是否一定不存在，而无法判断数据是否一定存在。 五、Bloom Filter的安装官网：https://oss.redislabs.com/redisbloom/Quick_Start/ 1、docker安装1docker run -p 6379:6379 --name redis-redisbloom redislabs/rebloom:latest 2、编译安装123456789cd redis-5.0.7git clone https://github.com/RedisBloom/RedisBloom.gitcd RedisBloom/##编译make##切换上级目录cd ..##运行redis-server --loadmodule ./RedisBloom/redisbloom.so 后台运行，加入配置文件： 1redis-server redis.conf --loadmodule ./RedisBloom/redisbloom.so 进入redis测试是否安装成功： 123redis-cli -a 密码## 插入值bf.add k1 v1 避免每次启动布隆过滤器都要redis-server redis.conf --loadmodule ./RedisBloom/redisbloom.so这样写，比较麻烦。 我们修改redis.conf文件： 12345678################################## MODULES ###################################### Load modules at startup. If the server is not able to load modules# it will abort. It is possible to use multiple loadmodule directives.## loadmodule /path/to/my_module.so# loadmodule /path/to/other_module.soloadmodule /root/redis-5.0.8/RedisBloom/redisbloom.so 保存退出。这是我们次正常启动即可 redis-server redis.conf 六、基本用法1、bf.add/bf.madd 添加成功返回1 ，否则返回0 添加： bf.add [key] [value] 批量添加： bf.madd [key] [value1] [value2] [ value3] 2、bf.exists/bf.mexists 存在返回1，不存在返回0 判断是否存在 bf.exists [key] [value] 批量判断是否存在 bf.mexists [key] [value1] [value2] [value3] 12bf.add k1 v1 #==&gt; 1bf.exists k1 v1 #==&gt; 1 1234bf.madd k1 v1 v2 v3 1) (integer) 0 #重复的添加失败2) (integer) 13) (integer) 1 12345BF.MEXISTS k1 v1 v2 v3 v41) (integer) 12) (integer) 13) (integer) 14) (integer) 0 #不存在返回0 七、jedis实现布隆过滤器1、pom.xml注意这里的jedis版本必须在3以上才能使用布隆过滤器 1234567891011121314&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;&lt;!--布隆过滤器--&gt;&lt;dependency&gt; &lt;groupId&gt;com.redislabs&lt;/groupId&gt; &lt;artifactId&gt;jrebloom&lt;/artifactId&gt; &lt;version&gt;1.2.0&lt;/version&gt;&lt;/dependency&gt; 2、测试代码123456789101112131415161718192021public class BloomFilerTest { public static void main(String[] args) { GenericObjectPoolConfig config=new GenericObjectPoolConfig(); config.setMaxIdle(300); config.setMaxTotal(1000); config.setMaxWaitMillis(30000); config.setTestOnBorrow(true); JedisPool jedisPool = new JedisPool(config, \"47.96.141.44\", 6379, 30000, \"你的密码\"); Client client=new Client(jedisPool); for (int i = 0; i &lt; 1000; i++) {// 存入数据 client.add(\"k1\", \"lc:\"+i); }// 判断是否存在 //boolean exists= client.exists(\"k1\", \"lc:1001\"); //false //存在误判情况 boolean exists=client.exists(\"k1\",\"lc:1002\") //true System.out.println(exists); }} 八、设置布隆过滤器的错误率默认情况下，我们使用的布隆过滤器它的错误率是 0.01 ，默认的元素大小是 100。但是这两个参数也是可以配置的。 我们可以调用 bf.reserve 方法进行配置。 BF.RESERVE k1 0.0001 1000000 前提是该k1要存在，否则将设置为默认的值 第一个参数是 key，第二个参数是错误率，错误率越低，占用的空间越大，第三个参数预计存储的数量，当实际数量超出预计数量时，错误率会上升。 https://www.cnblogs.com/CodeBear/p/10911177.html","link":"/2020/07/24/redis/Redis%E4%B9%8B%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"},{"title":"Redis实现分布式锁的方式","text":"Redis实现分布式锁的方式问题场景：​ 例如一个简单的用户操作，一个线城去修改用户的状态，首先从数据库中读出用户的状态，然后在内存中进行修改，修改完成后，再存回去。在单线程中，这个操作没有问题，但是在多线程中，由于读取、修改、存 这是三个操作，不是原子操作，所以在多线程中，这样会出问题。 对于这种问题，我们可以使用分布式锁来限制程序的并发执行。 一、基本用法这里我们提前封装jedis连接池，拿到jedis对象 pom.xml 1234567&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt; CallWithJedis 123public interface CallWithJedis { void call(Jedis jedis);} Redis 1234567891011121314151617181920212223242526272829303132public class Redis { private JedisPool jedisPool; public Redis() {// 连接池配置对象 GenericObjectPoolConfig config=new GenericObjectPoolConfig();// 连接池最大空闲数 config.setMaxIdle(300);// 最大连接数 config.setMaxTotal(1000);// 连接最大等待时间（毫秒）。-1表示无限制 config.setMaxWaitMillis(30000);// 在空闲时检查有效性 config.setTestOnBorrow(true); /** * 1、连接池配置 * 2、redis地址 * 3、端口 * 4、超时时间 * 5、密码 */ jedisPool = new JedisPool(config, \"47.96.141.44\",6379,30000,\"你的密码\"); } public void execute(CallWithJedis callWithJedis) { try (Jedis jedis=jedisPool.getResource()) { callWithJedis.call(jedis); } }} 1、基本实现方式：123456789101112131415161718192021public class LockTest { public static void main(String[] args) { Redis redis = new Redis(); redis.execute(jedis -&gt; {// 获得锁，只有获得了锁才能进行数据的操作// 这里我们只是测试作用，作为占坑检验操作 Long setnx = jedis.setnx(\"k1\", \"v1\"); if (set != null &amp;&amp; set.equals(\"OK\")) {// 获得了锁 即没人占位 插入真正的key jedis.set(\"name\", \"lc\"); String s = jedis.get(\"name\"); System.out.println(s);// 释放占用的资源 jedis.del(\"k1\"); } else {// 修改失败 有人占位 System.out.println(\"有人占坑\"); } }); }} 上述代码问题：程序异常无法释放锁​ 如果我们的业务代码在执行的过程中抛出异常或者挂了，这样会导致del指令没有被调用(没有释放锁)，那么后面的请求全部堵塞在这，锁永远得不到释放 ​ 这里我们的解决方式就是在获得锁后，给锁添加过期时间，确保锁在一定的时间之后，能够得到释放。 2、给锁添加过期时间jedis.expire(&quot;k1&quot;, 5); 1234567891011121314151617181920212223public class LockTest { public static void main(String[] args) { Redis redis = new Redis(); redis.execute(jedis -&gt; {// 获得锁，只有获得了锁才能进行数据的操作// 这里我们只是测试作用，作为占坑检验操作 Long setnx = jedis.setnx(\"k1\", \"v1\"); if (set != null &amp;&amp; set.equals(\"OK\")) { //给锁添加一个过期时间，防止应用在运行过程中抛出异常导致锁无法及时得到释放 jedis.expire(\"k1\", 5);// 获得了锁 即没人占位 插入真正的key jedis.set(\"name\", \"lc\"); String s = jedis.get(\"name\"); System.out.println(s);// 释放占用的资源 jedis.del(\"k1\"); } else {// 修改失败 有人占位 System.out.println(\"有人占坑\"); } }); }} 上述代码的问题：获得锁和设置过期时间不能保证原子性​ 我们在获得锁和设置锁的过期时间如果服务器挂掉，这个时候锁被占用，过期时间也没有设置，那么也会发生死锁，因为获取锁和设置过期时间为两个操作，不具备原子性 ​ 解决方式：让setnx和exprie同时执行，即在获得锁的同时，同时设置锁的过期时间，保证原子性 3、获得锁同时设置锁过期时间为了解决这个问题，从 Redis2.8 开始，setnx 和 expire 可以通过一个命令一起来执行了 String set = jedis.set(&quot;k1&quot;, &quot;v1&quot;, new SetParams().nx().ex(5)); 1234567891011121314151617181920212223public class LockTest { public static void main(String[] args) { Redis redis = new Redis(); redis.execute(jedis -&gt; {// 这里我们可以在set操作的同时，同时加入其他参数：nx不存在时操作，ex设置过期时间// 这样我们可以防止在获得锁和设置过期时间，如果服务器挂掉，则这个时候锁被占用，无法及时得到释放，从而造成死锁。因为获得锁和设置过期时间是两个操作，不具备原子性。 String set = jedis.set(\"k1\", \"v1\", new SetParams().nx().ex(5)); if (set != null &amp;&amp; set.equals(\"OK\")) {// 给锁添加一个过期时间，防止应用在运行过程中抛出异常导致锁无法及时得到释放 jedis.expire(\"k1\", 5);// 修改成功 即没人占位 插入真正的key jedis.set(\"name\", \"lc\"); String s = jedis.get(\"name\"); System.out.println(s);// 释放占用的资源 jedis.del(\"k1\"); } else {// 修改失败 有人占位 System.out.println(\"有人占坑\"); } }); }} 二、解决超时问题​ 通过以上业务代码我们可以发现，为了防止业务在执行的时候抛出异常，我们给每一个锁添加一个超时时间，超时之后，锁自动释放。当业务时间过长，那么会出现线程紊乱。 ​ 案例：第一个线程首先获得锁，然后开始执行业务代码，这是执行业务代码的时间超过了锁设定的过期时间，那么该线程还未执行完业务代码该锁就被释放了。此时第二个线程获取到锁开始执行，此时该线程执行了几秒之后，第一个线程也执行完了，那么该第一个线程就会释放锁(del)，但是注意，它释放的这个锁是第二个线程的锁，第三个第四个线程也如此，那么就会造成线程紊乱，修改紊乱。 解决方式： ①尽量避免在获取锁的时候，执行耗时操作 ②我么可以在锁上考虑，将锁的value设置为一个随机字符串，每次释放锁的时候，都去比较随机字符串是否一致，如果一致，再去释放锁，否则，不释放。 对于第二种方案，由于释放锁的时候，要去查看锁的 value，第二个比较 value 的值是否正确，第三步释放锁，有三个步骤，很明显三个步骤不具备原子性，为了解决这个问题，我们得引入Lua脚本 Lua 脚本的优势： 使用方便，Redis 中内置了对 Lua 脚本的支持。 Lua 脚本可以在 Redis 服务端原子的执行多个 Redis 命令。 由于网络在很大程度上会影响到 Redis 性能，而使用 Lua 脚本可以让多个命令一次执行，可以有效解决网络给 Redis 带来的性能问题。 在 Redis 中，使用 Lua 脚本，大致上两种思路： 提前在 Redis 服务端写好 Lua 脚本，然后在 Java 客户端去调用脚本（推荐）。 可以直接在 Java 端去写 Lua 脚本，写好之后，需要执行时，每次将脚本发送到 Redis 上去执行。 在Redis服务器中创建Lua脚本基本步骤①、切换到redis安装目录，创建存储lua的文件夹 ②、创建vi releasewherevalueequal.lua文件 ③、编写内容,保存退出 12345if redis.call(\"get\",KEYS[1])==ARGV[1] then return redis.call(\"del\",KEYS[1])else return 0end reids.call 表示调用get操作方式，KEYS[1]表示传过来要操作的key(可以有多个key，索引从1开始)，ARGV表示传过来的其他参数。 ④、给Lua脚本求一个SHA1和(相当于给该lua文件算出一个标识符) redis-cli script load &quot;$(cat lua/releasewherevalueequal.lua)&quot; 返回的标识符： 19d0abd0b3b3bfd1b5294f957dcab483e58b97c84 script load相当于这个命令会在 Redis 服务器中缓存 Lua 脚本，并返回脚本内容的 SHA1 校验和，然后在 Java 端调用时，传入 SHA1 校验和作为参数，这样 Redis 服务端就知道执行哪个脚本了。 接下来，在 Java 端调用这个脚本。 1234567891011121314151617181920212223242526272829303132public class LuaTest { public static void main(String[] args) { Redis redis=new Redis(); redis.execute(jedis -&gt; {// 1、获取一个随机字符串 String s = UUID.randomUUID().toString();// 2、获取锁 String k1 = jedis.set(\"k1\", s, new SetParams().nx().ex(50));// 3、判断是否拿到锁 if (k1 != null &amp;&amp; k1.equals(\"OK\")) {// 4、业务操作 jedis.set(\"lc\", \"louchen.top\"); System.out.println(jedis.get(\"lc\"));// 5、释放锁// 校验和; keys; 其他的参数// 使用redis中加载的lua// jedis.evalsha(\"9d0abd0b3b3bfd1b5294f957dcab483e58b97c84\", Arrays.asList(\"k1\"),Arrays.asList(s));// 直接在java客户端中写lua String script = \"if redis.call('get',KEYS[1]) == ARGV[1] then\" + \" return redis.call('del',KEYS[1]) \" + \"else\" + \" return 0 \" + \"end\"; jedis.eval(script, Arrays.asList(\"k1\"), Arrays.asList(s)); }else{ System.out.println(\"没有拿到锁\"); } }); }} 三、基本命令介绍​ 使用jedis的2.7.x及以上版本。 ​ 命令：SET key value [NX|XX] [EX|PX] seconds ​ NX – 只有键key不存在的时候才会设置key的值 ​ XX – 只有键key存在的时候才会设置key的值 ​ EX seconds – 设置键key的过期时间，单位时秒 ​ PX milliseconds – 设置键key的过期时间，单位时毫秒","link":"/2020/07/24/redis/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"},{"title":"Redis做消息队列","text":"Redis做消息队列​ 我们平时说到消息队列，一般都是指 RabbitMQ、RocketMQ(阿里)、ActiveMQ 以及大数据里边的 Kafka，这些是我们比较常见的消息中间件，也是非常专业的消息中间件，作为专业的中间件，它里边提供了许多功能。 但是，当我们需要使用消息中间件的时候，并非每次都需要非常专业的消息中间件，假如我们只有一个消息队列，只有一个消费者，那就没有必要去使用上面这些专业的消息中间件，这种情况我们可以直接使用 Redis 来做消息队列。 Redis 的消息队列不是特别专业，他没有很多高级特性，适用简单的场景，如果对于消息可靠性有着极高的追求，那么不适合使用 Redis 做消息队列。 一、Redis 做消息队列​ 使用它里边的 List 数据结构就可以实现，我们可以使用 lpush/rpush 操作来实现入队，然后使用 lpop/rpop 来实现出队。 ​ 在客户端（例如 Java 端），我们会维护一个死循环来不停的从队列中读取消息，并处理，如果队列中有消息，则直接获取到，如果没有消息，就会陷入死循环，直到下一次有消息进入，这种死循环会造成大量的资源浪费，这个时候，我们可以使用之前讲的 blpop/brpop(阻塞式的弹出) 二、延迟消息队列延迟队列可以通过 zset 来实现，因为 zset 中有一个 score，我们可以把时间作为 score，将 value 存到 redis 中，然后通过轮询的方式，去不断的读取消息出来。 首先，如果消息是一个字符串，直接发送即可，如果是一个对象，则需要对对象进行序列化，这里我们使用 JSON 来实现序列化和反序列化。 1、pom.xml123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;distributed_lock&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;!--序列化我们需要使用到的jackson--&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.10.3&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2、jedis和jedis连接池工具 CallWithJedis 1234public interface CallWithJedis { void call(Jedis jedis);} Redis 12345678910111213141516171819202122232425262728293031public class Redis { private JedisPool jedisPool; public Redis() {// 连接池配置对象 GenericObjectPoolConfig config=new GenericObjectPoolConfig();// 连接池最大空闲数 config.setMaxIdle(300);// 最大连接数 config.setMaxTotal(1000);// 连接最大等待时间（毫秒）。-1表示无限制 config.setMaxWaitMillis(30000);// 在空闲时检查有效性 config.setTestOnBorrow(true); /** * 1、连接池配置 * 2、redis地址 * 3、端口 * 4、超时时间 * 5、密码 */ jedisPool = new JedisPool(config, \"47.96.141.44\",6379,30000,\"你的密码\"); } public void execute(CallWithJedis callWithJedis) { try (Jedis jedis=jedisPool.getResource()) { callWithJedis.call(jedis); } }} 3、消息对象 LcMessgae 123456789101112131415161718192021222324252627282930public class LcMessgae implements Serializable { private String id; private Object data; public String getId() { return id; } public LcMessgae setId(String id) { this.id = id; return this; } public Object getData() { return data; } public LcMessgae setData(Object data) { this.data = data; return this; } @Override public String toString() { return \"LcMessgae{\" + \"id='\" + id + '\\'' + \", data=\" + data + '}'; }} 4、延迟消息队列对象1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * 延迟消息队列 */public class DelayMsgQueue { private Jedis jedis; private String queue; public DelayMsgQueue(Jedis jedis, String queue) { this.jedis = jedis; this.queue = queue; } /** * 消息入队 * @param data 要发送的数据 */ public void queue(Object data) {// 构造一个消息对象 LcMessgae msg=new LcMessgae(); msg.setId(UUID.randomUUID().toString()); msg.setData(data);// 序列化对象 try {// 序列化对象为字符串 String s = new ObjectMapper().writeValueAsString(msg); System.out.println(\"msg publish:\"+new Date());// 队列的名称; 延迟五秒发送; 发送的消息 jedis.zadd(queue, System.currentTimeMillis() + 5000, s); } catch (JsonProcessingException e) { e.printStackTrace(); } } /** * 消息消费 */ public void loop() {// 如果当前线程没有被打断 则一直循环查找消息 while (!Thread.interrupted()){// 读取的队列; 从0开始; 到当前时间戳结束; 偏移量; 读取的个数 Set&lt;String&gt; zrange= jedis.zrangeByScore(queue, 0, System.currentTimeMillis(), 0, 1);// 如果读到的为空 if (zrange.isEmpty()) { try {// 休息0.5秒 Thread.sleep(500); } catch (InterruptedException e) {// 抛出异常直接。直接跳出循环 break; }// 否则 直接进行下一次循环 continue; }// 如果有消息 直接加载消息 String next = zrange.iterator().next();// 如果成功弹出指定消息 if(jedis.zrem(queue, next)&gt;0){// 处理业务// 消费该队列即可 try {// 将该字符串member反序列化为对象 LcMessgae lcMessgae = new ObjectMapper().readValue(next, LcMessgae.class); System.out.println(\"receive msg:\"+new Date()+\"&gt;&gt;&gt;&gt;&gt;&gt;&gt;\"+lcMessgae); } catch (JsonProcessingException e) { e.printStackTrace(); } } } }} 5、测试123456789101112131415161718192021222324252627282930313233343536373839404142package org.lc.distributed_lock;import javax.annotation.Resource;/** * @BelongsProject: distributed_lock * @BelongsPackage: org.lc.distributed_lock * @Author: lc * @CreateTime: 2020-04-23 22:17 * @Description: */public class DelayMsgTest { public static void main(String[] args) { Redis redis=new Redis(); redis.execute(jedis-&gt;{// 构造一个消息队列 DelayMsgQueue queue = new DelayMsgQueue(jedis, \"lc-queue\"); Thread producer= new Thread(() -&gt; { for (int i = 0; i &lt; 5; i++) {// 生产者 queue.queue(\"louchen.top&gt;&gt;&gt;&gt;\"+i); } });// 消费者 Thread consumer = new Thread(() -&gt; queue.loop());// 启动 producer.start(); consumer.start();// 休息7s，停止程序 try { Thread.sleep(7000); //中断消费 consumer.interrupt(); } catch (InterruptedException e) { e.printStackTrace(); } }); }} 12345678910msg publish:Thu Apr 23 22:44:55 GMT+08:00 2020msg publish:Thu Apr 23 22:44:55 GMT+08:00 2020msg publish:Thu Apr 23 22:44:55 GMT+08:00 2020msg publish:Thu Apr 23 22:44:55 GMT+08:00 2020msg publish:Thu Apr 23 22:44:55 GMT+08:00 2020receive msg:Thu Apr 23 22:45:00 GMT+08:00 2020&gt;&gt;&gt;&gt;&gt;&gt;&gt;LcMessgae{id='d366029d-0a62-49f5-96fb-20f87c51db4e', data=louchen.top&gt;&gt;&gt;&gt;0}receive msg:Thu Apr 23 22:45:01 GMT+08:00 2020&gt;&gt;&gt;&gt;&gt;&gt;&gt;LcMessgae{id='e9c730f6-aebc-4244-982c-28063f2ad439', data=louchen.top&gt;&gt;&gt;&gt;1}receive msg:Thu Apr 23 22:45:01 GMT+08:00 2020&gt;&gt;&gt;&gt;&gt;&gt;&gt;LcMessgae{id='ef6129d3-b62b-4222-9c89-dffce6a3ed7c', data=louchen.top&gt;&gt;&gt;&gt;2}receive msg:Thu Apr 23 22:45:01 GMT+08:00 2020&gt;&gt;&gt;&gt;&gt;&gt;&gt;LcMessgae{id='7077679f-f968-4261-a688-cd8f637874d9', data=louchen.top&gt;&gt;&gt;&gt;3}receive msg:Thu Apr 23 22:45:01 GMT+08:00 2020&gt;&gt;&gt;&gt;&gt;&gt;&gt;LcMessgae{id='1089b3e5-bea4-47a0-886f-b020091fe01a', data=louchen.top&gt;&gt;&gt;&gt;4}","link":"/2020/07/24/redis/Redis%E5%81%9A%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"title":"Redis基本数据类型的操作","text":"Redis基本数据类型与key相关的基本操作1、删除keydel [key] 2、删除当前数据库中的所有key1flushdb 3、删除所有数据库的key1flushall 4、序列化给定的keydump [key] 5、判断指定的key是否存在0不存在；1存在 exists [key] 6、查看key的有效期（秒）-2已过期 -1永久有效 ttl [key] 7、设置key的有效期注意：如果key在过期时间被重新set了，那么过期时间会失效 1设置成功 0设置失败 expire [key] [seconds(秒)] 8、移除一个key的过期时间persist [key] 9、通配符查看所有的keykeys * 查看所有key keys k 查看以k开头的所有key keys [pattern] 10、查看key的有效期（毫秒）pttl [key] 注意：四种数据类型（list/set/zset/hash），在第一次使用时，如果容器不存在，就自动创建一个 四种数据类型（list/set/zset/hash），如果里边没有元素了，那么立即删除容器，释放内存。 一、StringString 是 Redis 里边最最简单的一种数据结构。在 Redis 中，所以的 key 都是字符串，但是，不同的 key 对应的 value 则具备不同的数据结构，我们所说的五种不同的数据类型，主要是指 value 的数据类型不同。 Redis 中的字符串是动态字符串，内部是可以修改的，像 Java 中的 StringBuffer，它采用分配冗余空间的方式来减少内存的频繁分配。在 Redis 内部结构中，一般实际分配的内存会大于需要的内存，当字符串小于 1M 的时候，扩容都是在现有的空间基础上加倍，扩容每次扩 1M 空间，最大 512M。 1、append追加操作append [key] [value] 12345append k1 lcappend k1 .hello#获取键值get k1 #==&gt; 'lc.hello' 2、set给key赋值set [key] [value] 12set k2 33get k2 # ==&gt; '33' 3、decr可以实现对 value 的减 1 操作（前提是 value 是一个数字），如果 value 不是数字，会报错，如果 value 不存在，则会给一个默认的值为 0，在默认值的基础上减一。 decr [key] 1decr k3 # ==&gt; '-1' 12set k2 33decr k2 #==&gt; '32' 4、decrby设置减的步长decrby [key] [decrement] 12set k2 100decrby k2 10 #==&gt; '90' 5、get获取key的valueget [key] 6、getrange截取指定范围的字符串，相当于java中的substringstart 表示开始的位置(包含此位置) end 表示结束的位置 -1 表示截取到最后一个(包含) getrange [key] [start] [end] 1234set lou www.louchen.topget lou #==&gt; \"www.louchen.top\"getrange lou 4 -1 #==&gt; \"louchen.top\"getrange lou 4 -5 #==&gt; \"louchen\" 7、getset获取并更新某一个keygetset [key] [value] 123set k2 90getset k2 100get k2 #==&gt; \"100\" 8、incr给某一个key的value自增incr [key] 9、incrby给某一个key的value自增，并设置步长incrby [key] 10、incrbyfloat和incrby类似，步长可以设置为浮点数incrbyfloat [key] [increment] 123set k2 100incrbyfloat k2 0.22get k2 #==&gt; 100.22 11、mget 和 mset批量获取与批量设置mget [key1] [key2] [key3] [key...] mset [key1] [value1] [key2] [value2] [key...] [value..] 12mset k1 11 k2 22 k3 33mget k1 k2 k3 #===&gt; \"11\" \"22\" \"33\" 12、setex给key设置value并同时设置过期时间(秒)set [key] [seconds] [value] 123set k1 10 woshi#十秒后再获取get k1 #==&gt; \"nil(表示不存在)\" 13、ttl查看key的过期时间 -1表示不会过期 -2表示已过期ttl [key] 14、psetex给key设置value并同时设置过期时间(毫秒)set [key] [millseconds] [value] 15、setnx默认情况下set命令会覆盖已存在的key, setnx不会修改已存在的key0表示修改失败 setnx [key] [value] 15、msetnx批量设置，只要有一个已存在的key都不会修改msetnx [key1] [value1] [key2] [value2] [key...] [value..] 16、setrange覆盖一个已经存在的key的value，指定范围覆盖offset为偏移量,若偏移量超过本身字符的长度，则超过的位置用0补齐 setrange [key] [offset] [value] 123456set k1 louchensetrange k1 0 222get k1 #==&gt; \"222chen\"setrange k1 10 333get k1 #==&gt; \"222chen\\x00\\x00\\x00333\" 17、strlen查看字符串总长度strlen [key] 二、String的BIT操作在 Redis 中，字符串都是以二进制的方式来存储的。例如 set k1 a，a 对应的 ASCII 码是 97，97 转为二进制是 01100001，BIT 相关的命令就是对二进制进行操作的。 getbit key 对应的 value 在 offset 处的 bit 值。 getbit [key] [offset] setbit 修改 key 对应的 value 在 offset 处的 bit 值 setbit [key] [offset] [value] bitcount 统计二进制数据中 1 的个数。 bitcount [key] 三、List集合(可重复)1、lpush 和 lrangelpush将所有指定的值插入到存于 key 的列表的头部(相当于栈,先进后出)。如果 key 不存在，那么在进行 push 操作前会创建一个空列表。 如果 key 对应的值不是一个 list 的话，那么会返回一个错误。 lpush [key] [value1] [value2] [value...] lrange返回列表指定区间内的元素 返回列表所有元素 lrange [key] 0 -1 lrange [key] [start] [stop] 12lpush lc louchen.top lc.vhrlrange lc 0 1 #==&gt; 1) \"lc.vhr\" 2) \"louchen.top\" 2、rpush从右往左插入，先进先出rpush [key] [value1] [value2] [value...] 3、rpop移除并返回列表的尾元素rpop [key] 4、lpop移除并返回列表的头元素lpop [key] 5、lindex返回列表中下标为index的元素，只是查询索引从0开始 lindex [key] [index] 6、ltrim对列表进行修剪从指定start索引位置(包含此位置)到stop位置截取(包含此位置) ltrim [key] [start] [stop] 7、blpop阻塞式的弹出，相当于lpop的阻塞版即当弹出所有元素时，再次弹出会阻塞此操作，等待下一次插入再弹出，阻塞时间设置为秒 blpop [key] [timeout秒] 四、set集合(不可重复)1、sadd添加元素到集合若有重复的value，则只会添加一个 sadd [key] [value1] [value2] [value...] 2、smembers获取该key的所有元素smembers [key] 3、srem移除指定的元素,可以同时移除多个srem [key] [member1] [member2] 4、sismember返回某一个元素是否在集合中0 代表不存在，1代表存在 sismember [key] [member] 5、scard返回集合的数量scard [key] 6、srandmember随机返回一个或多个元素count表示随机返回元素的个数。没有count则返回一个 srandmember [key] [count] 7、spop随机返回并出栈一个元素spop [key] 8、smove把一个元素从一个集合移动到另一个集合source:源集合 destination：目标集合 member：元素 smove [source] [destination] [member] 123sadd k1 a b c#将k1中的a元素移动到k2中smove k1 k2 a 9、sdiff返回两个集合的差集这里注意 是key1-key2集合。除去key2在key1中的元素。反之类似 sidff [key1] [key2] 10、sinter返回两个集合的交集sinter [key1] [key2] 11、sdiffstore类似于sdiff,只不过，计算出来的结果会保存在一个新的集合中destination:保存的新集合的key key1-key2的差集 sdiffstore [destination] [key1] [key2] 12、sinterstore类似于sinter,只不过，计算出来的交集会保存在一个新的集合中destination:保存的新集合的key key1，key2的交集 sinterstore [destination] [key1] [key2] 13、sunion求并集14、sunionstore求并集保存到新的集合中五、Hash在 hash 结构中，key 是一个字符串，value 则是一个 key/value 键值对 1、hset添加值hset [key] [field] [value] 123hset k1 name lchset k1 age 18hset k1 gender male 2、hget获取值hget [key] [field] 1hget k1 name #==&gt; \"lc\" 3、hmset批量设置hmset [key] [field1] [value1] [field2] [value2].. 1hmset k2 name lcc age 18 gender femle 4、hmget批量获取hmget [key] [field1] [field2]... 12345hmget k2 name age gender------1) \"lcc\"2) \"18\"3) \"femle\" 5、hdel删除一个指定的fieldhdel [key] [field1] [field2] 6、hsetnx默认情况下，如果field存在则会覆盖已有的value。但是hsetn不能覆盖已有的field值hsetnx [key] [field] [value] 7、hvals获取所有的valuehvals [key] 8、hkeys获取所有的keyhkeys [key] 9、hgetall同时获取所有的key和valuehgetall [key] 10、hexists返回指定field是否存在不存在返回0 存在返回1 hexists [key] [field] 11、hincrby给指定的value自增1或指定步长increment:步长 hincrby [key] [field] [increment] 12、hincrbyfloat给指定的value自增指定浮点数hincrby [key] [field] [increment] 13、hlen返回某一个key中value的数量hlen [key] 14、hstrlen返回某一个key中的某一个field的字符串长度hstrlen [key] [filed] 六、ZSet有序set集合 1、zadd将指定的元素添加到有序集合中score：分数 作为值 member1： 作为键 zadd [key] [score1] [member1] [score2] [member2]... 1zadd k1 20 v1 k1 30 v2 40 v3 50 v4 2、zscore返回member的score值zscore [key] [member] 1zscore k1 v1 # ==&gt; \"20\" 3、zrange返回指定集合范围中的一组元素withsocres: 返回score值(可选) 返回k1集合中的所有member和score zcore k1 0 -1 withsocres zcore [key] [start] [stop] withsocres 123456789101112131415161718zrange k1 0 -1 withscores---------1) \"v1\"2) \"20\"3) \"v2\"4) \"30\"5) \"v3\"6) \"40\"7) \"v4\"8) \"50\"zrange k1 0 3--------------1) \"v1\"2) \"v2\"3) \"v3\"4) \"v4\" 4、zrevrange逆序返回指定集合范围中的一组元素zrevrange [key] [start] [stop] withscores 5、zcard返回元素个数member键的个数 zcard [key] 6、zcount返回score在某一个区间内的元素的个数默认是闭区间 即包含min和max zcount [key] [min] [max] 1234#包含20，50ZCOUNT k1 20 50 #==&gt; 4#在20到50之间 不包含20，50zocunt k1 (20 (50 #==&gt; 2 7、zrangebyscore按照score的范围返回元素withscores: 是否携带score(可选) zrangebyscore [key] [min] [max] withscores 8、zrank返回元素的排名(从小到大，从0开始)zrank [key] [member] 1zrank k1 v1 #==&gt; 0 9、zrevrank返回元素排名(从大到小)zrevrank [key] [memeber] 1zrevrank k1 v1 #==&gt; 3 10、zincrby按照指定步长自增increment: 步长 zincrby [key] [increment] [member] 11、zinterstore求两个集合的交集并存入新的集合destination：新的目标集合 numkeys：相同member的个数 把key1和key2中的members相同的元素把其score累加得到新的score zinterstore [destination] [numkeys] [key1] [key2].. 12、zrem弹出指定member元素zrem [key] [member1] [member2] 13、zlexcount计算有序集合中成员数量ZLEXCOUNT k1 - + 返回最小的到最大的成员数量(即全部) zlexcount [key] [min] [max] 12#统计v2到v3之间的成功数 包括v2和v3zlexcount k1 [v2 [v3 #==&gt; 2 14、zrangebylex返回指定区间内的成员zrangebylex [key] [min] [max] 12345ZRANGEBYLEX k1 - +------------------1) \"v2\"2) \"v3\"3) \"v4\"","link":"/2020/07/24/redis/Redis%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"title":"Redis持久化方式","text":"Redis持久化方式Redis 是一个缓存工具，也叫做 NoSQL 数据库，既然是数据库，必然支持数据的持久化操作。在 Redis 中，数据库持久化一共有两种方案： 1、RDB(快照方式)：半持久化方式 Reids在内存中的数据库记录定时dump到磁盘上的RDB持久化 RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。 一次全量备份。存储的形式为二进制序列化的形式，存储比较紧簇，比较省空间。 2、AOF(append only file) 全持久化方式 Reids的操作日志以追加的方式写入文件 AOF持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。 连续的增量备份，存储的是内存修改的指令的记录文本，随着时间的推移，该文本会越来越大。如果我们服务器需要重启，进行数据恢复加载的时候，会非常慢，相当于把文本中的指令从头到尾重新执行一遍，所以我们需要定期对日志进行重新瘦身 一、RDB（快照持久化）1.1原理Redis使用操作系统的多进程机制来实现快照持久化。Redis持久化的时候，会调用glibc函数fork一个子进程，然后将快照持久化操作完全交给子进程去处理，而父进程处理客户端请求。在这个过程中，子进程能够看到内存中的数据在子进程产生的一瞬间就固定下来了。再也不会改变，这就是Redis持久化交快照 1.2具体配置在我们重启Redis服务器时，发现之前存储的数据依然还在。所以在Redis中，默认情况下RDB快照持久化是默认开启的，我们在Reidis安装目录下默认会产生一个dump.rdb 文件，这个文件就是备份下来的文件。当Redis重新启动时，就会加载该文件。当我们删除drum.rdb文件时，再去重启服务器，会发现没有数据 redis.conf中的具体配置： 12345678910111213141516#快照的频率save 900 1 #900秒内如果有一个键被修改，就备份 save 300 10save 60 10000#在快照创建出错的时候是否继续执行客户端写命令 stop-writes-on-bgsave-error yes #默认为yes#是否对快照文件进行压缩rdbcompression yes #默认为yes#生成日志文件的名称dbfilename dump.rdb#日志文件的目录 默认在当前安装目录的下dir ./ 1.3备份的流程1、在Redis运行过程中，我们可以向Redis发送一条save命令来创建一个快照。（没有手动指定是，在配置文件中满足条件的快照频率，redis自动帮我们执行） 12#手动发送save 但是save是一个阻塞命令，Redis在收到save命令开始处理备份操作的之后，在处理完成之前，将不再处理其他请求。其他命令等待被挂起，所以用到的并不多 2、我们一般使用bgsave命令，bgsave会fork一个子进程去处理备份的事情，不影响父进程处理客户端请求 1bgsave 3、我们定义的备份规则，如果规则 满足，也会自动触发bgsave 4、此外，当我们执行shutdown命令时，也会触发save命令，备份完成后，Redis才会关闭。 5、用Redis搭建主从复制时，在从连上主机之后，会自动发送一个sync同于命令，主机收到命令之后，首先执行bgsave对数据执行快照，然后才会给从机发送快照数据进行同步。 、 1.4 RDB触发备份的三种机制①、save会阻塞当前Redis服务器，执行save期间，不能执行其他客户端命令，只有当前命令执行完毕，才能执行其他命令 ②、bgsaveredis服务器父进程fork一个子进程执行该save命令，不影响父进程执行客户端的其他的命令 ③、自动触发在redis.conf配置中，我们可以save 900 1的配置 表示900秒内有一个key修改就执行该备份操作 二、AOF持久化与快照持久化不同，AOF 持久化是将被执行的命令追加到 aof 文件末尾，在恢复时，只需要把记录下来 的命令从头到尾执行一遍即可。 redis.conf的详细配置： 12345678910111213141516#是否开启 aof配置 默认为noappendonly yes#AOF文件名appendfilename \"appendonly.aof\"#备份的时机# appendfsync always #每执行一个命令都追加appendfsync everysec #每秒都执行一次备份# appendfsync no#表示AOP文件在压缩时，是否还继续进行同步操作no-appendfsync-on-rewrite no#压缩的时机auto-aof-rewrite-percentage 100 #表示当前aof文件大小超过上一次重写时的aof文件大小的百分之多少时，再次进行重新auto-aof-rewrite-min-size 64mb #如果之前没有重写，则以启动的aof大小为依据，同时要求文件大小至少大于64mb 当我们开启aof配置后，如果也开启了rdb配置，则不知道是哪个在备份，这里我们关闭rdb备份 1234 save \"\"#save 900 1#save 300 10#save 60 10000 我们删点之前的dump.rdb的备份文件，然后重启服务器，执行一个set k1 v1的测试命令,回到根目录，这时我们发现增加了一个appendonly.aof的文件。进入到文件中: 123456789101112*2$6SELECT$10*3$3set$2k1$2v1 我们发现就是通过resp协议来执行的命令 手动发送备份的命令： 原理和gbsave一致 自动执行在配置文件中配置 1127.0.0.1:6379&gt; BGREWRITEAOF 2.1 AOP触发备份的三种机制（1）每修改同步always：同步持久化 每次发生数据变更会被立即记录到磁盘 性能较差但数据完整性比较好 （2）每秒同步everysec：异步操作，每秒记录 如果一秒内宕机，有数据丢失 （3）不同no：从不同步 三、RDB和AOP的选择比较1、RDB优势和劣势：①、优势（1）RDB文件紧凑，全量备份，非常适合用于进行备份和灾难恢复。 （2）生成RDB文件的时候，redis主进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作。 （3）RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快 ②、劣势​ RDB快照是一次全量备份，存储的是内存数据的二进制序列化形式，存储上非常紧凑。当进行快照持久化时，会开启一个子进程专门负责快照持久化，子进程会拥有父进程的内存数据，父进程修改内存子进程不会反应出来，所以在快照持久化期间修改的数据不会被保存，可能丢失数据。 2、AOF的优势和劣势①、优势（1）AOF可以更好的保护数据不丢失，一般AOF会每隔1秒，通过一个后台线程执行一次fsync操作，最多丢失1秒钟的数据。 （2）AOF日志文件没有任何磁盘寻址的开销，写入性能非常高，文件不容易破损。 （3）AOF日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。 （4）AOF日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用flushall命令清空了所有数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall命令给删了，然后再将该AOF文件放回去，就可以通过恢复机制，自动恢复所有数据 ②、劣势（1）对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大 （2）AOF开启后，支持的写QPS会比RDB支持的写QPS低，因为AOF一般会配置成每秒fsync一次日志文件，当然，每秒一次fsync，性能也还是很高的 （3）以前AOF发生过bug，就是通过AOF记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。","link":"/2020/07/24/redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%93%8D%E4%BD%9C/"},{"title":"Redis事务","text":"Redis事务​ 正常来说，一个可以商用的数据库往往都有比较完善的事务支持，Redis 当然也不例外。相对于 关系型 数据库中的事务模型，Redis 中的事务要简单很多。因为简单，所以 Redis 中的事务模型不太严格，所 以我们不能像使用关系型数据库中的事务那样来使用 Redis。 在关系型数据库中，和事务相关的三个指令分别是： begin commit callback 在 Redis 中，当然也有对应的指令： multi(开启事务) 标记一个事务块的开始（ queued ） exec (执行事务) 执行所有事务块的命令 （ 一旦执行exec后，之前加的监控锁都会被取消掉 ） discard(事务回滚) 关系型数据库中ACID事务四大特性： 原子性（Atomicity）原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 一致性（Consistency）事务前后数据的完整性必须保持一致。即操作完成的状态必须一致 隔离性（Isolation）事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。 持久性（Durability）持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响 Redis事务的概念：​ Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。 总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。 Redis没有事务的隔离级别的概念：​ 批量操作在发送 EXEC 命令前被放入队列缓存，并不会被实际执行，也就不存在事务内的查询要看到事务里的更新，事务外查询不能看到。 Redis事务的三个阶段： 开始事务 命令入队 执行事务 Redis不保证原子性​ Redis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。 注意，Redis 中的事务并不能算作原子性。它仅仅具备隔离性，也就是说当前的事务可以不被其他事务 打断。 由于每一次事务操作涉及到的指令还是比较多的，为了提高执行效率，我们在使用客户端的时候，可以 通过 pipeline 来优化指令的执行。 如下操作： multl/exec: 事务开启–执行 123456789101112131415161718192021127.0.0.1:6379&gt; multi #开启事务OK127.0.0.1:6379&gt; set k1 v1 #操作1QUEUED 127.0.0.1:6379&gt; set k2 v2 #操作2QUEUED127.0.0.1:6379&gt; INCR k1 #给k1键的值自增1，操作失败QUEUED127.0.0.1:6379&gt; exec #执行事务#结果1) OK2) OK3) (error) ERR value is not an integer or out of range #只有第三个操作失败 #结论 事务并没有因为一个操作失败而回滚其他事务，只是具备其隔离性。127.0.0.1:6379&gt; get k1\"v1\"127.0.0.1:6379&gt; keys *1) \"k1\"2) \"k2\" 1、非隔离性事务案例 案例：银行转账 ①、初始化余额： 1set money 1000 ②、开启一个线程A执行取钱操作： 注意此时，我们并没有提交事务 1234127.0.0.1:6379&gt; multi #开启事务OK127.0.0.1:6379&gt; set money 0QUEUED ③、开启另外一个线程B存钱操作 开启事务，并且提交事务。 123456127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set money 3000QUEUED127.0.0.1:6379&gt; exec #提交事务1) OK ④、线程B操作完之后，这是恰好线程A完成取钱操作 12345678127.0.0.1:6379&gt; multi OK127.0.0.1:6379&gt; set money 0QUEUED127.0.0.1:6379&gt; exec 1) OK127.0.0.1:6379&gt; get money\"0\" 这时我们发现存钱的操作没有完成。导致出现事务的非隔离性 2、watch指令​ watch指令类似于乐观锁，在事务提交时，如果watch监控的多个KEY中任何KEY的值已经被其他客户端更改，则使用EXEC执行事务时，事务队列将不会被执行，同时返回Nullmulti-bulk应答以通知调用者事务执行失败。 在Redis中，提供一个watch指令来监控一个key,通过这种监控，我们可以确保在 exec 之前，watch 的键的没有被修改过。 如果一个被watch监控的key被其他事务改变，那么当前事务所操作的就会失败 初始化余额 1set money 1000 ①监视money 开启一个线程A执行取钱操作 注意：这里未提交事务 123456127.0.0.1:6379&gt; watch money #监视要操作的keyOK127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set money 0QUEUED ②开启另一个线程B执行存钱操作 123456127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set money 3000QUEUED127.0.0.1:6379&gt; exec1) OK ③这是B线程执行完毕后，这是恰好线程A再去执行提交操作 监控的key被其他事务所改变，即该事务执行失败。 12345678910127.0.0.1:6379&gt; watch moneyOK127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set money 0QUEUED127.0.0.1:6379&gt; exec (nil) #执行失败127.0.0.1:6379&gt; get money\"3000\" 3、unwatch 指令取消watch对所有key的监控 4、discard指令取消事务，放弃事务块中的所有命令 multi/discard: 事务开启–回滚 （放弃当前事务执行的所有操作） 1234567891011121314127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set k1 v1QUEUED127.0.0.1:6379&gt; set k2 v2QUEUED127.0.0.1:6379&gt; INCR k1QUEUED127.0.0.1:6379&gt; set k3 v3QUEUED127.0.0.1:6379&gt; DISCARDOK127.0.0.1:6379&gt; keys *(empty list or set) 二、java操作reids实现事务jedis连接工具 Redis 12345678910111213141516171819202122232425262728293031public class Redis { private JedisPool jedisPool; public Redis() {// 连接池配置对象 GenericObjectPoolConfig config=new GenericObjectPoolConfig();// 连接池最大空闲数 config.setMaxIdle(300);// 最大连接数 config.setMaxTotal(1000);// 连接最大等待时间（毫秒）。-1表示无限制 config.setMaxWaitMillis(30000);// 在空闲时检查有效性 config.setTestOnBorrow(true); /** * 1、连接池配置 * 2、redis地址 * 3、端口 * 4、超时时间 * 5、密码 */ jedisPool = new JedisPool(config, \"主机\",6379,30000,\"密码\"); } public void execute(CallWithJedis callWithJedis) { try (Jedis jedis=jedisPool.getResource()) { callWithJedis.call(jedis); } }} CallWithJedis 123public interface CallWithJedis { void call(Jedis jedis);} 123456789101112131415161718192021222324252627282930313233343536373839404142public class WatchTest { public static void main(String[] args) { new Redis().execute(jedis -&gt; { Integer integer = savaMoney(jedis, \"louchen\", 2000); System.out.println(integer); }); } /** * 存钱操作 * @param jedis jedis对象 * @param userId 要操作的用户 * @param money 存的金额 * @return 返回用户余额 */ public static Integer savaMoney(Jedis jedis, String userId, Integer money) {// 判断当前用户是否有余额 if (jedis.get(userId) == null) {// 没有余额设为0 jedis.set(userId, \"0\"); }// 若当前事务执行失败 重新执行 while (true) {// 监视用户 jedis.watch(userId);// 加钱 int i = Integer.valueOf(jedis.get(userId)) + money;// 开启事务 Transaction transaction = jedis.multi();//// 重新存入 transaction.set(userId, String.valueOf(i));// 执行当前事务 List&lt;Object&gt; exec = transaction.exec();// 是否存入成功 if (exec != null) {// 成功 跳出 break; } } return Integer.valueOf(jedis.get(userId)); }} 示例：事务异常 当我们监听该key时，运行到开启事务之前的时候，我们用其他事务执行对该key的增加操作，那么会发现操作失败。会重新while循环一次，重新执行。 用其他事务操作： 继续运行代码： 发现出现异常，继续执行。进入while循环，重新执行，此时没有其他事务执行。执行成功 三、要注意的点一但执行 EXEC 开启事务的执行后，无论事务使用执行成功， WARCH 对变量的监控都将被取消。 故当事务执行失败后，需重新执行WATCH命令对变量进行监控，并开启新的事务进行操作。","link":"/2020/07/24/redis/Redis%E4%BA%8B%E5%8A%A1/"},{"title":"springboot与jpa构建restful风格","text":"springboot与jpa构建restful风格一、基本配置1、pom.xmlspring-boot-starter-data-rest 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;jpa-rest&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;jpa-rest&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-rest&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.18&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;version&gt;5.1.27&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、实体bean1234567891011@Getter@Setter@ToString@Entity(name = \"t_book\")public class Book { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; private String name; private String author;} 3、yaml配置1234567891011121314151617181920212223spring: datasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=UTF-8 username: root password: 123456 jpa: # 显示sql语句 show-sql: true # 数据库 database: mysql # 数据库平台 database-platform: mysql # 设置表的结构的生成类型 hibernate: # 每次启动更新表结构 ddl-auto: update properties: hibernate: # 设置方言 mysql57 dialect: org.hibernate.dialect.MySQL57Dialect 4、dao接口配置12public interface BookDao extends JpaRepository&lt;Book,Integer&gt; {} 二、基本的restful风格的增删改查1、查询所有数据要查询的实体的类名首字母小写，然后在后面加s get: http://localhost:8080/books 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384{ \"_embedded\": { \"books\": [ { \"name\": \"三国演义\", \"author\": \"罗贯中\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/books/1\" }, \"book\": { \"href\": \"http://localhost:8080/books/1\" } } }, { \"name\": \"水浒传\", \"author\": \"施耐庵\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/books/2\" }, \"book\": { \"href\": \"http://localhost:8080/books/2\" } } }, { \"name\": \"红楼梦\", \"author\": \"曹雪芹\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/books/3\" }, \"book\": { \"href\": \"http://localhost:8080/books/3\" } } }, { \"name\": \"西游记\", \"author\": \"吴承恩\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/books/4\" }, \"book\": { \"href\": \"http://localhost:8080/books/4\" } } }, { \"name\": \"童年\", \"author\": \"鲁迅\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/books/5\" }, \"book\": { \"href\": \"http://localhost:8080/books/5\" } } } ] }, \"_links\": { \"self\": { //可对分页进行排序操作 \"href\": \"http://localhost:8080/books{?page,size,sort}\", \"templated\": true }, \"profile\": { \"href\": \"http://localhost:8080/profile/books\" } }, //分页信息 //页的大小20 ；总记录数为5 ，总页数为1 ， 当前页为1（jpa中页面从0开始） \"page\": { \"size\": 20, \"totalElements\": 5, \"totalPages\": 1, \"number\": 0 }} 2、分页查询查询第二页，每页大小为2 get: http://localhost:8080/books?page=1&amp;size=2 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162{ \"_embedded\": { \"books\": [ { \"name\": \"红楼梦\", \"author\": \"曹雪芹\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/books/3\" }, \"book\": { \"href\": \"http://localhost:8080/books/3\" } } }, { \"name\": \"西游记\", \"author\": \"吴承恩\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/books/4\" }, \"book\": { \"href\": \"http://localhost:8080/books/4\" } } } ] }, \"_links\": { //首页地址 \"first\": { \"href\": \"http://localhost:8080/books?page=0&amp;size=2\" }, //上一页地址 \"prev\": { \"href\": \"http://localhost:8080/books?page=0&amp;size=2\" }, //排序 \"self\": { \"href\": \"http://localhost:8080/books{&amp;sort}\", \"templated\": true }, //下一页地址 \"next\": { \"href\": \"http://localhost:8080/books?page=2&amp;size=2\" }, //最后一页地址 \"last\": { \"href\": \"http://localhost:8080/books?page=2&amp;size=2\" }, \"profile\": { \"href\": \"http://localhost:8080/profile/books\" } }, \"page\": { \"size\": 2, \"totalElements\": 5, \"totalPages\": 3, \"number\": 1 }} 3、分页排序查询先按照id降序排列，然后查询出第二页的数据 get : http://localhost:8080/books?page=1&amp;size=2&amp;sort=id,desc 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556{ \"_embedded\": { \"books\": [ { \"name\": \"红楼梦\", \"author\": \"曹雪芹\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/books/3\" }, \"book\": { \"href\": \"http://localhost:8080/books/3\" } } }, { \"name\": \"水浒传\", \"author\": \"施耐庵\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/books/2\" }, \"book\": { \"href\": \"http://localhost:8080/books/2\" } } } ] }, \"_links\": { \"first\": { \"href\": \"http://localhost:8080/books?page=0&amp;size=2&amp;sort=id,desc\" }, \"prev\": { \"href\": \"http://localhost:8080/books?page=0&amp;size=2&amp;sort=id,desc\" }, \"self\": { \"href\": \"http://localhost:8080/books\" }, \"next\": { \"href\": \"http://localhost:8080/books?page=2&amp;size=2&amp;sort=id,desc\" }, \"last\": { \"href\": \"http://localhost:8080/books?page=2&amp;size=2&amp;sort=id,desc\" }, \"profile\": { \"href\": \"http://localhost:8080/profile/books\" } }, \"page\": { \"size\": 2, \"totalElements\": 5, \"totalPages\": 3, \"number\": 1 }} 4、查询指定id数据查询id为3的数据 get: http://localhost:8080/books/3 123456789101112{ \"name\": \"红楼梦\", \"author\": \"曹雪芹\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/books/3\" }, \"book\": { \"href\": \"http://localhost:8080/books/3\" } }} 5、添加数据post: http://localhost:8080/books application-type: json 1234{ \"name\":\"史记\", \"author\":\"司马迁\"} 123456789101112{ \"name\": \"史记\", \"author\": \"司马迁\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/books/6\" }, \"book\": { \"href\": \"http://localhost:8080/books/6\" } }} 6、根据id修改put: http://localhost:8080/books/6 application-type: json 这里的修改必须要传所有字段，否则没有传的字段会赋值为null 1234{ \"name\":\"《史记》\", \"author\":\"司马老贼\"} 123456789101112{ \"name\": \"《史记》\", \"author\": \"司马老贼\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/books/6\" }, \"book\": { \"href\": \"http://localhost:8080/books/6\" } }} 7、根据id删除delete: http://localhost:8080/books/6 三、自定义查询方法接口1、dao接口123456789public interface BookDao extends JpaRepository&lt;Book,Integer&gt; { /** * 查询包含的名称的数据 * @param name * @return */ List&lt;Book&gt; findBooksByNameContaining(@Param(\"name\") String name);} 2、postman测试①查询所有可使用的接口get： http://localhost:8080/books/search 1234567891011{ \"_links\": { \"findBooksByNameContaining\": { \"href\": \"http://localhost:8080/books/search/findBooksByNameContaining{?name}\", \"templated\": true }, \"self\": { \"href\": \"http://localhost:8080/books/search\" } }} ②使用自定义的接口查询名称包含红的集合 get: http://localhost:8080/books/search/findBooksByNameContaining?name=红 1234567891011121314151617181920212223{ \"_embedded\": { \"books\": [ { \"name\": \"红楼梦\", \"author\": \"曹雪芹\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/books/3\" }, \"book\": { \"href\": \"http://localhost:8080/books/3\" } } } ] }, \"_links\": { \"self\": { \"href\": \"http://localhost:8080/books/search/findBooksByNameContaining?name=%E7%BA%A2\" } }} ③修改请求路径及集合路径@RepositoryRestResource(path = “bs”,collectionResourceRel = “bs1”,itemResourceRel = “b”) path： 请求的一级路径 collectionResourceRel ： 集合名称 itemResourceRel： 集合中的路径herf元素名称 @RestResource(exported = true,path = “byname”,rel = “findByName”) exported : 是否暴露此接口（默认为true） path: 请求的二级路径 rel : 查询所有接口时的该方法的对象名称 修改dao接口==&gt; 123456789101112@RepositoryRestResource(path = \"bs\",collectionResourceRel = \"bs1\",itemResourceRel = \"b\")public interface BookDao extends JpaRepository&lt;Book,Integer&gt; { /** * 查询包含的名称的数据 * @param name * @return */ @RestResource(exported = true,path = \"byname\",rel = \"findByName\") List&lt;Book&gt; findBooksByNameContaining(@Param(\"name\") String name); } 查询所有接口==&gt; get: http://localhost:8080/bs/search 1234567891011{ \"_links\": { \"findByName\": { \"href\": \"http://localhost:8080/bs/search/byname{?name}\", \"templated\": true }, \"self\": { \"href\": \"http://localhost:8080/bs/search\" } }} 使用该findByName接口==&gt; get : http://localhost:8080/bs/search/byname?name=红 1234567891011121314151617181920212223{ \"_embedded\": { \"bs1\": [ { \"name\": \"红楼梦\", \"author\": \"曹雪芹\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/bs/3\" }, \"b\": { \"href\": \"http://localhost:8080/bs/3\" } } } ] }, \"_links\": { \"self\": { \"href\": \"http://localhost:8080/bs/search/byname?name=%E7%BA%A2\" } }} 四、实现跨域@CrossOrigin 默认为允许所有请求 @CrossOrigin(“*”) 12345678910111213@CrossOrigin@RepositoryRestResource(path = \"bs\",collectionResourceRel = \"bs1\",itemResourceRel = \"b\")public interface BookDao extends JpaRepository&lt;Book,Integer&gt; { /** * 查询包含的名称的数据 * @param name * @return */ @RestResource(exported = true,path = \"byname\",rel = \"findByName\") List&lt;Book&gt; findBooksByNameContaining(@Param(\"name\") String name);} 五、更改spring中对restful的自动配置org.springframework.boot.autoconfigure.data.rest.RepositoryRestProperties==&gt; 12345678910111213141516171819202122232425@ConfigurationProperties( prefix = \"spring.data.rest\")public class RepositoryRestProperties { //基础路径 private String basePath; //默认页 private Integer defaultPageSize; //每页的最大尺寸 private Integer maxPageSize; //页码的参数名称 private String pageParamName; private String limitParamName; //排序的参数名称 private String sortParamName; private RepositoryDetectionStrategies detectionStrategy; private MediaType defaultMediaType; //创建后并返回 private Boolean returnBodyOnCreate; //更新后并返回 private Boolean returnBodyOnUpdate; private Boolean enableEnumTranslation; //**** //****} 1、yaml的配置12345spring: data: rest:# 加前缀 base-path: /api 2、配置文件配置1234567891011121314/** * 此类的优先级配置 高于 yaml中的配置 */@Configurationpublic class RestConfig implements RepositoryRestConfigurer { @Override public void configureRepositoryRestConfiguration(RepositoryRestConfiguration config) { //设置默认路径 config.setBasePath(\"/lc\") //设置默认页大小 .setDefaultPageSize(2); }} 请求测试：==&gt; get: http://localhost:8080/lc/bs/search/byname?name=红 1234567891011121314151617181920212223{ \"_embedded\": { \"bs1\": [ { \"name\": \"红楼梦\", \"author\": \"曹雪芹\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/lc/bs/3\" }, \"b\": { \"href\": \"http://localhost:8080/lc/bs/3\" } } } ] }, \"_links\": { \"self\": { \"href\": \"http://localhost:8080/lc/bs/search/byname?name=%E7%BA%A2\" } }}","link":"/2020/07/24/restful/jpa%E6%9E%84%E5%BB%BArestful%E9%A3%8E%E6%A0%BC/"},{"title":"SpringCache 整合Ehcache","text":"SpringCache 整合Ehcache一 、介绍​ EhCache 是一个纯Java的进程内缓存框架，具有快速、精干等特点，是Hibernate中默认CacheProvider。Ehcache是一种广泛使用的开源Java分布式缓存。主要面向通用缓存,Java EE和轻量级容器。它具有内存和磁盘存储，缓存加载器,缓存扩展,缓存异常处理程序,一个gzip缓存servlet过滤器,支持REST和SOAP api等特点。 特性 快速、简单 多种缓存策略 缓存数据有两级：内存和磁盘，因此无需担心容量问题 缓存数据会在虚拟机重启的过程中写入磁盘 可以通过RMI、可插入API等方式进行分布式缓存 具有缓存和缓存管理器的侦听接口 支持多缓存管理器实例，以及一个实例的多个缓存区域 提供Hibernate的缓存实现 集成​ 可以单独使用，一般在第三方库中被用到的比较多（如mybatis、shiro等）ehcache 对分布式支持不够好，多个节点不能同步，通常和redis一块使用 灵活性​ ehcache具备对象api接口和可序列化api接口 不能序列化的对象可以使用出磁盘存储外ehcache的所有功能 支持基于Cache和基于Element的过期策略，每个Cache的存活时间都是可以设置和控制的。 提供了LRU、LFU和FIFO缓存淘汰算法，Ehcache 1.2引入了最少使用和先进先出缓存淘汰算法，构成了完整的缓存淘汰算法。 提供内存和磁盘存储，Ehcache和大多数缓存解决方案一样，提供高性能的内存和磁盘存储。 动态、运行时缓存配置，存活时间、空闲时间、内存和磁盘存放缓存的最大数目都是可以在运行时修改的。 应用持久化​ 在vm重启后，持久化到磁盘的存储可以复原数据 Ehache是第一个引入缓存数据持久化存储的开源java缓存框架，缓存的数据可以在机器重启后从磁盘上重新获得​ 根据需要将缓存刷到磁盘。将缓存条目刷到磁盘的操作可以通过cache.fiush方法执行,这大大方便了ehcache的使用 二、ehcache 和 redis 比较ehcache直接在jvm虚拟机中缓存，速度快，效率高；但是缓存共享麻烦，集群分布式应用不方便。 redis是通过socket访问到缓存服务，效率比ecache低，比数据库要快很多， 处理集群和分布式缓存方便，有成熟的方案。如果是单个应用或者对缓存访问要求很高的应用，用ehcache。如果是大型系统，存在缓存共享、分布式部署、缓存内容很大的，建议用redis。 三、基本配置所有的存储操作还是SpringCache的那一套，只是存储采取的载体不同 1、pom.xmlehcache spring-boot-starter-cache 1234567891011121314151617181920212223242526272829&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--ehcache依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt; &lt;artifactId&gt;ehcache&lt;/artifactId&gt; &lt;version&gt;2.10.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2、yaml配置若缓存配置文件名为ehcache.xml则无需配置此项 配置ehcache文件的存放位置 ==&gt; 1234spring: cache: ehcache: config: classpath:ehcache/ehcache1.xml 3、ehcache配置文件配置文件说明==&gt; diskStore path ：指定磁盘存储的位置 defaultCache 默认的缓存 cache 自定的缓存，当自定的配置不满足实际情况时可以通过自定义（可以包含多个cache节点） name : 缓存的名称，可以通过指定名称获取指定的某个Cache对象 maxElementsInMemory ：内存中允许存储的最大的元素个数，0代表无限个 clearOnFlush：内存数量最大时是否清除。 eternal ：设置缓存中对象是否为永久的，如果是，超时设置将被忽略，对象从不过期。根据存储数据的不同，例如一些静态不变的数据如省市区等可以设置为永不过时 timeToIdleSeconds ： 设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。 timeToLiveSeconds ：缓存数据的 生存时间（TTL），也就是一个元素从构建到消亡的最大时间间隔值，这只能在元素不是永久驻留时有效，如果该值是0就意味着元素可以停顿无穷长的时间。(和上面的两者取最小值) overflowToDisk：内存不足时，是否启用磁盘缓存。 maxEntriesLocalDisk：当内存中对象数量达到maxElementsInMemory时，Ehcache将会对象写到磁盘中。 maxElementsOnDisk：硬盘最大缓存个数。 diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。 diskPersistent：是否在VM重启时存储硬盘的缓存数据。默认值是false。 diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。 memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。这里比较遗憾，Ehcache并没有提供一个用户定制策略的接口，仅仅支持三种指定策略，感觉做的不够理想。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;ehcache&gt; &lt;!-- 磁盘缓存位置 --&gt; &lt;!-- diskStore:为缓存路径，ehcache分为内存和磁盘 2级，此属性定义磁盘的缓存位置 user.home - 用户主目录 user.dir - 用户当前工作目录 java.io.tmpdir - 默认临时文件路径--&gt; &lt;diskStore path=\"java.io.tmpdir/ehcache\"/&gt; &lt;!-- name:缓存名称。 maxElementsInMemory:缓存最大数目 maxElementsOnDisk：硬盘最大缓存个数。 eternal:对象是否永久有效，一但设置了，timeout将不起作用。 overflowToDisk:是否保存到磁盘，当系统宕机时 timeToIdleSeconds:设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。 timeToLiveSeconds:设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。 diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false. diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。 diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。 memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。 clearOnFlush：内存数量最大时是否清除。 memoryStoreEvictionPolicy:可选策略有：LRU（最近最少使用，默认策略）、FIFO（先进先出）、LFU（最少访问次数）。 FIFO，first in first out，这个是大家最熟的，先进先出。 LFU， Less Frequently Used，就是上面例子中使用的策略，直白一点就是讲一直以来最少被使用的。如上面所讲，缓存的元素有一个hit属性，hit值最小的将会被清出缓存。 LRU，Least Recently Used，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。--&gt; &lt;!-- 默认缓存 --&gt; &lt;defaultCache maxEntriesLocalHeap=\"10000\" eternal=\"false\" timeToIdleSeconds=\"120\" timeToLiveSeconds=\"120\" maxEntriesLocalDisk=\"10000000\" diskExpiryThreadIntervalSeconds=\"120\" memoryStoreEvictionPolicy=\"LRU\"&gt; &lt;persistence strategy=\"localTempSwap\"/&gt; &lt;/defaultCache&gt; &lt;!-- 自定义缓存 --&gt; &lt;!--name 为缓存名称--&gt; &lt;cache name=\"mycache\" maxElementsInMemory=\"1000\" eternal=\"false\" timeToIdleSeconds=\"600\" timeToLiveSeconds=\"600\" overflowToDisk=\"true\" memoryStoreEvictionPolicy=\"LRU\"/&gt;&lt;/ehcache&gt; 4、实体bean(实现serializable)12345678@Getter@Setter@ToStringpublic class User implements Serializable { private Integer id; private String username; private String address;} 5、开启缓存12345678910@SpringBootApplication//启用缓存@EnableCachingpublic class JpaRestApplication { public static void main(String[] args) { SpringApplication.run(JpaRestApplication.class, args); }} 6、service层123456789101112@Servicepublic class UserService { @Cacheable(cacheNames = \"mycache\",key = \"#id\") public User getUserById(Integer id){ User user=new User(); user.setId(id); System.out.println(\"id=====&gt;\"+id); return user; }} 测试==&gt; 12345678910111213@SpringBootTestclass JpaRestApplicationTests { @Autowired private UserService userService; @Test void contextLoads() { User userById = userService.getUserById(1); User userById1 = userService.getUserById(1); System.out.println(userById); System.out.println(userById1); }}","link":"/2020/07/24/springcache/Spring%20Cache%E6%95%B4%E5%90%88Ehcache/"},{"title":"SpringBoot整合@Scheduled定时任务","text":"SpringBoot整合@Scheduled定时任务一、JAVA常见的几种定时任务比较1、Timer： ​ jdk自带的java.util.Timer类，这个类允许你调度一个java.util.TimerTask任务。使用这种方式可以让程序按照某一个频度执行，但不能在指定时间运行，一般很少使用，主要用于非Spring项目简单的任务调度。 2、Spring Task： ​ Spring3.0以后自带的Task，可以将它看成一个轻量级的Quartz，使用起来比Quartz简单很多，在Spring应用中，直接使用@Scheduled注解即可，但对于集群项目比较麻烦，需要避免集群环境下任务被多次调用的情况，而且不能动态维护，任务启动以后不能修改、暂停等。 3、Quartz： ​ 好用的第三方任务调度工具，可谓是企业级应用系统任务调度工具的老大。可以方便的在集群下使用、可以动态增加、删除、暂停等维护任务，动态定时任务更加灵活。而且，和Spring Boot集成非常方便。 基本配置1、pom.xmlspring3之后自带定时任务 spring-boot-starter-web 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;sechdule&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;sechdule&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、开启定时任务123456789@SpringBootApplication//开启定时任务@EnableSchedulingpublic class SechduleApplication { public static void main(String[] args) { SpringApplication.run(SechduleApplication.class, args); }} 3、任务123456789101112131415161718192021222324252627282930313233343536373839404142@Servicepublic class HelloService { /** * rate速率 * 第一次任务和第二次任务开始的时间间隔(可能第一次任务还没结束，第二次就接着执行) * 毫秒为单位(这里为2s) */ @Scheduled(fixedRate = 2000) public void fixedRate() { System.out.println(\"fixedRate&gt;&gt;&gt;&gt;\"+new Date()); } /** * delay延期 * 第一次任务的结束时间和第二次任务开始的时间间隔(即第一次任务已经执行完毕后再执行第二次任务的间隔) * 毫秒为单位(这里为3s) */ @Scheduled(fixedDelay = 3000) public void fixedDelay() { System.out.println(\"fixedDelay&gt;&gt;&gt;&gt;\"+new Date()); } /** * initialDelay 表示首次任务启动的延迟时间 */ @Scheduled(initialDelay = 2000,fixedDelay = 2000) public void initialDelay() { System.out.println(\"initialDelay&gt;&gt;&gt;\"+new Date()); } /** * cron表达式 * [秒] [分] [小时] [日] [月] [周] [年](可省略) * 在这里 / 用于递增触发，如在秒上面设置”0/5” 表示从0秒开始，每增5秒触发(0,5,10,15……) */ @Scheduled(cron = \"0/5 * * * * *\") public void cron() { System.out.println(\"cron&gt;&gt;&gt;&gt;&gt;\"+new Date()); }} 配置详解1、@Scheduled常用属性： 首先使用 @Scheduled 注解开启一个定时任务。 fixedRate 表示任务执行之间的时间间隔，具体是指两次任务的开始时间间隔，即第二次任务开始时，第一次任务可能还没结束。 fixedDelay 表示任务执行之间的时间间隔，具体是指本次任务结束到下次任务开始之间的时间间隔。 initialDelay 表示首次任务启动的延迟时间。 所有时间的单位都是毫秒。 其他属性： fixedDelayString：与fixedDelay含义一样，只是参数类型变为String； fixedRateString: 与fixedRate的含义一样，只是将参数类型变为String； initialDelayString：与initialDelay的含义一样，只是将参数类型变为String； #####2、cron表达式 [秒] [分] [小时] [日] [月] [周] [年](可省略) 具体取值 序号 说明 是否必填 允许填写的值 允许的通配符 1 秒 是 0-59 - * / 2 分 是 0-59 - * / 3 时 是 0-23 - * / 4 日 是 1-31 - * ? / L W 5 月 是 1-12 or JAN-DEC - * / 6 周 是 1-7 or SUN-SAT - * ? / L # 7 年 否 1970-2099 - * / 这一块需要大家注意的是，月份中的日期和星期可能会起冲突，因此在配置时这两个得有一个是 ? 在线Cron表达式生成器 示例： 0 0 10 ？ * WED 每个星期三的10:00:00 @Scheduled(cron = &quot;0/5 * * * * *&quot;) 每隔5秒触发一次 通配符含义： ? 表示不指定值，即不关心某个字段的取值时使用。需要注意的是，月份中的日期和星期可能会起冲突，因此在配置时这两个得有一个是 ? * 表示所有值，例如:在秒的字段上设置 *,表示每一秒都会触发 , 用来分开多个值，例如在周字段上设置 “MON,WED,FRI” 表示周一，周三和周五触发 - 表示区间，例如在秒上设置 “10-12”,表示 10,11,12秒都会触发 / 用于递增触发，如在秒上面设置”5/15” 表示从5秒开始，每增15秒触发(5,20,35,50) # 序号(表示每月的第几个周几)，例如在周字段上设置”6#3”表示在每月的第三个周六，(用 在母亲节和父亲节再合适不过了) 周字段的设置，若使用英文字母是不区分大小写的 ，即 MON 与mon相同 L 表示最后的意思。在日字段设置上，表示当月的最后一天(依据当前月份，如果是二月还会自动判断是否是润年), 在周字段上表示星期六，相当于”7”或”SAT”（注意周日算是第一天）。如果在”L”前加上数字，则表示该数据的最后一个。例如在周字段上设置”6L”这样的格式,则表示”本月最后一个星期五” W 表示离指定日期的最近工作日(周一至周五)，例如在日字段上设置”15W”，表示离每月15号最近的那个工作日触发。如果15号正好是周六，则找最近的周五(14号)触发, 如果15号是周未，则找最近的下周一(16号)触发，如果15号正好在工作日(周一至周五)，则就在该天触发。如果指定格式为 “1W”,它则表示每月1号往后最近的工作日触发。如果1号正是周六，则将在3号下周一触发。(注，”W”前只能设置具体的数字,不允许区间”-“) L 和 W 可以一组合使用。如果在日字段上设置”LW”,则表示在本月的最后一个工作日触发(一般指发工资 )","link":"/2020/07/24/task/SpringBoot%E6%95%B4%E5%90%88@Scheduled%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"},{"title":"SpringBoot整合Swagger2","text":"SpringBoot整合Swagger2一、swagger简介Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。总体目标是使客户端和文件系统作为服务器以同样的速度来更新。 作用： 接口的文档在线自动生成。 功能测试。 二、基本配置1、pom.xmlspringfox-swagger2 springfox-swagger-ui 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;swagger2&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;swagger2&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、swagger配置文件1234567891011121314151617181920212223242526272829303132333435@Configuration@EnableSwagger2//是否开启swagger，正式环境一般是需要关闭的（避免不必要的漏洞暴露！），可根据springboot的多环境配置进行设置//这里properties中的配置的swagger.enable和havingValue相等这个配置文件才会生效@ConditionalOnProperty(name = \"swagger.enable\", havingValue = \"true\")public class Swagger2Config { /** *构建swagger摘要 * @return */ @Bean Docket docket() {// 选择文本类型为SWAGGER_2 return new Docket(DocumentationType.SWAGGER_2) .select()// 指定controller所在的包 .apis(RequestHandlerSelectors.basePackage(\"org.lc.swagger2.controller\"))// 指定包下的所有路径生成文档 .paths(PathSelectors.any()) .build().apiInfo(new ApiInfoBuilder()// 文档描述信息 .description(\"这是接口文档描述信息\")// 标题 .title(\"这是项目标题\")// 联系信息 .contact(new Contact(\"lc\", \"www.louchen.top\", \"421192425@qq.com\"))// 版本 .version(\"v0.0.1\")// 许可证 .license(\"apache2.0\") .build()); }} 3、是否开启swagger配置1swagger.enable=true 4、实体描述123456789101112@Getter@Setter@ToString@ApiModel(value = \"用户实体类\",description = \"用户信息描述\")public class User { @ApiModelProperty(value = \"用户id\") private Integer id; @ApiModelProperty(value = \"用户名\") private String name; @ApiModelProperty(value = \"用户地址\") private String address;} ![](F:\\桌面内容\\springboot2\\springboot整合定时任务及swagger2\\images\\批注 2020-04-07 211747.png) 5、接口描述1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859@RestController//接口上的描述@Api(tags = \"用户数据接口\")public class UserController { /** * 这里需要指定的请求方式 否则swagger会启用所有方法类型调用 * @param id * @return */// 接口方法上的描述 @ApiOperation(value = \"查询用户\",notes = \"根据用户id查询用户\")// 接口参数上的描述// 这里的name为参数名，value为对该参数的解释，required只是对swagger的约束表示必填，默认值为11 @ApiImplicitParam(name = \"id\",value = \"用户id\",required = true,defaultValue = \"11\") @GetMapping(\"/user\") public User getUserById(Integer id) { User user=new User(); user.setId(id); return user; } @ApiOperation(value = \"删除用户\",notes = \"根据用户id删除用户\") @ApiImplicitParam(name = \"id\",value = \"用户id\",required = true,defaultValue = \"22\")// 设置响应的状态码的描述信息 @ApiResponses({ @ApiResponse(code = 200, message = \"删除成功\"), @ApiResponse(code = 500, message = \"删除失败\") }) @DeleteMapping(\"/user/{id}\") public void deleteById(@PathVariable(\"id\")Integer id){ System.out.println(\"deleteById:\"+id); } @ApiOperation(value = \"更新用户\",notes = \"根据用户id更新用户\") @ApiImplicitParams({ @ApiImplicitParam(name = \"username\",value = \"用户名\",required = true,defaultValue = \"lc\"), @ApiImplicitParam(name = \"id\",value = \"用户id\",required = true,defaultValue = \"1\") }) // 表示忽略此接口生成在swagger中// @ApiIgnore @PutMapping(\"/user\") public User updateUserById(String username,Integer id){ User user=new User(); user.setId(id); user.setName(username); return user; } @ApiOperation(value = \"添加用户\",notes = \"添加用户信息\") @PostMapping(\"/user\") public User addUser(@RequestBody User user){ return user; }} ![](F:\\桌面内容\\springboot2\\springboot整合定时任务及swagger2\\images\\批注 2020-04-07 211922.png) ![](F:\\桌面内容\\springboot2\\springboot整合定时任务及swagger2\\images\\批注 2020-04-07 211949.png) ![](F:\\桌面内容\\springboot2\\springboot整合定时任务及swagger2\\images\\批注 2020-04-07 212014.png) 6、swagger注解介绍 @Api：可设置对控制器的描述- @ApiOperation：: 可设置对接口方法的描述 @ApiIgnore: Swagger 文档不会显示拥有该注解的接口。 @ApiImplicitParams: 用于描述接口的非对象参数集。 @ApiImplicitParam: 用于描述接口的非对象参数，一般与 @ApiImplicitParams 组合使用。 @ApiImplicitParam 注解用来描述一个参数，可以配置参数的中文含义，也可以给参数设置默认值，这样在接口测试的时候可以避免手动输入。 如果有多个参数，则需要使用多个 @ApiImplicitParam 注解来描述，多个 @ApiImplicitParam 注解需要放在一个 @ApiImplicitParams 注解中。 需要注意的是，@ApiImplicitParam 注解中虽然可以指定参数是必填的，但是却不能代替 @RequestParam(required = true) ，前者的必填只是在 Swagger2 框架内必填，抛弃了 Swagger2 ，这个限制就没用了，所以假如开发者需要指定一个参数必填， @RequestParam(required = true) 注解还是不能省略。 @ApiModel:可设置接口相关实体的描述 @ApiModelProperty: 可设置实体属性的相关描述。 7、在 Security 中的配置​ 如果我们的 Spring Boot 项目中集成了 Spring Security，那么如果不做额外配置，Swagger2 文档可能会被拦截，此时只需要在 Spring Security 的配置类中重写 configure 方法，添加如下过滤即可： 1234567@Overridepublic void configure(WebSecurity web) throws Exception { web.ignoring() .antMatchers(\"/swagger-ui.html\") .antMatchers(\"/v2/**\") .antMatchers(\"/swagger-resources/**\");} 如此之后，Swagger2 文件就不需要认证就能访问了","link":"/2020/07/24/springboot/SpringBoot%E6%95%B4%E5%90%88Swagger2/"},{"title":"Springboot整合Quartz","text":"Springboot整合Quartz一、什么是Quartz在Quartz官网上是这么写的 1、Quartz 是一个完全由 Java 编写的开源作业调度框架，为在 Java 应用程序中进行作业调度提供了简单却强大的机制。2、Quartz 可以与 J2EE 与 J2SE 应用程序相结合也可以单独使用。 3、Quartz 允许程序开发人员根据时间的间隔来调度作业。4、Quartz 实现了作业和触发器的多对多的关系，还能把多个作业与不同的触发器关联。 二、Quartz核心概念1、Job 表示一个工作，要执行的具体内容。2、JobDetail 表示一个具体的可执行的调度程序，Job 是这个可执行程调度程序所要执行的内容，另外 JobDetail 还包含了这个任务调度的方案和策略。3、Trigger 代表一个调度参数的配置，什么时候去调。4、Scheduler 代表一个调度容器，一个调度容器中可以注册多个 JobDetail 和 Trigger。当 Trigger 与 JobDetail 组合，就可以被 Scheduler 容器调度了。 三、基本配置使用1、pom.xmlspring-boot-starter-quartz 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;quartz&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;quartz&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-quartz&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、启用定时任务12345678910@SpringBootApplication//启动定时任务@EnableSchedulingpublic class QuartzApplication { public static void main(String[] args) { SpringApplication.run(QuartzApplication.class, args); }} 3、job任务配置①直接定义一个Bean作为任务 首先将这个 Job 注册到 Spring 容器中。 这种定义方式有一个缺陷，就是无法传参。 123456789@Componentpublic class MyFirstJob { /** * 这种方式配置的任务不支持传参 */ public void sayHello() { System.out.println(\"first job say hello:\"+new Date()); }} ②继承 QuartzJobBean 并实现默认的方法这种方式支持传参，任务启动时，executeInternal 方法将会被执行。 12345678910111213141516171819202122public class MySecondJob extends QuartzJobBean { /** * 给当前job传入参数 */ private String name; public MySecondJob setName(String name) { this.name = name; return this; } /** * 这种形式的job支持传参 * @param jobExecutionContext * @throws JobExecutionException */ @Override protected void executeInternal(JobExecutionContext jobExecutionContext) throws JobExecutionException { System.out.println(\"second job say hello:\"+name+\":\"+new Date()); }} 4、JobDetail和Trigger配置JobDetail（要做的事情），另一个是触发器（什么时候做） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384@Configurationpublic class QuartzConfig { /** * 配置job实例 * MethodInvokingJobDetailFactoryBean配置的任务不能传输参数 * @return */ @Bean MethodInvokingJobDetailFactoryBean methodInvokingJobDetailFactoryBean() { MethodInvokingJobDetailFactoryBean bean=new MethodInvokingJobDetailFactoryBean();// 设置job所在的类名 （类名开头小写） bean.setTargetBeanName(\"myFirstJob\");// 设置指定job方法名 bean.setTargetMethod(\"sayHello\"); return bean; } /** * 配置job实例 *JobDetailFactoryBean 可以设置job参数 * @return */ @Bean JobDetailFactoryBean jobDetailFactoryBean() { JobDetailFactoryBean bean=new JobDetailFactoryBean();// 向job传入参数 JobDataMap dataMap=new JobDataMap(); dataMap.put(\"name\", \"lccc\"); bean.setJobDataMap(dataMap);// 设置该job所在的class对象// 此job因为实现QuartzJobBean类所以自动实现内部的执行executeInternal方法完成任务 bean.setJobClass(MySecondJob.class); return bean; } /** * 配置简单的触发器(执行时间规则) * @return */ @Bean SimpleTriggerFactoryBean simpleTriggerFactoryBean() { SimpleTriggerFactoryBean bean=new SimpleTriggerFactoryBean();// 将job对象和触发器绑定 bean.setJobDetail(methodInvokingJobDetailFactoryBean().getObject());// job开启的时间 --当前时间 bean.setStartTime(new Date());// job重复间隔 bean.setRepeatInterval(2000);// job执行次数 bean.setRepeatCount(3); return bean; } /** *配置cron表达式 * @return */ @Bean CronTriggerFactoryBean cronTriggerFactoryBean() { CronTriggerFactoryBean bean=new CronTriggerFactoryBean();// 绑定job任务和触发器对象 bean.setJobDetail(jobDetailFactoryBean().getObject());// 设置cron表达式// 每秒执行一次 bean.setCronExpression(\"* * * * * ?\"); return bean; } /** * 配置调度任务 * @return */ @Bean SchedulerFactoryBean schedulerFactoryBean() { SchedulerFactoryBean bean=new SchedulerFactoryBean();// 向调度任务中加入配置好的触发器和job对象 bean.setTriggers(simpleTriggerFactoryBean().getObject(),cronTriggerFactoryBean().getObject()); return bean; }} 5、配置解释关于这个配置说如下几点： JobDetail 的配置有两种方式：MethodInvokingJobDetailFactoryBean 和 JobDetailFactoryBean 。 使用 MethodInvokingJobDetailFactoryBean 可以配置目标 Bean 的名字和目标方法的名字，这种方式不支持传参。 使用 JobDetailFactoryBean 可以配置 JobDetail ，任务类继承自 QuartzJobBean ，这种方式支持传参，将参数封装在 JobDataMap 中进行传递。 Trigger 是指触发器，Quartz 中定义了多个触发器，这里向大家展示其中两种的用法，SimpleTrigger 和 CronTrigger 。 SimpleTrigger 有点类似于前面说的 @Scheduled 的基本用法。 CronTrigger 则有点类似于 @Scheduled 中 cron 表达式的用法。","link":"/2020/07/24/task/SpringBoot%E6%95%B4%E5%90%88Quartz/"},{"title":"springsecurity&#x2F;Spring-Security整合OAuth2","text":"Spring-Security整合OAuth2基本配置1、pom.xmlspring-security-oauth2 spring-boot-starter-security spring-boot-starter-data-redis 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lx&lt;/groupId&gt; &lt;artifactId&gt;security-oauth&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;security-oauth&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security.oauth&lt;/groupId&gt; &lt;artifactId&gt;spring-security-oauth2&lt;/artifactId&gt; &lt;version&gt;2.3.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--redis 存储token--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、yaml配置1234567spring:# redis配置 redis: port: 6379 password: xxxxxx host: 47.96.141.44 database: 0 3、controller123456789101112131415161718192021222324252627282930@RestControllerpublic class controller { /** * 模拟admin用户 * @return */ @GetMapping(\"/admin/hello\") public String admin() { return \"hello admin\"; } /** * 模拟user用户 * @return */ @GetMapping(\"/user/hello\") public String user() { return \"user hello\"; } /** * 普通用户（登录即可访问） * @return */ @GetMapping(\"/hello\") public String hello() { return \"hello\"; }} 4、核心配置①授权服务器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/** * 授权服务器 */@Configuration//开启授权服务器@EnableAuthorizationServerpublic class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter { /** * 注入认证管理器 来支持password的认证模式 * * 在oauth2模式中，有四种不同的认证模式. * 第三方登录一般使用授权码模式 * 前后端分离一般使用password模式 */ @Autowired private AuthenticationManager authenticationManager; @Autowired private RedisConnectionFactory redisConnectionFactory; @Autowired private UserDetailsService userDetailsService; @Bean PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); } /** * 配置password模式 * 配置用户 * @param clients * @throws Exception */ @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception {// 配置在内存中 clients.inMemory()// 设置认证模式 设置客户端id .withClient(\"password\")// 配置授权模式 标准的oauth并不包含refresh_token。但是在springsecurity实现下refresh_token归为其中一种// 获取token 和 刷新token的 .authorizedGrantTypes(\"password\", \"refresh_token\")// 设置过期时间 1800s .accessTokenValiditySeconds(1800)// 设置资源id .resourceIds(\"rid\") .scopes(\"all\")// 需要的密码（加密之后）密码 123 .secret(\"$2a$10$vMu/taZjUE/JPUUi8Aep/epAjQjT5XqJj1/fOKqH/n1k9x8DOnkW6\"); } /** * 令牌的存储 * @param endpoints * @throws Exception */ @Override public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception { endpoints.tokenStore(new RedisTokenStore(redisConnectionFactory)) .authenticationManager(authenticationManager) .userDetailsService(userDetailsService); } /** *支持client id和 client secret 作登录认证 * @param security * @throws Exception */ @Override public void configure(AuthorizationServerSecurityConfigurer security) throws Exception { security.allowFormAuthenticationForClients(); }} ②资源服务器（提供资源，即访问的路径，引用的令牌）123456789101112131415161718192021222324252627282930/** * 资源服务器 提供资源 */@Configuration//开启资源服务器@EnableResourceServerpublic class ResourceServerConfig extends ResourceServerConfigurerAdapter{ @Override public void configure(ResourceServerSecurityConfigurer resources) throws Exception {// 指定资源id resources.resourceId(\"rid\")// 这些资源基于令牌进行认证 .stateless(true); } /** * 先去授权服务器获取token，再去访问资源 * 在这里我们提供访问资源的路径 * @param http * @throws Exception */ @Override public void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers(\"/admin/**\").hasRole(\"admin\") .antMatchers(\"/user/**\").hasRole(\"user\") .anyRequest().authenticated(); }} ③security配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter { @Bean @Override public AuthenticationManager authenticationManagerBean() throws Exception { return super.authenticationManagerBean(); } @Bean @Override protected UserDetailsService userDetailsService() { return super.userDetailsService(); } /** * 配置模拟用户 * @param auth * @throws Exception */ @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.inMemoryAuthentication() //密码123 .withUser(\"lc\").password(\"$2a$10$vMu/taZjUE/JPUUi8Aep/epAjQjT5XqJj1/fOKqH/n1k9x8DOnkW6\") .roles(\"admin\") .and() //密码123 .withUser(\"zs\").password(\"$2a$10$vMu/taZjUE/JPUUi8Aep/epAjQjT5XqJj1/fOKqH/n1k9x8DOnkW6\") .roles(\"user\"); } /** * 拦截指定的请求 * @param http * @throws Exception */ @Override protected void configure(HttpSecurity http) throws Exception { http.antMatcher(\"/oauth/**\")// 拦截像/oauth/**的请求 .authorizeRequests()// 符合/oauth/** .antMatchers(\"/oauth/**\")// 全部放行 .permitAll() .and() .csrf().disable(); }} 5、请求过程详解① 获取令牌PUT: http://localhost:8080/oauth/token content-type : x-www-form-urlencoded 请求参数==&gt; username 和 password 为登录的用户名和密码 123456\"key\":\"username\",\"value\":\"lc\"\"key\":\"password\",\"value\":\"123\"\"key\":\"grant_type\",\"value\":\"password\"\"key\":\"client_id\",\"value\":\"password\"\"key\":\"scope\",\"value\":\"all\"\"key\":\"client_secret\",\"value\":\"123\" 结果: ==&gt; 123456789{ \"access_token\": \"d274cd88-1c84-4d6a-9da4-11ed734aed6f\", \"token_type\": \"bearer\", //用户请求获得新的token的验证 \"refresh_token\": \"0a454a83-9bf5-4331-bf12-35d4ac519f30\", //过期时间 \"expires_in\": 1064, \"scope\": \"all\"} ②请求资源接口访问普通接口==&gt; GET: http://localhost:8080/hello?access_token=d274cd88-1c84-4d6a-9da4-11ed734aed6f admin接口==&gt; GET: http://localhost:8080/admin/hello?access_token=d274cd88-1c84-4d6a-9da4-11ed734aed6f user接口==&gt; GET: http://localhost:8080/user/hello?access_token=d274cd88-1c84-4d6a-9da4-11ed734aed6f ③获取新的token，旧token失效POST: http://localhost:8080/oauth/token 请求参数==&gt; refresh_token 是之前用户登录 refresh_token的的值 1234\"key\":\"grant_type\",\"value\":\"refresh_token\"\"key\":\"refresh_token\",\"value\":\"0a454a83-9bf5-4331-bf12-35d4ac519f30\"\"key\":\"client_id\",\"value\":\"password\"\"key\":\"client_secret\",\"value\":\"123\" 请求结果==&gt; 1234567{ \"access_token\": \"8b03dd6a-18c7-49c0-b2ab-e0962627608c\", \"token_type\": \"bearer\", \"refresh_token\": \"0a454a83-9bf5-4331-bf12-35d4ac519f30\", \"expires_in\": 1799, \"scope\": \"all\"}","link":"/2020/07/24/springsecurity/Spring-Security%E6%95%B4%E5%90%88OAuth2/"},{"title":"SpringBoot国际化","text":"SpringBoot国际化​ 国际化，也叫 i18n，为啥叫这个名字呢？因为国际化英文是 internationalization ，在 i 和 n 之间有 18 个字母，所以叫 i18n。我们的应用如果做了国际化就可以在不同的语言环境下，方便的进行切换，最常见的就是中文和英文之间的切换，国际化这个功能也是相当的常见。在 Spring 中，就通过 AcceptHeaderLocaleResolver 对国际化提供了支持，开发者通过简单配置，就可以在项目中直接使用国际化功能了。 一、基本使用Spring Boot 和 Spring 一脉相承，对于国际化的支持，默认是通过 AcceptHeaderLocaleResolver 解析器来完成的，这个解析器，默认是通过请求头的 Accept-Language 字段来判断当前请求所属的环境的，进而给出合适的响应。 首先创建一个普通的 Spring Boot 项目，添加 web 依赖即可。项目创建成功后，默认的国际化配置文件放在 resources 目录下，所以我们直接在该目录下创建四个测试文件，如下： 我们的 message 文件是直接创建在 resources 目录下的，IDEA 在展示的时候，会多出一个 Resource Bundle，这个大家不用管，千万别手动去创建这个目录。 messages.properties 这个是默认的配置，其他的则是不同语言环境下的配置，en_US 是英语(美国)，zh_CN 是中文简体，zh_TW 是中文繁体（文末附录里边有一个完整的语言简称表格）。 ![](F:\\桌面内容\\springboot2\\springboot系列\\images\\批注 2020-04-12 110435.png) 四个文件创建好之后，第一个默认的我们可以先空着，另外三个分别填入以下内容： messages.properties 1user.name=default messages_zh_CN.properties 1user.name=张三 messages_zh_TW.properties 1user.name=張三 messages_en_US.properties 1user.name=lc 配置完成后，我们就可以直接开始使用了。在需要使用值的地方，直接注入 MessageSource 实例即可。 在 Spring 中需要配置的 MessageSource 现在不用配置了，Spring Boot 会通过 org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration 自动帮我们配置一个 MessageSource 实例。 引用web依赖即可使用 spring-boot-starter-web 直接创建一个controller使用即可 1234567891011@RestControllerpublic class HelloController { @Autowired MessageSource messageSource; @GetMapping(\"/hello\") public String hello() { return messageSource.getMessage(\"user.name\", null, LocaleContextHolder.getLocale()); }} 在 HelloController 中我们可以直接注入 MessageSource 实例，然后调用该实例中的 getMessage 方法去获取变量的值，第一个参数是要获取变量的 key，第二个参数是如果 value 中有占位符，可以从这里传递参数进去，第三个参数传递一个 Locale 实例即可，这相当于当前的语言环境。 接下来我们就可以直接去调用这个接口了。 默认情况下，在接口调用时，通过请求头的 Accept-Language 来配置当前的环境，我这里通过 POSTMAN 来进行测试，结果如下： 直接在请求头中设置Accept-Language即可 直接切换：Accept-Language的value值即可 输出不同的语言 注意：这种方式只能将参数放在请求头中，不能放在url即params中 二、自定义切换将参数放在请求参数中，即url上 localeResolver的名字必须为这个 12345678910111213141516171819@Configurationpublic class WebConfig implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { LocaleChangeInterceptor interceptor=new LocaleChangeInterceptor();// 设置参数名 interceptor.setParamName(\"lang\"); registry.addInterceptor(interceptor); } //注意 这里的localeResolver只能叫这个名，不能叫其他名 @Bean LocaleResolver localeResolver() { SessionLocaleResolver localeResolver=new SessionLocaleResolver();// 默认语言中文 localeResolver.setDefaultLocale(Locale.SIMPLIFIED_CHINESE); return localeResolver; }} 在这段配置中，我们首先提供了一个 SessionLocaleResolver 实例，这个实例会替换掉默认的 AcceptHeaderLocaleResolver，不同于 AcceptHeaderLocaleResolver 通过请求头来判断当前的环境信息，SessionLocaleResolver 将客户端的 Locale 保存到 HttpSession 对象中，并且可以进行修改（这意味着当前环境信息，前端给浏览器发送一次即可记住，只要 session 有效，浏览器就不必再次告诉服务端当前的环境信息）。 另外我们还配置了一个拦截器，这个拦截器会拦截请求中 key 为 lang 的参数（不配置的话是 locale），这个参数则指定了当前的环境信息。 这个指定只需要一次即可，也就是说，在 session 不变的情况下，下次请求可以不必带上 lang 参数，服务端已经知道当前的环境信息了。 ![](F:\\桌面内容\\springboot2\\springboot系列\\images\\批注 2020-04-12 114357.png) 三、自定义位置默认情况下，我们的配置文件放在 resources 目录下，如果大家想自定义，也是可以的，例如定义在 resources/i18n 目录下： ![](F:\\桌面内容\\springboot2\\springboot系列\\images\\批注 2020-04-12 114632.png) 但是这种定义方式系统就不知道去哪里加载配置文件了，此时还需要 application.properties 中进行额外配置(注意这是一个相对路径)： ![](F:\\桌面内容\\springboot2\\springboot系列\\images\\批注 2020-04-12 115638.png) 四、语言简称表 语言 简称 简体中文(中国) zh_CN 繁体中文(中国台湾) zh_TW 繁体中文(中国香港) zh_HK 英语(中国香港) en_HK 英语(美国) en_US 英语(英国) en_GB 英语(全球) en_WW 英语(加拿大) en_CA 英语(澳大利亚) en_AU 英语(爱尔兰) en_IE 英语(芬兰) en_FI 芬兰语(芬兰) fi_FI 英语(丹麦) en_DK 丹麦语(丹麦) da_DK 英语(以色列) en_IL 希伯来语(以色列) he_IL 英语(南非) en_ZA 英语(印度) en_IN 英语(挪威) en_NO 英语(新加坡) en_SG 英语(新西兰) en_NZ 英语(印度尼西亚) en_ID 英语(菲律宾) en_PH 英语(泰国) en_TH 英语(马来西亚) en_MY 英语(阿拉伯) en_XA 韩文(韩国) ko_KR 日语(日本) ja_JP 荷兰语(荷兰) nl_NL 荷兰语(比利时) nl_BE 葡萄牙语(葡萄牙) pt_PT 葡萄牙语(巴西) pt_BR 法语(法国) fr_FR 法语(卢森堡) fr_LU 法语(瑞士) fr_CH 法语(比利时) fr_BE 法语(加拿大) fr_CA 西班牙语(拉丁美洲) es_LA 西班牙语(西班牙) es_ES 西班牙语(阿根廷) es_AR 西班牙语(美国) es_US 西班牙语(墨西哥) es_MX 西班牙语(哥伦比亚) es_CO 西班牙语(波多黎各) es_PR 德语(德国) de_DE 德语(奥地利) de_AT 德语(瑞士) de_CH 俄语(俄罗斯) ru_RU 意大利语(意大利) it_IT 希腊语(希腊) el_GR 挪威语(挪威) no_NO 匈牙利语(匈牙利) hu_HU 土耳其语(土耳其) tr_TR 捷克语(捷克共和国) cs_CZ 斯洛文尼亚语 sl_SL 波兰语(波兰) pl_PL 瑞典语(瑞典) sv_SE 西班牙语(智利) es_CL","link":"/2020/07/24/springboot/springboot%E5%9B%BD%E9%99%85%E5%8C%96/"},{"title":"Spring-Security整合jwt","text":"Spring-Security整合jwt一、有状态登录和无状态登录有状态：有状态服务，即服务端需要记录每次会话的客户端信息，从而识别客户端身份，根据用户身份进行请求的处理，典型的设计如Tomcat中的Session。例如登录：用户登录后，我们把用户的信息保存在服务端session中，并且给用户一个cookie值，记录对应的session，然后下次请求，用户携带cookie值来（这一步有浏览器自动完成），我们就能识别到对应session，从而找到用户的信息。这种方式目前来看最方便，但是也有一些缺陷，如下： 服务端保存大量数据，增加服务端压力 服务端保存用户状态，不支持集群化部署 无状态：微服务集群中的每个服务，对外提供的都使用RESTful风格的接口。而RESTful风格的一个最重要的规范就是：服务的无状态性，即： 服务端不保存任何客户端请求者信息 客户端的每次请求必须具备自描述信息，通过这些信息识别客户端身份 那么这种无状态性有哪些好处呢？ 客户端请求不依赖服务端的信息，多次请求不需要必须访问到同一台服务器 服务端的集群和状态对客户端透明 服务端可以任意的迁移和伸缩（可以方便的进行集群化部署） 减小服务端存储压力 二、如何实现无状态登录无状态登录的流程： 首先客户端发送账户名/密码到服务端进行认证 认证通过后，服务端将用户信息加密并且编码成一个token，返回给客户端 以后客户端每次发送请求，都需要携带认证的token 服务端对客户端发送来的token进行解密，判断是否有效，并且获取用户登录信息 三、JWT简介JWT包含三部分数据： Header：头部，通常头部有两部分信息： 声明类型，这里是JWT 加密算法，自定义 我们会对头部进行Base64Url编码（可解码），得到第一部分数据。 Payload：载荷，就是有效数据，在官方文档中(RFC7519)，这里给了7个示例信息： iss (issuer)：表示签发人 exp (expiration time)：表示token过期时间 sub (subject)：主题 aud (audience)：受众 nbf (Not Before)：生效时间 iat (Issued At)：签发时间 jti (JWT ID)：编号 这部分也会采用Base64Url编码，得到第二部分数据。 Signature：签名，是整个数据的认证信息。一般根据前两步的数据，再加上服务的的密钥secret（密钥保存在服务端，不能泄露给客户端），通过Header中配置的加密算法生成。用于验证整个数据完整和可靠性。 生成的数据格式如下： eyJhbGciOiJIUzUxMiJ9. ==&gt; 1{\"alg\":\"HS512\"} eyJhdXRob3JpdGllcyI6IlJPTEVfdXNlciwiLCJzdWIiOiJ6cyIsImV4cCI6MTU4NTY2ODQyM30. ==&gt; 1{\"authorities\":\"ROLE_user,\",\"sub\":\"zs\",\"exp\":1585668423} 5IgsesOWhkVPpyLbIHWbgeNNQFZvIRik2FlZHWCIoD7jH1b2BOgYHqWKb7LehZ_lyK53ZggXIdLVQJ_cqnVPtQ 最后一段无法解密 jwt交互流程： 应用程序或客户端向授权服务器请求授权 获取到授权后，授权服务器会向应用程序返回访问令牌 应用程序使用访问令牌来访问受保护资源（如API） 因为JWT签发的token中已经包含了用户的身份信息，并且每次请求都会携带，这样服务的就无需保存用户信息，甚至无需去数据库查询，这样就完全符合了RESTful的无状态规范。 四、基本配置1、pom.xmljjwt 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;springsecurity-jwt&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;springsecurity-jwt&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、实体1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package org.lc.springsecurityjwt.bean;import org.springframework.security.core.GrantedAuthority;import org.springframework.security.core.userdetails.UserDetails;import java.util.Collection;/** * @BelongsProject: springsecurity-jwt * @BelongsPackage: org.lc.springsecurityjwt.bean * @Author: lc * @CreateTime: 2020-03-31 16:53 * @Description: */public class User implements UserDetails { private Integer id; private String username; private String password; public User setId(Integer id) { this.id = id; return this; } public Integer getId() { return id; } public User setUsername(String username) { this.username = username; return this; } public User setPassword(String password) { this.password = password; return this; } @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() { return null; } @Override public String getPassword() { return password; } @Override public String getUsername() { return username; } @Override public boolean isAccountNonExpired() { return true; } @Override public boolean isAccountNonLocked() { return true; } @Override public boolean isCredentialsNonExpired() { return true; } @Override public boolean isEnabled() { return true; }} 3、jwt登录的过滤器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class JwtLoginFilter extends AbstractAuthenticationProcessingFilter { public JwtLoginFilter(String defaultFilterProcessesUrl, AuthenticationManager authenticationManager) { super(defaultFilterProcessesUrl); setAuthenticationManager(authenticationManager); } @Override public Authentication attemptAuthentication(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws AuthenticationException, IOException, ServletException {// 从过滤的请求中 ，获得流。获取登录的用户对象// 以json形式登录 User user=new ObjectMapper().readValue(httpServletRequest.getInputStream(), User.class); return getAuthenticationManager().authenticate(new UsernamePasswordAuthenticationToken(user.getUsername(), user.getPassword())); } //登录成功的回调 @Override protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult) throws IOException, ServletException {// 获取登录用户的角色 Collection&lt;? extends GrantedAuthority&gt; authorities=authResult.getAuthorities(); StringBuffer sb=new StringBuffer(); for (GrantedAuthority authority : authorities) {// 将角色所有角色加到一个以逗号隔开的字符串中 sb.append(authority.getAuthority()).append(\",\"); }// 构建jwt String jwt = Jwts.builder()// 构建角色 .claim(\"authorities\", sb)// 构建的主题 一般为用户名 .setSubject(authResult.getName())// 设置过期时间为 当前时间加上一个小时，即一个小时的过期时间 .setExpiration(new Date(System.currentTimeMillis() + 60 * 60 * 1000))// 签名 .signWith(SignatureAlgorithm.HS512, \"louchen\") .compact(); Map&lt;String,String&gt; map=new HashMap&lt;&gt;(); map.put(\"token\", jwt); map.put(\"msg\", \"登录成功！\"); response.setContentType(\"application/json;charset=utf-8\"); PrintWriter printWriter=response.getWriter(); printWriter.write(new ObjectMapper().writeValueAsString(map)); printWriter.flush(); printWriter.close(); }// 登录失败的回调 @Override protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed) throws IOException, ServletException { Map&lt;String,String&gt; map=new HashMap&lt;&gt;(); map.put(\"msg\", \"登录失败！\"); response.setContentType(\"application/json;charset=utf-8\"); PrintWriter printWriter=response.getWriter(); printWriter.write(new ObjectMapper().writeValueAsString(map)); printWriter.flush(); printWriter.close(); }} 4、jwt的Token验证过滤器12345678910111213141516public class JwtFilter extends GenericFilterBean { @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { HttpServletRequest req = (HttpServletRequest)servletRequest; String jwtToken = req.getHeader(\"authorization\"); Jws&lt;Claims&gt; jws= Jwts.parser().setSigningKey(\"louchen\") .parseClaimsJws(jwtToken.replace(\"Bearer\", \"\")); Claims claims=jws.getBody(); String username = claims.getSubject(); List&lt;GrantedAuthority&gt; authorities= AuthorityUtils.commaSeparatedStringToAuthorityList((String) claims.get(\"authorities\")); UsernamePasswordAuthenticationToken token = new UsernamePasswordAuthenticationToken(username, null, authorities); SecurityContextHolder.getContext().setAuthentication(token); filterChain.doFilter(servletRequest, servletResponse); }} 5、security配置123456789101112131415161718192021222324252627282930313233343536373839@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter { @Bean PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); } @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.inMemoryAuthentication() .withUser(\"lc\") .password(\"$2a$10$qrWxqVUCyOc.C5/uTx.9cO8cu89ast7g.mGhSms8yfj/4VPGRLab2\") .roles(\"admin\") .and() .withUser(\"zs\") .password(\"$2a$10$qrWxqVUCyOc.C5/uTx.9cO8cu89ast7g.mGhSms8yfj/4VPGRLab2\") .roles(\"user\"); } @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers(\"/hello\") .hasRole(\"user\") .antMatchers(\"/admin\") .hasRole(\"admin\") .antMatchers(HttpMethod.POST,\"/login\")// 允许登录的接口 .permitAll() .anyRequest().authenticated() .and()// 传入JwtLoginFilter中第一个参数 。作为过滤之前的请求 .addFilterBefore(new JwtLoginFilter(\"/login\", authenticationManager()), UsernamePasswordAuthenticationFilter.class) .addFilterBefore(new JwtFilter(),UsernamePasswordAuthenticationFilter.class) .csrf().disable(); }} 6、controller1234567891011121314@RestControllerpublic class HelloController { @GetMapping(\"/hello\") public String hello() { return \"hello everyone\"; } @GetMapping(\"/admin\") public String admin() { return \"hello admin\"; }} 7、请求测试请求登录：POST: http://localhost:8080/logincontent-type: application/json ==&gt; 请求参数 1234{ \"username\":\"zs\", \"password\":\"123\"} 结果==&gt; 1234{ \"msg\": \"登录成功！\", \"token\": \"eyJhbGciOiJIUzUxMiJ9.eyJhdXRob3JpdGllcyI6IlJPTEVfdXNlciwiLCJzdWIiOiJ6cyIsImV4cCI6MTU4NTY2ODQyM30.5IgsesOWhkVPpyLbIHWbgeNNQFZvIRik2FlZHWCIoD7jH1b2BOgYHqWKb7LehZ_lyK53ZggXIdLVQJ_cqnVPtQ\"} 请求接口：GET: http://localhost:8080/hello 选择Authorization的type为Bearer Token ，将Token输入。每次请求携带此token","link":"/2020/07/24/springsecurity/Spring-Security%E6%95%B4%E5%90%88jwt/"},{"title":"Java反射基础","text":"一、什么是反射？在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；这种动态获取信息以及动态调用对象方法的功能称为java语言的反射机制。 二、与反射相关的类 类名 用途 Class类 代表类的实体，在运行的Java应用程序中表示类和接口 Field类 代表类的成员变量（成员变量也称为类的属性） Method类 代表类的方法 Constructor类 代表类的构造方法 ### 三、Class类 public final class Class&lt;T&gt; implements java.io.Serializable, GenericDeclaration,Type,AnnotatedElement{} Class类表示正在运行的Java应用程序中的类和接口。 1、获取Class类实例以下知识点代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class Person { //私有属性 private String name; //公有属性 public int age; /** * 公有无参构造 */ public Person() { } /** * 私有构造 * @param name */ private Person(String name) { this.name = name; } /** * 公有构造 * @param name 姓名 * @param age 年龄 */ public Person(String name, int age) { this.name = name; this.age = age; } public String getName() { return name; } public Person setName(String name) { this.name = name; return this; } public int getAge() { return age; } public Person setAge(int age) { this.age = age; return this; } /** * 公有方法 */ public void show() { System.out.println(\"I am a good gay!\"); } /** * 私有方法 * @return 国籍 */ private String showNation() { System.out.println(\"I am an American\"); return \"America\"; } @Override public String toString() { return \"Person{\" + \"name='\" + name + '\\'' + \", age=\" + age + '}'; }} 1)通过类的Class属性123Class pClass1=Person.class;//class org.lc.reflect_test.PersonSystem.out.println(pClass1); 2)通过类的实例的getClass()方法1234Person person=new Person();Class pClass2 = person.getClass();//class org.lc.reflect_test.PersonSystem.out.println(pClass2); 3)通过Class.forName获取12345Class pClass3= Class.forName(\"org.lc.reflect_test.Person\");//class java.lang.StringClass sClass= Class.forName(\"java.lang.String\");System.out.println(sClass);//class org.lc.reflect_test.Person 4)通过类加载器获取12345678//通过当前线程获取类加载器Class pClass4 = Thread.currentThread().getContextClassLoader().loadClass(\"org.lc.reflect_test.Person\");//通过当前启动类获取类加载器Class pClass5 = T1.class.getClassLoader().loadClass(\"org.lc.reflect_test.Person\");//class org.lc.reflect_test.PersonSystem.out.println(pClass4);//class org.lc.reflect_test.PersonSystem.out.println(pClass5); 5)总结12//trueSystem.out.println((pClass1==pClass2) &amp; (pClass3==pClass4)); 通过反射获取到的运行时的类的Class对象时，它们的实例都是相同的。在内存中保存一份，无需重复创建。 2、可以获取Class的结构实例1234567891011121314151617181920212223public static void main(String[] args) throws ClassNotFoundException { //类 Class c1 = Object.class; //接口 Class c2 = Comparable.class; //一维数组 Class c3 = String[].class; //二维数组 Class c4 = int[][].class; //枚举 Class c5 = ElementType.class; //基本类型 Class c6 = int.class; //无返回类型 Class c7 = void.class; //获取Class类的自身Class Class c8 = Class.class; int[] a = new int[10]; int[] b = new int[100]; //true 只要元素类型和维度一致，就是同一个Class System.out.println(a.getClass()==b.getClass());} 3、获取运行时类的实例对象通过Class中的newInstance()方法获取实例对象 注意 该无参构造器不能为私有，因为newInstance()方法默认的还是调用的无参构造器 123456public static void main(String[] args) throws IOException, IllegalAccessException, InstantiationException { Class personClass = Person.class; Person o = (Person)personClass.newInstance(); //Person{name='null', age=0} System.out.println(o);} 以下知识点代码： Person.java 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455@MyAnnotation(value = \"哈哈哈\")public class Person extends Creature&lt;String&gt; implements Comparable&lt;String&gt;,MyInterface{ private String name; protected Date birthday; int age; public int id; public Person() { } @MyAnnotation(value = \"呵呵呵\") private Person(String name) { this.name=name; } public Person(String name, int age) { this.name=name; this.age=age; } @MyAnnotation(value = \"啧啧啧\") private String showNation(String nation) throws NullPointerException,IndexOutOfBoundsException{ System.out.println(\"my nationality is:\" + nation); return nation; } public String play(String interest) { System.out.println(\"my interest is :\"+interest); return interest; } private static void selfDescription() { System.out.println(\" i am a good gay\"); } @Override public int compareTo(String o) { return 0; } @Override public void info() { System.out.println(\"i am a people\"); } @Override public String toString() { return \"Person{\" + \"name='\" + name + '\\'' + \", birthday=\" + birthday + \", age=\" + age + \", id=\" + id + '}'; }} Creature.java 123456789101112public class Creature&lt;T&gt; implements Serializable { private char gender; public double weight; private void breath() { System.out.println(\"animals breath\"); } public void eat() { System.out.println(\"animals eating\"); }} MyInterface.java 1234public interface MyInterface { void info();} MyAnnotation.java 123456789//target：可用在类上，字段，方法，参数，构造器 ，本地局部变量上@Target({TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE})//在运行时可以获得此注解@Retention(RetentionPolicy.RUNTIME)public @interface MyAnnotation { //定义属性value ，默认值hello String value() default \"hello\";} 4、 获取属性①获取当前类和父类的所有public属性123456789Class personClass = Person.class;//获取所有的属性//只能获取属性为public的，且从父类继承的属性也为public的Field[] fields = personClass.getFields();for (Field field : fields) { //public int org.lc.reflect_01.Person.id //public double org.lc.reflect_01.Creature.weight System.out.println(field);} ②获取所有本类的所有(任意访问修饰符)属性(不包括父类的属性)1234567891011Class personClass = Person.class;//获取所有属性//只能获取本类的中的所有属性(任意访问修饰符)Field[] declaredFields = personClass.getDeclaredFields();for (Field field : declaredFields) { //private java.lang.String org.lc.reflect_01.Person.name //protected java.util.Date org.lc.reflect_01.Person.birthday //int org.lc.reflect_01.Person.age //public int org.lc.reflect_01.Person.id System.out.println(field);} 5、获取方法①获取所有本类中和父类中的所有public方法 （只能为public）12345678910Class personClass=Person.class;Method[] methods = personClass.getMethods();for (Method method : methods) { //public int org.lc.reflect_01.Person.compareTo(java.lang.String) //public int org.lc.reflect_01.Person.compareTo(java.lang.Object) //public void org.lc.reflect_01.Person.info() //public java.lang.String org.lc.reflect_01.Person.play(java.lang.String) //.... System.out.println(method);} ②获取本类中的所有(任意访问修饰符)方法(不包括父类的方法)12345678910Class personClass=Person.class;Method[] declaredMethods = personClass.getDeclaredMethods();for (Method method : declaredMethods) { //public int org.lc.reflect_01.Person.compareTo(java.lang.String) //public int org.lc.reflect_01.Person.compareTo(java.lang.Object) //public java.lang.String org.lc.reflect_01.Person.play(java.lang.String) //public void org.lc.reflect_01.Person.info() //private java.lang.String org.lc.reflect_01.Person.showNation(java.lang.String) System.out.println(method);} 6、获取构造器①获取本类中所有为public的构造器123456Class personClass = Person.class;//获取当前运行类的public修饰的构造器Constructor[] constructors = personClass.getConstructors();for (Constructor constructor : constructors) { System.out.println(constructor);} 12public org.lc.reflect_01.Person(java.lang.String,int)public org.lc.reflect_01.Person() ②获取本类中所有的构造器(任意访问修饰符)123456Class personClass = Person.class; //获取当前类的所有的构造器(任何访问修饰符) Constructor[] declaredConstructors = personClass.getDeclaredConstructors(); for (Constructor constructor : declaredConstructors) { System.out.println(constructor); } 123public org.lc.reflect_01.Person(java.lang.String,int)private org.lc.reflect_01.Person(java.lang.String)public org.lc.reflect_01.Person() 7、获取父类8、获取带泛型的父类9、获取带泛型父类的泛型123456789101112131415161718192021Class personClass = Person.class;//1、获取父类Class superclass = personClass.getSuperclass();//class org.lc.reflect_01.CreatureSystem.out.println(superclass);System.out.println(\"---------\");//2、取带泛型的父类Type genericSuperclass = personClass.getGenericSuperclass();//org.lc.reflect_01.Creature&lt;java.lang.String&gt;System.out.println(genericSuperclass.getTypeName());System.out.println(\"-----\");//获取带泛型父类的泛型Type genericSuperclass1 = personClass.getGenericSuperclass();ParameterizedType parameterizedType= (ParameterizedType) genericSuperclass1;//父类的泛型，可能有多个 Creature&lt;T,V,N&gt;Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();//[class java.lang.String]System.out.println(Arrays.toString(actualTypeArguments)); 11、 获取类实现的接口123456789Class personClass = Person.class;//1、获取当前类的实现接口Class[] interfaces = personClass.getInterfaces();//[interface java.lang.Comparable, interface org.lc.reflect_01.MyInterface]System.out.println(Arrays.toString(interfaces));//2、获取当前类的父类实现的接口Class[] interfaces1 = personClass.getSuperclass().getInterfaces();//[interface java.io.Serializable]System.out.println(Arrays.toString(interfaces1)); 12、获取当前类的包名13、获取当前类的所有注解12345678910Class personClass = Person.class;//1、获取当前类的包名Package aPackage = personClass.getPackage();//package org.lc.reflect_01System.out.println(aPackage);System.out.println(\"----------\");//2、获取当前类的所有注解Annotation[] annotations = personClass.getAnnotations();//[@org.lc.reflect_01.MyAnnotation(value=哈哈哈)]System.out.println(Arrays.toString(annotations)); 四、Field属性类1、获取访问修饰符getModifiers() 2、获取数据类型getType() 3、获取变量名getName() 12345678910111213141516171819202122public static void main(String[] args) { Class personClass = Person.class; for (Field field : personClass.getDeclaredFields()) { //1、访问修饰符 //访问修饰符对应的整数 int modifiers = field.getModifiers(); //private 对应的整数为2 //protected 对应的整数4 // 默认不写 对应的整数为0 //public 对应的整数为1 //将访问修饰符转为真正的字符串 System.out.print(\"访问修饰符:\"+modifiers+\"=\"+Modifier.toString(modifiers)); //2、获取数据类型 Class type = field.getType(); System.out.print(\"\\t类型名:\"+type.getName()); //3、获取变量名 String name = field.getName(); System.out.println(\"\\t变量名:\"+name); }} 1234访问修饰符:2=private 类型名:java.lang.String 变量名:name访问修饰符:4=protected 类型名:java.util.Date 变量名:birthday访问修饰符:0= 类型名:int 变量名:age访问修饰符:1=public 类型名:int 变量名:id 五、Method方法类1、获取在该方法上的所有注解2、获取访问修饰符3、返回值类型4、方法名5、获取形参列表6、获取所有的异常123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public static void main(String[] args) { Class personClass=Person.class; Method[] declaredMethods = personClass.getDeclaredMethods(); for (Method method : declaredMethods) { //1、获取方法上所有的注解 //注意这里声明的注解 必须 @Retention(RetentionPolicy.RUNTIME) 运行时可获取 Annotation[] annotations = method.getAnnotations(); for (Annotation annotation : annotations) { System.out.print(\"注解:\"+annotation); } //2、获取访问修饰符 System.out.print(\"\\t\"+Modifier.toString(method.getModifiers())); //3、返回值类型 System.out.print(\"\\t\"+method.getReturnType().getName()); //4、方法名 System.out.print(\"\\t\"+method.getName()); //5、获取形参列表 Class[] parameterTypes = method.getParameterTypes(); //若没有参数则不获取参数 if (!(parameterTypes == null || parameterTypes.length == 0)) { System.out.print(\"(\"); for (int i = 0; i &lt; parameterTypes.length; i++) { //变量到最后一个参数换行 if (i == parameterTypes.length - 1) { System.out.print(parameterTypes[i].getName()+\" arg_\"+i+\")\"); break; } System.out.print(parameterTypes[i].getName()+\" arg_\"+i+\",\"); } }else{ System.out.println(); } //6、获取所有的异常 Class[] exceptionTypes = method.getExceptionTypes(); if (!(exceptionTypes == null || exceptionTypes.length == 0)) { System.out.print(\" throws \"); for (int i = 0; i &lt; exceptionTypes.length; i++) { if (i == exceptionTypes.length - 1) { System.out.println(exceptionTypes[i].getName()); break; } System.out.print(exceptionTypes[i].getName()+\",\"); } }else{ System.out.println(); } }} 12345 public int compareTo(java.lang.String arg_0) public volatile int compareTo(java.lang.Object arg_0) public java.lang.String play(java.lang.String arg_0) public void info注解:@org.lc.reflect_01.MyAnnotation(value=啧啧啧) private java.lang.String showNation(java.lang.String arg_0,int arg_1) throws java.lang.NullPointerException,java.lang.IndexOutOfBoundsException 六、调用运行时类中指定结构：属性、方法、构造器1、调用属性①通过getDeclaredField(String name) (不适用)1234567891011//1、获取Class对象Class personClass = Person.class;//2、通过Class对象创建类的实例对象Person person = (Person)personClass.newInstance();//3、获取属性(获取的为本类和父类的public属性) 注意：此时获取的属性必须为publicField id = personClass.getField(\"id\");//4、为该属性设置值id.set(person, 11);//5、获取该属性的值int x = (int)id.get(person);System.out.println(x); ②通过getField(String name)(常用)12345678910111213//1、获取Class对象Class personClass = Person.class;//2、通过Class对象创建类的实例对象Person person = (Person)personClass.newInstance();//3、获取属性(获取的为本类的所有属性)Field name = personClass.getDeclaredField(\"name\");//3'当获取的属性为private私有的属性时，进行访问设值的时候需要设置访问权限setAccessible为truename.setAccessible(true);//4、为该属性设置值name.set(person, \"张三\");//5、获取该属性的值String x = (String)name.get(person);System.out.println(x); 2、调用方法 public Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes) name：要获得的方法名称 parameterTypes：参数列表对应的Class类 public Object invoke(Object obj, Object... args) 参数 obj：实例对象 args：传入的实际的方法参数 返回值 调用该方法的返回值 ①调用实例方法123456789101112//1、获取Class对象Class personClass = Person.class;//2、通过Class对象创建类的实例对象Person person = (Person)personClass.newInstance();//3、获取方法Method showNation = personClass.getDeclaredMethod(\"showNation\", String.class);//3' 当获取的方法为private私有类型时，同理也必须设置setAccessible为true.代表可访问showNation.setAccessible(true);//4、回调方法并获取返回值Object cn = showNation.invoke(person, \"CN\");//CNSystem.out.println(cn); ②调用静态方法12345678910111213//1、获取Class对象Class personClass = Person.class;//2、通过Class对象创建类的实例对象Person person = (Person)personClass.newInstance();//3、获取方法Method selfDescription = personClass.getDeclaredMethod(\"selfDescription\");//3'、使private方法可访问selfDescription.setAccessible(true);//回调方法的实例类型可传null或者selfDescription.invoke(null);Object invoke = selfDescription.invoke(Person.class);//若方法没有返回值则返回 null//nullSystem.out.println(invoke); ③调用构造器1)使用Class的newInstance()方法 (常用)12345//1、获取Class对象Class personClass = Person.class;//2、直接通过newInstance回去默认的无参构造器Person person = (Person) personClass.newInstance();System.out.println(person); 2)使用getDeclaredConstructor (不常用)123456789101112 //1、获取Class对象 Class personClass = Person.class; //2、获取无参的构造器// Constructor declaredConstructor = personClass.getDeclaredConstructor(); //2'、获取有参构造器，传入指定的参数的Class类 Constructor declaredConstructor = personClass.getDeclaredConstructor(String.class); //3若构造器为private私有的，则需要设置访问权限为true declaredConstructor.setAccessible(true); //4、若为无参构造器则无需传入参数，有参构造器则需要传入实参值 Person person = (Person) declaredConstructor.newInstance(\"张三\"); //Person{name='张三', birthday=null, age=0, id=0} System.out.println(person);","link":"/2020/07/24/javase/Java%E5%8F%8D%E5%B0%84/"},{"title":"Springboot整合RabbitMQ","text":"Springboot整合RabbitMQ一、安装RabbitMQ这里我们使用docker 通信端口 : 5672 管理界面端口 :15672 默认账户密码都是 guest 1、拉取镜像docker pull rabbitmq:3-management //下载带管理界面的消息队列 2、初始化容器docker run -d -p 5672:5672 -p 15672:15672 --restart=always --name myrabbitmq 镜像id 3、修改rabbitmq密码123docker exec -it fd4f81cdd3e7 bash //进入容器rabbitmqctl list_users //查看所有用户 rabbitmqctl change_password guest 'Newpassword' //修改指定用户密码 4、常见命令12345新建用户：rabbitmqctl add_user username passwd删除用户：rabbitmqctl delete_user username改密码: rabbimqctl change_password {username} {newpassword}设置用户角色：rabbitmqctl set_user_tags {username} {tag ...}rabbitmqctl set_permissions -p / username \".*\" \".*\" \".*\" //添加权限 二、springboot整合RabbitMQ1、什么是RabbitMQ？​ RabbitMQ是一个基于AMQP(Advanced Message Queuing Protocol)协议的高级消息中间件，是应用层协议的一个开放标准。基于Erlang语言，可跨平台。它主要的技术特点是可用性，安全性，集群，多协议支持，可视化的客户端，活跃的社区。 ​ AMQP为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。 AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。 RabbitMQ是一个开源的AMQP实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。 2、基本配置pom.xml配置spring-boot-starter-amqp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;rabbitmq&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;rabbitmq&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.amqp&lt;/groupId&gt; &lt;artifactId&gt;spring-rabbit-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; properties配置12345678#配置主机地址spring.rabbitmq.host=47.96.141.44#通信端口spring.rabbitmq.port=5672#用户名spring.rabbitmq.username=guest#密码spring.rabbitmq.password=guest ①直连交换机(Direct)直连型交换机，根据消息携带的路由键将消息投递给对应队列。 大致流程，有一个队列绑定到一个直连交换机上，同时赋予一个路由键 routing key 。然后当一个消息携带着路由值为X，这个消息通过生产者发送给交换机时，交换机就会根据这个路由值X去寻找绑定值也是X的队列。 队列交换机配置： 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Direct策略 直接指定到发送的队列名称。 */@Configurationpublic class RabbitDirectConfig { /** * 定义directExchange的名称 */ public final static String DIRECTNAME = \"javaMr-direct\"; /** * 注意导的包 org.springframework.amqp.core.Queue; * 定义队列 * @return */ @Bean Queue queue() { return new Queue(\"hello.lc\"); } /** * 定义Direct交换机 * @return */ @Bean DirectExchange directExchange() { //定义的DirectExchange名称; durable(持久性)重启后是否依然有效; autodelete长期未使用是否自动删除 return new DirectExchange(DIRECTNAME,true,false); } /** * 绑定指定的队列到交换机上并指定策略 * @return */ @Bean Binding binding() {// 绑定队列到交换机上 并指定路由匹配规则 return BindingBuilder.bind(queue()).to(directExchange()).with(\"direct\"); }} 消费者： 12345678910111213141516/** * direct消费者 */@Componentpublic class DirectReceiver { /** * 监听指定队列(hello.lc) * @param msg */ @RabbitListener(queues = \"hello.lc\") public void handler(String msg) { System.out.println(\"&gt;&gt;&gt;&gt;&gt;&gt;&gt;:\"+msg); }} 生产者： 1234567891011121314151617@SpringBootTestclass RabbitmqApplicationTests { @Autowired private RabbitTemplate rabbitTemplate; /** * direct模式 发送到指定队列 */ @Test void directTest() {// 发送到指定路由规则(默认为队列名)队列; 发送的消息 rabbitTemplate.convertAndSend(RabbitDirectConfig.DIRECTNAME,\"direct\", \"你好呀 direct!!!\");// 如果不指定发送的交换机名称则直接匹配的routingkey到队列名// rabbitTemplate.convertAndSend(\"hello.lc\", \"你好呀 direct!!!\"); }} ②主题交换机(Topic)前面讲到direct类型的Exchange路由规则是完全匹配binding key与routing key，但这种严格的匹配方式在很多情况下不能满足实际业务需求。topic类型的Exchange在匹配规则上进行了扩展，它与direct类型的Exchage相似，也是将消息路由到binding key与routing key相匹配的Queue中，但这里的匹配规则有些不同，它约定： routing key为一个句点号“. ”分隔的字符串（我们将被句点号“. ”分隔开的每一段独立的字符串称为一个单词），如“stock.usd.nyse”、“nyse.vmw”、“quick.orange.rabbit” binding key与routing key一样也是句点号“. ”分隔的字符串 binding key中可以存在两种特殊字符“ * ”与“#”，用于做模糊匹配，其中“*”用于匹配一个单词，“#”用于匹配多个单词（可以是零个） 队列交换机配置： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** *topic策略 根据指定路径匹配符转发到指定队列 */@Configurationpublic class RabbitTopicCofig { public static final String TOPICNAME = \"javaMr-topic\"; @Bean Queue xiaomi() { return new Queue(\"xiaomi\"); } @Bean Queue huawei() { return new Queue(\"huawei\"); } @Bean Queue iphone() { return new Queue(\"iphone\"); } @Bean TopicExchange topicExchange() { return new TopicExchange(TOPICNAME, true, false); } @Bean Binding xiaomiBinding() {// 绑定xiaomi队列到topic交换机，并指定队列访问规则// 发送匹配的路由规格 以 xiao. 开头的路径 return BindingBuilder.bind(xiaomi()).to(topicExchange()).with(\"xiaomi.#\"); } @Bean Binding huaweiBinding() {// 绑定huawei队列到topic交换机，并指定队列访问规则// 发送匹配的路由规格 以 huawei. 开头的路径 return BindingBuilder.bind(huawei()).to(topicExchange()).with(\"huawei.#\"); } @Bean Binding iphoneBinding() {// 绑定iphone队列到topic交换机，并指定队列访问规则// 发送匹配的路由规格 以 .phone. 规则的路径 return BindingBuilder.bind(iphone()).to(topicExchange()).with(\"#.iphone.#\"); }} 消费者配置： 1234567891011121314151617@Componentpublic class TopicReceiver { @RabbitListener(queues = \"xiaomi\") public void handlerXiaomi(String msg) { System.out.println(\"TopicReceiver:handlerXiaomi&gt;&gt;&gt;&gt;&gt;\"+msg); } @RabbitListener(queues = \"huawei\") public void handlerHuawei(String msg) { System.out.println(\"TopicReceiver:handlerHuawei&gt;&gt;&gt;&gt;&gt;\"+msg); } @RabbitListener(queues = \"iphone\") public void handlerIphone(String msg) { System.out.println(\"TopicReceiver:handlerIphone&gt;&gt;&gt;&gt;&gt;\"+msg); }} 生成者配置： 12345678910111213141516171819@SpringBootTestclass RabbitmqApplicationTests { @Autowired private RabbitTemplate rabbitTemplate; /** * topic模式 发送到指定交换机下的路径匹配的队列 */ @Test void topicTest() {// 发送到指定交换机; 匹配路由为 xiaomi.# 的路径--&gt;指定到xiaomi队列; 发送的消息 rabbitTemplate.convertAndSend(RabbitTopicCofig.TOPICNAME, \"xiaomi.news\", \"小米手机\");// 发送到指定交换机; 匹配路由为 #.iphone.# 的路径--&gt;指定到iphone队列; 发送的消息 rabbitTemplate.convertAndSend(RabbitTopicCofig.TOPICNAME, \"iphoneXR.iphone\", \"iphone手机\");// 发送到指定交换机; 匹配路由为 huawei.# 和 #.iphone.# 的路径--&gt;指定到huawei和iphone队列; 发送的消息 rabbitTemplate.convertAndSend(RabbitTopicCofig.TOPICNAME, \"huawei.iphone\", \"A12系列和麒麟系列芯片\"); }} ③扇形交换机(Fanout)扇型交换机，这个交换机没有路由键概念，就算你绑了路由键也是无视的。 这个交换机在接收到消息后，会直接转发到绑定到它上面的所有队列。 队列交换机配置： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * fanout策略 转发到该交换机下的所有队列（跟路由规则（routingkey）无关） */@Configurationpublic class RabbitFanoutConfig { /** * 定义交换机名称 */ public static final String FANOUTNAME = \"javaMr-fanout\"; /** * 定义第一个队列 * @return */ @Bean Queue queueOne() { return new Queue(\"queue-one\"); } /** * 定义第二个队列 * @return */ @Bean Queue queueTwo() { return new Queue(\"queue-two\"); } /** * 定义Fanout交换机 * @return */ @Bean FanoutExchange fanoutExchange() { return new FanoutExchange(FANOUTNAME,true,false); } /** * 绑定第一个队列到交换机 * @return */ @Bean Binding bindingOne() { return BindingBuilder.bind(queueOne()).to(fanoutExchange()); } /** * 绑定到第二个交换机 * @return */ @Bean Binding bindingTwo() { return BindingBuilder.bind(queueTwo()).to(fanoutExchange()); }} 消费者配置： 1234567891011121314151617/** * 定义消费者 */@Componentpublic class FanoutReceiver { @RabbitListener(queues = \"queue-one\") public void handlerOne(String msg) { System.out.println(\"queue-one&gt;&gt;&gt;&gt;&gt;:\"+msg); } @RabbitListener(queues = \"queue-two\") public void handlerTwo(String msg) { System.out.println(\"queue-two&gt;&gt;&gt;&gt;&gt;:\"+msg); }} 生产者配置： 123456789101112131415@SpringBootTestclass RabbitmqApplicationTests { @Autowired private RabbitTemplate rabbitTemplate; /** * fanout模式 发送到所有该交换机下的队列 */ @Test void fanoutTest(){ //发送到指定交换机; 这里的routingkey队列关键词会无效; 发送的消息 rabbitTemplate.convertAndSend(RabbitFanoutConfig.FANOUTNAME, null, \"java fanout np!!!!\"); }} ④头部交换机(Headers)headers类型的Exchange不依赖于routing key与binding key的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。 在绑定Queue与Exchange时指定一组键值对；当消息发送到Exchange时，RabbitMQ会取到该消息的headers（也是一个键值对的形式），对比其中的键值对是否完全匹配Queue与Exchange绑定时指定的键值对；如果完全匹配则消息会路由到该Queue，否则不会路由到该Queue。 队列交换机配置： 1234567891011121314151617181920212223242526272829303132333435363738394041/** * headers策略 根据指定头部转发到指定队列(跟路由规则routingkey无关) */@Configurationpublic class RabbitHeadersConfig { public static final String HEADERNAME = \"javaMr-header\"; @Bean Queue queueName() { return new Queue(\"name-queue\"); } @Bean Queue queueAge() { return new Queue(\"age-queue\"); } @Bean HeadersExchange headersExchange() { return new HeadersExchange(HEADERNAME, true, false); } @Bean Binding bindingName() { Map&lt;String,Object&gt; map=new HashMap&lt;&gt;(); map.put(\"name\", \"lcc\");// 需要满足发送的消息 携带头部 name为lcc才匹配到该队列// 只需要匹配该map中的任意一个即可 return BindingBuilder.bind(queueName()).to(headersExchange()).whereAny(map).match();// 当有多个键值对时，必须必须匹配所有。// return BindingBuilder.bind(queueName()).to(headersExchange()).whereAll(map).match(); } @Bean Binding bindingAge() {// 满足只要有age属性存在 即可匹配到该队列 return BindingBuilder.bind(queueAge()).to(headersExchange()).where(\"age\").exists(); }} 消费者配置： 123456789101112131415@Componentpublic class HeadersReceiver { @RabbitListener(queues = \"name-queue\") public void handlerName(byte[] msg) {// 将字节数组解码为字符串对象 System.out.println(\"HeaderReceiver:handlerName&gt;&gt;&gt;&gt;&gt;&gt;\"+new String(msg,0,msg.length)); } @RabbitListener(queues = \"age-queue\") public void handlerAge(byte[] msg) {// 将字节数组解码为字符串对象 System.out.println(\"HeaderReceiver:handlerAge&gt;&gt;&gt;&gt;&gt;&gt;\"+new String(msg,0,msg.length)); }} 生产者配置： 1234567891011121314151617181920212223@SpringBootTestclass RabbitmqApplicationTests { @Autowired private RabbitTemplate rabbitTemplate; /** * header模式 发送消息时携带指定的头部信息 满足条件时即转发到指定队列 */ @Test void headerTest() {// 构建消息对象// 传入消息体转为字节数组; 设置匹配到路由的规则（map形式）; Message nameMsg= MessageBuilder.withBody(\"hello lcccccccc\".getBytes()).setHeader(\"name\", \"lcc\").build();// 发送到指定交换机; 此时路由无效; 传入消息 rabbitTemplate.send(RabbitHeadersConfig.HEADERNAME, null, nameMsg);// 构建消息对象// 传入消息体转为字节数组; 设置匹配到路由的规则（map形式）; Message ageMsg=MessageBuilder.withBody(\"i am 20\".getBytes()).setHeader(\"age\", \"22\").build();// 发送到指定交换机; 此时路由无效; 传入消息 rabbitTemplate.send(RabbitHeadersConfig.HEADERNAME, null, ageMsg); }} 三、RabbitMQ 选型和对比1.从社区活跃度按照目前网络上的资料，RabbitMQ 、activeM 、ZeroMQ 三者中，综合来看，RabbitMQ 是首选。 2.持久化消息比较ZeroMq 不支持，ActiveMq 和RabbitMq 都支持。持久化消息主要是指我们机器在不可抗力因素等情况下挂掉了，消息不会丢失的机制。 3.综合技术实现可靠性、灵活的路由、集群、事务、高可用的队列、消息排序、问题追踪、可视化管理工具、插件系统等等。 RabbitMq / Kafka 最好，ActiveMq 次之，ZeroMq 最差。当然ZeroMq 也可以做到，不过自己必须手动写代码实现，代码量不小。尤其是可靠性中的：持久性、投递确认、发布者证实和高可用性。 4.高并发毋庸置疑，RabbitMQ 最高，原因是它的实现语言是天生具备高并发高可用的erlang 语言。 5.比较关注的比较， RabbitMQ 和 KafkaRabbitMq 比Kafka 成熟，在可用性上，稳定性上，可靠性上， RabbitMq 胜于 Kafka （理论上）。 另外，Kafka 的定位主要在日志等方面， 因为Kafka 设计的初衷就是处理日志的，可以看做是一个日志（消息）系统一个重要组件，针对性很强，所以 如果业务方面还是建议选择 RabbitMq 。 还有就是，Kafka 的性能（吞吐量、TPS ）比RabbitMq 要高出来很多。","link":"/2020/07/24/mq/SpringBoot%E6%95%B4%E5%90%88RabbitMQ/"},{"title":"Springboot应用监控","text":"Springboot应用监控使用Actuator实现监控应用端点信息介绍 /info 应用基本信息 /health 健康度信息 /metrics 运行指标 /env 环境变量信息 /loggers 日志相关 /dump 线程相关信息 /trace 请求调用轨迹 ID 描述 是否需要鉴权 actuator 为其他端点提供“发现页面”。要求Spring HATEOAS在classpath路径上。 需要 auditevents 陈列当前应用程序的审计事件信息。 需要 autoconfig 展示自动配置信息并且显示所有自动配置候选人以及他们“被不被”应用的原因。 需要 beans 显示应用程序中所有Spring bean的完整列表。 需要 configprops 显示所有配置信息。 需要 dump dump所有线程。 需要 env 陈列所有的环境变量。 需要 flyway Shows any Flyway database migrations that have been applied. 需要 health 显示应用程序运行状况信息 不需要 info 显示应用信息。 不需要 loggers 显示和修改应用程序中的loggers配置。 需要 liquibase 显示已经应用的任何Liquibase数据库迁移。 需要 metrics 显示当前应用程序的“指标”信息。 需要 mappings 显示所有@RequestMapping的url整理列表。 需要 shutdown 关闭应用（默认情况下不启用）。 需要 trace 显示跟踪信息（默认最后100个HTTP请求）。 需要 一、应用端点1、pom.xmlspring-boot-starter-actuator spring-boot-starter-security 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;actuator&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;actuator&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、security安全配置httpBasic: 使用httpBasic认证 12345678910111213141516@Configurationpublic class SecurtyConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception {// 请求匹配其他所有端点的请求 http.requestMatcher(EndpointRequest.toAnyEndpoint())// 开启所有请求授权 .authorizeRequests()// 其他请求必须要有admin角色 .anyRequest().hasRole(\"admin\") .and()// 使用httpBasic认证 .httpBasic(); }} 3、properties配置123456789101112131415161718192021222324252627282930#关闭默认的配置（即 关闭所有默认开启的端口），一般没有必要配置#management.endpoints.enabled-by-default=false#是否开启远程应用关闭功能 （默认一般只有这个是关闭的）#post：http://localhost:8080/actuator/shutdown 即可关闭应用#但是这样不够安全 需要进行配置securitymanagement.endpoint.shutdown.enabled=true#虽然默认开启了很多端点 但是都没有暴露#暴露所有端点management.endpoints.web.exposure.include=*#配置用户名密码角色spring.security.user.name=lcspring.security.user.password=123spring.security.user.roles=admin#配置访问的基础路径#默认为/actuatormanagement.endpoints.web.base-path=/lc#默认为/actuator/helath#health路径的重新配置management.endpoints.web.path-mapping.health=/lc-health#允许的域（默认* 所有）#自定义运行请求的地址http://localhost:8081management.endpoints.web.cors.allowed-origins=http://localhost:8081#允许的请求方法类型#默认为* 所有management.endpoints.web.cors.allowed-methods=GET,POST 4、访问测试①访问health默认：GET http://localhost:8080/actuaotr/health GET http://localhost:8080/lc/lc-health 选择：Authorization-&gt;Basic Auth Username:lc password:123 ②访问beans默认：GET http://localhost:8080/actuaotr/beans GET http://localhost:8080/lc/beans 选择：Authorization-&gt;Basic Auth Username:lc password:123 二、 health端点123456789101112131415161718192021222324252627282930313233#关闭默认的配置（即 关闭所有默认开启的端口），一般没有必要配置#management.endpoints.enabled-by-default=false#是否开启远程应用关闭功能 （默认一般只有这个是关闭的）#post：http://localhost:8080/actuator/shutdown 即可关闭应用#但是这样不够安全 需要进行配置securitymanagement.endpoint.shutdown.enabled=true#虽然默认开启了很多端点 但是都没有暴露#暴露所有端点management.endpoints.web.exposure.include=*#配置用户名密码角色spring.security.user.name=lcspring.security.user.password=123spring.security.user.roles=admin#配置访问的基础路径#默认为/actuator#management.endpoints.web.base-path=/lc#默认为/actuator/helath#health路径的重新配置#management.endpoints.web.path-mapping.health=/lc-health#允许的域（默认* 所有）#自定义运行请求的地址http://localhost:8081management.endpoints.web.cors.allowed-origins=http://localhost:8081#允许的请求方法类型#默认为* 所有management.endpoints.web.cors.allowed-methods=GET,POST#验证后展示健康信息management.endpoint.health.show-details=when_authorized 当配置其他应用时，如redis,mongo,mysql等都会有健康信息 GET http://localhost:8080/actuaotr/health 12345678910111213141516{ \"status\": \"UP\", \"components\": { \"diskSpace\": { \"status\": \"UP\", \"details\": { \"total\": 492657700864, \"free\": 265716948992, \"threshold\": 10485760 } }, \"ping\": { \"status\": \"UP\" } }} 三、info端点1、自定义信息①通过配置文件配置12345678910111213141516171819202122232425262728293031323334353637383940#关闭默认的配置（即 关闭所有默认开启的端口），一般没有必要配置#management.endpoints.enabled-by-default=false#是否开启远程应用关闭功能 （默认一般只有这个是关闭的）#post：http://localhost:8080/actuator/shutdown 即可关闭应用#但是这样不够安全 需要进行配置securitymanagement.endpoint.shutdown.enabled=true#虽然默认开启了很多端点 但是都没有暴露#暴露所有端点management.endpoints.web.exposure.include=*#配置用户名密码角色spring.security.user.name=lcspring.security.user.password=123spring.security.user.roles=admin#配置访问的基础路径#默认为/actuator#management.endpoints.web.base-path=/lc#默认为/actuator/helath#health路径的重新配置#management.endpoints.web.path-mapping.health=/lc-health#允许的域（默认* 所有）#自定义运行请求的地址http://localhost:8081management.endpoints.web.cors.allowed-origins=http://localhost:8081#允许的请求方法类型#默认为* 所有management.endpoints.web.cors.allowed-methods=GET,POST#验证后展示健康信息management.endpoint.health.show-details=when_authorized#配置应用信息info.app.encoding=@project.build.sourceEncoding@info.app.java.source=@java.version@info.app.java.target=@java.version@info.author.name=lcinfo.author.address=www.louchen.top GET:http://localhost:8080/actuator/info 12345678910111213{ \"app\": { \"encoding\": \"UTF-8\", \"java\": { \"source\": \"1.8.0_191\", \"target\": \"1.8.0_191\" } }, \"author\": { \"name\": \"lc\", \"address\": \"www.louchen.top\" }} ②通过代码配置会覆盖在properties的配置 123456789@Componentpublic class LcInfo implements InfoContributor { @Override public void contribute(Info.Builder builder) { Map&lt;String,Object&gt; info=new HashMap&lt;&gt;(); info.put(\"email\", \"421192425@qq.com\"); builder.withDetail(\"author\", info); }} GET http://localhost:8080/actuaotr/health 123456789101112{ \"app\": { \"encoding\": \"UTF-8\", \"java\": { \"source\": \"1.8.0_191\", \"target\": \"1.8.0_191\" } }, \"author\": { \"email\": \"421192425@qq.com\" }} 2、git信息①创建该项目所在的版本库git init–&gt;git add . –&gt;git commit -m ‘信息’ ②安装git信息插件12345678910111213&lt;build&gt; &lt;plugins&gt; &lt;!--添加git插件 获取git版本信息--&gt; &lt;plugin&gt; &lt;groupId&gt;pl.project13.maven&lt;/groupId&gt; &lt;artifactId&gt;git-commit-id-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; ③生成git.propertiesmaven-&gt;plugins-&gt;git-commit-id 点击：git-commit-id:revision 在target-&gt;classes下生成：git.properties 12345678910111213141516171819202122232425#Generated by Git-Commit-Id-Plugin#Wed Apr 08 16:33:41 GMT+08:00 2020git.branch=mastergit.build.host=LAPTOP-LJJM9R29git.build.time=2020-04-08T16\\:33\\:41+0800git.build.user.email=421192425@qq.comgit.build.user.name=louchen97git.build.version=0.0.1-SNAPSHOTgit.closest.tag.commit.count=git.closest.tag.name=git.commit.id=5a55c763ecfb66fff1986fce9880663a72ab7e88git.commit.id.abbrev=5a55c76git.commit.id.describe=5a55c76-dirtygit.commit.id.describe-short=5a55c76-dirtygit.commit.message.full=创建git.commit.message.short=创建git.commit.time=2020-04-08T16\\:30\\:36+0800git.commit.user.email=421192425@qq.comgit.commit.user.name=louchen97git.dirty=truegit.local.branch.ahead=NO_REMOTEgit.local.branch.behind=NO_REMOTEgit.remote.origin.url=Unknowngit.tags=git.total.commit.count=1 ④主配置文件123456789101112131415161718192021222324252627282930313233343536373839404142434445#关闭默认的配置（即 关闭所有默认开启的端口），一般没有必要配置#management.endpoints.enabled-by-default=false#是否开启远程应用关闭功能 （默认一般只有这个是关闭的）#post：http://localhost:8080/actuator/shutdown 即可关闭应用#但是这样不够安全 需要进行配置securitymanagement.endpoint.shutdown.enabled=true#虽然默认开启了很多端点 但是都没有暴露#暴露所有端点management.endpoints.web.exposure.include=*#配置用户名密码角色spring.security.user.name=lcspring.security.user.password=123spring.security.user.roles=admin#配置访问的基础路径#默认为/actuator#management.endpoints.web.base-path=/lc#默认为/actuator/helath#health路径的重新配置#management.endpoints.web.path-mapping.health=/lc-health#允许的域（默认* 所有）#自定义运行请求的地址http://localhost:8081management.endpoints.web.cors.allowed-origins=http://localhost:8081#允许的请求方法类型#默认为* 所有management.endpoints.web.cors.allowed-methods=GET,POST#验证后展示健康信息management.endpoint.health.show-details=when_authorized#配置应用信息info.app.encoding=@project.build.sourceEncoding@info.app.java.source=@java.version@info.app.java.target=@java.version@info.author.name=lcinfo.author.address=www.louchen.top#git信息配置#simple(默认)展示一些简单信息#full展示所有git信息management.info.git.mode=full GET: http://localhost:8080/actuator/info 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667{ \"app\": { \"encoding\": \"UTF-8\", \"java\": { \"source\": \"1.8.0_191\", \"target\": \"1.8.0_191\" } }, \"author\": { \"email\": \"421192425@qq.com\" }, \"git\": { \"build\": { \"host\": \"LAPTOP-LJJM9R29\", \"version\": \"0.0.1-SNAPSHOT\", \"time\": \"2020-04-08T08:33:41Z\", \"user\": { \"name\": \"louchen97\", \"email\": \"421192425@qq.com\" } }, \"branch\": \"master\", \"commit\": { \"message\": { \"short\": \"创建\", \"full\": \"创建\" }, \"id\": { \"describe\": \"5a55c76-dirty\", \"abbrev\": \"5a55c76\", \"describe-short\": \"5a55c76-dirty\", \"full\": \"5a55c763ecfb66fff1986fce9880663a72ab7e88\" }, \"time\": \"2020-04-08T08:30:36Z\", \"user\": { \"email\": \"421192425@qq.com\", \"name\": \"louchen97\" } }, \"closest\": { \"tag\": { \"name\": \"\", \"commit\": { \"count\": \"\" } } }, \"local\": { \"branch\": { \"ahead\": \"NO_REMOTE\", \"behind\": \"NO_REMOTE\" } }, \"dirty\": \"true\", \"remote\": { \"origin\": { \"url\": \"Unknown\" } }, \"tags\": \"\", \"total\": { \"commit\": { \"count\": \"1\" } } }} 3、项目构建信息maven--&gt;Plugins--&gt;spring-boot 点击：spring-boot:build-info 在classes下的META-INF下生成build-info.properties 12345build.artifact=actuatorbuild.group=org.lcbuild.name=actuatorbuild.time=2020-04-08T09\\:33\\:21.830Zbuild.version=0.0.1-SNAPSHOT GET http://localhost:8080/actuator/info 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374{ \"app\": { \"encoding\": \"UTF-8\", \"java\": { \"source\": \"1.8.0_191\", \"target\": \"1.8.0_191\" } }, \"author\": { \"email\": \"421192425@qq.com\" }, \"git\": { \"build\": { \"host\": \"LAPTOP-LJJM9R29\", \"version\": \"0.0.1-SNAPSHOT\", \"time\": \"2020-04-08T08:33:41Z\", \"user\": { \"name\": \"louchen97\", \"email\": \"421192425@qq.com\" } }, \"branch\": \"master\", \"commit\": { \"message\": { \"short\": \"创建\", \"full\": \"创建\" }, \"id\": { \"describe\": \"5a55c76-dirty\", \"abbrev\": \"5a55c76\", \"describe-short\": \"5a55c76-dirty\", \"full\": \"5a55c763ecfb66fff1986fce9880663a72ab7e88\" }, \"time\": \"2020-04-08T08:30:36Z\", \"user\": { \"email\": \"421192425@qq.com\", \"name\": \"louchen97\" } }, \"closest\": { \"tag\": { \"name\": \"\", \"commit\": { \"count\": \"\" } } }, \"local\": { \"branch\": { \"ahead\": \"NO_REMOTE\", \"behind\": \"NO_REMOTE\" } }, \"dirty\": \"true\", \"remote\": { \"origin\": { \"url\": \"Unknown\" } }, \"tags\": \"\", \"total\": { \"commit\": { \"count\": \"1\" } } }, \"build\": { \"version\": \"0.0.1-SNAPSHOT\", \"artifact\": \"actuator\", \"name\": \"actuator\", \"group\": \"org.lc\", \"time\": \"2020-04-08T09:33:21.830Z\" }}","link":"/2020/07/24/projectcontrol/SpringBoot%E5%BA%94%E7%94%A8%E7%9B%91%E6%8E%A7/"},{"title":"springboot整合Jpa及多数据源","text":"springboot整合Jpa1、基本配置：①pom.xml配置： 123456789101112131415161718192021222324252627282930313233343536373839&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.18&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;version&gt;5.1.27&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; ②yaml配置：1234567891011121314151617181920212223spring: datasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=UTF-8 username: root password: 123456 jpa:# 显示sql语句 show-sql: true# 数据库 database: mysql # 数据库平台 database-platform: mysql# 设置表的结构的生成类型 hibernate:# 每次启动更新表结构 ddl-auto: update properties: hibernate:# 设置方言 mysql57 dialect: org.hibernate.dialect.MySQL57Dialect ③实体配置：1234567891011121314151617181920212223242526272829303132/** * 指定表的名称 若不存在 则自动为你创建此表 */@Entity(name = \"t_book\")@Getter@Setter@ToStringpublic class Book { /** *在jpa中一个表必须设置主键，否则创建会失败 * @Id标注的属性为主键 * @GeneratedValue指定生成策略为自增长 * @column中可设置字段的约束操作（长度为10） */ @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(length = 10) private Integer id; /** * 设置自动不能为空，长度为50,设置数据库中和属性的对应名称 */ @Column(nullable = false,length = 50,name = \"name\") private String name; /** * 设置自动不能为空，长度为20,设置数据库中和属性的对应名称 */ @Column(nullable = false,length = 20,name = \"author\") private String author;} ④jpa接口配置：123456789/** * 这里要实现 JpaRepository 接口 * JpaRepository已经帮我们实现了很多操作直接使用即可 * 第一个参数为 操作的实体的类型 * 第二个参数为 主键的类型 */public interface BookDao extends JpaRepository&lt;Book,Integer&gt; {} ⑤测试：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475@SpringBootTestclass JpaApplicationTests { @Autowired private BookDao bookDao; /** * 增加 */ @Test void addBokk() { Book book=new Book(); book.setName(\"西游记\"); book.setAuthor(\"施耐庵\"); bookDao.save(book); } /** * 有则更新 无则添加 */ @Test void updateBook() { Book book=new Book(); book.setName(\"xiyouji\"); book.setAuthor(\"shinaian\"); book.setId(1); bookDao.saveAndFlush(book); } /** * 通过id删除 */ @Test void deleteBook() { bookDao.deleteById(1); } /** * 通过id查询 查询所有 */ @Test void findBook() { Optional&lt;Book&gt; byId = bookDao.findById(2); System.out.println(byId.get()); List&lt;Book&gt; all = bookDao.findAll(); System.out.println(all); } /** * 按照id 降序排序 */ @Test void findBookSort() { List&lt;Book&gt; all = bookDao.findAll(Sort.by(Sort.Direction.DESC, \"id\")); System.out.println(all); } /** * 分页查询 */ @Test void findBookPage() { //从第一页开始查询（起始为0），每页大小为2 Pageable pageable = PageRequest.of(2, 2); Page&lt;Book&gt; all = bookDao.findAll(pageable); System.out.println(\"总记录数:\"+all.getTotalElements()); System.out.println(\"当前页记录数:\"+all.getNumberOfElements()); System.out.println(\"每页记录数:\" + all.getSize()); System.out.println(\"总页数:\" + all.getTotalPages()); System.out.println(\"查询结果数据:\" + all.getContent()); System.out.println(\"当前页数(从0开始):\" + all.getNumber()); System.out.println(\"是否为首页:\" + all.isFirst()); System.out.println(\"是否为尾页:\" + all.isLast()); }} 2、jpa使用关键字进行查询：关键字查询参考表： Keyword Sample JPQL snippet And findByLastnameAndFirstname … where x.lastname = ?1 and x.firstname = ?2 Or findByLastnameOrFirstname … where x.lastname = ?1 or x.firstname = ?2 Is,Equals findByFirstname,findByFirstnameIs … where x.firstname = ?1 Between findByStartDateBetween … where x.startDate between ?1 and ?2 LessThan findByAgeLessThan … where x.age &lt; ?1 LessThanEqual findByAgeLessThanEqual … where x.age &lt;= ?1 GreaterThan findByAgeGreaterThan … where x.age &gt; ?1 GreaterThanEqual findByAgeGreaterThanEqual … where x.age &gt;= ?1 After findByStartDateAfter … where x.startDate &gt; ?1 Before findByStartDateBefore … where x.startDate &lt; ?1 IsNull findByAgeIsNull … where x.age is null IsNotNull,NotNull findByAge(Is)NotNull … where x.age not null Like findByFirstnameLike … where x.firstname like ?1 NotLike findByFirstnameNotLike … where x.firstname not like ?1 StartingWith findByFirstnameStartingWith … where x.firstname like ?1(parameter bound with appended %) EndingWith findByFirstnameEndingWith … where x.firstname like ?1(parameter bound with prepended %) Containing findByFirstnameContaining … where x.firstname like ?1(parameter bound wrapped in %) OrderBy findByAgeOrderByLastnameDesc … where x.age = ?1 order by x.lastname desc Not findByLastnameNot … where x.lastname &lt;&gt; ?1 In findByAgeIn(Collection ages) … where x.age in ?1 NotIn findByAgeNotIn(Collection ages) … where x.age not in ?1 True findByActiveTrue() … where x.active = true False findByActiveFalse() … where x.active = false IgnoreCase findByFirstnameIgnoreCase … where UPPER(x.firstame) = UPPER(?1) ①接口配置1234567891011121314151617181920212223242526272829303132/** * 这里要实现 JpaRepository 接口 * JpaRepository已经帮我们实现了很多操作直接使用即可 * 第一个参数为 操作的实体的类型 * 第二个参数为 主键的类型 */public interface BookDao extends JpaRepository&lt;Book,Integer&gt; { /** * 根据id查找 * @param id * @return */ Book findBookById(Integer id); /** * 查询比id小的 * @param integer * @return */ List&lt;Book&gt; findBookByIdLessThan(Integer integer); /** * 查询比id大的或者包含此名称的 * @param id * @param name * @return */ List&lt;Book&gt; findBookByIdGreaterThanOrNameContaining(Integer id, String name);} ②测试123456789 @Testvoid customeFind(){ Book bookById = bookDao.findBookById(4); System.out.println(bookById); List&lt;Book&gt; bookByIdLessThan = bookDao.findBookByIdLessThan(3); System.out.println(bookByIdLessThan); List&lt;Book&gt; finc = bookDao.findBookByIdGreaterThanOrNameContaining(6, \"马\"); System.out.println(finc);} 3、jpa自定义sql查询@Query标记为自定义的sql查询，nativeQuery=true，使用原生的sql操作 @Modifying标记为更新删除或新增的方法 @Transactional当方法为更新删除或者新增的时候，需要在自定义的方法上加上事务，或者在方法所在的dao或者service上加上事务@Transactional 两种传参形式：① 冒号形式 12Query(value = \"insert into t_book(name,author) values(:name,:author)\",nativeQuery = true)Integer addBook(@Param(\"name\")String name,@Param(\"author\")String author); ② ?形式 1234@Modifying@Transactional @Query(value = \"insert into t_book(name,author) values(?1,?2)\",nativeQuery = true) Integer addBook1(String name,String author); 12345678910111213141516171819202122/** * 这里要实现 JpaRepository 接口 * JpaRepository已经帮我们实现了很多操作直接使用即可 * 第一个参数为 操作的实体的类型 * 第二个参数为 主键的类型 */public interface BookDao extends JpaRepository&lt;Book,Integer&gt; { @Query(value = \"select * from t_book where id=(select max(id) from t_book)\",nativeQuery = true) Book getMaxIdBook(); @Modifying @Transactional @Query(value = \"insert into t_book(name,author) values(:name,:author)\",nativeQuery = true) Integer addBook(@Param(\"name\")String name,@Param(\"author\")String author); @Modifying @Transactional @Query(value = \"insert into t_book(name,author) values(?1,?2)\",nativeQuery = true) Integer addBook1(String name,String author);} 4、多数据源配置①pom.xml配置一致②yaml配置12345678910111213141516171819202122232425262728293031spring: datasourceone: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=UTF-8 username: root password: 123456 datasourcetwo: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://47.96.141.44:3306/test?useUnicode=true&amp;characterEncoding=UTF-8 username: root password: 你的密码 jpa: # 显示sql语句 show-sql: true # 数据库 database: mysql # 数据库平台 database-platform: mysql # 设置表的结构的生成类型 hibernate: # 每次启动更新表结构 ddl-auto: create properties: hibernate:# 搜索mysql57即可 找到类路径 # 设置方言 mysql57 dialect: org.hibernate.dialect.MySQL57Dialect ③实体bean1234567891011121314151617181920212223242526272829303132/** * 指定表的名称 若不存在 则自动为你创建此表 */@Entity(name = \"t_book\")@Getter@Setter@ToStringpublic class Book { /** *在jpa中一个表必须设置主键，否则创建会失败 * @Id标注的属性为主键 * @GeneratedValue指定生成策略为自增长 * @column中可设置字段的约束操作（长度为10） */ @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(length = 10) private Integer id; /** * 设置自动不能为空，长度为50,设置数据库中和属性的对应名称 */ @Column(nullable = false,length = 50,name = \"name\") private String name; /** * 设置自动不能为空，长度为20,设置数据库中和属性的对应名称 */ @Column(nullable = false,length = 20,name = \"author\") private String author;} ④数据源注入1234567891011121314151617@Configurationpublic class DataSourceConfig { @Primary @Bean @ConfigurationProperties(\"spring.datasourceone\") DataSource dataSourceOne(){ return DruidDataSourceBuilder.create().build(); } @Bean @ConfigurationProperties(\"spring.datasourcetwo\") DataSource dataSourceTwo() { return DruidDataSourceBuilder.create().build(); }} ⑤事务及LocalContainerEntityManagerFactoryBean配置1234567891011121314151617181920212223242526272829303132333435363738394041/** * basePackages 扫描所在接口的包 * entityManagerFactoryRef 引用配置的localContainerEntityManagerFactoryBeanOne * transactionManagerRef 引用配置的 事务platformTransactionManagerOne */@EnableJpaRepositories(basePackages = \"org.lc.jpa.dao.dao1\",entityManagerFactoryRef = \"localContainerEntityManagerFactoryBeanOne\",transactionManagerRef = \"platformTransactionManagerOne\")@Configurationpublic class JpaConfigOne { @Autowired @Qualifier(\"dataSourceOne\") DataSource dataSourceOne; //注入yaml中的其他属性配置 @Autowired JpaProperties jpaProperties; @Bean LocalContainerEntityManagerFactoryBean localContainerEntityManagerFactoryBeanOne(EntityManagerFactoryBuilder builder) { //注入数据源 return builder.dataSource(dataSourceOne)// 配置操作的实体bean .packages(\"org.lc.jpa.bean\")// 注入配置属性文件 .properties(jpaProperties.getProperties())// 初始化单元 不同即可 .persistenceUnit(\"pu1\") .build(); } /** * 事务的配置 * @param builder * @return */ @Bean PlatformTransactionManager platformTransactionManagerOne(EntityManagerFactoryBuilder builder) { return new JpaTransactionManager(localContainerEntityManagerFactoryBeanOne(builder).getObject()); }} 123456789101112131415161718192021222324252627282930313233343536373839404142/** * basePackages 扫描所在接口的包 * entityManagerFactoryRef 引用配置的localContainerEntityManagerFactoryBeanOne * transactionManagerRef 引用配置的 事务platformTransactionManagerOne */@EnableJpaRepositories(basePackages = \"org.lc.jpa.dao.dao2\",entityManagerFactoryRef = \"localContainerEntityManagerFactoryBeanTwo\",transactionManagerRef = \"platformTransactionManagerTwo\")@Configurationpublic class JpaConfigTwo { @Autowired @Qualifier(\"dataSourceTwo\") DataSource dataSourceTwo; //注入yaml中的其他属性配置 @Autowired JpaProperties jpaProperties; @Primary @Bean LocalContainerEntityManagerFactoryBean localContainerEntityManagerFactoryBeanTwo(EntityManagerFactoryBuilder builder) { //注入数据源 return builder.dataSource(dataSourceTwo)// 配置操作的实体bean .packages(\"org.lc.jpa.bean\")// 注入配置属性文件 .properties(jpaProperties.getProperties())// 初始化单元 不同即可 .persistenceUnit(\"pu1\") .build(); } /** * 事务的配置 * @param builder * @return */ @Primary @Bean PlatformTransactionManager platformTransactionManagerTwo(EntityManagerFactoryBuilder builder) { return new JpaTransactionManager(localContainerEntityManagerFactoryBeanTwo(builder).getObject()); }} ⑥两个不同包及名称的接口123public interface BookDaoOne extends JpaRepository&lt;Book,Integer&gt; { } 123public interface BookDaoTwo extends JpaRepository&lt;Book,Integer&gt; { } ⑦测试注入不同的dao进行测试 123456789101112@Autowiredprivate BookDaoOne bookDaoOne; @Autowiredprivate BookDaoTwo bookDaoTwo;@Testvoid multipleFind() { List&lt;Book&gt; all = bookDaoOne.findAll(); System.out.println(all); List&lt;Book&gt; all1 = bookDaoTwo.findAll(); System.out.println(all1);}","link":"/2020/07/24/multipledatasource/%E6%95%B4%E5%90%88Jpa%E5%8F%8A%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90/"},{"title":"SpringCache 整合redis缓存","text":"Spring Cache 整合redis缓存一、概述SpringCache本身是一个缓存体系的抽象实现，并没有具体的缓存能力，要使用SpringCache还需要配合具体的缓存实现来完成。 虽然如此，但是SpringCache是所有Spring支持的缓存结构的基础，而且所有的缓存的使用最后都要归结于SpringCache，那么一来，要想使用SpringCache，还是要仔细研究一下的。 SpringCache只是定义的一种规范，所有的实现均有redis实现，即我们需要使用其他的缓存只需要替换引用操作的缓存件即可。 二、缓存注解SpringCache缓存功能的实现是依靠下面的这几个注解完成的。 @EnableCaching：开启缓存功能 @Cacheable：定义缓存，用于触发缓存 @CachePut：定义更新缓存，触发缓存更新 @CacheEvict：定义清除缓存，触发缓存清除 @Caching：组合定义多种缓存功能 @CacheConfig：定义公共设置，位于class之上 2.1 @EnableCaching12345678910111213141516171819202122232425@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Import(CachingConfigurationSelector.class)public @interface EnableCaching { // 用于设置使用哪种代理方式，默认为基于接口的JDK动态代理（false）， // 设置为true，则使用基于继承的CGLIB动态代理 boolean proxyTargetClass() default false; // 用于设置切面织入方式(设置面向切面编程的实现方式)， // 默认为使用动态代理的方式织入，当然也可以设置为ASPECTJ的方式来实现AOP AdviceMode mode() default AdviceMode.PROXY; // 用于设置在一个切点存在多个通知的时候各个通知的执行顺序，默认为最低优先级， // 其中数字却大优先级越低，这里默认为最低优先级，int LOWEST_PRECEDENCE = // Integer.MAX_VALUE;，却是整数的最大值 int order() default Ordered.LOWEST_PRECEDENCE;}public enum AdviceMode { PROXY, ASPECTJ}public interface Ordered { int HIGHEST_PRECEDENCE = Integer.MIN_VALUE; int LOWEST_PRECEDENCE = Integer.MAX_VALUE; int getOrder();} 2.2 @Cacheable​ 该注解用于标注于方法之上用于标识该方法的返回结果需要被缓存起来，标注于类之上标识该类中所有方法均需要将结果缓存起来。 ​ 该注解标注的方法每次被调用前都会触发缓存校验，校验指定参数的缓存是否已存在（已发生过相同参数的调用），若存在，直接返回缓存结果，否则执行方法内容，最后将方法执行结果保存到缓存中。 12345678910111213141516171819202122232425262728293031323334353637383940@Target({ElementType.METHOD, ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface Cacheable { // 用于指定缓存名称，与cacheNames()方法效果一致 @AliasFor(\"cacheNames\") String[] value() default {}; // 用于指定缓存名称，与value()方法效果一致 @AliasFor(\"value\") String[] cacheNames() default {}; // 用于使用SPEL手动指定缓存键的组合方式，默认情况使用所有的参数来组合成键，除非自定义了keyGenerator。 // 使用SPEL表达式可以根据上下文环境来获取到指定的数据： // #root.method：用于获取当前方法的Method实例 // #root.target：用于获取当前方法的target实例 // #root.caches：用于获取当前方法关联的缓存 // #root.methodName：用于获取当前方法的名称 // #root.targetClass：用于获取目标类类型 // #root.args[1]：获取当前方法的第二个参数，等同于：#p1和#a1和#argumentName String key() default \"\"; // 自定义键生成器，定义了该方法之后，上面的key方法自动失效，这个键生成器是： // org.springframework.cache.interceptor.KeyGenerator，这是一个函数式接口， // 只有一个generate方法，我们可以通过自定义的逻辑来实现自定义的key生成策略。 String keyGenerator() default \"\"; // 用于设置自定义的cacheManager(缓存管理器),可以自动生成一个cacheResolver // （缓存解析器），这一下面的cacheResolver()方法设置互斥 String cacheManager() default \"\"; // 用于设置一个自定义的缓存解析器 String cacheResolver() default \"\"; // 用于设置执行缓存的条件，如果条件不满足，方法返回的结果就不会被缓存，默认无条件全部缓存。 // 同样使用SPEL来定义条件，可以使用的获取方式同key方法。 String condition() default \"\"; // 这个用于禁止缓存功能，如果设置的条件满足，就不执行缓存结果，与上面的condition不同之处在于， // 该方法执行在当前方法调用结束，结果出来之后，因此，它除了可以使用上面condition所能使用的SPEL // 表达式之外，还可以使用#result来获取方法的执行结果，亦即可以根据结果的不同来决定是否缓存。 String unless() default \"\"; // 设置是否对多个针对同一key执行缓存加载的操作的线程进行同步，默认不同步。这个功能需要明确确定所 // 使用的缓存工具支持该功能，否则不要滥用。 boolean sync() default false;} 2.3 @CachePut该注解用于更新缓存，无论结果是否已经缓存，都会在方法执行结束插入缓存，相当于更新缓存。一般用于更新方法之上。 123456789101112131415161718192021222324@Target({ElementType.METHOD, ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface CachePut { // 同上 @AliasFor(\"cacheNames\") String[] value() default {}; // 同上 @AliasFor(\"value\") String[] cacheNames() default {}; // 同上 String key() default \"\"; // 同上 String keyGenerator() default \"\"; // 同上 String cacheManager() default \"\"; // 同上 String cacheResolver() default \"\"; // 同上 String condition() default \"\"; // 同上 String unless() default \"\";} 2.4 @CacheEvict该注解主要用于删除缓存操作 1234567891011121314151617181920212223242526@Target({ElementType.METHOD, ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface CacheEvict { // 同上 @AliasFor(\"cacheNames\") String[] value() default {}; // 同上 @AliasFor(\"value\") String[] cacheNames() default {}; // 同上 String key() default \"\"; // 同上 String keyGenerator() default \"\"; // 同上 String cacheManager() default \"\"; // 同上 String cacheResolver() default \"\"; // 同上 String condition() default \"\"; // 这个设置用于指定当前缓存名称名下的所有缓存是否全部删除，默认false。 boolean allEntries() default false; // 这个用于指定删除缓存的操作是否在方法调用之前完成，默认为false，表示先调用方法，在执行缓存删除。 boolean beforeInvocation() default false;} 2.5 @Caching这个注解用于组个多个缓存操作，包括针对不用缓存名称的相同操作等，源码： 123456789101112@Target({ElementType.METHOD, ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface Caching { // 用于指定多个缓存设置操作 Cacheable[] cacheable() default {}; // 用于指定多个缓存更新操作 CachePut[] put() default {}; // 用于指定多个缓存失效操作 CacheEvict[] evict() default {};} 用法==&gt; 123456789101112131415161718192021222324@Service@Log4j2public class AnimalService { @Autowired private AnimalRepository animalRepository; //... @Caching( evict = { @CacheEvict(value = \"animalById\", key = \"#id\"), @CacheEvict(value = \"animals\", allEntries = true, beforeInvocation = true) } ) public ResponseEntity&lt;Integer&gt; deleteAnimalById(final int id){ return ResponseEntity.ok(animalRepository.deleteById(id)); } @Cacheable(\"animals\") public ResponseEntity&lt;Page&lt;Animal&gt;&gt; getAnimalPage(final Animal animal, final int pageId, final int pageSize){ Page&lt;Animal&gt; page = new Page&lt;&gt;(); page.setCurrent(pageId); page.setSize(pageSize); return ResponseEntity.ok((Page&lt;Animal&gt;) animalRepository.selectPage(page,packWrapper(animal, WrapperType.QUERY))); } //...} 2.6 @CacheConfig该注解标注于类之上，用于进行一些公共的缓存相关配置。源码为： 12345678910111213@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface CacheConfig { // 设置统一的缓存名，适用于整个类中的方法全部是针对同一缓存名操作的情况 String[] cacheNames() default {}; // 设置统一个键生成器，免去了每个缓存设置中单独设置 String keyGenerator() default \"\"; // 设置统一个自定义缓存管理器 String cacheManager() default \"\"; // 设置统一个自定义缓存解析器 String cacheResolver() default \"\";} 三、基本配置1、pom.xmlspring-boot-starter-security spring-boot-starter-cache spring-boot-starter-data-redis 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;jpa-rest&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;jpa-rest&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、yaml配置1234567891011spring:# redis配置 redis: host: 47.96.141.44 database: 0 password: 你的密码 port: 6379# 配置缓存名称 cache: cache-names: c1 3、实体Bean12345678@Getter@Setter@ToStringpublic class User implements Serializable { private Integer id; private String username; private String address;} 4、开启缓存12345678910@SpringBootApplication//启用缓存@EnableCachingpublic class JpaRestApplication { public static void main(String[] args) { SpringApplication.run(JpaRestApplication.class, args); }} 5、service层①缓存存储： key：指定一个或多个参数作为key12345678910111213141516171819@Servicepublic class UserService {/** * 方法的参数为key * 方法返回的结果为value * * cacheNames配置的缓存名称 * key 只指定某一个参数作为key,或者联合多个参数作为key * @param id * @return */ @Cacheable(cacheNames = \"c1\",key = \"#id+'-'+#name\") public User getUserById(Integer id,String name) { System.out.println(\"getUserId===&gt;&gt;&gt;&gt;\" + id); User u=new User(); u.setId(id); return u; }} 当参数即key相同时，直接从redis中取 测试==&gt; 1234567891011121314@SpringBootTestclass JpaRestApplicationTests { @Autowired private UserService userService; @Test void contextLoads() { User userById = userService.getUserById(1,\"bb\"); User userById1 = userService.getUserById(1,\"bb\"); System.out.println(userById); System.out.println(userById1); }} ②自定义key1234567891011121314@Componentpublic class RedisKeyGenerator implements KeyGenerator { /** * 自定义返回的key 当前定义的key形式为 \" 方法名:所有参数组成的字符串数组 \" * @param o * @param method 当前方法名 * @param objects 方法的参数 * @return */ @Override public Object generate(Object o, Method method, Object... objects) { return method.getName()+\":\"+ Arrays.toString(objects); }} 12345678910111213141516@Servicepublic class UserService { /** * keyGenerator 自定义生成的key 当前引用的配置类为开头字母小写的类名 * @param id * @param name * @return */ @Cacheable(cacheNames = \"c1\",keyGenerator = \"redisKeyGenerator\") public User getUserById1(Integer id,String name,String author) { System.out.println(\"getUserId===&gt;&gt;&gt;&gt;\" + id); User u=new User(); u.setId(id); return u; }} 测试==&gt; 1234567@Testvoid contextLoads1() { User userById = userService.getUserById1(1,\"bb\",\"张三\"); User userById1 = userService.getUserById1(1,\"bb\",\"张三\"); System.out.println(userById); System.out.println(userById1);} ③删除缓存1234567891011121314151617181920@Servicepublic class UserService { @Cacheable(cacheNames = \"c1\") public User getUserById2(Integer id) { System.out.println(\"getUserId===&gt;&gt;&gt;&gt;\" + id); User u=new User(); u.setId(id); return u; } /** * 删除缓存中的内容 * 默认根据方法的参数作为key进行删除 * @param id */ @CacheEvict(cacheNames = \"c1\") public void deleteUserById(Integer id) { System.out.println(\"deleteUserById==&gt;&gt;&gt;&gt;\"+id); }} 测试==&gt; 12345678@Test void contextLoads2() { User userById = userService.getUserById2(1); userService.deleteUserById(1); User userById1 = userService.getUserById2(1); System.out.println(userById); System.out.println(userById1); } ④更新缓存123456789101112@Servicepublic class UserService { /** * 更新缓存中的内容 key: 指定user对象中的id作为键 * @param user * @return */ @CachePut(cacheNames = \"c1\",key = \"#user.id\") public User updateUserById(User user){ return user; }} 测试==&gt; 123456789101112@Test void contextLoads3() { User userById = userService.getUserById2(2); User user = new User(); user.setId(1); user.setUsername(\"张三\"); user.setAddress(\"湖北武汉\"); userService.updateUserById(user); User userById1 = userService.getUserById2(2); System.out.println(userById); System.out.println(userById1); } ⑤定义全局缓存名称@CacheConfig(cacheNames = &quot;c1&quot;) 无需在每个方法上加cacheName 123456789101112131415161718192021@Service@CacheConfig(cacheNames = \"c1\")public class UserService { /** * 方法的参数为key * 方法返回的结果为value * * cacheNames配置的缓存名称 * key 只指定某一个参数作为key,或者联合多个参数作为key * @param id * @return */ @Cacheable(key = \"#id+'-'+#name\") public User getUserById(Integer id,String name) { System.out.println(\"getUserId===&gt;&gt;&gt;&gt;\" + id); User u=new User(); u.setId(id); return u; }}","link":"/2020/07/24/springcache/Spring%20Cache%E6%95%B4%E5%90%88redis/"},{"title":"FastDFS构建分布式文件管理系统","text":"FastDFS构建分布式文件管理系统​ 说起分布式文件管理系统，大家可能很容易想到 HDFS、GFS 等系统，前者是 Hadoop 的一部分，后者则是 Google 提供的分布式文件管理系统。除了这些之外，国内淘宝和腾讯也有自己的分布式文件管理系统，都叫 TFS（Taobao File System 和 Tencent File System）。 ​ 相对于上面提到的这些分布式文件管理系统而言，FastDFS 可能离我们 Java 工程师更近一些，因为文件上传这个功能太常见了，而想要搭建独立的分布式文件管理系统，FastDFS+Nginx 组合无疑是最佳方案。 一、FastDFS简介 fastDFS 是以C语言开发的一项开源轻量级分布式文件系统，他对文件进行管理，主要功能有：文件存储，文件同步，文件访问（文件上传/下载）,特别适合以文件为载体的在线服务，如图片网站，视频网站等 分布式文件系统：基于客户端/服务器的文件存储系统 对等特性允许一些系统扮演客户端和服务器的双重角色，可供多个用户访问的服务器，比如，用户可以“发表”一个允许其他客户机访问的目录，一旦被访问，这个目录对客户机来说就像使用本地驱动器一样 FastDFS 由淘宝的余庆大佬在 2008 年开源的一款轻量级分布式文件管理系统，FastDFS 用 C 语言实现，支持 Linux、FreeBSD、MacOS 等类 UNIX 系统。FastDFS 类似 google FS，属于应用级文件系统，不是通用的文件系统，只能通过专有 API 访问，目前提供了 C 和 Java SDK ，以及 PHP 扩展 SDK。 这款开源软件从发布至今，历经数十年，这款开源软件的生命力依然旺盛，在业界依然备受推崇，当然这也得益于作者一直在不断完善该软件。 FastDFS 专为互联网应用量身定做，解决大容量文件存储问题，追求高性能和高扩展性，它可以看做是基于文件的 key/value 存储系统，key 为文件 ID，value 为文件内容，因此称作分布式文件存储服务更为合适。 1.1为什么需要FastDFS？传统的企业级开发对于高并发要求不是很高，而且数据量可能也不大，在这样的环境下文件管理可能非常 Easy。 但是互联网应用访问量大、数据量大，在互联网应用中，我们必须考虑解决文件大容量存储和高性能访问的问题，而 FastDFS 就特别适合干这件事情，常见的图片存储、视频存储、文档存储等等我们都可以采用 FastDFS 来做。 1.2FastDFS 架构作为一款分布式文件管理系统，FastDFS 主要包括四个方面的功能： 文件存储 文件同步 文件上传 文件下载 这个方面的功能，基本上就能搞定我们常见的文件管理需求了。 下面这是一张来自 FastDFS 官网的系统架构图： 从上面这张图中我们可以看到，FastDFS 架构包括 Tracker 和 Storage 两部分，看名字大概就能知道，Tracker 用来追踪文件，相当于是文件的一个索引，而 Storage 则用来保存文件。 我们上传文件的文件最终保存在 Storage 上，文件的元数据信息保存在 Tracker 上，通过 Tracker 可以实现对 Storage 的负载均衡。 Storage 一般会搭建成集群，一个 Storage Cluster 可以由多个组构成，不同的组之间不进行通信，一个组又相当于一个小的集群，组由多个 Storage Server 组成，组内的 Storage Server 会通过连接进行文件同步来保证高可用。 二、安装FastDFS介绍完 FastDFS 之后，相信小伙伴已经摩拳擦掌跃跃欲试了，接下来我们就来看下 FastDFS 的安装。 我这里为了测试方便，就不开启多台虚拟机了，Tracker 和 Storage 我将安装在同一台服务器上。 图片上传我们一般使用 FastDFS，图片上传成功之后，接下来的图片访问我们一般采用 Nginx，所以这里的安装将从三个方面来介绍： Tracker(追踪器) 安装 Storage(存储) 安装 Nginx 安装 2.1 Tracker 安装安装，我们首先需要准备一个环境,两个库以及一个安装包。 2.1.1一个环境先来看一个环境，由于 FastDFS 采用 C 语言开发，所以在安装之前，如果没有 gcc 环境，需要先安装，安装命令如下： 1yum install gcc-c++ 2.1.2两个库再来看两个库，由于 FastDFS 依赖 libevent 库，安装命令如下： 1yum -y install libevent 另一个库是 libfastcommon，这是 FastDFS 官方提供的，它包含了 FastDFS 运行所需要的一些基础库。 libfastcommon 下载地址：https://github.com/happyfish100/libfastcommon/archive/V1.0.43.tar.gz 1wget https://github.com/happyfish100/libfastcommon/archive/V1.0.43.tar.gz 将下载好的 libfastcommon 拷贝至 /usr/local/ 目录下， 1mv V1.0.43.tar.gz /usr/local/ 然后依次执行如下命令： 12345cd /usr/localtar -zxvf V1.0.43.tar.gzcd libfastcommon-1.0.43/./make.sh./make.sh install 2.1.3一个安装包接下来我们下载 Tracker，注意，由于 Tracker 和 Storage 是相同的安装包，所以下载一次即可（2.2 小节中不用再次下载）。 安装文件可以从 FastDFS 的 GitHub 仓库上下载，下载地址：https://github.com/happyfish100/fastdfs/archive/V6.06.tar.gz 1wget https://github.com/happyfish100/fastdfs/archive/V6.06.tar.gz 下载成功后，将下载文件拷贝到 /usr/local 目录下， 1mv V6.06.tar.gz /usr/local 然后依次执行如下命令安装： 12345cd /usr/localtar -zxvf V6.06.tar.gzcd fastdfs-6.06/./make.sh./make.sh install 安装成功后，执行如下命令，将安装目录内 conf 目录下的配置文件拷贝到 /etc/fdfs 目录下： 12cd conf/cp ./* /etc/fdfs/ 2.1.4配置接下来进入 /etc/fdfs/ 目录下进行配置： 打开 tracker.conf 文件： 1vi tracker.conf 修改如下配置： 默认端口是 22122，可以根据实际需求修改，我这里就不改了。然后下面配置一下元数据的保存目录（注意目录要存在）。 设置存储是否需要限额的百分比： 若硬盘的剩余空间不足20%,则会储存失败！ 若不存在home和sang文件夹，则需要创建 12mkdir homemkdir sang 2.1.5启动接下来执行如下命令启动 Tracker： 1/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf start 2.2 Storage 安装简单起见，这里我们搭建一个 Storage 实例即可。Storage 安装也需要 libevent 和 libfastcommon，这两个库的安装参考上文，这里无需再次安装。 Storage 本身的安装，也和 Tracker 一致，执行命令也都一样，因为我这里将 Tracker 和 Storage 安装在同一台服务器上，所以不用再执行安装命令了（相当于安装 Tracker 时已经安装了 Storage 了）。 唯一要做的，就是进入到 /etc/fdfs 目录下，配置 Storage： 1vi storage.conf ![](images\\批注 2020-04-10 152254.png) 这里一共配置三个地方，分别是 base_path、store_path0 以及 tracker_server ，tracker_server 模板有两个地址，我们这里只有一个，配置完成后，记得注释掉另外一个不用的。 配置完成后，执行如下命令启动 Storage： 1/usr/bin/fdfs_storaged /etc/fdfs/storage.conf start 这两个启动完成后，现在就可以做文件的上传了 注意：这里我们的服务器需要暴露 22122(tracker) 和 23000(storage) 端口 2.3 实现文件上传这里我们使用Springboot来整合 1、pom.xmlfastdfs-client-java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;fastdfs&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;fastdfs&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--fastdfs 客户端--&gt; &lt;dependency&gt; &lt;groupId&gt;net.oschina.zcx7878&lt;/groupId&gt; &lt;artifactId&gt;fastdfs-client-java&lt;/artifactId&gt; &lt;version&gt;1.27.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、fastdfs客户端配置修改tracker公网地址即可 12345678910111213141516171819202122232425## fastdfs-client.propertiesfastdfs.connect_timeout_in_seconds = 5fastdfs.network_timeout_in_seconds = 30fastdfs.charset = UTF-8fastdfs.http_anti_steal_token = falsefastdfs.http_secret_key = FastDFS1234567890fastdfs.http_tracker_http_port = 80#修改tracker公网地址fastdfs.tracker_servers = 47.96.141.44:22122## Whether to open the connection pool, if not, create a new connection every timefastdfs.connection_pool.enabled = true## max_count_per_entry: max connection count per host:port , 0 is not limitfastdfs.connection_pool.max_count_per_entry = 500## connections whose the idle time exceeds this time will be closed, unit: second, default value is 3600fastdfs.connection_pool.max_idle_time = 3600## Maximum waiting time when the maximum number of connections is reached, unit: millisecond, default value is 1000fastdfs.connection_pool.max_wait_time_in_ms = 1000 3、测试123456789101112131415161718@SpringBootTestclass FastdfsApplicationTests { @Test void contextLoads() throws IOException, MyException {// 加载配置文件 ClientGlobal.initByProperties(\"fastdfs-client.properties\"); TrackerClient trackerClient = new TrackerClient(); TrackerServer trackerServer= trackerClient.getConnection(); StorageServer storageServer= null; StorageClient1 storageClient1 = new StorageClient1(trackerServer, storageServer); NameValuePair pairs[]=null; String[] fileId= storageClient1.upload_file(\"F:\\\\桌面内容\\\\i\\\\1.jpg\", \"jpg\", pairs); System.out.println(Arrays.toString(fileId)); }} ==&gt;输出 1[group1, M00/00/00/L2CNLF6QAt6AejqEAADgTCtaXcs207.jpg] 这里，首先加载配置文件，然后构造一个 TrackerClient 对象，接着再根据这个对象获取到一个 TrackerServer，然后创建一个 StorageClient1 实例。NameValuePair 中保存的是文件的元数据信息，如果有的话，就以 key/value 的方式来设置，如果没有的话，直接给一个 null 即可。 最后，调用 client 的 upload_file1 方法上传文件，第一个参数是文件路径，第二个参数是文件的扩展名，第三个参数就是文件的元数据信息. group1 表示我们的一个个storage组 M00，M01, M02, 表示我们的storage中的每一台storage服务器 00/00/L2CNLF6QAt6AejqEAADgTCtaXcs207.jpg 才是真真正的路径地址 查看文件的存储位置 1cd /home/sang/fastdfs/data 1cd 00/00/ ![](F:\\桌面内容\\springboot2\\vhr项目\\images\\批注 2020-04-10 154344.png) 即可查看到文件的存储位置 2.4 Nginx的安装实现文件访问Nginx 可以算是 FastDFS 的重要搭档。 Nginx 的安装分为两个步骤： 安装 Nginx 首先在 Storage 下安装 fastdfs-nginx-module 首先下载 fastdfs-nginx-module，下载地址：https://github.com/happyfish100/fastdfs-nginx-module/archive/V1.22.tar.gz 1wget https://github.com/happyfish100/fastdfs-nginx-module/archive/V1.22.tar.gz 下载完成后，将下载的文件拷贝到 /usr/local 目录下。 1mv V1.22.tar.gz /usr/local 然后进入 /usr/local 目录，分别执行如下命令： 12cd /usr/localtar -zxvf V1.22.tar.gz 然后将 /usr/local/fastdfs-nginx-module-1.22/src/mod_fastdfs.conf 文件拷贝到 /etc/fdfs/ 目录下 1cp /usr/local/fastdfs-nginx-module-1.22/src/mod_fastdfs.conf /etc/fdfs/ 并修改该文件的内容： 1vi /etc/fdfs/mod_fastdfs.conf ![](images\\批注 2020-04-10 155554.png) 接下来，回到第一步下载的 nginx 安装文件的解压目录中，执行如下命令，重新配置编译安装： 在/root/nginx-1.8.1/下 123./configure --add-module=/usr/local/fastdfs-nginx-module-1.22/srcmakemake install 安装完成后，修改 nginx 的配置文件，如下： 1vi /usr/local/nginx/conf/nginx.conf ![](images\\批注 2020-04-10 155945.png) 在这里配置 nginx 请求转发。 配置完成后，启动 nginx，看到如下日志，表示 nginx 启动成功： ngx_http_fastdfs_set pid=9908 疑问：fastdfs-nginx-module 有啥用 看了整个安装过程之后，到头来还是 nginx 本身直接找到了图片文件目录，fastdfs-nginx-module 到底有啥用？ 前面我们说过，Storage 由很多组构成，每个组又是一个小的集群，在每一个组里边，数据会进行同步，但是如果数据还没同步，这个时候就有请求发来了，该怎么办？此时fastdfs-nginx-module 会帮助我们直接从源 Storage 上获取文件。 安装成功了。 文件访问测试：1http://47.96.141.44/group1/M00/00/00/L2CNLF6QAt6AejqEAADgTCtaXcs207.jpg 实现文件下载 其他配置和文件上传一致 1234567891011121314 @Test public void downloadTest() throws IOException, MyException { // 加载配置文件 ClientGlobal.initByProperties(\"fastdfs-client.properties\"); TrackerClient trackerClient = new TrackerClient(); TrackerServer trackerServer= trackerClient.getConnection(); StorageServer storageServer= null; StorageClient1 storageClient1 = new StorageClient1(trackerServer, storageServer); byte[] bytes = storageClient1.download_file1(\"group1/M00/00/00/L2CNLF6QAt6AejqEAADgTCtaXcs207.jpg\");// 写入新的路径 FileOutputStream outputStream=new FileOutputStream(new File(\"F:\\\\桌面内容\\\\i\\\\2.jpg\")); outputStream.write(bytes); outputStream.close(); } 2.5添加访问令牌，防止盗链现在，任何人都可以访问我们服务器上传文件，这肯定是不行的，这个问题好解决，加一个上传时候的令牌即可。 首先我们在服务端开启令牌校验： 1vi /etc/fdfs/http.conf ![](images\\批注 2020-04-10 164343.png) 配置完成后，记得重启nginx服务端： 123cd /usr/local/nginx/sbin./nginx -s stop./nginx 配置token有效期修改vi /etc/fdfs/http.conf 默认为10分钟 1234# token TTL (time to live), seconds# default value is 600#设置为1800s 即30分钟http.anti_steal.token_ttl = 1800 获取令牌访问12345678910111213141516@Test public void tokenTest() throws UnsupportedEncodingException, NoSuchAlgorithmException, MyException {// 获取时间戳 int ts = (int)Instant.now().getEpochSecond();// 获取token// 注意第一个参数不需要加group1; 时间戳; 令牌 String token = ProtoCommon.getToken(\"M00/00/00/L2CNLF6QLYqAPtyOAADgTCtaXcs276.jpg\", ts, \"FastDFS421192425\"); StringBuffer sb= new StringBuffer(); sb.append(\"http://47.96.141.44\") .append(\"/group1/M00/00/00/L2CNLF6QLYqAPtyOAADgTCtaXcs276.jpg\") .append(\"?token=\") .append(token) .append(\"&amp;ts=\") .append(ts); System.out.println(sb.toString()); } 得到如下地址 http://47.96.141.44/group1/M00/00/00/L2CNLF6QLYqAPtyOAADgTCtaXcs276.jpg?token=18247d981993d006085a519c4fcb668e&amp;ts=1586507960 这里，我们主要是根据 ProtoCommon.getToken 方法来获取令牌，注意这个方法的第一个参数是你要访问的文件 id，注意，这个地址里边不包含 group，千万别搞错了；第二个参数是时间戳，第三个参数是密钥，密钥要和服务端的配置一致。 将生成的字符串拼接，追加到访问路径后面，如：http://192.168.91.128/group1/M00/00/00/wKhbgF5aMteAWy0gAAJkI7-2yGk361.png?token=7e329cc50307000283a3ad3592bb6d32&amp;ts=1582975854。此时访问路径里边如果没有令牌，会访问失败。","link":"/2020/07/24/springboot/FastDFS%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"title":"SSM整合示例","text":"1、pom.xml配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;ssm01&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;ssm01 Maven Webapp&lt;/name&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;!-- spring版本号管理 --&gt; &lt;spring.version&gt;5.2.7.RELEASE&lt;/spring.version&gt; &lt;/properties&gt;&lt;!--more--&gt; &lt;dependencies&gt; &lt;!--【IOC核心】--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!--【JDBC核心】--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;5.2.4.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.2.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--【SpringMVC核心】--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!--文件上传下载--&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;/dependency&gt; &lt;!--数据校检--&gt; &lt;dependency&gt; &lt;groupId&gt;org.hibernate.validator&lt;/groupId&gt; &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt; &lt;version&gt;6.1.5.Final&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.validation&lt;/groupId&gt; &lt;artifactId&gt;validation-api&lt;/artifactId&gt; &lt;version&gt;2.0.1.Final&lt;/version&gt; &lt;/dependency&gt; &lt;!--jackson依赖 @jsonFormat @JsonIgnore使用 ObjectMapper与json转换 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.11.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.11.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.11.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--【AOP核心】--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!--加强版的面向切面编程(即使目标对象没有实现任何接口也能创建动态代理)--&gt; &lt;dependency&gt; &lt;groupId&gt;cglib&lt;/groupId&gt; &lt;artifactId&gt;cglib&lt;/artifactId&gt; &lt;version&gt;3.2.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;aopalliance&lt;/groupId&gt; &lt;artifactId&gt;aopalliance&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.5&lt;/version&gt; &lt;/dependency&gt; &lt;!--【测试核心】--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!--junit4测试--&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--测试可能会出现的问题--&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;/dependency&gt; &lt;!--【getter setter插件 日志核心】--&gt; &lt;!--getter setter插件 日志框架--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.18.12&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-slf4j-impl&lt;/artifactId&gt; &lt;version&gt;2.11.0&lt;/version&gt; &lt;/dependency&gt; &lt;!--【MyBatis核心】--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;2.0.4&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatis逆向工程--&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.5&lt;/version&gt; &lt;/dependency&gt; &lt;!--mybatis分页插件--&gt; &lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.1.8&lt;/version&gt; &lt;/dependency&gt; &lt;!--【数据库连接驱动】--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.47&lt;/version&gt; &lt;/dependency&gt; &lt;!--【数据库连接池】--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.18&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;resources&gt; &lt;!--忽略java下的xml文件--&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;!-- resources无需配置 自动帮我们过滤xml等其他文件。若配置则覆盖默认配置 --&gt; &lt;/resources&gt; &lt;/build&gt;&lt;/project&gt; 2、web.xml配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;!--&lt;welcome-file-list&gt;--&gt; &lt;!-- &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt;--&gt; &lt;!--&lt;/welcome-file-list&gt;--&gt; &lt;!--配置spring IOC容器启动--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!--指定spirng配置文件位置--&gt; &lt;param-value&gt;classpath:spring/spring.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!--springmvc前端控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring/spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--tomcat启动时创建--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;!--拦截所有 不拦截*.jsp的请求--&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--设置字符编码--&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceRequestEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceResponseEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;!--拦截所有--&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!--rest风格支持--&gt; &lt;!--使表单支持 delete 和 put请求--&gt; &lt;filter&gt; &lt;filter-name&gt;hiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;hiddenHttpMethodFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; 3、mybatis-config.xml配置1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;configuration&gt; &lt;settings&gt; &lt;!--是否开启驼峰命名自动映射，即从经典数据库列名 A_COLUMN 映射到经典 Java 属性名 aColumn。--&gt; &lt;!--数据库中的字段一般不需要大写,到大写的字母之前加下划线即可，开启后 视图bean直接以驼峰命名即可--&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"true\"/&gt; &lt;!--全局性地开启或关闭所有映射器配置文件中已配置的任何缓存。--&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt; &lt;/settings&gt; &lt;!--配置mybatis分页插件--&gt; &lt;plugins&gt; &lt;plugin interceptor=\"com.github.pagehelper.PageInterceptor\"&gt;&lt;/plugin&gt; &lt;/plugins&gt; &lt;/configuration&gt; 4、db.propertoes数据库连接文件1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/test?serverTimeZone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=falsejdbc.uername=rootjdbc.password=123456 5、log4j2.xml日志文件12345678910111213141516171819&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;configuration status=\"INFO\"&gt; &lt;appenders&gt; &lt;Console name=\"Console\" target=\"SYSTEM_OUT\"&gt; &lt;PatternLayout pattern=\"%d{HH:mm:ss.SSS} [%t] %-5level %logger{36} - %msg%n\"/&gt; &lt;/Console&gt; &lt;RollingFile name=\"RollingFile\" fileName=\"logs/app.log\" filePattern=\"logs/$${date:yyyy-MM}/app-%d{MM-dd-yyyy}-%i.log.gz\"&gt; &lt;PatternLayout pattern=\"%d{yyyy.MM.dd 'at' HH:mm:ss z} %-5level %class{36} %L %M - %msg%xEx%n\"/&gt; &lt;SizeBasedTriggeringPolicy size=\"5 MB\"/&gt; &lt;/RollingFile&gt; &lt;/appenders&gt; &lt;loggers&gt; &lt;root level=\"DEBUG\"&gt; &lt;appender-ref ref=\"Console\"/&gt; &lt;appender-ref ref=\"RollingFile\"/&gt; &lt;/root&gt; &lt;/loggers&gt;&lt;/configuration&gt; 6、spring.xml配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:mybatis-spring=\"http://mybatis.org/schema/mybatis-spring\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://mybatis.org/schema/mybatis-spring http://mybatis.org/schema/mybatis-spring.xsd\"&gt; &lt;!--配置spirng包扫描。除了被@Controllers标注的不扫描外，其他的注解都扫描--&gt; &lt;context:component-scan base-package=\"org.lc\"&gt; &lt;context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt; &lt;/context:component-scan&gt; &lt;!--引入数据库基本配置文件--&gt; &lt;context:property-placeholder location=\"classpath:dbconfig.properties\"/&gt; &lt;!--druid连接池配置参考地址 https://github.com/alibaba/druid/wiki/DruidDataSource%E9%85%8D%E7%BD%AE--&gt; &lt;bean id=\"druidDataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"${jdbc.driver}\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"${jdbc.url}\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"${jdbc.uername}\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"${jdbc.password}\"&gt;&lt;/property&gt; &lt;!-- 配置初始化大小、最小、最大 --&gt; &lt;property name=\"initialSize\" value=\"5\" /&gt; &lt;property name=\"minIdle\" value=\"5\" /&gt; &lt;property name=\"maxActive\" value=\"10\" /&gt; &lt;!-- 配置从连接池获取连接等待超时的时间 --&gt; &lt;property name=\"maxWait\" value=\"10000\" /&gt; &lt;!-- 配置间隔多久启动一次DestroyThread，对连接池内的连接才进行一次检测，单位是毫秒。 检测时:1.如果连接空闲并且超过minIdle以外的连接，如果空闲时间超过minEvictableIdleTimeMillis设置的值则直接物理关闭。2.在minIdle以内的不处理。 --&gt; &lt;property name=\"timeBetweenEvictionRunsMillis\" value=\"60000\" /&gt; &lt;!-- 配置一个连接在池中最大空闲时间，单位是毫秒 --&gt; &lt;property name=\"minEvictableIdleTimeMillis\" value=\"300000\" /&gt; &lt;!-- 设置从连接池获取连接时是否检查连接有效性，true时，如果连接空闲时间超过minEvictableIdleTimeMillis进行检查，否则不检查;false时，不检查 --&gt; &lt;property name=\"testWhileIdle\" value=\"true\" /&gt; &lt;!-- 设置从连接池获取连接时是否检查连接有效性，true时，每次都检查;false时，不检查 --&gt; &lt;property name=\"testOnBorrow\" value=\"false\" /&gt; &lt;!-- 设置往连接池归还连接时是否检查连接有效性，true时，每次都检查;false时，不检查 --&gt; &lt;property name=\"testOnReturn\" value=\"false\" /&gt; &lt;property name=\"poolPreparedStatements\" value=\"true\" /&gt; &lt;property name=\"maxOpenPreparedStatements\" value=\"20\" /&gt; &lt;property name=\"asyncInit\" value=\"true\" /&gt; &lt;/bean&gt; &lt;!--配置mybatis操作数据库--&gt; &lt;!--得到SqlSessionFatory--&gt; &lt;bean class=\"org.mybatis.spring.SqlSessionFactoryBean\"&gt; &lt;!--引用mybatis的配置文件--&gt; &lt;property name=\"configLocation\" value=\"classpath:mybatis/mybatis-config.xml\"&gt;&lt;/property&gt; &lt;!--指定数据源--&gt; &lt;property name=\"dataSource\" ref=\"druidDataSource\"&gt;&lt;/property&gt; &lt;!--指定xml位置--&gt; &lt;property name=\"mapperLocations\" value=\"classpath:mybatis/mapper/**/*.xml\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--扫描所有的dao接口加入到IOC容器中--&gt; &lt;!--&lt;bean class=\"org.mybatis.spring.mapper.MapperScannerConfigurer\"&gt;--&gt; &lt;!-- &lt;property name=\"basePackage\" value=\"org.lc.dao\"&gt;&lt;/property&gt;--&gt; &lt;!--&lt;/bean&gt;--&gt; &lt;!--或者--&gt; &lt;mybatis-spring:scan base-package=\"org.lc.dao\"&gt;&lt;/mybatis-spring:scan&gt; &lt;!--配置事务控制。配置事务管理器，让我们的事务管理器控制我们的数据源的链接的关闭和提交--&gt; &lt;bean id=\"dataSourceTransactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;property name=\"dataSource\" ref=\"druidDataSource\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--配置基于xml的事务。指定切点并将通知切入指定连接点--&gt; &lt;aop:config&gt; &lt;!--全局切点表达式--&gt; &lt;aop:pointcut id=\"pc1\" expression=\"execution(* org.lc.service..*(..))\"/&gt; &lt;!--事务增强 引用配置增强的方法及属性，引用切点--&gt; &lt;aop:advisor advice-ref=\"advic1t1\" pointcut-ref=\"pc1\"&gt;&lt;/aop:advisor&gt; &lt;/aop:config&gt; &lt;!--配置事务增强的方法及属性--&gt; &lt;tx:advice id=\"advic1t1\" transaction-manager=\"dataSourceTransactionManager\"&gt; &lt;!--配置事务属性--&gt; &lt;tx:attributes&gt; &lt;!--任何方法的任何异常都回滚(方法必须throw抛出异常才回滚,无论是运行时异常还是非运行异常)--&gt; &lt;tx:method name=\"*\" rollback-for=\"java.lang.Exception\"/&gt; &lt;!--设置添加的方法 隔离级别为总是新建一个事务运行。为本来非运行时异常设为可回滚的异常--&gt; &lt;tx:method name=\"add*\" propagation=\"REQUIRES_NEW\" isolation=\"REPEATABLE_READ\" rollback-for=\"java.lang.Exception\"&gt;&lt;/tx:method&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt;&lt;/beans&gt; 7、spring-mvc.xml配置1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;!--springmvc只扫描@controller.禁用默认的扫描规则--&gt; &lt;context:component-scan base-package=\"org.lc\" use-default-filters=\"false\"&gt; &lt;context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt; &lt;/context:component-scan&gt; &lt;!--配置jsp视图解析器--&gt; &lt;!--通过控制器直接返回的字符串 视图解析器自动帮我们添加前缀和后缀--&gt; &lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;!--只能得到在WEN-INF/pages下的jsp文件--&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/pages/\"&gt;&lt;/property&gt; &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--配置文件上传和下载--&gt; &lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;!--设置编码--&gt; &lt;property name=\"defaultEncoding\" value=\"utf-8\"&gt;&lt;/property&gt; &lt;!--文件上传最大为5MB--&gt; &lt;property name=\"maxUploadSize\" value=\"#{1024*1024*5}\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--处理静态资源--&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!--处理动态资源--&gt; &lt;mvc:annotation-driven&gt; &lt;!-- 配置消息转换器 解决@ResponseBody返回乱码 --&gt; &lt;mvc:message-converters register-defaults=\"true\"&gt; &lt;bean class=\"org.springframework.http.converter.StringHttpMessageConverter\"&gt; &lt;property name=\"defaultCharset\" value=\"UTF-8\"/&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt;&lt;/beans&gt; 8、目录结构图1)整体目录 2)分层目录","link":"/2020/07/24/ssm/SSM%E6%95%B4%E5%90%88%E7%A4%BA%E4%BE%8B/"},{"title":"SpringBoot整合邮件服务","text":"SpringBoot整合邮件服务一、邮件服务简介SMTP(发送邮件) 协议SMTP 的全称是“Simple Mail Transfer Protocol”，即简单邮件传输协议。它是一组用于从源地址到目的地址传输邮件的规范，通过它来控制邮件的中转方式。SMTP 协议属于 TCP/IP 协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。SMTP 服务器就是遵循 SMTP 协议的发送邮件服务器。SMTP 认证，简单地说就是要求必须在提供了账户名和密码之后才可以登录 SMTP 服务器，这就使得那些垃圾邮件的散播者无可乘之机。增加 SMTP 认证的目的是为了使用户避免受到垃圾邮件的侵扰。 POP3(接收邮件)协议​ POP3是Post Office Protocol 3的简称，即邮局协议的第3个版本,它规定怎样将个人计算机连接到Internet的邮件服务器和下载电子邮件的电子协议。它是因特网电子邮件的第一个离线协议标准,POP3允许用户从服务器上把邮件存储到本地主机（即自己的计算机）上,同时删除保存在邮件服务器上的邮件，而POP3服务器则是遵循POP3协议的接收邮件服务器，用来接收电子邮件的。但目前的 POP3 邮件服务器大都可以“只下载邮件，服务器端并不删除”，也就是改进的 POP3 协议。 SMTP 和 POP3 是最初的两个协议，随着邮件的不断发展后来又增加了两个协议： IMAP 协议IMAP全称是Internet Mail Access Protocol，即交互式邮件存取协议，它是跟POP3类似邮件访问标准协议之一。不同的是，开启了IMAP后，您在电子邮件客户端收取的邮件仍然保留在服务器上，同时在客户端上的操作都会反馈到服务器上，如：删除邮件，标记已读等，服务器上的邮件也会做相应的动作。所以无论从浏览器登录邮箱或者客户端软件登录邮箱，看到的邮件以及状态都是一致的。 Mime 协议MIME的英文全称是”Multipurpose Internet Mail Extensions” 多功能Internet 邮件扩充服务，它是一种多用途网际邮件扩充协议，在1992年最早应用于电子邮件系统，但后来也应用到浏览器。MIME意为多目Internet邮件扩展，它设计的最初目的是为了在发送电子邮件时附加多媒体数据，让邮件客户程序能根据其类型进行处理。然而当它被HTTP协议支持之后，它的意义就更为显著了。它使得HTTP传输的不仅是普通的文本，而变得丰富多彩。 二、发送邮件的准备工作申请授权码：以qq邮箱为例 登录qq邮箱–&gt;设置–&gt;账户–&gt;开启POP3/SMTP服务–&gt;验证–&gt;获取授权码 三、发送简单邮件1、pom.xmlspring-boot-starter-mail 123456789101112131415161718192021&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2、properties配置1234567891011121314#指定邮件服务器的地址 这里我们使用qq的smtp服务器发送邮件spring.mail.host=smtp.qq.com# 服务器的端口号修改成465或587；spring.mail.port=587# 邮件发送者的邮件spring.mail.username=421192425@qq.com# 这里使用的为授权码（不能使用邮箱密码）spring.mail.password=eqsdqizwdnenbgif#设置默认编码spring.mail.default-encoding=UTF-8#设置ssl协议spring.mail.properties.mail.smtp.socketFactory.class=javax.net.ssl.SSLSocketFactory#打印发送邮件的日志spring.mail.properties.mail.debug=true 3、发送邮件123456789101112131415161718192021222324252627@SpringBootTestclass MailApplicationTests { @Autowired private JavaMailSender javaMailSender; /** * 发送简单文本邮件 */ @Test void contextLoads() { SimpleMailMessage smm=new SimpleMailMessage();// 谁发的 这里需要和配置文件中的一致 smm.setFrom(\"421192425@qq.com\");// 发给谁 smm.setTo(\"421192425@qq.com\");// 定义主题 smm.setSubject(\"这是一份测试主题\");// 定义发送的日期 smm.setSentDate(new Date());// 发送的内容 smm.setText(\"测试lclcllclcl\");// 发送 javaMailSender.send(smm); }} 四、发送附件1、pom.xml123456789101112131415161718192021&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2、properties配置1234567891011121314#指定邮件服务器的地址 这里我们使用qq的smtp服务器发送邮件spring.mail.host=smtp.qq.com# 服务器的端口号修改成465或587；spring.mail.port=587# 邮件发送者的邮件spring.mail.username=421192425@qq.com# 这里使用的为授权码（不能使用邮箱密码）spring.mail.password=eqsdqizwdnenbgif#设置默认编码spring.mail.default-encoding=UTF-8#设置ssl协议spring.mail.properties.mail.smtp.socketFactory.class=javax.net.ssl.SSLSocketFactory#打印发送邮件的日志spring.mail.properties.mail.debug=true 3、发送邮件12345678910111213141516171819202122232425262728293031@SpringBootTestclass MailApplicationTests { @Autowired private JavaMailSender javaMailSender; /** * 发送附件 * @throws MessagingException */ @Test public void attachmentTest() throws MessagingException {// 创建模拟消息对象 MimeMessage msg = javaMailSender.createMimeMessage();// 传入模拟消息对象; 文件上传类型为true MimeMessageHelper helper = new MimeMessageHelper(msg, true);// 谁发的 这里需要和配置文件中的一致 helper.setFrom(\"421192425@qq.com\");// 发给谁 helper.setTo(\"421192425@qq.com\");// 定义主题 helper.setSubject(\"附件主题\");// 定义发送的日期 helper.setSentDate(new Date());// 发送的内容 helper.setText(\"附件内容哈哈哈---\");// 发送附件// 附件的名称(需要携带扩展名); 附件的地址 helper.addAttachment(\"lc.png\", new File(\"F:\\\\桌面内容\\\\i\\\\1.jpg\")); javaMailSender.send(msg); }} 五、发送图片资源文件1、pom.xml123456789101112131415161718192021&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2、properties配置1234567891011121314#指定邮件服务器的地址 这里我们使用qq的smtp服务器发送邮件spring.mail.host=smtp.qq.com# 服务器的端口号修改成465或587；spring.mail.port=587# 邮件发送者的邮件spring.mail.username=421192425@qq.com# 这里使用的为授权码（不能使用邮箱密码）spring.mail.password=eqsdqizwdnenbgif#设置默认编码spring.mail.default-encoding=UTF-8#设置ssl协议spring.mail.properties.mail.smtp.socketFactory.class=javax.net.ssl.SSLSocketFactory#打印发送邮件的日志spring.mail.properties.mail.debug=true 3、发送邮件12345678910111213141516171819202122232425262728293031323334@SpringBootTestclass MailApplicationTests { @Autowired private JavaMailSender javaMailSender; /** * 发送图片资源邮件 * @throws MessagingException */ @Test public void resourcesImgTest() throws MessagingException { // 创建模拟消息对象 MimeMessage msg = javaMailSender.createMimeMessage();// 传入模拟消息对象; multipalt(多部分)类型为true MimeMessageHelper helper = new MimeMessageHelper(msg, true);// 谁发的 这里需要和配置文件中的一致 helper.setFrom(\"421192425@qq.com\");// 发给谁 helper.setTo(\"421192425@qq.com\");// 定义主题 helper.setSubject(\"图片资源\");// 定义发送的日期 helper.setSentDate(new Date());// 发送的内容 ； cid定义文本id ; 设置发送的内容为html为true helper.setText(\"图片资源---》》这是第一张图片：&lt;img src='cid:p01'/&gt;，这是第二张图片：&lt;img src='cid:p02'/&gt;\",true);// 设置文本id helper.addInline(\"p01\", new FileSystemResource((new File(\"F:\\\\桌面内容\\\\i\\\\1.jpg\"))));// 设置文本id helper.addInline(\"p02\", new FileSystemResource((new File(\"F:\\\\桌面内容\\\\i\\\\2.png\")))); javaMailSender.send(msg); }} 六、使用thymeleaf发送邮件1、pom.xmlspring-boot-starter-thymeleaf spring-boot-starter-mail 12345678910111213141516171819202122232425&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2、properties1234567891011121314#指定邮件服务器的地址 这里我们使用qq的smtp服务器发送邮件spring.mail.host=smtp.qq.com# 服务器的端口号修改成465或587；spring.mail.port=587# 邮件发送者的邮件spring.mail.username=421192425@qq.com# 这里使用的为授权码（不能使用邮箱密码）spring.mail.password=eqsdqizwdnenbgif#设置默认编码spring.mail.default-encoding=UTF-8#设置ssl协议spring.mail.properties.mail.smtp.socketFactory.class=javax.net.ssl.SSLSocketFactory#打印发送邮件的日志spring.mail.properties.mail.debug=true 3、mail.html1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;hello &lt;span th:text=\"${username}\"&gt;&lt;/span&gt;,欢迎加入大家庭！！&lt;table border=\"1\" cellspacing=\"0\" cellpadding=\"0\"&gt; &lt;tr&gt; &lt;td&gt;职位&lt;/td&gt; &lt;td th:text=\"${position}\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;职称&lt;/td&gt; &lt;td th:text=\"${jobLevel}\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;薪水&lt;/td&gt; &lt;td th:text=\"${salary}\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;部门&lt;/td&gt; &lt;td th:text=\"${dep}\"&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;div style=\"color: red;font-size: 30px\"&gt;希望在未来的日子携手共进&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 4、发送邮件12345678910111213141516171819202122232425262728293031323334353637@SpringBootTestclass MailApplicationTests { @Autowired private JavaMailSender javaMailSender; //注入模板引擎 将thymeleaf的一些指令渲染成html @Autowired private TemplateEngine templateEngine; @Test public void thymeleafTemplateTest() throws MessagingException { // 创建模拟消息对象 MimeMessage msg = javaMailSender.createMimeMessage();// 传入模拟消息对象; multipalt(多部分)类型为true MimeMessageHelper helper = new MimeMessageHelper(msg, true);// 谁发的 这里需要和配置文件中的一致 helper.setFrom(\"421192425@qq.com\");// 发给谁 helper.setTo(\"421192425@qq.com\");// 定义主题 helper.setSubject(\"thymeleaf主题\");// 定义发送的日期 helper.setSentDate(new Date());// thymeleaf内容 Context context = new Context(); context.setVariable(\"username\", \"lc\"); context.setVariable(\"position\", \"总经理\"); context.setVariable(\"jobLevel\", \"架构师\"); context.setVariable(\"salary\",\"2000\"); context.setVariable(\"dep\", \"研发部\");// 将thymeleaf和context解析为字符串 String process = templateEngine.process(\"mail.html\", context);// 发送的内容 ； 设置发送的内容为html为true helper.setText(process,true); javaMailSender.send(msg); }} 七、使用freemarker发送邮件1、pom.xmlspring-boot-starter-mail spring-boot-starter-freemarker 12345678910111213141516171819202122232425&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2、properties配置1234567891011121314#指定邮件服务器的地址 这里我们使用qq的smtp服务器发送邮件spring.mail.host=smtp.qq.com# 服务器的端口号修改成465或587；spring.mail.port=587# 邮件发送者的邮件spring.mail.username=421192425@qq.com# 这里使用的为授权码（不能使用邮箱密码）spring.mail.password=eqsdqizwdnenbgif#设置默认编码spring.mail.default-encoding=UTF-8#设置ssl协议spring.mail.properties.mail.smtp.socketFactory.class=javax.net.ssl.SSLSocketFactory#打印发送邮件的日志spring.mail.properties.mail.debug=true 3、mail.ftlh123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;freemarker&lt;/h1&gt;hello &lt;span&gt;${username}&lt;/span&gt;,欢迎加入大家庭！！&lt;table border=\"1\" cellspacing=\"0\" cellpadding=\"0\"&gt; &lt;tr&gt; &lt;td&gt;职位&lt;/td&gt; &lt;td &gt;${position}&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;职称&lt;/td&gt; &lt;td&gt;${jobLevel}&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;薪水&lt;/td&gt; &lt;td&gt;${salary}&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;部门&lt;/td&gt; &lt;td&gt;${dep}&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;div style=\"color: red;font-size: 30px\"&gt;希望在未来的日子携手共进&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 4、发送邮件12345678910111213141516171819202122232425262728293031323334353637@SpringBootTestclass MailApplicationTests { @Autowired private JavaMailSender javaMailSender; @Test public void freemakerTest() throws MessagingException, IOException, TemplateException { // 创建模拟消息对象 MimeMessage msg = javaMailSender.createMimeMessage();// 传入模拟消息对象; multipalt(多部分)类型为true MimeMessageHelper helper = new MimeMessageHelper(msg, true);// 谁发的 这里需要和配置文件中的一致 helper.setFrom(\"421192425@qq.com\");// 发给谁 helper.setTo(\"421192425@qq.com\");// 定义主题 helper.setSubject(\"freeMaiker主题\");// 定义发送的日期 helper.setSentDate(new Date());// 设置freemarker配置版本 Configuration configuration=new Configuration(Configuration.VERSION_2_3_29);// 传入当前对象的类加载器; 所在的基础包路径 configuration.setClassLoaderForTemplateLoading(this.getClass().getClassLoader(), \"templates\"); Template template=configuration.getTemplate(\"mail.ftlh\"); Map&lt;String,Object&gt; map= new HashMap&lt;&gt;(); map.put(\"username\", \"lcccc\"); map.put(\"position\", \"总经理\"); map.put(\"jobLevel\", \"架构师\"); map.put(\"salary\",\"2000\"); map.put(\"dep\", \"研发部\"); StringWriter out=new StringWriter(); template.process(map, out);// 发送的内容 ； 设置发送的内容为html为true helper.setText(out.toString(),true); javaMailSender.send(msg); }}","link":"/2020/07/24/springboot/SpringBoot%E6%95%B4%E5%90%88%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1/"},{"title":"SpringBoot整合WebSocket","text":"SpringBoot整合WebSocket一、springboot实现在线群聊1、pom.xml主要的后端依赖 spring-boot-starter-websocket 前端依赖 sockjs-client jquery stomp-websocket webjars-locator-core 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;websocket1&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;websocket1&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--前端websocket客户端依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;sockjs-client&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--jquery--&gt; &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;stomp-websocket&lt;/artifactId&gt; &lt;version&gt;2.3.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;webjars-locator-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、消息bean123456@Getter@Setterpublic class Message { private String name; private String content;} 3、websocket代理服务器123456789101112131415161718192021222324/** * 实现websocket消息代理人配置器 */@Configuration//开启消息代理@EnableWebSocketMessageBrokerpublic class WebSocketConfig implements WebSocketMessageBrokerConfigurer { @Override public void configureMessageBroker(MessageBrokerRegistry registry) {// 消息代理的前缀 registry.enableSimpleBroker(\"/topic\"); registry.setApplicationDestinationPrefixes(\"/app\"); } /** * 建立连接点 * @param registry */ @Override public void registerStompEndpoints(StompEndpointRegistry registry) { registry.addEndpoint(\"/chat\").withSockJS(); }} 4、消息请求处理controller1234567891011121314@Controllerpublic class GreetingController {// 处理客户端请求消息的路径 //客户端发送消息的路径 /app/hello @MessageMapping(\"/hello\") // 服务器广播的路径(/topic/greetings) 由配置的topic前缀的服务去处理 //客户端订阅消息的路径 /topic/greeting @SendTo(\"/topic/greetings\") public Message greeting(Message message) { return message; }} 5、聊天页面123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;群聊&lt;/title&gt; &lt;script src=\"/webjars/jquery/jquery.min.js\"&gt;&lt;/script&gt; &lt;script src=\"/webjars/sockjs-client/sockjs.min.js\"&gt;&lt;/script&gt; &lt;script src=\"/webjars/stomp-websocket/stomp.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;请输入用户名&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" id=\"name\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=\"button\" id=\"connect\" value=\"连接\"/&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=\"button\" id=\"disconnect\" value=\"断开连接\" disabled=\"disabled\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;!--display:none 此块不会显示--&gt; &lt;div id=\"chat\" style=\"display: none;\"&gt; &lt;table&gt; &lt;tr&gt;请输入聊天内容&lt;/tr&gt; &lt;td&gt;&lt;input type=\"text\" id=\"content\"/&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=\"button\" id=\"send\" value=\"发送\"&gt;&lt;/td&gt; &lt;/table&gt; &lt;div id=\"conversation\"&gt;群聊进行中....&lt;/div&gt; &lt;/div&gt;&lt;script&gt; $(function () { //点击连接 $(\"#connect\").click(function () { connect() }); // 断开连接 $(\"#disconnect\").click(function () { if(stompClient!=null){ //直接断开连接 stompClient.disconnect(); } setConnect(false); }); $(\"#send\").click(function () { stompClient.send('/app/hello',{},JSON.stringify({'name':$(\"#name\").val(),'content':$(\"#content\").val()})) }) }) var stompClient=null; //尝试连接 function connect() { //如果没有输入用户名 直接返回 if(!$(\"#name\").val()){ alert(\"请输入用户名\") return; } //建立连接点 var socket=new SockJS('/chat'); stompClient=Stomp.over(socket); stompClient.connect({},function (success) { //连接成功的回调 //建立连接 （界面的处理） setConnect(true); // 订阅服务器的消息（后端服务服务器广播消息的路径） stompClient.subscribe('/topic/greetings',function (msg) { //服务端的msg的具体消息 在body属性中 //将字符串消息转为json对象 showGreeting(JSON.parse(msg.body)) }) },function () { // 连接失败的回调 }) } //展示消息 function showGreeting(msg) { //向聊天div中追加内容 $(\"#conversation\").append('&lt;div&gt;'+msg.name+\":\"+msg.content+'&lt;/div&gt;') } //建立连接 function setConnect(flag) { //prop() 方法设置或返回被选元素的属性和值。 //如果连接成功 则设置 '连接' 按钮不可用 $(\"#connect\").prop(\"disabled\",flag); //断开连接按钮 可用 $(\"#disconnect\").prop(\"disabled\",!flag); if (flag) { //显示 聊天界面 $(\"#chat\").show(); }else{ $(\"#chat\").hide(); } }&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 二、 springboot实现在线单聊1、pom.xml主要的后端依赖 spring-boot-starter-websocket spring-boot-starter-security 前端依赖 sockjs-client jquery stomp-websocket webjars-locator-core 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;websocket1&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;websocket1&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--前端websocket客户端依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;sockjs-client&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--jquery--&gt; &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;stomp-websocket&lt;/artifactId&gt; &lt;version&gt;2.3.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;webjars-locator-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、消息bean12345678910111213141516@Getter@Setterpublic class Chat { /** * 消息从哪来 */ private String from; /** * 消息内容 */ private String content; /** * 消息发给谁 */ private String to;} 3、websocket代理服务器1234567891011121314151617181920212223242526/** * 实现websocket消息代理人配置器 */@Configuration//开启消息代理@EnableWebSocketMessageBrokerpublic class WebSocketConfig implements WebSocketMessageBrokerConfigurer { @Override public void configureMessageBroker(MessageBrokerRegistry registry) {// 消息代理的前缀// 在这里我们定义 /topic为群聊消息 /queue为单聊消息 registry.enableSimpleBroker(\"/topic\",\"/queue\");// 定义程序的发送目标前缀 registry.setApplicationDestinationPrefixes(\"/app\"); } /** * 建立连接点 * @param registry */ @Override public void registerStompEndpoints(StompEndpointRegistry registry) { registry.addEndpoint(\"/chat\").withSockJS(); }} 4、security配置12345678910111213141516171819202122232425262728293031@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter { @Bean public PasswordEncoder passwordEncoder() { return NoOpPasswordEncoder.getInstance(); } @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.inMemoryAuthentication() .withUser(\"lc\") .password(\"123\") .roles(\"admin\") .and() .withUser(\"zs\") .password(\"123\") .roles(\"user\"); } @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests(). anyRequest().authenticated() .and() .formLogin()// 允许所有登录请求 .permitAll(); }} 5、消息请求处理controller12345678910111213141516171819202122232425262728293031323334353637@Controllerpublic class GreetingController {// // 处理客户端请求消息的路径// @MessageMapping(\"/hello\")//// 服务器广播的路径(/topic/greetings) 由配置的topic前缀的服务去处理// @SendTo(\"/topic/greetings\")// public Message greeting(Message message) {// return message;// } /** * 使用消息发送模板 */ @Autowired private SimpMessagingTemplate simpMessagingTemplate; @MessageMapping(\"/hello\") public void greeting(Message message) {// 直接指定发送的路径和消息 simpMessagingTemplate.convertAndSend(\"/topic/greetings\",message); } /** * 单聊 * @param principal 当前登录的用户信息 * @param chat */ @MessageMapping(\"/chat\") public void chat(Principal principal, Chat chat) { //谁发的消息 （指定发送人） chat.setFrom(principal.getName());// 指定发送人 ，发送的路径 ，发送的消息 simpMessagingTemplate.convertAndSendToUser(chat.getTo(), \"/queue/chat\", chat); }} 6、聊天页面注意： 123456// 注意在单聊是 发送给指定用户，那么websocket服务端自动帮我们加 /user 所以这里我们也要加 /user stompClient.subscribe('/user/queue/chat', function (msg) { //服务端的msg的具体消息 在body属性中 //将字符串消息转为json对象 showGreeting(JSON.parse(msg.body)) }) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;单聊&lt;/title&gt; &lt;script src=\"/webjars/jquery/jquery.min.js\"&gt;&lt;/script&gt; &lt;script src=\"/webjars/sockjs-client/sockjs.min.js\"&gt;&lt;/script&gt; &lt;script src=\"/webjars/stomp-websocket/stomp.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=\"button\" id=\"connect\" value=\"连接\"/&gt;&lt;input type=\"button\" id=\"disconnect\" value=\"断开连接\" disabled=\"disabled\"/&gt;&lt;hr&gt;&lt;table&gt; &lt;tr&gt; &lt;td&gt;消息内容:&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" id=\"content\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;目标用户:&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" id=\"to\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=\"button\" value=\"发送\" id=\"send\"&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;div id=\"chat\" style=\"display: none\"&gt; &lt;div id=\"conversation\"&gt;连接进行中...&lt;/div&gt;&lt;/div&gt;&lt;script&gt; $(function () { //点击连接 $(\"#connect\").click(function () { connect() }); // 断开连接 $(\"#disconnect\").click(function () { if (stompClient != null) { //直接断开连接 stompClient.disconnect(); } setConnect(false); }); //点击发送 $(\"#send\").click(function () { stompClient.send('/app/chat', {}, JSON.stringify({ 'to': $(\"#to\").val(), 'content': $(\"#content\").val() })) }) }) var stompClient = null; //尝试连接 function connect() { // 创建连接点 var socket = new SockJS('/chat'); stompClient = Stomp.over(socket); stompClient.connect({}, function (success) { //连接成功的回调 //建立连接 （界面的处理） setConnect(true); // 订阅服务器的消息 // 注意在单聊是 发送给指定用户，那么websocket服务端自动帮我们加 /user 所以这里我们也要加 /user stompClient.subscribe('/user/queue/chat', function (msg) { //服务端的msg的具体消息 在body属性中 //将字符串消息转为json对象 showGreeting(JSON.parse(msg.body)) }) }, function () { // 连接失败的回调 }) } //展示消息 function showGreeting(msg) { //向聊天div中追加内容 $(\"#conversation\").append('&lt;div&gt;' + msg.from + \":\" + msg.content + '&lt;/div&gt;') } //建立连接 function setConnect(flag) { //prop() 方法设置或返回被选元素的属性和值。 //如果连接成功 则设置 '连接' 按钮不可用 $(\"#connect\").prop(\"disabled\", flag); //断开连接按钮 可用 $(\"#disconnect\").prop(\"disabled\", !flag); if (flag) { //显示 聊天界面 $(\"#chat\").show(); } else { $(\"#chat\").hide(); } }&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2020/07/24/websocket/SpringBoot%E6%95%B4%E5%90%88WebSocket/"},{"title":"MySQL基础","text":"一、SQL查询语句执行顺序12345678910(1)from (3)join (2)on (4)where (5)group by(只有group的分组字段或者聚合函数，才能出现在select后面)(6)having(having一般在分组后配合聚合函数使用)(7)select (8)distinct (9)order by (10)limit 二、基本函数的使用 1、字符函数1)concat连接函数concat('字符串1','字符串2',变量3,...) 12#张三你好3SELECT CONCAT(\"张三\",\"你\",\"好\",3) as demo; 通过我们使用模糊查询采用 1select * from employee where name like concat('%',\"张三\",'%') 2) upper/lower/ucase/lcase 大小写转换12SELECT upper('chINese') as 大写,lower('chINese') as 小写; # CHINESE chineseSELECT ucase('chINese') as 大写,lcase('chINese') as 小写; # CHINESE chinese 3)length 字符的字节数1234# 5SELECT LENGTH('hello')# 6SELECT LENGTH('你好') 4)substr 字符串截取 索引从1开始 1234567#从索引为3位置的开始截取到结尾# hello worldSELECT substr('你好hello world',3)#从索引为3的位置截取5个字符# helloSELECT substr('你好hello world',3,5) 5)instr判断子串出现的索引 索引从1开始 12# 5SELECT INSTR('你好hello world','l') 6)trim去除前后空格123456#去除前后空格SELECT TRIM(' 你好 ');#从字符串中取出前后为a的字符# 你aa好SELECT TRIM('a' from 'aaaaa你aa好aaaaa'); 7)lpad/rpad填充字符1234567# 向左填充字符，填充的字符和原来的字符相加的字符长度为8# ++++++你好SELECT lpad('你好',8,'++')# 向右填充字符，填充的字符和原来的字符相加的字符长度为4# 你好##SELECT rpad('你好',4,'--') 8)replace 替换字符串 replace(T1,T2,T3) 将T1中的T2字符串替换为T3 12# hello，hello，hello，世界!!SELECT replace('你好，你好，你好，世界!!','你好','hello') 2、convert小数格式化1)decimal(P,D)函数的使用 P是表示有效数字数(从左边第一个非0开始)的精度。 P范围为1〜65。 D是表示小数点后的位数。 D的范围是0~30。MySQL要求D小于或等于(&lt;=)P。 当直接使用decimal时，不包含小数，并且只保留整数，且有效数字P为10 保留小数是四舍五入的形式 例如: 12amount DECIMAL(6,2); amount列最多可以存储6位数字，小数位数为2位; 因此，amount列的范围是从-9999.99到9999.99。 测试： 12#2312SELECT convert(2312.335,DECIMAL) as 结果 12#2312.34SELECT convert(2312.335,DECIMAL(6,2)) as 测试 3、ifnull 判断空并赋值 ifnull(T1,T2) 若T1为null则输出T2，否则输出T1 12#若emp_name为空，则输出第二个参数的值，否则输出emp_name列的值SELECT id,IFNULL(emp_name,'无') as 姓名 from employee 4、日期函数1)日期格式化参数缩写 %a 缩写星期名 %b 缩写月名 %c 月，数值 %D 带有英文前缀的月中的天 %d 月的天，数值(00-31) %e 月的天，数值(0-31) %f 微秒 %H 小时 (00-23) %h 小时 (01-12) %I 小时 (01-12) %i 分钟，数值(00-59) %j 年的天 (001-366) %k 小时 (0-23) %l 小时 (1-12) %M 月名 %m 月，数值(00-12) %p AM 或 PM %r 时间，12-小时（hh:mm:ss AM 或 PM） %S 秒(00-59) %s 秒(00-59) %T 时间, 24-小时 (hh:mm:ss) %U 周 (00-53) 星期日是一周的第一天 %u 周 (00-53) 星期一是一周的第一天 %V 周 (01-53) 星期日是一周的第一天，与 %X 使用 %v 周 (01-53) 星期一是一周的第一天，与 %x 使用 %W 星期名 %w 周的天 （0=星期日, 6=星期六） %X 年，其中的星期日是周的第一天，4 位，与 %V 使用 %x 年，其中的星期一是周的第一天，4 位，与 %v 使用 %Y 年，4 位 %y 年，2 位 2)日期名称解释 HOUR 小时 MINUTE 分 SECOND 秒 MICROSECOND 毫秒 YEAR 年 MONTH 月 DAY 日 WEEK 周 QUARTER 季 YEAR_MONTH 年和月 DAY_HOUR 日和小时 DAY_MINUTE 日和分钟 DAY_ SECOND 日和秒 HOUR_MINUTE 小时和分 HOUR_SECOND 小时和秒 MINUTE_SECOND 分钟和秒 3)时间获取123456789101112131415161718192021222324# 2020-07-25 23:15:31 返回当前系统的 日期+时间SELECT now();# 2020-07-25 返回当前系统的 日期SELECT CURDATE();# 23:16:05 返回当前系统的 时间SELECT CURTIME();# 获取 年 SELECT year(NOW());SELECT year('2011-1-1');# 获取 月SELECT MONTH(NOW());# July 获取月 对应的英文SELECT MONTHNAME(NOW());#获取 日select DAY(NOW())#获取 时select HOUR(NOW())#获取 分select minute(NOW())#获取 秒select second(NOW()) 4)格式化日期①字符格式化为日期查询日期为2019-9-9，但是需要将不规范的日期格式转换为对应的时间日期格式 1SELECT * from employee where birthday = str_to_date('9-9 2019','%m-%d %Y') ②日期格式化为字符12# 将2019-09-09 转换为 2020年09月09日SELECT id,DATE_FORMAT(birthday,'%Y年%m月%d日') from employee 5)日期间隔差值计算 日期相减 DATEDIFF(T1,T2) T1减去T2，得到相隔的天数 12# 1822SELECT DATEDIFF(\"2020-08-01\",\"2015-08-06\") 时间相减 TIMEDIFF(T1,T2) T1减去T2,得到相隔时分秒 12# 02:40:00SELECT TIMEDIFF(\"15:44:44\",\"13:04:44\") 6)加减天数/时间 adddate(T1,T2) 给T1日期加上指定T2天数 12#2019-05-30 13:42:29SELECT adddate(\"2019-05-28 13:42:29\",2); ADDTIME(T1,T2) 给T1日期加上指定T2的天数和时间 12#2017-03-05 14:53:40SELECT ADDTIME(\"2017-03-03 13:42:29\",\"2 1:11:11\"); 5、流程控制函数1)if if(T1,T2,T3) 若T1为真，输出T2，否则输出T3 12# 嘻嘻SELECT if(10&lt;3,'哈哈','嘻嘻'); 2)case…when…then…else… end if - else 结构 ： select case 列名 when 列值 then ... else ... end from 表名 等同于 select case when 列名='列值' then ... else ... end from 表名 12SELECT case isbn when 'ISBN-001' then '001' else 'other' end as 备注 from book; SELECT case when isbn='ISBN-001' then '001' else 'other' end as 备注 from book; swith-case 结构： 着重强调判断相等 即 case T1 when T2 then ，判断T1变量或表达式是否等于常量T2 123456789 SELECT case isbn when 'ISBN-001' then '001' when 'ISBN-002' then '002' when 'ISBN-003' then '003' when 'ISBN-004' then '004' when 'ISBN-005' then '005' else 'other' end as 备注 from book; if-else if-else 结构 : case when 条件 then ，条件可以是随意的，例如 &gt; &lt; = 等判断 123456SELECT case when price&gt;100 then 'good' when price=100 then 'normal' when price&lt;100 then 'bad' end as 备注from book; 6、聚合函数sum 求和，avg平均值，max最大值，min最小值，count计算个数 sum,avg 一般处理数值型 max,min,count可以处理任何类型 所有分组函数进行处理的时候都忽略null值 三、基本关键字的使用1、between … and …12#查询hrid在3到5直接的id，包括3和5SELECT * FROM `hr` where hrid BETWEEN 3 and 5; 等价于 1SELECT * from hr where hrid&gt;=3 and hrId&lt;=5 2、distinct去重12345#去除price重复的值SELECT DISTINCT price from book#去除isbn，price，book_name都不重复的值，即同时满足每一行的这三个值都不相同SELECT DISTINCT isbn,price,book_name from book 单独的distinct，必须放在开头，否则报错，语法错误；但是与其它的函数一起使用的时候，没有位置限制。 可以去重null值和空值，当有多个null值和空值时，去重后只有一个null值和空值 3、group by多条件分组12#按照每一行的price，book_name都相同时分组，若只一个不同则视为不同行SELECT book_name,price from book GROUP BY price,book_name 4、case when … then … else … end行转列123456789SELECT student.sno, sname, sc.grade, course.cnameFROM studentLEFT JOIN sc ON student.sno = sc.snoLEFT JOIN course ON sc.cno = course.cno 将学生按照学生的id和姓名进行分组，查询成绩的时候有选择的输出到列，将分组的成绩转换为对应列的成绩 12345678910111213141516SELECT student.sno,sname, #若当前查询cname列为数据库，则输出成绩列grade,否则输出为空 max(case when cname='数据库' then grade else null end) as '数据库', max(case when cname='数学' then grade else null end) as '数学', max(case when cname='信息系统' then grade else null end) as '信息系统', max(case when cname='数据结构' then grade else null end) as '数据结构', max(case when cname='操作系统' then grade else null end) as '操作系统', #转换小数，将avg(grade)得到的平均成绩，保留5位有效数字，并且保留2位小数。 convert(avg(grade),DECIMAL(5,2)) '平均成绩'FROM studentLEFT JOIN sc ON student.sno = sc.snoLEFT JOIN course ON sc.cno = course.cnoGROUP BY student.sno, sname 5、exists和not exists用法 exists 后面的查询若查的不为空值则返回该次查询，否则该条查询无效 not exists 后面的查询若为空，则返回此次查询。若不为空，则该条查询无效 12#每次执行一次外部查询 都会执行子查询（会引用外部查询的值）是否返回结果集SELECT * FROM b WHERE not EXISTS(SELECT * from a where a.id=b.id); 1234567891011121314151617181920212223242526#查询选修了 1006课程的学生SELECT sname from s where EXISTS(SELECT * from sc where s.sid=sc.sid and cid='1006')#查询选修了课程的学生 SELECT sname from s where EXISTS(select * from sc WHERE s.sid=sc.sid)1 查询到 退出5 没查询到 #查询选修了全部课程的学生SELECT sname from s where not EXISTS(select * from c where not exists(SELECT * from sc where s.sid=sc.sid and c.cid=sc.cid)) #相当于三个for循环嵌套，都匹配返回，不匹配往下循环查找1 1001 空 1 1002 不为空1 1003 不为空 ....1 1006 空#遍历完二层后结果集 整体有值则不会返回 14 1001 空4 1002 空4 1003 空4 1004 空4 1005 空4 1006 空#遍历完二层后结果集 整体为空则会返回 1 6、limit使用一个参数： 等价于 limit 0,n 12#取两条数据，即1,2条SELECT * from employee LIMIT 2 两个参数： 第一个参数：从哪个索引位置开始取，limit 的索引从0开始，即对应第一条数据 第二个参数：取几条数据 12#从索引为2位位置即第三行开始，取3条数据。即 3,4,5SELECT * from employee LIMIT 2,3 offset的使用： offset：后面表示偏移的位置，即索引开始的位置 limit: 后面表示取几条数据 12#从索引为2的位置开始取三条数据，即 3,4,5SELECT * from employee LIMIT 3 OFFSET 2 等价于==&gt;SELECT * from employee LIMIT 2,3 7、like模糊查询 _ 匹配单个字符 % 匹配多个字符 查询带_下划线的字符串, 需要使用反斜杠来转义下划线 1SELECT * from employee where emp_name like '张三\\_' 或者使用ESCAPE关键字指定对应的字符来转义 12#使用美元符号指定转义字符SELECT * from employee where emp_name like '张三$_' ESCAPE '$' 8、not null/is not null 判断空 空值 不等于 null值 若某一列的约束设置为null，则可以为 null和空字符串 若某一列的约束设置为not null，则可以为空字符串，但是不能为null值 判断null只能用 is null/not null判断，不能用 =、&gt;、&lt; ，!= ,&lt;&gt; 等判断 12#找出emp_name为null值的数据，空字符串的数据可以被查出SELECT * from employee where emp_name is NULL 9、order by 排序 使用 ASC(升序) 或 DESC(降序) 关键字来设置查询结果是按升序或降序排列。 默认为ASC升序 order by 后可加2个（或多个）字段，字段之间用英文逗号隔开。 若A用升序，B用降序，SQL该这样写：order by A ASC, B DESC;默认同理，也可以这样写：order by A, B DESC; 若A、B都用降序，必须用两个order by A DESC, B DESC; 若A、B都用升序，则order by A,B ; 多个字段时，优先级按先后顺序而定。 12#先按照sno升序排列，再按照cno降序排列SELECT * FROM `sc` ORDER by sno,cno desc; 9、some/all/anyany/some: any 可以与=、&gt;、&gt;=、&lt;、&lt;=、&lt;&gt;结合起来使用，分别表示等于、大于、大于等于、小于、小于等于、不等于其中的任何一个数据即返回。 只要有sage小于其中sdept为IS条件的任何一个数据即返回 1select *from student where sage&lt; any(select sage from student where sdept='IS') and sdept&lt;&gt;'IS' all: all可以与=、&gt;、&gt;=、&lt;、&lt;=、&lt;&gt;结合是来使用，分别表示等于、大于、大于等于、小于、小于等于、不等于其中的所有数据。 只要sgae 小于select sage from student中的所有数据即返回 1select *from student where sage&lt;=all(select sage from student) 10、natural join 自然连接无需手动建立等值连接，不能写on关键字，自动连接等值的列，并且自动去掉重复的列 1SELECT * from course NATURAL join sc WHERE cno=1 11、union/union all 列名的要相同 123select * from Table1 union #去除重复的行select * from Table2 123select * from Table1 union all #不会去除重复select * from Table2 12、delete多表联合删除 ①删除单表中的数据 1delete from course where c_id=12; ②删除联合查询的指定一个表的数据 即删除联合查询后delete关键字后面的表course 1DELETE course from course,score where course.c_id = score.c_id and c_name='语文'; ③删除联合查询中两个表的数据 即删除联合查询中delete关键字后面的表course和score 1DELETE course,score from course,score where course.c_id = score.c_id and c_name='语文'; ④注意事项 当联合多表删除时，需要在delete后面指定需要删除的表，且表名不能为别名 错误写法： 1DELETE from course,score where course.c_id = score.c_id and c_name='语文'; 四、DDL操作1、数据库管理12345678910#创建数据库create database test1;#删除数据库drop database test1#如果存在test1数据库则删除drop database if EXISTS test1#使用test数据库use test; 2、表的管理 alter table 表名 change|modify|add|drop column 列名 【约束名 约束】 123456789101112131415161718192021222324252627282930313233343536#如果person表存在则删除该表drop table if exists person;#创建表create table person( id int primary key, name varchar(50) not null, height int, birthday date, gender char(2));#修改列名及其类型和约束#修改列名gender为sex并为其重新指定类型为char(1)alter table person change column gender sex char(1) not null#修改列的类型及约束alter table person modify column birthday datetime not null#增加列alter table person add column address varchar(100)#删除列alter table person drop column height#修改表名person为person_tablealter table person rename to person_table#删除表drop table person;#查看表的结构 `desc 表名`desc person#查看表的所有索引 `show index from 表名`show index from person 4、数据类型1)枚举的创建和使用 枚举值 不区分大小写 123456789101112131415161718create table table_char( # 设置主键自增 id int PRIMARY key auto_increment, gender enum('男','女'))INSERT into table_char(gender) values('男');INSERT into table_char(gender) values('女');# 插入 男INSERT into table_char(gender) values('1');INSERT into table_char(gender) values(1);#插入 女INSERT into table_char(gender) values('2');INSERT into table_char(gender) values(2);#插入 空值INSERT into table_char(gender) values('0'); 2)日期类型 ①datetime与timestamp区别 日期显示的格式一致 一般我们在创建表时，如果希望得到表的更新时间，则创建一个更新字段，勾选timestamp/datetime类型为时间戳类型，当修改表的数据时会自动更新该字段为当前系统时间，但首次插入时不会更新该字段 3)整型 4)浮点型 5)字符型 text：与char和varchar不同的是，text不可以有默认值，其最大长度是2的16次方-1 5、约束的操作 not null 非空约束 default 默认约束 primary key 唯一非空约束 unique 唯一约束，可为null，可以有多个null值。也可以为空值，空值也算一种值，但是不能有多个空值。 check 检查约束【mysql不支持，但是写不报错】 foreign key 外键约束(不常用) 1)约束添加的时机 列级约束 六大约束语法上都支持，但外键约束没有效果 标记约束 除了非空，默认，其他的都支持 12345create table 表名( 字段名 字段类型 列级约束, 字段名 字段类型 列级约束 表级约束); 2)创建表时添加列级约束123456789101112131415create table class_info( id int primary key auto_increment, name VARCHAR(20));drop table if EXISTS stu_info;create table stu_info( id int primary key auto_increment, username varchar(20) unique not null, name varchar(30) not null, # 检查约束在mysql中无效，但写不报错 gender char(1) check(gender='男' or gender='女'), age int default 18, # 在列级添加外键约束无效 classid int REFERENCES class_info(id)); 3)创建表时添加表级约束123456789101112131415161718192021222324create table class_info( id int primary key auto_increment, name VARCHAR(20));drop table if EXISTS stu_info;create table stu_info( id int auto_increment, username varchar(20) not null, name varchar(30) not null, gender char(1) default '男', age int default 18, classid int, #主键约束 primary key(id), #唯一约束 unique(username), #check在mysql中不生效 check(gender='男' or gender='女'), #外键的命名规则一般为 fk_本表字段_外键字段 constraint fk_calssid_id foreign key(classid) references class_info(id));#查看表的所有索引信息show index from stu_info 4)创建表时常规写法12345678910drop table if EXISTS stu_info;create table stu_info( id int primary key auto_increment, username varchar(20) unique not null, name varchar(30) not null, gender char(1) default '男', age int default 18, classid int, constraint fk_calssid_id foreign key(classid) references class_info(id)); 5)主键约束和非空约束的区别 主键 不允许为null，若主键为字符型，那么只能有一个空的字符作为主键 非空约束 不允许为null值，可以为空值 6)唯一约束(索引) 允许为null，且可以为多个null值。允许为空值，但是最多只能有一个空值 一个表可以有多个唯一约束 7)联合主键 当只有一个字段作为主键时，字段不为null，且唯一 当有两个字段作为联合主键时，只要两个字段在多行只要有一个不相等则可以插入。 一个表只能有一个主键 9)修改表添加约束123456789101112131415161718192021#添加列级约束# 添加主键约束alter table stu_info MODIFY column id int PRIMARY key auto_increment;#添加表级约束# 添加主键约束alter table stu_info add PRIMARY key(id);#添加列级约束# 添加非空唯一约束alter table stu_info modify column username varchar(20) not null unique;#添加表级约束# 添加唯一约束 alter table stu_info add unique(username);#添加外键约束alter table stu_info add CONSTRAINT fk_calssid_id FOREIGN key(classid) REFERENCES class_info(id)#查看表的结构desc stu_info;#查看表的索引信息show index from stu_info 10)修改表时删除约束1234567891011#删除字段上的其他约束(默认约束，非空约束)。直接重新修改字段即可alter table stu_info modify column username varchar(20);#删除唯一约束 `alter table 表名 drop index 约束名`alter table stu_info drop index username#删除主键alter table stu_info drop PRIMARY key#删除外键 `alter table 表名 drop FOREIGN key 外键名称`alter table stu_info drop FOREIGN key fk_calssid_id 6、视图的操作 视图的好处 重用sql语句 简化复杂的sql操作，不必知道它的查询细节 保护数据，提高安全性 1)视图创建12345678910#创建视图 `create view 视图名 as 查询语句`CREATE VIEW v1 AS SELECT hr.*, d.depName, d.enabledFROM hrLEFT JOIN department AS d ON hr.depId = d.depId;#视图使用 `select * from 视图名 where ...`SELECT * FROM v1 WHERE hrTelephone LIKE '029%'; 2)视图的修改123456789#若v2存在则修改视图，若不存在则创建视图v2 `create or replace view 视图名 as 查询语句`create or replace view v2 as select hr.hrId from hr;#修改视图 `alter view 视图名 as 查询语句`alter view v1 as select * from hr;SELECT * from v1SELECT * from v2 3)删除视图12#删除视图 `drop view 视图名1,视图名2`drop view v1,v2 4)查看视图结构12#查看视图结构 `desc 视图名`desc v2 5)视图和表的区别 视图没有保存实际的数据，只是一张虚拟表，只是保存的sql逻辑。一般适用于查询操作 表保存了实际的数据 ###四、其他 1、查看时区和修改时区 查看当前系统的时区 1SHOW VARIABLES LIKE \"%time_zone%\"; 设置系统时区 123456#全局设置SET GLOBAL time_zone = '+8:00';#只在当前会话有效SET time_zone = '+8:00';#刷新FLUSH PRIVILEGES;","link":"/2020/08/07/mysql/MySQL%E5%9F%BA%E7%A1%80/"},{"title":"MySQL进阶","text":"一、存储引擎简介1、MyISAM与InnoDB 的区别 对比项 MyISAM InnoDB 主外键 不支持 支持 事务 不支持 支持 行表锁 表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作 行锁，操作时只锁某一行，不对其他行有影响。适合高并发操作 缓存 只缓存索引，不缓存真实数据 不仅缓存索引还要缓存真实数据，对内存要求较高，而且内存大小对性能有决定性的影响 表空间 小 大 关注点 性能 事务 默认安装 Y Y MySQL5.5版本开始Innodb已经成为Mysql的默认引擎(之前是MyISAM) Innodb不支持全文索引，而MyISAM支持全文索引，在涉及全文索引领域的查询效率上MyISAM速度更快高；PS：5.6以后的InnoDB支持全文索引了 二、七种JOIN A表 B表 1、√左连接(显示A的所有,包含公共部分)123#左连接# A左连接B,显示A的所有部分,A没有的显示为nullSELECT * from hr LEFT JOIN department on hr.depId=department.depId 2、左连接(显示A独有的,不包含AB共有)12# A左连接B, 只显示A部分，不显示公共部分。SELECT * from hr LEFT JOIN department on hr.depId=department.depId where department.depId is null 3、√右连接(显示B的所有,包含公共)123#右连接# A右连接B,显示B的所有部分SELECT * from hr right JOIN department on hr.depId=department.depId 4、右连接(显示B的独有，不包含AB公共)12# A右连接B, 只显示B部分，不显示公共部分。SELECT * from hr right JOIN department on hr.depId=department.depId where hr.depId is null; 5、√内连接(等值连接)，只包含AB的公共部分1234#内连接SELECT * from hr INNER JOIN department on hr.depId=department.depId #等值连接 和 内连接一致#SELECT * from hr,department WHERE hr.depId=department.depId 6、union联合，同时包含A和B,不包含公共部分 union会自动去重 1234#查询 A的独有 和 B的独有，不包含AB的共有SELECT * from hr left JOIN department on hr.depId=department.depId where department.depId is nullunion SELECT * from hr right JOIN department on hr.depId=department.depId where hr.depId is null 7、union联合，包含A和B的所有 union会自动去重 12345#全连接#包含A的所有,B的所有SELECT * from hr left JOIN department on hr.depId=department.depId union SELECT * from hr right JOIN department on hr.depId=department.depId 二、索引1、索引的定义索引(Index)是帮助MySQL高效获取数据的数据结构，简单的理解为：排好序的快速查找数据结构 MySQL官方对索引的定义为：索引(Index)是帮助MySQL高校获取数据的数据结构。可以得到索引的本质：索引是数据结构 下图就是一种可能的索引方式（二叉树）示例： ​ 左边是数据表，一共有两列七条记录，最左边的是数据记录的物理地址。为了加快 Col2 的查找，可以维护一个右边所示的二叉查找树，每个节点分别包含索引键值和一个指向对应数据记录物理地址的指 针，这样就可以运用二叉查找在一定的复杂度内获取到相应数据，从而快速的检索出符合条件的记录。​ 一般来说索引本身也很大，不可能全部存储在内存中，因此索引往往以索引文件的形式存储的磁盘上。 2、索引的优势和劣势 优势 类似大学图书馆建书目索引，提高数据检索效率，降低数据库的IO成本 通过索引列对数据进行排序，降低数据排序成本，降低了CPU的消耗 劣势 实际上索引也是一张表，该表保存了主键和索引字段，并指向实体表的记录,所以索引列也是要占用空间的 虽然索引大大提高了查询速度，同时却会降低更新表的速度,如果对表INSERT,UPDATE和DELETE。因为更新表时，MySQL不仅要不存数据，还要保存一下索引文件每次更新添加了索引列的字段，都会调整因为更新所带来的键值变化后的索引信息 3、索引的分类1)主键索引(Primary Key)数据表的主键列使用的就是主键索引。 一张数据表有只能有一个主键，并且主键不能为null，不能重复。 *在mysql的InnoDB的表中，当没有显示的指定表的主键时，InnoDB会自动先检查表中是否有唯一索引的字段，如果有，则选择该字段为默认的主键，否则InnoDB将会自动创建一个6Byte的自增主键。(虽然我们看不到)* 2)二级索引(辅助索引)二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。 唯一索引，普通索引，前缀索引等索引属于二级索引。 单值索引 即一个索引只包含单个列，一个表可以有多个单列索引 建议一张表索引不要超过5个，优先考虑复合索引 唯一索引 唯一索引也是一种约束。唯一索引的属性列不能出现重复的数据，但是允许数据为NULL，一张表允许创建多个唯一索引。建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。 复合索引 即一个索引包含多个列 前缀索引 前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。 全文索引(Full Text) 全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6之前只有MYISAM引擎支持全文索引，5.6之后InnoDB也支持了全文索引。 4、索引创建和删除 创建 create index 索引名 on 表名(字段名) 1CREATE index index_username on hr(hrname) create table 表名 add index 索引名(字段名) 1alter table hr add index index_username(hrname) 删除 alter table 表名 drop index 索引名 1alter table hr drop index index_username drop index 索引名 on 表名 1drop index index_username on hr 查看表的所有索引 show index from 表名 1SHOW INDEX FROM table_name 添加全文索引 1ALTER TABLE `table_name` ADD FULLTEXT ( `column`) 添加PRIMARY KEY（主键索引） 1ALTER TABLE `table_name` ADD PRIMARY KEY ( `column` ) 添加UNIQUE 唯一索引 1ALTER TABLE `table_name` ADD UNIQUE ( `column` ) 5、MySQL主要使用两种索引的数据结构 full-text全文索引(了解即可) R-Tree索引(了解即可) 1)Hash索引 对于哈希索引来说，底层的数据结构就是哈希表，因此在绝大多数需求为单条记录查询的时候，可以选择哈希索引，查询性能最快；其余大部分场景，建议选择BTree索引 2)BTree索引3)BTree和B+Tree的区别？①BTree B树的所有节点既存放 键(key) 也存放 数据(data); B树的叶子节点都是独立的; B树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了 ②B+Tree B+树只有叶子节点存放 key (索引值)和 data(数据的物理地址指针)，其他内节点只存放key。 B+树的叶子节点有一条引用链指向与它相邻的叶子节点。 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。 B+树其实就是一个多叉平衡树 4)MyISAM与InnoDB实现B+Tree的区别？聚集索引和非聚集索引？①MyISAM实现的BTree索引(非聚集索引)​ B+Tree叶节点的data域存放的是数据记录的地址。在索引检索的时候，首先按照B+Tree搜索算法搜索索引，如果指定的索引Key存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“非聚簇索引”。 非聚簇索引：将数据与索引分开存储，索引结构的叶子节点指向了数据对应的物理位置(指针)，二级索引属于非聚集索引。 MYISAM引擎的表的.MYI文件包含了表的索引， 该表的索引(B+树)的每个叶子非叶子节点存储索引， 叶子节点存储索引和索引对应数据的指针，指向.MYD文件的数据。 非聚集索引的叶子节点并不一定存放数据的指针， 因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。 优点： 更新代价比聚集索引要小 。非聚集索引的更新代价就没有聚集索引那么大了，非聚集索引的叶子节点是不存放数据的 缺点： 跟聚集索引一样，非聚集索引也依赖于有序的数据 可能会二次查询(回表) :这应该是非聚集索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。 ②InnoDB实现BTree索引(聚集索引)​ 其数据文件本身就是索引文件。相比MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点data域保存了完整的数据记录。这个索引的key是数据表的主键，因此InnoDB表数据文件本身就是主索引。这被称为“聚簇索引（或聚集索引）”，而其余的索引都作为辅助索引，辅助索引的data域存储相应记录主键的值而不是地址，这也是和MyISAM不同的地方。在根据主索引搜索时，直接找到key所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，在走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。 聚簇索引：将数据存储与索引放到了一块，索引结构的叶子节点保存了行数据，主键索引属于聚集索引。 在 Mysql 中，InnoDB引擎的表的 .ibd文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。 优点： 聚集索引的查询速度非常的快，因为整个B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。 缺点： 依赖于有序的数据 ：因为B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或UUID这种又长又难比较的数据，插入或查找的速度肯定比较慢。 更新代价大 ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改， 而且况聚集索引的叶子节点还存放着数据，修改代价肯定是较大的， 所以对于主键索引来说，主键一般都是不可被修改的。 ③非聚集索引一定要回表查询吗?(使用覆盖索引)非聚集索引不一定回表查询。 试想一种情况，用户准备使用SQL查询用户名，而用户名字段正好建立了索引。 1SELECT name FROM table WHERE username='guang19'; 那么这个索引的key本身就是name，查到对应的name直接返回就行了，无需回表查询。 即使是MYISAM也是这样，虽然MYISAM的主键索引确实需要回表， 因为它的主键索引的叶子节点存放的是指针。但是如果SQL查的就是主键呢? 1SELECT id FROM table WHERE id=1; 主键索引本身的key就是主键，查到返回就行了。这种情况就称之为覆盖索引了。 6、哪些情况需要创建索引和无需建索引 需要建索引 1.主键自动建立唯一索引 2.频繁作为查询的条件的字段应该创建索引 3.查询中与其他表关联的字段，外键关系建立索引 4.频繁更新的字段不适合创建索引 因为每次更新不单单是更新了记录还会更新索引，加重IO负担 5.Where条件里用不到的字段不创建索引 6.单间/组合索引的选择问题，who？（在高并发下倾向创建组合索引） 7.查询中排序的字段，排序字段若通过索引去访问将大大提高排序的速度 8.查询中统计或者分组字段 无需建索引 1.表记录太少 2.经常增删改的表 3.数据重复且分布平均的表字段，因此应该只为经常查询和经常排序的数据列建立索引。注意，如果某个数据列包含许多重复的内容，为它建立索引就没有太大的实际效果。 7、使用EXPLAIN+SQL语句来实现性能分析 参数介绍 1)id查询的序列号 select查询的序列号，包含一组数字，表示查询中执行select子句或操作表的顺序 三种情况 id相同，执行顺序由上至下 id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行 先执行优先级高即序号最大的id,若id相同，则从上到下依次执行 2)select_type查询类型查询的类型，主要用于区别：普通查询、联合查询、子查询等的复杂查询 1.SIMPLE 简单的select查询，查询中不包含子查询或者UNION 2.PRIMARY 查询中若包含任何复杂的子部分，最外层查询则被标记为primary 3.SUBQUERY 在SELECT或者WHERE列表中包含了子查询 4.DERIVED 在FROM列表中包含的子查询被标记为DERIVED（衍生） MySQL会递归执行这些子查询，把结果放在临时表里。 5.UNION 若第二个SELECT出现在UNION之后，则被标记为UNION;若UNION包含在FROM子句的子查询中，外层SELECT将被标记为：DERIVED 6.UNION RESULT 从UNION表获取结果的SELECT 3)table哪张表 显示这一行的数据是关于哪张表的 4)type访问类型显示查询使用了何种类型从最好到最差依次是：system&gt;const&gt;eq_ref&gt;ref&gt;range&gt;index&gt;ALL 达到ref和range级别的索引即可 system 表只有一行记录（等于系统表），这是const类型的特例，平时不会出现，这个也可以忽略不计 const 表示通过索引一次就找到了，const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快。如将主键至于where列表中，MySQL就能将该查询转换为一个常量 eq_ref 唯一性索引，对于每个索引键，表中只有一条记录与之匹配，常见于主键或唯一索引扫描 即相当于在表中 通过主键索引或唯一索引只找到一条数据 ref 非唯一索引扫描，返回匹配某个单独值的所有行。本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体 通过非唯一索引扫描找到多条数据 range 只检索给定范围的行，使用一个索引来选择行。key列显示使用了哪个索引一般就是在你的where语句中出现了between、&lt;、&gt;、in等的查询这种范围扫描索引扫描比全表扫描要好，因为他只需要开始索引的某一点，而结束语另一点，不用扫描全部索引 index Full Index Scan,index与ALL区别为index类型只遍历索引树。这通常比ALL快，因为索引文件通常比数据文件小。（也就是说虽然all和index都是读全表，但index是从索引中读取的，而all是从硬盘中读的） all FullTable Scan,将遍历全表以找到匹配的行 (效率最差) 一般来说，得保证查询只是达到range级别，最好达到ref 5)possible_keys可能用到的索引 显示可能应用在这张表中的索引,一个或多个。查询涉及的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用 6)key真正用到的索引 实际使用的索引。如果为null则没有使用索引 查询中若使用了覆盖索引，则索引和查询的select字段重叠 7)key_len索引中使用的字节数 表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。在不损失精确性的情况下，长度越短越好 key_len显示的值为索引最大可能长度，并非实际使用长度，即key_len是根据表定义计算而得，不是通过表内检索出的 8)ref引用的索引列 显示索引那一列被使用了，如果可能的话，是一个常数。那些列或常量被用于查找索引列上的值 9)rows读取到的行 根据表统计信息及索引选用情况，大致估算出找到所需的记录所需要读取的行数 行数越小越好 10)Extra其他额外信息包含不适合在其他列中显示但十分重要的额外信息 1.Using filesort 说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL中无法利用索引完成排序操作成为“文件排序”（需要优化） 2.Using temporary 使用了临时表保存中间结果，MySQL在对查询结果排序时使用临时表。常见于排序order by 和分组查询 group by (需要优化) 3.Using index 表示相应的select操作中使用了覆盖索引（Coveing Index）,避免访问了表的数据行，效率不错！如果同时出现using where，表明索引被用来执行索引键值的查找；如果没有同时出现using where，表面索引用来读取数据而非执行查找动作。 4.Using where 表面使用了where过滤 5.using join buffer 使用了连接缓存 6.impossible where where子句的值总是false，不能用来获取任何元组 7.select tables optimized away 在没有GROUPBY子句的情况下，基于索引优化MIN/MAX操作或者对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。 8.distinct 优化distinct，在找到第一匹配的元组后即停止找同样值的工作 8、JOIN表的联合优化1)单表 范围索引导致索引失效。即查询的时候如果查询的范围字段建立了索引，那么会索引失效。应该避开范围字段索引的建立 测试表 12345678910111213141516drop table if EXISTS article;CREATE TABLE IF NOT EXISTS `article`(`id` INT(10) UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT,`author_id` INT (10) UNSIGNED NOT NULL,`category_id` INT(10) UNSIGNED NOT NULL , `views` INT(10) UNSIGNED NOT NULL , `comments` INT(10) UNSIGNED NOT NULL,`title` VARBINARY(255) NOT NULL,`content` TEXT NOT NULL);INSERT INTO `article`(`author_id`,`category_id` ,`views` ,`comments` ,`title` ,`content` )VALUES(1,1,1,1,'1','1'),(2,2,2,2,'2','2'),(3,3,3,3,'3','3');SELECT * FROM ARTICLE;show index from article; 1234567891011121314151617# type:全表扫描, extra:using filesortexplain select id,author_id from article where category_id=1 and comments&gt;1 order by views desc limit 1;#建立 category_id和comments和views的联合索引create index idx_article_ccv on article(category_id,comments,views);#再次查看执行计划 type:range, extra:using filesortexplain select id,author_id from article where category_id=1 and comments&gt;1 order by views desc limit 1;#删除原来的索引drop index idx_article_ccv on article;#建立 category_id和views的联合索引. 即不对范围的字段建立索引alter table article add index idx_article_cv(category_id,views);#再次查看执行计划 type:ref, extra:Using whereexplain select id,author_id from article where category_id=1 and comments&gt;1 order by views desc limit 1;#得出结论：范围索引导致索引失效。即查询的时候如果查询的范围字段建立了索引，那么会索引失效。应该避开范围字段索引的建立 2)两表 得出结论，我们使用左连接时，即以左表为主表时，需建立右表索引。得出结论，我们使用右连接时，即以右表为主表时，需建立左表索引。即我们可以为 两个表都加索引 测试表 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849CREATE TABLE IF NOT EXISTS `class`(`id` INT(10) UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT,`card` INT (10) UNSIGNED NOT NULL);CREATE TABLE IF NOT EXISTS `book`(`bookid` INT(10) UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT,`card` INT (10) UNSIGNED NOT NULL);INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO class(card)VALUES(FLOOR(1+(RAND()*20))); INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO book(card)VALUES(FLOOR(1+(RAND()*20))); 1234567891011121314151617# 执行查询计划explain SELECT * from book left JOIN class on book.card=class.card;#建立左表的索引alter table book add index b(card);# row:总共为40; 左表使用了索引，右表为全表扫描explain SELECT * from book left JOIN class on book.card=class.card;#删除左表的索引drop index b on book;#建立右表的所索引create index c on class(card);#再次执行查询计划，左表进行全表扫描，右表type:ref; 右表使用了索引， rows：总共为21explain SELECT * from book left JOIN class on book.card=class.card;#得出结论，我们使用左连接时，即以左表为主表时，需建立右表索引。#得出结论，我们使用右连接时，即以右表为主表时，需建立左表索引。# 即我们可以为 两个表都加索引 3)三表 当我们join联立多张表时，建立在其它表的索引即可。 1234567891011121314151617181920212223242526# 在上面两表的基础上增加一个表CREATE TABLE IF NOT EXISTS `phone`(`phoneid` INT(10) UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT,`card` INT (10) UNSIGNED NOT NULL)ENGINE = INNODB;INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20)));INSERT INTO phone(card)VALUES(FLOOR(1+(RAND()*20))); 123456789101112show index from class;show index from book;2show index from phone;#执行查询计划。三张表都没有使用索引，type都是all全表扫描 rows：总共为 60EXPLAIN SELECT * from class left JOIN book on book.card=class.card left JOIN phone on book.card=phone.card;#为leftjon的第二和第三张表建立索引create index b on book(card);alter table phone add index p(card);#再次执行查询计划，发现 第二和第三张表使用了索引 rows：总共为20+1+1=22EXPLAIN SELECT * from class left JOIN book on book.card=class.card left JOIN phone on book.card=phone.card;#当我们join联立多张表时，建立在其它表的索引即可。 总结 尽可能减少join语句中的nestedloop的循环总次数：永远用小结果集驱动大结果集 优先优化nestedloop的内存循环 保证join语句中被驱动表上join条件字段已经被索引 当无法保证被驱动表的join条件字段被索引且内存充足的前提下，不要太吝啬joinbuffer的设置 9、索引的失效及优化 表 1234567891011CREATE TABLE staffs(id INT PRIMARY KEY AUTO_INCREMENT,`name` VARCHAR(24)NOT NULL DEFAULT'' COMMENT'姓名',`age` INT NOT NULL DEFAULT 0 COMMENT'年龄',`pos` VARCHAR(20) NOT NULL DEFAULT'' COMMENT'职位',`add_time` TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT'入职时间')CHARSET utf8 COMMENT'员工记录表';INSERT INTO staffs(`name`,`age`,`pos`,`add_time`) VALUES('z3',22,'manager',NOW());INSERT INTO staffs(`name`,`age`,`pos`,`add_time`) VALUES('ls',22,'manager',NOW());INSERT INTO staffs(`name`,`age`,`pos`,`add_time`) VALUES('July',23,'dev',NOW());INSERT INTO staffs(`name`,`age`,`pos`,`add_time`) VALUES('2000',23,'dev',NOW()); 1)全索引匹配 即建立的索引全部用上 2)最佳左前缀法则 使用select * 时需要符合最佳左前缀法则。但是使用select 索引字段时，需要符合最佳左前缀法则或者覆盖索引规则 如果索引了多例，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列。order by的字段和group by也要遵守最左前缀法则(必须为从左到右的顺序，否则索引order by/group by后面的索引字段失效)，若前面的索引失效，则需要在order by和group by的后建立起完整的左前缀规范 必须使用到联合索引的第一个索引，索引才有效。如果只使用第一二四个索引，那么中间缺失的索引和后面的索引列会失效，此时只会用到第一二个索引。 123456789101112131415161718#建立 name和age和pos的联合索引alter table staffs add index idx_nameAgePos(name,age,pos);# 索引失效的情况# 用到联合索引的第二和第三个，没有用到第一个 type:all全表扫描 EXPLAIN SELECT * from staffs where age=22 and pos='manager'; # 只用到联合索引的第二个 或者 第三个 type:all全表扫描 EXPLAIN SELECT * from staffs where pos='manager'; # 索引有效的情况# 联合索引的字段全部用到 type:ref key:idx_nameAgePosEXPLAIN SELECT * from staffs where pos='manager' and age=22 and name='ls' # 只用到联合索引的第一个和第三个，第二个字段缺失。那么只会使用到第一个索引。EXPLAIN SELECT * from staffs where name='ls' and pos='manager';# 只用到联合索引的第一个和第二个，那么只会使用到第一个和第二个索引。EXPLAIN SELECT * from staffs where name='ls' and age=22;# 只用到联合索引的第一个，那么只会使用到第一个索引。EXPLAIN SELECT * from staffs where name='ls'; 3)不在索引列上做任何操作（计算、函数、（自动or手动）类型转换），会导致索引失效而转向全表扫描4)存储引擎不能使用索引中范围条件右边的列 即使用的范围自字段的索引，那么范围字段后面的字段索引将会失效 123456# key_len=74EXPLAIN SELECT * from staffs where name='ls';# key_len=78 type=rangeEXPLAIN SELECT * from staffs where name='ls' and age&gt;22 # key_len=78 type=range 即范围索引后面的字段索引失效，即只使用到了name和age索引 EXPLAIN SELECT * from staffs where name='ls' and age&gt;22 and pos='manager' 5)尽量使用覆盖索引（只访问索引的查询（索引列和查询列一致）），减少select* 在select后面使用任一索引字段按需查询效率得到提升 12345# extra:Using indexEXPLAIN SELECT name,age,pos from staffs where name='ls' and age&gt;22# extra:Using index condition EXPLAIN SELECT * from staffs where name='ls' and age&gt;22 #结论：在select查询后面，使用索引的查询列比使用*多了 Using index，即效果会更好。 若where的条件不符合最佳左前缀法则， where使用第二三个索引，但是select后面满足覆盖索引的条件，则结果都可以用 到索引 6)mysql在使用不等于（！=或者&lt;&gt;）的时候无法使用索引会导致全表扫描 使用！=或者&lt;&gt; 导致全表扫描，但是根据具体业务情况分析，该得用的时候还是得用 1234# type:all 全表扫描EXPLAIN SELECT * from staffs where name!='ls'# type:all 全表扫描EXPLAIN SELECT * from staffs where name&lt;&gt;'ls' 7)is null,is not null 也无法使用索引1234# type:null 索引失效EXPLAIN SELECT * from staffs where name is null# type:all 全表扫描EXPLAIN SELECT * from staffs where name is not null 8)like以通配符开头（’$abc…’或者’%abc..’）mysql索引失效会变成全表扫描操作解决办法： like匹配的 % 写右边 即可避免全表扫描 即 like ‘a%’ 问题：解决like ‘%字符串%’ 索引不被使用的方法？？即在like后面的字段 前后都加%abc% 可以使用主键索引 使用覆盖索引，查询字段必须是建立覆盖索引字段 ,即查询的字段属于建立的复合索引的子集或本身。否则使用 select * 或者查询到索引外的字段那么会全表扫描 当覆盖索引指向的字段是varchar(380)及380以上的字段时，覆盖索引会失效！ 12345678910111213141516171819202122232425262728CREATE TABLE `tbl_user`(`id` INT(11) NOT NULL AUTO_INCREMENT,`name` VARCHAR(20) DEFAULT NULL,`age`INT(11) DEFAULT NULL,`email` VARCHAR(20) DEFAULT NULL,PRIMARY KEY(`id`))ENGINE=INNODB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;INSERT INTO tbl_user(`name`,`age`,`email`)VALUES('1aa1',21,'a@163.com');INSERT INTO tbl_user(`name`,`age`,`email`)VALUES('2bb2',23,'b@163.com');INSERT INTO tbl_user(`name`,`age`,`email`)VALUES('3cc3',24,'c@163.com');INSERT INTO tbl_user(`name`,`age`,`email`)VALUES('4dd4',26,'d@163.com');# 创建 name和age的联合索引alter table tbl_user add index idx_nameAge(name,age);#extra:Using where; Using index 使用到了索引#id使用了主键索引。name,age使用的联合索引explain SELECT id,name,age from tbl_user where name like '%a%';#extra:Using where; Using index 使用到了索引#name使用了覆盖索引。即select的字段是索引字段explain SELECT name from tbl_user where name like '%a%';#type:all全表扫描。索引失效#email没有建立索引，导致索引失效explain SELECT id,name,age,email from tbl_user where name like '%a%';explain SELECT * from tbl_user where name like '%a%'; 9)字符串不加单引号索引失效 底层会自动进行类型转换 123#type:all全表扫描，extra:Using where# 索引失效EXPLAIN SELECT * from staffs where name=2000; 10)少用or,用它连接时会索引失效123#type:all全表扫描，extra:Using where# 索引失效EXPLAIN SELECT * from staffs where name='july' or name='2000' 11)like KK%相当于=常量 ，而%KK和%KK% 相当于范围 即只要like后面的字段 不以%开头，即算是定值，都能后续索引都有效 若以%开头，那么当前%的字段索引和后续索引即全部失效，相当于范围字符 10、索引面试题分析123456789101112131415create table test03(id int primary key not null auto_increment,c1 char(10),c2 char(10),c3 char(10),c4 char(10),c5 char(10));insert into test03(c1,c2,c3,c4,c5) values ('a1','a2','a3','a4','a5');insert into test03(c1,c2,c3,c4,c5) values ('b1','b2','b3','b4','b5');insert into test03(c1,c2,c3,c4,c5) values ('c1','c2','c3','c4','c5');insert into test03(c1,c2,c3,c4,c5) values ('d1','d2','d3','d4','d5');insert into test03(c1,c2,c3,c4,c5) values ('e1','e2','e3','e4','e5');create index idx_test03_c1234 on test03(c1,c2,c3,c4); 1、全匹配的索引字段与顺序无关，MYSQL底层会自动帮我们进行重排 底层自动重排序，与顺序无关 12#索引全部有效EXPLAIN SELECT * from test03 where c1='a1' and c2='a2' and c4='a4' and c3='a3' 2、范围之后全失效，范围索引也会重排序 底层MYSQL对索引重排序后顺序为 c1,c2,c3,c4 虽然从c4范围索引后失效，但是c4重排序后面并无其他索引。所以索引全部有效 12#索引全部有效EXPLAIN SELECT * from test03 where c1='a1' and c2='a2' and c4&gt;'a4' and c3='a3' 3、order by必须按照顺序索引排列，当where中的索引字段在order by中时，order by中的索引字段可忽略。当where中的范围索引失效时，需要在order by中重新补上索引来保证其顺序 1234567891011#因为c2是常量，所以我们在order by中的c2无效，即order by被优化为c3，所以我们使用的索引为 c1,c2,c3 (其中c1,c2用于查找，c3用于排序)EXPLAIN SELECT * from test03 where c1='a1' and c2='a2' and c5='a5' order by c3,c2#因为我们只用到了c1,在order by中必须按照索引顺序，所有这里我们只用到c1索引。extra: Using filesort 产生文件排序EXPLAIN SELECT * from test03 where c1='a1' and c5='a5' order by c3,c2#where中c1索引有效，order by按照顺序索引，则c1,c2,c3都有效，（其中c1用于查找，c2,c3用于排序）EXPLAIN SELECT * from test03 where c1='a1' and c5='a5' order by c2,c3#where中的c2后范围索引失效，在roder by 中需要重新补上索引c2#EXPLAIN SELECT * from test03 where c1='a1' and c2&gt;'a2' and c5='a5' order by c2,c3 4、group 也必须按照顺序索引排序，和order by的用法一致 123456# c1,c2,c3索引有效（其中c1用于查找，c2,c3用于分组）EXPLAIN SELECT * from test03 where c1='a1' and c4='a4' GROUP BY c2,c3#因为我们只用到了c1,在group by中必须按照索引顺序，所有这里我们只用到c1索引。extra: Using temporary; 产生临时表 Using filesort 产生文件排序EXPLAIN SELECT * from test03 where c1='a1' and c4='a4' GROUP BY c3,c2#因为c1是常量，所以我们在group by中的c2无效，即group by被优化为c3，所以我们使用的索引为 c1,c2,c3 (其中c1,c2用于查找，c3用于分组)EXPLAIN SELECT * from test03 where c1='a1' and c2='a2' and c4='a4' GROUP BY c3,c2 where和 order by/group by中的索引字段相互独立，只需保证where中的有效索引字段和order by/group by中的索引字段有序即可11、小表驱动大表小表驱动大表，即小的数据集驱动大的数据集 当b表的数据集小于a表的数据集时，用in优于exists select * from a where id in(select id from b) 等价于 for select id from b for select * from a where a.id=b.id &lt;!--￼37--&gt; 注意：a表与b表的id字段应建立索引 exists理解 select ... from table where exists(subquery) 将主查询的数据，放到子查询中做条件验证，根据验证结果（true或false）来决定主查询的数据结果是否得以保留 12、为order by/group by排序使用索引Mysql两种排序方式：文件排序(using filesort需要优化)或有序索引排序 Mysql能为排序与查询使用相同的索引 建立索引 KEY_a_b_c(a,b,c) order by 能使用索引最左前缀法则。没有where的情况，select后的字段满足覆盖索引 order by a order by a,b order by a,b,c order by a desc ,b.desc，c.desc 同为升序或降序 如果where使用索引的最左前缀定义为常量，则oder by能使用索引，可以使用 select * where a =const order by b,c where a =const and b=const order by c where a =const order by b,c where a=const and b&gt;const order by b,c #b范围索引及其后面失效，所以在order by上要补上失效的索引 不能使用索引进行排序的情况 order by a asc,b desc, c desc #排序不一致 where g=const order by b,c #不满足最左前缀法则，丢失a索引 where a=const order by c #丢失b索引 where a=const order by a,d #d不是索引的一部分 select * from 表名 order a,b,c #select后的字段必须满足覆盖索引的情况，否则filesort where a in(…) order by b,c #a也相当于范围索引，即a后面的索引失效，即order by缺失a索引 三、慢查询日志SQL（1）MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句，具 体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。 （2）具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为 10，意思是运行10秒以上的语句。 （3）由他来查看哪些SQL超出了我们的最大忍耐时间值，比如一条sql执行超过5秒钟，我们就算慢SQL，希望能 收集超过5秒的sql，结合之前explain进行全面分析。 1、开启慢查询日志默认情况下，MySQL 数据库没有开启慢查询日志，需要我们手动来设置这个参数。 当然，如果不是调优需要的话，一般不建议启动该参数，因为开启慢查询日志会或多或少带来一定的性能影响。慢查询日志支持将日志记录写入文件。 临时开启 SQL 语句 描述 备注 SHOWVARIABLESLIKE’%slow_query_log%’; 查看慢查询日志是否开启 默认情况下 slow_query_log 的值为 OFF，表示慢查询日志是禁用的 set global slow_query_log=1; 开启慢查询日志 SHOW VARIABLES LIKE ‘long_query_time%’; 查看慢查询设定阈值 单位秒 setlong_query_time=1 设定慢查询阈值 单位秒 永久开启(配置文件my.ini) 12345[mysqld] slow_query_log=1 slow_query_log_file=/var/lib/mysql/atguigu-slow.log long_query_time=3 log_output=FILE 运行查询时间长的 sql，打开慢查询日志查看 测试 我们设置3s为日志慢查询sql 1set long_query_time=3 123#使用sleep测试超过3s的sql的执行select sleep(4);select sleep(5); 查看慢查询sql日志文件 D:\\mysql-5.7.24-winx64\\data\\LAPTOP-LJJM9R29-slow.log 1234567891011121314MySQL, Version: 5.7.24 (MySQL Community Server (GPL)). started with:TCP Port: 3306, Named Pipe: MySQLTime Id Command Argument# Time: 2020-07-31T10:01:19.381079Z# User@Host: root[root] @ localhost [::1] Id: 5# Query_time: 4.000882 Lock_time: 0.000000 Rows_sent: 1 Rows_examined: 0use index_test;SET timestamp=1596189679;select sleep(4);# Time: 2020-07-31T10:01:54.843723Z# User@Host: root[root] @ localhost [::1] Id: 5# Query_time: 5.000658 Lock_time: 0.000000 Rows_sent: 1 Rows_examined: 0SET timestamp=1596189714;select sleep(5); 2、使用日志分析工具 mysqldumpslow（1） 查看mysqldumpslow的帮助信息 （2） 常用命名 1234567891011#得到返回记录集最多的 10 个 SQL mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log#得到访问次数最多的 10 个 SQL mysqldumpslow -s c -t10 /var/lib/mysql/atguigu-slow.log#得到按照时间排序的前 10 条里面含有左连接的查询语句 mysqldumpslow -s t -t 10 -g \"leftjoin\" /var/lib/mysql/atguigu-slow.log#另外建议在使用这些命令时结合 | 和 more 使用 ，否则有可能出现爆屏情况 mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log|more 四、show profile 查看SQL执行周期利用showprofile 可以查看 sql 的执行周期！ 1、开启profile查看 profile 是否开启：show variables like'%profiling%' 如果没有开启，可以执行 set profiling=1开启！ 2、使用profile执行 show prifiles 命令，可以查看最近的几次查询。 根据 Query_ID,可以进一步执行 show profile cpu,block io for query Query_id 来查看 sql 的具体执行步骤。 1show profile cpu,block io for query 115 五、MySQL锁机制1、锁的分类1)从数据操作的类型（读、写）分 读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响 写锁（排它锁）：当前写操作没有完成前，它会阻断其他写锁和读锁。 2)从对数据操作的颗粒度 表锁(偏读) 开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。 行锁(偏写) 开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。 页锁 (了解) 开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般 存储引擎 行锁 页锁 表锁 MyISAM Y InnoDB Y Y 2、表锁(MyISAM偏读)1)特点偏向MyISAM存储引擎，开销小，加锁快，无死锁，锁定粒度大，发生锁冲突的概率最高，并发最低 2)案例123456789101112131415use big_data;#注意这里我们创建myisam的数据库引擎create table mylock (id int not null primary key auto_increment,name varchar(20) default '') engine myisam;insert into mylock(name) values('a');insert into mylock(name) values('b');insert into mylock(name) values('c');insert into mylock(name) values('d');insert into mylock(name) values('e');select * from mylock; 查看表的加锁情况: 1show open tables; 为表加写锁或者读锁： lock table 表名 write/read,表名2 write/read; 12#给mylock加写锁, book表加读锁lock table mylock read,book write; 当In_use为1时，代表此表加了锁，为0时没有加锁 释放所有锁(解锁) 1unlock tables; 读锁案例解析(共享锁) 写锁案例解析(排它锁) 3)结论(基于MyISAM)MyISAM在执行查询语句前，会自动给涉及的所有表加读锁，在执行增删改操作前，会自动给锁涉及的表加写锁 对MyISAM表的读操作(加读锁)，不会阻塞其他进程对同一表的读请求，但会阻塞对同一表的写请求，只有当读锁释放后，才会执行其他进程的写操作 对MyISAM表的写操作(加写锁)，会阻塞其他进程对同一表的读和写请求，只有当写锁释放后，才会执行其他进程的读和写操作 简而言之 —- 读锁阻塞其他进程的写操作，不会阻塞读操作。写锁会阻塞其他进程的读和写操作 4)分析表锁的情况1show status like 'table%'; Table_locks_immediate 产生表级锁定的次数，表示可以立即获得锁的查询次数，每立即获得锁值加1 Table_locks_waited 出现表级锁定而发生等待的次数(不能立即获取锁的次数，每等待一次锁值加1)，此值高则说明存在较严重的表级锁争用情况 所以Myisam的读写锁调度是写优先，这也是myisam不适合做写主表的引擎。因为锁表后，其他线程不能做任何操作，大量的更新会使查询难得到锁，从而造成永远阻塞。所以myisam偏向做读锁表 3、行锁(InnoDB偏写)偏向InnoDB存储引擎，开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。 InnoDB与MyISAM的最大不同点，InnoDB支持事务，InnoDB采用的是行级锁 1)创建行锁的条件 表中创建索引， select 。。。 where 字段（必须是索引） 不然行锁就无效。 必须要有事务，这样才是行锁（排他锁） 2)行锁案例注意引擎为INNODB，且行锁存在的条件时必须有索引(索引必须有效)和必须有事务 123456789101112CREATE TABLE test_innodb_lock (a INT(11),b VARCHAR(16))ENGINE=INNODB;INSERT INTO test_innodb_lock VALUES(1,'b2');INSERT INTO test_innodb_lock VALUES(3,'3');INSERT INTO test_innodb_lock VALUES(4, '4000');INSERT INTO test_innodb_lock VALUES(5,'5000');INSERT INTO test_innodb_lock VALUES(6, '6000');INSERT INTO test_innodb_lock VALUES(7,'7000');INSERT INTO test_innodb_lock VALUES(8, '8000');INSERT INTO test_innodb_lock VALUES(9,'9000');INSERT INTO test_innodb_lock VALUES(1,'b1');CREATE INDEX test_innodb_a_ind ON test_innodb_lock(a);CREATE INDEX test_innodb_lock_b_ind ON test_innodb_lock(b); 可重复读 行锁—修改同一行数据阻塞 行锁–修改不同行数据正常 行锁升级为表锁—无索引/索引失效 3)分析行锁show status like 'innodb_row_lock%'; 4、间隙锁(InnoDB)12345678910111213drop TABLE if EXISTS test_innodb_lock CREATE TABLE test_innodb_lock (a INT(11),b VARCHAR(16))ENGINE=INNODB;INSERT INTO test_innodb_lock VALUES(1,'b2');INSERT INTO test_innodb_lock VALUES(3,'3');INSERT INTO test_innodb_lock VALUES(4, '4000');INSERT INTO test_innodb_lock VALUES(5,'5000');INSERT INTO test_innodb_lock VALUES(6, '6000');INSERT INTO test_innodb_lock VALUES(7,'7000');INSERT INTO test_innodb_lock VALUES(8, '8000');INSERT INTO test_innodb_lock VALUES(9,'9000');INSERT INTO test_innodb_lock VALUES(1,'b1');CREATE INDEX test_innodb_a_ind ON test_innodb_lock(a);CREATE INDEX test_innodb_lock_b_ind ON test_innodb_lock(b); 【什么是间隙锁？】 当我们用范围条件而不是相等条件检索数据，并请求共享和排它锁时，InnoDB会给符合条件的已有数据记录的索引项加锁；对于键值在条件范围内但并不存在的记录，叫做间隙(GAP) 【间隙锁的危害】 因为where条件在检索的通过范围查找的话，它会锁定整个范围内所有的索引键值，即使这个键值不存在。 当锁定一个范围键值后，即使某些不存在的键值也会被锁定，而造成锁定的时候无法在锁定健值范围内的任何数据进行删除/更新/插入操作。在某些场景下对性造成极大伤害 5、for update锁定某一行数据使用select * from …. for update 锁定某行数据，前它会话的操作会被阻塞，直到该会话提交 六、MySQL主从复制待续….","link":"/2020/08/07/mysql/MySQL%E8%BF%9B%E9%98%B6/"},{"title":"Spring注解驱动","text":"一、组件注册1、@Bean和@Configuration @Bean 注册bean到容器中 方法返回类型为相当于bean中的class属性 方法名称默认为相当于bean中的id属性 通过 @Bean(name/value = &quot;person01&quot;) 方式指定bean的id属性 @Configuration 相当于xml文件 1)传统注册bean的方式： 实体 123456789@Getter@Setter@ToString@NoArgsConstructor@AllArgsConstructorpublic class Person { private String name; private Integer age;} xml 123456789&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean class=\"org.lc.entity.Person\" id=\"person\"&gt; &lt;property name=\"age\" value=\"12\"&gt;&lt;/property&gt; &lt;property name=\"name\" value=\"张三\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 12345678public class T1 { public static void main(String[] args) { //xml方式注册bean并获取bean ApplicationContext classPathXmlApplicationContext = new ClassPathXmlApplicationContext(\"bean.xml\"); Person person = ((Person) classPathXmlApplicationContext.getBean(\"person\")); System.out.println(person); }} 2)基于注解的注册：12345678910111213//使用@Configuration注册该类为配置文件（相当于xml配置文件）@Configurationpublic class BeanConfiguration { //使用@Bean注册到容器 （相当于bean注册到xml中） //默认方法返回的类型为 bean中的class //方法的名称为 bean中的id //name属性指定bean的id名称 @Bean(name = \"person01\") public Person person() { //直接new对象方式为属性赋值 return new Person(\"张三\",20); }} 123456789101112public class T1 { public static void main(String[] args) { //注解方式注册并获取bean //获取该配置文件对象 ApplicationContext annotation = new AnnotationConfigApplicationContext(BeanConfiguration.class); //获取指定的bean对象 Person bean = annotation.getBean(Person.class); //获取该bean的id名称 String[] beanDefinitionNames = annotation.getBeanNamesForType(bean.getClass()); System.out.println(Arrays.toString(beanDefinitionNames)); }} 2、@Component和@Configuration注册组件区别https://blog.csdn.net/isea533/article/details/78072133 测试Bean 12public class Country {} 12345678910@Getter@Setterpublic class UserInfo { private Country country; public UserInfo(Country country) { this.country = country; } public UserInfo() { }} 1)使用@Component1234567891011@Componentpublic class MyBeanConfig { @Bean public Country country() { return new Country(); } @Bean public UserInfo userInfo() { return new UserInfo(country()); }} 获取UserInfo中的Country对象 1234567public static void main(String[] args) { ApplicationContext annotation = new AnnotationConfigApplicationContext(MyBeanConfig.class); Country Country= annotation.getBean(Country.class); UserInfo userInfo= annotation.getBean(UserInfo.class); //false System.out.println(Country==userInfo.getCountry());} 我们发现通过在@Component中注册的组件Country在同类配置直接使用的时候并不是单例的，且country()并不会被Spring代理，会直接调用country()方法获取一个全新的Country对象实例，所以全局会有多个Country对象的实例。而new UserInfo(country())只是纯JAVA方式的调用，多次调用该方法返回的是不同的对象实例。 解决方式通过注入的方式得到单例对象引用即可 12345678910111213141516@Componentpublic class MyBeanConfig { //通过注入即得到单例对象 @Autowired private Country country; @Bean public Country country() { return new Country(); } @Bean public UserInfo userInfo() { return new UserInfo(country); }} 1234567public static void main(String[] args) { ApplicationContext annotation = new AnnotationConfigApplicationContext(MyBeanConfig.class); Country Country= annotation.getBean(Country.class); UserInfo userInfo= annotation.getBean(UserInfo.class); //true System.out.println(Country==userInfo.getCountry());} 2)使用@Configuration1234567891011@Configurationpublic class MyBeanConfig { @Bean public Country country() { return new Country(); } @Bean public UserInfo userInfo() { return new UserInfo(country()); }} 12345ApplicationContext annotation = new AnnotationConfigApplicationContext(MyBeanConfig.class);Country Country= annotation.getBean(Country.class);UserInfo userInfo= annotation.getBean(UserInfo.class);//trueSystem.out.println(Country==userInfo.getCountry()); 我们发现通过在@Configuration中注册的组件Country在同类配置直接使用的时候是单例的，因为new UserInfo(country())这段代码中country()方法会由Spring代理执行，Spring发现方法所请求的Bean已经在容器中，那么就直接返回容器中的Bean。所以全局只有一个Country对象的实例。 ​ 在@Configuration中注册的Bean标记的方法会被包装成CGLIB的wrapper，其工作原理是:如果方式是首次被调用那么原始的方法体会被执行并且结果对象会被注册到Spring上下文中。之后所有的对该方法的调用仅仅只是从Spring上下文中取回该对象返回给调用者。 3、@ComponentScan包扫描的使用1234//修改默认规则为false(默认规则时扫描所有)，只扫描注解为@controller@ComponentScan(basePackages = \"org.lc\",useDefaultFilters = false,includeFilters = { @ComponentScan.Filter(type = FilterType.ANNOTATION,classes ={Controller.class} )}) 1234//注解类型的，且为@Controller注解的不扫描@ComponentScan(basePackages = \"org.lc\",excludeFilters = { @ComponentScan.Filter(type = FilterType.ANNOTATION,classes = {Controller.class})}) @ComponentScan为可重复注解即可以使用@ComponentScans包含多个扫描器 1234@ComponentScans({ @ComponentScan(basePackages = \"org.lc\"), @ComponentScan(basePackages = \"org.lc\")}) FilterType过滤类型介绍： FilterType.ANNOTATION:按照注解过滤 FilterType.ASSIGNABLE_TYPE : 按照类型进行过滤 1@ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE,classes = {EmployeeService.class}) FilterType.REGEX 按照正则表达式过滤 FilterType.CUSTOM 自定义规则 @ComponentScan(basePackages = \"org.lc\",useDefaultFilters = false,includeFilters = { @ComponentScan.Filter(type = FilterType.CUSTOM,classes = {MyFilter.class}) }) 123456789101112131415161718192021222324- ```java //需要实现 TypeFilter接口 public class MyFilter implements TypeFilter { @Override public boolean match(MetadataReader metadataReader, MetadataReaderFactory metadataReaderFactory) throws IOException { //获取当前类的注解的信息 AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata(); //获取当前正在扫描的类的class类信息 ClassMetadata classMetadata = metadataReader.getClassMetadata(); //获取当前类资源（路径） Resource resource = metadataReader.getResource(); //获取当前类的类名 String className = classMetadata.getClassName(); System.out.println(&quot;------:&quot;+className); //自定义类名中包含为'er'的字符串就加入到容器中 if (className.contains(&quot;er&quot;)) { return true; } //返回true 扫描到容器中 //返回true 不扫描到容器中 return false; } } @Test public void Test2(){ AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(SpringApplication.class); String[] beanDefinitionNames = applicationContext.getBeanDefinitionNames(); for (String s : beanDefinitionNames) { System.out.println(s); } } } &lt;!--￼18--&gt; @Test public void Test3(){ ApplicationContext annotation = new AnnotationConfigApplicationContext(MyBeanConfig1.class); Person bean = annotation.getBean(Person.class); Person bean1 = annotation.getBean(Person.class); //false System.out.println(bean==bean1); } &lt;!--￼19--&gt; 6、@Conditional按条件注册bean@Conditional注解中传入一个Condition接口实例类，通过matches方法返回true或false。如果方法返回true，则该条件下的bean配置生效。如果返回false，则bean配置失效 @Conditional 在类上 若实现Condition接口中的matches方法返回false，则该配置类中的所有bean都不会生效(都不会注册到IOC容器中) @Conditional 在bean方法上 若若实现Condition接口中的matches方法返回false，则该bean不会生效(不会注册到IOC容器中) 配置类 123456789101112131415161718192021//若WindowsCondition中的matches为false则该配置下的所有bean不生效@Conditional({WindowsCondition.class})@Configurationpublic class MyBeanConfig2 { //如果操作系统是linux 则给容器注册@Bean(\"linas-tuoa\") //如果操作系统是windows 则给容器注册@Bean(\"bill-gaci\") //传入一个Condition接口实例类，通过matches方法返回true或false @Conditional({WindowsCondition.class}) @Bean(\"bill-gaci\") public Person person1() { return new Person(\"比尔-盖茨\", 60); } @Conditional(LinuxCondition.class) @Bean(\"linas-tuoa\") public Person person2() { return new Person(\"林纳斯·托瓦兹\", 60); }} 条件类 1234567891011121314151617181920212223242526272829public class WindowsCondition implements Condition { /** * 返回true则条件生效(该配置生效)，返回false则条件不生效(配置失效) * @param conditionContext 判断条件能使用的上下文(环境) * @param annotatedTypeMetadata 注释信息 * @return */ @Override public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) { //获取当前ioc使用的bean工厂 ConfigurableListableBeanFactory beanFactory = conditionContext.getBeanFactory(); //获取类加载器 ClassLoader classLoader = conditionContext.getClassLoader(); //获取当前环境信息 Environment environment = conditionContext.getEnvironment(); //获取到bean定义的注册类 。可以判断容器中bean的注册情况，也可以给容器注册bean BeanDefinitionRegistry registry = conditionContext.getRegistry(); //判断当前容器中是否有该bean，传入需要判断的bean的id boolean person = registry.containsBeanDefinition(\"bill-gaci\"); System.out.println(\"++++\"+person); //获取当前的操作系统 String s = environment.getProperty(\"os.name\"); //如果当前时windows则返回true。代表该配置有效 if (s.contains(\"Windows\")) { return true; } return false; }} 12345678910111213141516171819public class LinuxCondition implements Condition { /** * 返回true则条件生效(该配置生效)，返回false则条件不生效(配置失效) * @param conditionContext 判断条件能使用的上下文(环境) * @param annotatedTypeMetadata 注释信息 * @return */ @Override public boolean matches(ConditionContext conditionContext, AnnotatedTypeMetadata annotatedTypeMetadata) { Environment environment = conditionContext.getEnvironment(); //获取当前的操作系统 String s = environment.getProperty(\"os.name\"); //如果当前时linux则返回true。代表该配置有效 if (s.contains(\"linux\")) { return true; } return false; }} 测试 123456789101112131415161718@Testpublic void Test4(){ ApplicationContext annotation = new AnnotationConfigApplicationContext(MyBeanConfig2.class); //获取当前ioc运行的环境，操作系统等属性 Environment environment = annotation.getEnvironment(); //获取操作系统 String property = environment.getProperty(\"os.name\"); System.out.println(\"本操作系统：\"+property); //获取所有的bean的id名称 String[] beanDefinitionNames = annotation.getBeanDefinitionNames(); for (String s : beanDefinitionNames) { System.out.println(s); } //获取该Bean的所有bean对象。 //key为bean的id，value为初始化的对象 Map&lt;String, Person&gt; beansOfType = annotation.getBeansOfType(Person.class); System.out.println(beansOfType);} 可通过启动参数配置本操作系统的虚拟变量 -Dos.name=linux 7、@Import导入组件1)注册组件的三种方式 包扫描(@ComponentScan)+组件标注注解(@Component，@Controller，@Service，@Repository，@Configuration) @Bean【一般导入第三方里面的组件】 @Import【要导入到容器的组件，容器就会自动注册这个组件，bean的id默认为全类名】 public class Red {} public class Green {} &lt;!--￼24--&gt; @Test public void Test5(){ ApplicationContext annotation = new AnnotationConfigApplicationContext(MyBeanConfig3.class); String[] beanDefinitionNames = annotation.getBeanDefinitionNames(); //person //org.lc.custom.Red //org.lc.custom.Green for (String s : beanDefinitionNames) { System.out.println(s); } } &lt;!--￼25--&gt; 123456789101112131415/** * 自定义逻辑返回需要导入的组件 */public class MyImportSelector implements ImportSelector { /** * @param annotationMetadata 当前标注@Import注解上的所有注解信息 * @return */ @Override public String[] selectImports(AnnotationMetadata annotationMetadata) { //默认不能返回null,否则会抛异常 //直接将要导入的组件以全类名写入到数组中 return new String[]{\"org.lc.custom.White\",\"org.lc.custom.Blue\"}; }} 12345678@Configuration@Import({Red.class, Green.class, MyImportSelector.class})public class MyBeanConfig3 { @Bean public Person person() { return new Person(\"张三\",11); }} 12345678910111213@Testpublic void Test5(){ ApplicationContext annotation = new AnnotationConfigApplicationContext(MyBeanConfig3.class); String[] beanDefinitionNames = annotation.getBeanDefinitionNames(); //org.lc.custom.Red // org.lc.custom.Green // org.lc.custom.White // org.lc.custom.Blue // person for (String s : beanDefinitionNames) { System.out.println(s); }} 3)判断bean手动注册bean的规则 ImportBeanDefinitionRegistrar1public class RainBow {} 123456789101112131415161718192021public class MyImportBeanDefinitionRegister implements ImportBeanDefinitionRegistrar { /** * * @param importingClassMetadata 当前类的注解信息 * @param registry 把所有需要添加到容器中的bean,调用BeanDefinitionRegistry.registerBeanDefinition手工注册进来 */ @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) { //判断容器中是否有id为org.lc.custom.Green的bean实例 boolean b = registry.containsBeanDefinition(\"org.lc.custom.Red\"); //判断容器中是否有id为org.lc.custom.Green的bean实例 boolean b1 = registry.containsBeanDefinition(\"org.lc.custom.Green\"); //如果当前容器都有以上两个bean实例，就指定注册一个bean if (b &amp;&amp; b1) { //得到一个bean的定义对象 RootBeanDefinition rootBeanDefinition = new RootBeanDefinition(RainBow.class); //指定注册一个bean,并指定bean的id为rainBow registry.registerBeanDefinition(\"rainBow\",rootBeanDefinition); } }} 123456789@Configuration//注册不分先后顺序，只要在这个Import注解中都认为按照指定规则可以注册到ioc中@Import({Red.class, Green.class,MyImportSelector.class, MyImportBeanDefinitionRegister.class,})public class MyBeanConfig3 { @Bean public Person person() { return new Person(\"张三\",11); }} 1234567891011121314 @Testpublic void Test5(){ ApplicationContext annotation = new AnnotationConfigApplicationContext(MyBeanConfig3.class); //org.lc.custom.Red // org.lc.custom.Green // org.lc.custom.White // org.lc.custom.Blue // person // rainBow String[] beanDefinitionNames = annotation.getBeanDefinitionNames(); for (String s : beanDefinitionNames) { System.out.println(s); }} 8、FactoryBean工厂获取bean对象1public class Color {} 1234567891011121314151617181920212223242526272829303132//创建Color的bean的工厂public class MyFactoryBean implements FactoryBean&lt;Color&gt; { /** * 创建返回实例的bean对象 * @return * @throws Exception */ @Override public Color getObject() throws Exception { System.out.println(\"初始化bean\"); return new Color(); } /** * 返回要创建bean实例的类型 * @return 必须要和getObject()返回的类型对应 */ @Override public Class&lt;?&gt; getObjectType() { return Color.class; } /** * 指定返回的bean是否为单例 * @return true为单例，false为多例 */ @Override public boolean isSingleton() { return false; }} 123456789101112@Configurationpublic class MyBeanConfig4 { /** * 注册工厂到ioc中 * @return */ @Bean public MyFactoryBean myFactoryBean() { return new MyFactoryBean(); }} 1)获取工厂中的bean对象指定的bean为多例 ①通过工厂的bean的id获取指定创建的bean对象 123456789101112@Testpublic void Test6(){ ApplicationContext annotation = new AnnotationConfigApplicationContext(MyBeanConfig4.class); Object myFactoryBean = annotation.getBean(\"myFactoryBean\"); Object myFactoryBean1 = annotation.getBean(\"myFactoryBean\"); //初始化bean // 初始化bean // class org.lc.custom.Color // class org.lc.custom.Color System.out.println(myFactoryBean.getClass()); System.out.println(myFactoryBean1.getClass());} ②直接通过指定创建的bean的类型获取 123456789101112@Testpublic void Test6(){ ApplicationContext annotation = new AnnotationConfigApplicationContext(MyBeanConfig4.class); Object myFactoryBean = annotation.getBean(Color.class); Object myFactoryBean1 = annotation.getBean(Color.class); //初始化bean // 初始化bean // class org.lc.custom.Color // class org.lc.custom.Color System.out.println(myFactoryBean.getClass()); System.out.println(myFactoryBean1.getClass());} 2)获取工厂bean对象①直接通过工厂的类型获取 12345678910@Testpublic void Test6(){ ApplicationContext annotation = new AnnotationConfigApplicationContext(MyBeanConfig4.class); Object myFactoryBean = annotation.getBean(MyFactoryBean.class); Object myFactoryBean1 = annotation.getBean(MyFactoryBean.class); //class org.lc.custom.MyFactoryBean // class org.lc.custom.MyFactoryBean System.out.println(myFactoryBean.getClass()); System.out.println(myFactoryBean1.getClass());} ②通过工厂bean的id前面加上&amp;符号获取工厂bean对象 12345678910@Testpublic void Test6(){ ApplicationContext annotation = new AnnotationConfigApplicationContext(MyBeanConfig4.class); Object myFactoryBean = annotation.getBean(\"&amp;myFactoryBean\"); Object myFactoryBean1 = annotation.getBean(\"&amp;myFactoryBean\"); //class org.lc.custom.MyFactoryBean // class org.lc.custom.MyFactoryBean System.out.println(myFactoryBean.getClass()); System.out.println(myFactoryBean1.getClass());} 二、Bean的生命周期①、通过以下三种方式指定bean的初始化方法和销毁方法：1、使用Bean的initMethod和destroyMethod12345678910111213public class Car { public Car() { System.out.println(\"构造器方法...\"); } public void init() { System.out.println(\"初始化方法...\"); } public void destory() { System.out.println(\"销毁方法...\"); }} 1)单例bean的生命周期 在容器创建的时候调用： bean的构造方法，完成属性赋值—-&gt;bean的初始化方法(initMethod) 在容器close()的时候调用：bean的销毁方法(destroyMethod) 123456789@Configurationpublic class MyBeanConfig5 { //initMethod：指定bend的初始化方法 //destroyMethod: 指定bean的销毁方法 @Bean(initMethod = \"init\",destroyMethod = \"destory\") public Car car() { return new Car(); }} 1234567@Testpublic void Test7(){ //创建容器 AnnotationConfigApplicationContext annotation = new AnnotationConfigApplicationContext(MyBeanConfig5.class); //关闭容器 annotation.close();} 123//初始化ioc容器时即调用构造器方法...初始化方法... 2)多例bean的生命周期 在获取该bean时才调用： bean的构造方法，完成属性赋值—-&gt;bean的初始化方法(initMethod) 在容器close时，bean的销毁方法不由IOC容器控制 12345678910@Configurationpublic class MyBeanConfig5 { //initMethod：指定bend的初始化方法 //destroyMethod: 指定bean的销毁方法 @Scope(\"prototype\") @Bean(initMethod = \"init\",destroyMethod = \"destory\") public Car car() { return new Car(); }} 123456789@Testpublic void Test7(){ //创建容器 AnnotationConfigApplicationContext annotation = new AnnotationConfigApplicationContext(MyBeanConfig5.class); //在多例bean时，获取bean时才会调用构造方法和初始化方法 annotation.getBean(\"car\"); //关闭容器，多例对象的销毁不由IOC控制。 annotation.close();} 123//获取bean时才调用构造器方法...初始化方法... 2、实现InitializingBean和DisposableBean接口我们可以通过实现InitializingBean和DisposableBean接口来实现bean的初始化方法和构造方法 单例 在容器启动的时，调用bean的构造器方法，并完成属性赋值，再调用 afterPropertiesSet初始化方法 ioc容器close时，调用destroy方法 123456789101112131415161718192021222324public class Cat implements InitializingBean, DisposableBean { public Cat() { System.out.println(\"Cat 构造方法...\"); } /** * bean创建完成并且里面的属性赋值完毕就会调用 （相当于初始化方法） * @throws Exception */ @Override public void afterPropertiesSet() throws Exception { System.out.println(\"Cat afterPropertiesSet...\"); } /** * bran销毁调用的方法 * @throws Exception */ @Override public void destroy() throws Exception { System.out.println(\"Cat destory...\"); }} 1234567@Configurationpublic class MyBeanConfig5 { @Bean public Cat cat() { return new Cat(); }} 1234567@Testpublic void Test7(){ //创建容器 AnnotationConfigApplicationContext annotation = new AnnotationConfigApplicationContext(MyBeanConfig5.class); //关闭容器，多例对象的销毁不由IOC控制。 annotation.close();} 123Cat 构造方法...Cat afterPropertiesSet...Cat destory... 3)通过@PostConstruct和@PreDestroy 单例 IOC创建调用构造器方法并完成属性赋值，然后调用被 @PostConstruct标有的初始化方法 IOC调用close时调用 被@PreDestroy标有的销毁方法 12345678910111213141516171819202122public class Pig { public Pig() { System.out.println(\"pig 构造方法...\"); } /** * 构造器创建并完成属性赋值调用init方法 */ @PostConstruct public void init() { System.out.println(\"pig 初始化方法...\"); } /** * 容器移除之前调用的方法 */ @PreDestroy public void destory() { System.out.println(\"pig 销毁方法\"); }} 1234567@Configurationpublic class MyBeanConfig5 { @Bean public Pig pig() { return new Pig(); }} 123pig 构造方法...pig 初始化方法...pig 销毁方法 ②Bean的前后置处理器BeanPostProcessor接口 BeanPostProcessor对所有bean的init初始化方法进行管理，在初始化方法前调用BeanPostProcessor的postProcessBeforeInitialization前置处理器，在初始化方法完成后调用BeanPostProcessor的postProcessAfterInitialization后置处理器。 bean实例 12345678910111213141516171819202122public class Pig { public Pig() { System.out.println(\"pig 构造方法...\"); } /** * 构造器创建并完成属性赋值调用init方法 */ @PostConstruct public void init() { System.out.println(\"pig 初始化方法...\"); } /** * 容器移除之前调用的方法 */ @PreDestroy public void destory() { System.out.println(\"pig 销毁方法\"); }} bean的前后置处理器 1234567891011121314151617181920212223242526272829public class MyBeanPostProcessor implements BeanPostProcessor { /** * 在调用bean值的init初始化方法之前调用postProcessBeforeInitialization前置处理器 * @param bean 当前创建的bean * @param beanName bean的id * @return * @throws BeansException */ @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { System.out.println(\"bean的init前置处理器方法\"); System.out.println(\"bean:\"+bean); System.out.println(\"beanName:\"+beanName); return bean; } /** * 在调用bean值的init初始化方法之后调用postProcessAfterInitialization后置处理器 * @param bean * @param beanName * @return * @throws BeansException */ @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException { System.out.println(\"bean的init后置处理器方法\"); return bean; }} 注册到容器 12345678910111213@Configurationpublic class MyBeanConfig5 { //注册bean实例 @Bean public Pig pig() { return new Pig(); } //注册bean的前置后置处理器 @Bean public MyBeanPostProcessor myBeanPostProcessor() { return new MyBeanPostProcessor(); }} 测试 1234567@Test public void Test7(){ //创建容器 AnnotationConfigApplicationContext annotation = new AnnotationConfigApplicationContext(MyBeanConfig5.class); //关闭容器，多例对象的销毁不由IOC控制。 annotation.close(); } 结果 12345678910111213141516//调用bean的构造方法pig 构造方法...//调用bean的前置处理器bean的init前置处理器方法bean:org.lc.custom.Pig@63a65a25beanName:pig //调用bean指定的init初始化方法pig 初始化方法...//调用bean的后缀处理器方法bean的init后置处理器方法 //调用bean指定的destory销毁方法pig 销毁方法 三、属性赋值1、@Value123456789101112@Getter@Setter@ToString@NoArgsConstructor@AllArgsConstructorpublic class Person { @Value(\"张三\") private String name; //直接写SPEL表达式 @Value(\"#{20-5}\") private Integer age;} 1234567@Configurationpublic class MyBeanConfig5 { @Bean public Person person() { return new Person(); }} 1234567@Testpublic void Test7(){ AnnotationConfigApplicationContext annotation = new AnnotationConfigApplicationContext(MyBeanConfig5.class); Person person = annotation.getBean(Person.class); //Person(name=张三, age=15) System.out.println(person);} 2、@PropertySource 导入properties 配置文件 db.properties文件 1234jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql://localhost:3306/test?serverTimeZone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=falsejdbc.username=rootjdbc.password=123456 12345678910111213@ToString@Getter@Setterpublic class DbDataSource { @Value(\"${jdbc.driver}\") private String driver; @Value(\"${jdbc.url}\") private String url; @Value(\"${jdbc.username}\") private String username; @Value(\"${jdbc.password}\") private String password;} 123456789@Configuration//导入类路径下的db.properties配置到IOC中@PropertySource({\"classpath:db.properties\"})public class SpringConfig1 { @Bean public DbDataSource dbDataSource() { return new DbDataSource(); }} 1234567891011@Testpublic void Test8(){ AnnotationConfigApplicationContext annotation = new AnnotationConfigApplicationContext(SpringConfig1.class); ConfigurableEnvironment environment = annotation.getEnvironment(); String property = environment.getProperty(\"jdbc.url\"); //从环境中获取:jdbc:mysql://localhost:3306/test?serverTimeZone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false System.out.println(\"从环境中获取:\"+property); DbDataSource bean = annotation.getBean(DbDataSource.class); //DbDataSource(driver=com.mysql.jdbc.Driver, url=jdbc:mysql://localhost:3306/test?serverTimeZone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false, username=root, password=123456) System.out.println(bean);} 四、自动装配1、@Autowired @Qualifier2、@Resource3、@Primary1234567891011121314151617@Configurationpublic class SpringConfig1 { @Bean public EmployeeController employeeController() { return new EmployeeController(); } //当@Autowired不指定名称，按照默认规则进行注入时，会注入加@Primary的bean @Primary @Bean public EmployeeService employeeService1() { return new EmployeeService(); } @Bean public EmployeeService employeeService2() { return new EmployeeService(); }} 1234567891011@Controllerpublic class EmployeeController { //默认装配加@Primary的bean @Autowired private EmployeeService employeeServiceOne; //指定其他的bean @Qualifier(\"employeeService2\") @Autowired private EmployeeService employeeServiceTwo;} 4、@Profile 指定组件运行环境 标注在bean上，只有这个环境被激活的时候才能注册到容器中。默认是default环境 标注在配置类上，只有这个环境被激活的时候该配置类注册到容器中 若没有标注在任何bean或配置类上，则该bean和配置类都是加载到容器中的 指定环境参数 使用命令行动态参数指定环境 -Dspring.profiles.active=test 使用代码的方式激活环境 1234567AnnotationConfigApplicationContext annotation = new AnnotationConfigApplicationContext();//设置需要激活的环境 这里设置为proannotation.getEnvironment().setActiveProfiles(\"pro\");//加载主配置类annotation.register(SpringConfig2.class);//启动刷新新容器annotation.refresh(); 多数据源示例 db.properties 123456789jdbc.driver=com.mysql.jdbc.Driver#测试地址jdbc.url_test=jdbc:mysql://localhost:3306/test?serverTimeZone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false#开发地址jdbc.url_dev=jdbc:mysql://localhost:3306/hcg?serverTimeZone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false#生产地址jdbc.url_pro=jdbc:mysql://localhost:3306/hcgnew?serverTimeZone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=falsejdbc.username=rootjdbc.password=123456 12345678910111213141516171819202122@ToString@Getter@Setterpublic class DbDataSource { @Value(\"${jdbc.driver}\") private String driver; //测试地址 @Value(\"${jdbc.url_test}\") private String url_test; //开发地址 @Value(\"${jdbc.url_dev}\") private String url_dev; //生产地址 @Value(\"${jdbc.url_pro}\") private String url_pro; @Value(\"${jdbc.username}\") private String username; @Value(\"${jdbc.password}\") private String password;} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546@Configuration@PropertySource({\"classpath:db.properties\"})public class SpringConfig2 { //存放地址信息的数据源 @Bean public DbDataSource dbDataSource() { return new DbDataSource(); } //测试环境数据源 @Profile(\"test\") @Bean public DruidDataSource druidDataSourceTest() { DruidDataSource druidDataSource=new DruidDataSource(); druidDataSource.setDriverClassName(dbDataSource().getDriver()); druidDataSource.setUrl(dbDataSource().getUrl_test()); druidDataSource.setUsername(dbDataSource().getUsername()); druidDataSource.setPassword(dbDataSource().getPassword()); return druidDataSource; } //开发环境数据源 @Profile(\"dev\") @Bean public DruidDataSource druidDataSourceDev() { DruidDataSource druidDataSource=new DruidDataSource(); druidDataSource.setDriverClassName(dbDataSource().getDriver()); druidDataSource.setUrl(dbDataSource().getUrl_dev()); druidDataSource.setUsername(dbDataSource().getUsername()); druidDataSource.setPassword(dbDataSource().getPassword()); return druidDataSource; } //生产环境数据源 @Profile(\"pro\") @Bean public DruidDataSource druidDataSourcePro() { DruidDataSource druidDataSource=new DruidDataSource(); druidDataSource.setDriverClassName(dbDataSource().getDriver()); druidDataSource.setUrl(dbDataSource().getUrl_pro()); druidDataSource.setUsername(dbDataSource().getUsername()); druidDataSource.setPassword(dbDataSource().getPassword()); return druidDataSource; }} 1234567891011121314151617181920@Testpublic void Test10(){ AnnotationConfigApplicationContext annotation = new AnnotationConfigApplicationContext(); //设置需要激活的环境 这里设置为pro annotation.getEnvironment().setActiveProfiles(\"pro\"); //加载主配置类 annotation.register(SpringConfig2.class); //启动刷新新容器 annotation.refresh(); //获取所有IOC中bean的名称 String[] beanDefinitionNames = annotation.getBeanDefinitionNames(); for (String s : beanDefinitionNames) { System.out.println(s); if (s.contains(\"druidDataSource\")) { DruidDataSource bean = (DruidDataSource) annotation.getBean(s); System.out.println(s+\"的url为:\"+bean.getUrl()); } }} 12druidDataSourceProdruidDataSourcePro的url为:jdbc:mysql://localhost:3306/hcgnew?serverTimeZone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false 五、AOP配置基于注解的AOP配置流程1)目标类 如果目标类不实现接口，则从容器中获取Caculate对象时使用的是CGLIB代理，基于子类的代理 如果目标类实现接口，则需要从容器中获取目标类的接口对象来调用，使用的是jdk动态代理，基于接口的代理 1234567891011121314public class Caculate { public int add(int a, int b) { return a+b; } public int substract(int a, int b) { return a-b; } public int multiply(int a, int b) { return a-b; } public int divide(int a, int b) { return a/b; }} 2)切面配置，指定切面 @Aspect指定切面类 123456789101112131415161718192021222324252627282930313233343536@Aspectpublic class LogUtils { //指定切点表达式 @Pointcut(\"execution(public * org.lc.aop.Caculate.*(..))\") public void pointCut(){ } //指定前置通知 @Before(\"pointCut()\") public void startLog(JoinPoint joinPoint){ //获取方法对象 Signature signature = joinPoint.getSignature(); //获取方法参数 Object[] args = joinPoint.getArgs(); System.out.println(\"执行:【\" + signature.getName() + \"】方法之前的记录,方法的参数列表为【\"+ Arrays.toString(args)+\"】\"); } //返回通知(方法正常返回) 并指定方法返回的结果 @AfterReturning(value = \"pointCut()\",returning = \"object\") public void afterReturnLog(JoinPoint joinPoint,Object object) { System.out.println(\"执行:【\" + joinPoint.getSignature().getName() + \"】方法之后的记录,方法的结果为【\" + object + \"】\"); } //异常通知,并指定异常类型 @AfterThrowing(value = \"pointCut()\", throwing = \"e\") public void exceptionLog(JoinPoint joinPoint, Exception e) { System.out.println(\"【\"+joinPoint.getSignature().getName()+\"】方法抛出的异常为:【\"+e+\"】\"); } //后置通知(无论如何都会执行) @After(\"pointCut()\") public void afterLog(JoinPoint joinPoint) { System.out.println(\"方法【\"+joinPoint.getSignature().getName()+\"】总要执行的记录....\"); }} 3)主配置文件 @EnableAspectJAutoProxy开启基于注解的aop配置 123456789101112131415161718//@EnableAspectJAutoProxy开启基于注解的aop配置@EnableAspectJAutoProxy@Configurationpublic class AopConfig { //注册目标类到容器 @Bean public Caculate caculate() { return new Caculate(); } //注册切面类 @Bean public LogUtils logUtils() { return new LogUti4ls(); }} 4)测试1234567@Testpublic void Test1(){ AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(AopConfig.class); Caculate bean = applicationContext.getBean(Caculate.class); int add = bean.add(1, 2); System.out.println(add);} 1234执行:【add】方法之前的记录,方法的参数列表为【[1, 2]】执行:【add】方法之后的记录,方法的结果为【3】方法【add】总要执行的记录....3 六、事务配置基于注解的事务配置流程1)主配置文件 @EnableTransactionManagement 开启基于注解的事务管理 PlatformTransactionManager 配置事务管理器 123456789101112131415161718192021222324252627282930//扫描包@ComponentScan(basePackages = \"org.lc.tx\")//开启基于注解的事务管理@EnableTransactionManagement@Configurationpublic class TranscationConfig { //注入druid数据源 @Bean public DruidDataSource druidDataSource() { DruidDataSource druidDataSource=new DruidDataSource(); druidDataSource.setDriverClassName(\"com.mysql.jdbc.Driver\"); druidDataSource.setUrl(\"jdbc:mysql://localhost:3306/test?serverTimeZone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=false\"); druidDataSource.setUsername(\"root\"); druidDataSource.setPassword(\"123456\"); return druidDataSource; } //注入操作数据库的jdbc并指定数据源。 @Bean public JdbcTemplate jdbcTemplate() { return new JdbcTemplate(druidDataSource()); } //配置事务管理器 @Bean public PlatformTransactionManager transactionManager() { return new DataSourceTransactionManager(druidDataSource()); }} 2)service/dao层 dao 123456789101112131415161718192021222324252627282930313233343536@Repositorypublic class BookDao { @Autowired private JdbcTemplate jdbcTemplate; /** * 减去某个用户的余额 * @param username * @param money */ public void updataBalance(String username, int money) { String sql = \"update account set balance=balance-? where username=?\"; jdbcTemplate.update(sql, money, username); } /** * 按照ISBN号码获取图书的价格 * @param isbn * @return */ public int getPrice(String isbn) { String sql = \"SELECT price from book where isbn=?\"; return jdbcTemplate.queryForObject(sql,Integer.class, isbn); } /** * 按照ISBN号码减去库存 * 这里我们设置每次减1 * @param isbn */ public void updateStock(String isbn) { String sql = \"update book_stock set stock=stock-1 where isbn=?\"; jdbcTemplate.update(sql, isbn); }} service 123456789101112131415161718192021222324@Servicepublic class BookService { @Autowired private BookDao bookDao; /** * 结账 * @param username * @param isbn */ //在需要回滚的业务方法上加@Transactional注解 // @Transactional public void checkout(String username, String isbn) { //减库存 bookDao.updateStock(isbn); //查询图书价格 int price = bookDao.getPrice(isbn); //减余额 bookDao.updataBalance(username, price); //模拟运行时异常 // int i=1/0; }} 3)测试1234567@Testpublic void Test2(){ AnnotationConfigApplicationContext applicationContext = new AnnotationConfigApplicationContext(TranscationConfig.class); BookService bookService = applicationContext.getBean(BookService.class); bookService.checkout(\"Tom\",\"ISBN-001\"); System.out.println(\"结账成功！\");} 七、基于注解的SSM整合1、pom.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;springmvc_annotation&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;name&gt;springmvc_annotation Maven Webapp&lt;/name&gt; &lt;!-- FIXME change it to the project's website --&gt; &lt;url&gt;http://www.example.com&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.11&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.2.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.2.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;5.2.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;5.2.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-expression&lt;/artifactId&gt; &lt;version&gt;5.2.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.2.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2、Spring配置123456//spring不扫描@Controller容器@ComponentScan(value = \"org.lc\",excludeFilters = { @ComponentScan.Filter(type = FilterType.ANNOTATION,classes = {Controller.class})})public class SpringRootConfig {} 3、SpringMVC配置我们可以实现WebMvcConfigurer接口的对应方法实现对SpringMVC的一些配置 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687//springmvc只扫描controller@ComponentScan(value = \"org.lc\",useDefaultFilters = false,includeFilters = { @ComponentScan.Filter(type = FilterType.ANNOTATION,classes = {Controller.class})})//开启基于注解的sprignmvc配置 相当于&lt;mvc:annotation-driven/&gt;@EnableWebMvcpublic class SpringMVCAppConfig implements WebMvcConfigurer{ //配置视图解析器 @Override public void configureViewResolvers(ViewResolverRegistry registry) { //配置jsp的视图解析器 registry.jsp(\"/WEB-INF/pages/\", \".jsp\"); } //处理静态资源 相当于 &lt;mvc:default-servlet-handler/&gt; @Override public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) { configurer.enable(); } //配置拦截器 @Override public void addInterceptors(InterceptorRegistry registry) { //拦截任意请求 registry.addInterceptor(new MyFirstInterceptor()).addPathPatterns(\"/**\"); } @Override public void configurePathMatch(PathMatchConfigurer configurer) { } @Override public void configureContentNegotiation(ContentNegotiationConfigurer configurer) { } @Override public void configureAsyncSupport(AsyncSupportConfigurer configurer) { } @Override public void addFormatters(FormatterRegistry registry) { } @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { } @Override public void addCorsMappings(CorsRegistry registry) { } @Override public void addViewControllers(ViewControllerRegistry registry) { } @Override public void addArgumentResolvers(List&lt;HandlerMethodArgumentResolver&gt; resolvers) { } @Override public void addReturnValueHandlers(List&lt;HandlerMethodReturnValueHandler&gt; handlers) { } @Override public void configureMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) { } @Override public void extendMessageConverters(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters) { } @Override public void configureHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; resolvers) { } @Override public void extendHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; resolvers) { } @Override public Validator getValidator() { return null; } @Override public MessageCodesResolver getMessageCodesResolver() { return null; }} 1)配置拦截器123456789101112131415161718public class MyFirstInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\"MyFirstInterceptor....preHandle\"); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\"MyFirstInterceptor....postHandle\"); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(\"MyFirstInterceptor....afterCompletion\"); }} 4、初始化前端控制器和Spring容器替代web.xml文件 1234567891011121314151617181920212223242526272829303132//web容器启动的时候创建对象，调用方法来创建初始化容器以前的前端控制器public class MyWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer { /** * 获取根容器的配置类；(spring的配置文件) 父容器 * @return */ @Override protected Class&lt;?&gt;[] getRootConfigClasses() { return new Class[]{SpringRootConfig.class}; } /** * 获取web容器的配置类 （springmvc的配置文件） 子容器 * @return */ @Override protected Class&lt;?&gt;[] getServletConfigClasses() { return new Class[]{SpringMVCAppConfig.class}; } /** * 获取DispatcherServlet的映射信息 * / 代表拦截所有请求(包括静态资源（ .js, .png，.html等）)，但不拦截.jsp * @return */ @Override protected String[] getServletMappings() { //添加拦截规则 return new String[]{\"/\"}; }} 5、测试1)controller/service service 123456@Servicepublic class HelloService { public String hello() { return \"hello...\"; }} controller 123456789101112131415161718@Controller@RequestMapping(\"/\")public class HelloController { @Autowired private HelloService helloService; @GetMapping(\"/hello\") public String sayHello() { String hello = helloService.hello(); return hello; } @GetMapping(\"/hello1\") public String sayHello1() { return \"ccess\"; }} 八、SpringMVC异步处理1、返回Callable 拦截器 123456789101112131415161718public class MyFirstInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\"MyFirstInterceptor....preHandle\"); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\"MyFirstInterceptor....postHandle\"); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(\"MyFirstInterceptor....afterCompletion\"); }} 控制器测试 123456789101112131415161718192021222324@Controllerpublic class AsyncController { /** * 1、控制器返回Callable * 2、Spirng异步处理，将Callable提交到TaskExecutor，使用一个隔离的线程来执行 * 3、DispatcherServlet的所有的Filter退出web容器的线程，但是response保持打开状态 * 4、Callable返回结果，SpringMvc将请求重新派发给容器，恢复之前的处理 * 5、根据Callable返回的结果，SpringMvc继续进行视图渲染流程等(从收请求--视图渲染) * @return */ @ResponseBody @GetMapping(\"/async\") public Callable&lt;String&gt; async() { System.out.println(\"主线程开始:\"+Thread.currentThread()+\"==&gt;时间为:\"+System.currentTimeMillis()); Callable&lt;String&gt; callable = () -&gt; { System.out.println(\"副线程开始:\"+Thread.currentThread()+\"==&gt;时间为:\"+System.currentTimeMillis()); Thread.sleep(2000); System.out.println(\"副线程结束:\"+Thread.currentThread()+\"==&gt;时间为:\"+System.currentTimeMillis()); return \"Callable&lt;String&gt; async()\"; }; System.out.println(\"主线程结束:\"+Thread.currentThread()+\"==&gt;时间为:\"+System.currentTimeMillis()); return callable; }} 12345678910111213141516// 第一次拦截的请求 http://localhost:8080/async MyFirstInterceptor....preHandle主线程开始:Thread[http-bio-8080-exec-7,5,main]==&gt;时间为:1595580711963主线程结束:Thread[http-bio-8080-exec-7,5,main]==&gt;时间为:1595580711963//--------------- DispatcherServlet的所有的Filter退出web容器的线程---------//------------------等待callable执行-----副线程开始:Thread[MvcAsync1,5,main]==&gt;时间为:1595580711969副线程结束:Thread[MvcAsync1,5,main]==&gt;时间为:1595580713970////------------------callable执行完成----- //拦截器再次受到 请求 MyFirstInterceptor....preHandle//callable之前的返回值就是目标方法的返回值。 MyFirstInterceptor....postHandleMyFirstInterceptor....afterCompletion 如果时异步的情况下并不能真正的拦截到业务逻辑，需要实现AsyncHandlerInterceptor接口 2、返回DeferredResult 队列保存DeferredResult&lt;Object&gt; 123456789101112131415public class DeferredResultQueue { //使用队列存储DeferredResult&lt;Object&gt; private static Queue&lt;DeferredResult&lt;Object&gt;&gt; queue=new ConcurrentLinkedQueue&lt;&gt;(); //向队列中存储方法 public static void save(DeferredResult&lt;Object&gt; deferredResult) { queue.add(deferredResult); } //向队列中取的方法 public static DeferredResult&lt;Object&gt; get() { return queue.poll(); }} 控制器 12345678910111213141516171819202122@Controllerpublic class AsyncController1 { @ResponseBody @GetMapping(\"/creatOrder\") public DeferredResult&lt;Object&gt; createOrder() { //监听该线程必须3秒内完成，否则会失败 DeferredResult&lt;Object&gt; deferredResult = new DeferredResult&lt;&gt;((long) 3000, \"create fail\"); DeferredResultQueue.save(deferredResult); return deferredResult; } @ResponseBody @GetMapping(\"/create\") public String create() { String s = UUID.randomUUID().toString(); DeferredResult&lt;Object&gt; deferredResult = DeferredResultQueue.get(); //设置订单结果。 deferredResult.setResult(s); return \"success:\"+s; }} 首先请求 http://localhost:8080/creatOrder 将DeferredResult放入到队列监听，监听的超时时间为3s，超出实现则抛出错误信息，此时为阻塞状态 在3s内去请求 http://localhost:8080/create 创建订单信息869c40b1-25fd-4c48-b40d-f8809b1226aa，只要给DeferredResult设置了setResult(s)结果，那么监听的DeferredResult&lt;Object&gt;就会返回设置的结果。然后阻塞的creatOrder请求得到相应869c40b1-25fd-4c48-b40d-f8809b1226aa","link":"/2020/07/24/ssm/Spring%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8/"},{"title":"JDK1.8新特性","text":"JDK8特性详解一、接口的默认方法和静态方法 注： 接口的中的成员默认且必须为 public static final 且标识符最好为全大写，必须赋默认值 接口方法不能有实现。默认且必须为public abstarct 接口中的静态方法必须要有实现 Java 8允许我们给接口 允许添加一个非抽象的方法实现，只需要使用 default关键字即可，这个特征又叫做扩展方法 允许添加一个静态方法，必须有实现 注: 被default修饰的默认接口方法必须有实现 1234567891011public interface Formula { double caculate(int a); default double sqrt(int a) { return Math.sqrt(a); } static void say(){ System.out.println(\"hello\") }} 直接在caculate方法中使用接口中定义的default方法即可 12345678910111213public class Test { public static void main(String[] args) { Formula formula=new Formula(){ @Override public double caculate(int a) { return sqrt(a * 100); } }; double caculate = formula.caculate(1); System.out.println(caculate); }} 在Java中只有单继承，如果要让一个类赋予新的特性，通常是使用接口来实现 二、Lambda表达式使用限制： 如果要使用接口的中的Lambda中的表达，那么接口中需要满足如下条件： 普通的接口方法只能有一个 可以存在default方法(必须实现) 可以存在static方法(必须实现) 可以存在覆盖Object中的方法 语法：(parameter1,parameter2.....) -&gt; {expression;}; 提示:我们可以在接口上加@FunctionalInterface来判断我们的接口是否是函数式接口。 返回语句： 如果有一条语句，则无需写{} 如果有两条及其以上的语句，则必须加{} ①无参数，无返回值 1()-&gt;System.out.println(\"hello\"); ②有一个参数，无返回值 123(a)-&gt;System.out.println(\"hello\");//或者a -&gt;System.out.println(\"hello\"); ③有多个参数，无返回值 1(a,b)-&gt; System.out.println(\"hello\"); ④有多个参数，有一条语句的返回值 只有一条语句，则return 和 {}可以省略。 1(a,b)-&gt; a*b ④有多个参数，有多条语句的返回值 需要加{}，且需要return关键字 12345(a,b)-&gt;{ c=a*b; System.out.println(\"hello\"); return c;} 接口 123456789101112131415161718192021222324252627public interface NumberInterface{ //普通的接口方法只能以一个，多个的话，使用lamabda会报错 int caculate(int a,int b); default int opearate(int a,int b,NumberInterface numberInterface){ return numberInterface.caculate(a, b); } //可以存在默认方法 default String getMessage() { return \"hello java\"; } //可以存在静态方法 static void say() { System.out.println(\"static say\"); } //可以存在覆盖Object的方法 @Override boolean equals(Object obj); //可以存在覆盖Object的方法 @Override public String toString();} 实现： 1234567891011121314public class LamadaT { public static void main(String[] args) { int numberA=10; int numberB=5; NumberInterface add=(a,b)-&gt;a+b; NumberInterface sub=(a,b)-&gt;a-b; NumberInterface multi=(a,b)-&gt;a*b; NumberInterface div=(a,b)-&gt;a/b; System.out.println(\"加:\"+add.caculate(numberA, numberB)); System.out.println(\"减:\"+sub.caculate(numberA, numberB)); System.out.println(\"乘:\"+multi.caculate(numberA, numberB)); System.out.println(\"除:\"+div.caculate(numberA, numberB)); }} 注意： ①lambda不可以定义一个和外层变量名相同的变量，与变量类型无关 ②lambda中使用外层的变量，不能在lamdba表达式中修改其值，外层变量可以不是final类型的(jdk自动帮我们加了final)，但是绝对不可以在lambda表达式中修改外层变量的值。 ③lambda表达式主要为了执行方法类型的接口，避免定义匿名方法，开发更加简洁； ④lambda表达式中不能使用外部变量只能使用外部常量。即一般的情况不能使用for循环中的变量，需要在for循环中重新定义变量赋值。因为使用外面的变量lambda自动帮我们加final 三、四大核心内置接口 1、Consumer&lt;T&gt; 消费型接口 消费消息(有参无返)。提供一个T类型的参数，无返回值 原接口： 12345678910@FunctionalInterfacepublic interface Consumer&lt;T&gt; { void accept(T t); default Consumer&lt;T&gt; andThen(Consumer&lt;? super T&gt; after) { Objects.requireNonNull(after); return (T t) -&gt; { accept(t); after.accept(t); }; }} 测试： 1234567891011public class ConsumerTest { public static void main(String[] args) { new ConsumerTest().getMoney(2000.0, m-&gt; System.out.println(\"取钱：\"+m)); } public void getMoney(double money, Consumer&lt;Double&gt; consumer) {// 消费 consumer.accept(money); }} 2、Supplier&lt;T&gt; 供给型接口生产消息(无参有返)，无需提供参数，返回一个T类型的参数 原接口： 12345678910@FunctionalInterfacepublic interface Supplier&lt;T&gt; { /** * Gets a result. * * @return a result */ T get();} 测试： 12345678910111213141516public class SupplierTest { public static void main(String[] args) { //返回 20个随机整数 List&lt;Integer&gt; numberList = new SupplierTest().getNumberList(20, () -&gt; (int)(Math.random()*10)); System.out.println(numberList.toString()); } public &lt;T&gt; List&lt;T&gt; getNumberList(int num, Supplier&lt;T&gt; supplier) { List&lt;T&gt; list=new ArrayList&lt;&gt;(); for (int i = 0; i &lt; num; i++) { T t = supplier.get(); list.add(t); } return list; }} 3、Function&lt;T,R&gt; 函数型接口接收一个T类型的参数，返回R类型的参数 原接口： 1234567891011121314151617181920@FunctionalInterfacepublic interface Function&lt;T, R&gt; { R apply(T t); default &lt;V&gt; Function&lt;V, R&gt; compose(Function&lt;? super V, ? extends T&gt; before) { Objects.requireNonNull(before); return (V v) -&gt; apply(before.apply(v)); } default &lt;V&gt; Function&lt;T, V&gt; andThen(Function&lt;? super R, ? extends V&gt; after) { Objects.requireNonNull(after); return (T t) -&gt; after.apply(apply(t)); } static &lt;T&gt; Function&lt;T, T&gt; identity() { return t -&gt; t; }} 测试： 12345678910public class FunctionTest { public static void main(String[] args) { String s = new FunctionTest().HandlerStr(\"i like java\", (t) -&gt; t.toUpperCase()); System.out.println(s); } public &lt;T, R&gt; R HandlerStr(T t, Function&lt;T, R&gt; function) { return function.apply(t); }} 4、Predicate&lt;T&gt; 断言型接口接收一个T类型的参数，返回一个布尔值 原接口： 123456789101112131415161718192021222324@FunctionalInterfacepublic interface Predicate&lt;T&gt; { boolean test(T t); default Predicate&lt;T&gt; and(Predicate&lt;? super T&gt; other) { Objects.requireNonNull(other); return (t) -&gt; test(t) &amp;&amp; other.test(t); } default Predicate&lt;T&gt; negate() { return (t) -&gt; !test(t); } default Predicate&lt;T&gt; or(Predicate&lt;? super T&gt; other) { Objects.requireNonNull(other); return (t) -&gt; test(t) || other.test(t); } static &lt;T&gt; Predicate&lt;T&gt; isEqual(Object targetRef) { return (null == targetRef) ? Objects::isNull : object -&gt; targetRef.equals(object); }} 测试： 1234567891011121314151617181920public class PredicateTest { public static void main(String[] args) { List&lt;Integer&gt; list = Arrays.asList(2, 3, 4, 5, 6, 23, -233, -231, -33, 0); //过滤小于等于0的数 List&lt;Integer&gt; resultList = new PredicateTest().filterObject(list, (t) -&gt; t &lt;= 0); System.out.println(resultList); } public &lt;T&gt; List&lt;T&gt; filterObject(List&lt;T&gt; list, Predicate&lt;T&gt; predicate) { List&lt;T&gt; allList=new ArrayList&lt;&gt;(); list.forEach(c-&gt;{// 返回判断的结果 if(predicate.test(c)){// 过滤添加 allList.add(c); } }); return allList; }} 四、方法引用与构造器引用(双冒号)​ 实际上就是对Lambda表达式的再简写。:: 算符在Java 8中被用作方法引用（method reference），方法引用是与lambda表达式相关的一个重要特性。它提供了一种不执行方法的方法。为此，方法引用需要由兼容的函数接口组成的目标类型上下文。 ​ 大致意思是，使用lambda表达式会创建匿名方法， 但有时候需要使用一个lambda表达式只调用一个已经存在的方法（不做其它）， 所以这才有了方法引用！ 一、方法引用注意：要使用接口中的lamdba的方法必须要和你要使用::后面的方法的参数列表和返回值一致才可以使用:: 1、类对象::实例方法例1： 12345678910111213141516171819public static void main(String[] args) {// 1、lambad的实现方式// 具体的实现(lambda代替匿名内部类实现的接口) Consumer&lt;String&gt; consumer=(s)-&gt; System.out.println(s);// 方法调用 consumer.accept(\"hello world!\"); //得到打印流对象 PrintStream out = System.out; Consumer&lt;Integer&gt; consumer1 = (s) -&gt; out.println(s); consumer1.accept(100); // 2、::的实现方式。其中输出语句的最终方法要满足和lambad的方法参数列表和返回值一致// Consumer&lt;String&gt; consumer2=out::println; Consumer&lt;String&gt; consumer2= System.out::println; consumer2.accept(\"i like java\");} :: 能够使用的条件，参数列表和返回值一致, 如下：都是有参(String类型)，无返回值的方法 Consumer&lt;T&gt;中的accept方法 1234@FunctionalInterfacepublic interface Consumer&lt;T&gt; { void accept(T t);} System.out获取PrintStream对象中的println方法 123456public void println(String x) { synchronized (this) { print(x); newLine(); }} 例2： 1234567891011121314151617public class Employee { private String name; private Integer age; private Double salary; public Employee() { } public Employee(String name, Integer age, Double salary) { this.name = name; this.age = age; this.salary = salary; } //getter //setter //toString} 1234567891011121314151617public static void main(String[] args) { Employee employee=new Employee(); //这里我们提供一个消费型接口，要使用的接口中 有参无返回值 //所有我们使用 :: 即使用Employee中的setSalary为有参无返回值。 Consumer&lt;Double&gt; consumer=employee::setSalary; consumer.accept(21.2); //输出：Employee{name='null', age=null, salary=21.2} System.out.println(employee); Employee employee1=new Employee(); employee1.setName(\"louchen\");// 这里我们使用供给型接口，所使用的都是 无参有返回值的方法 Supplier&lt;String&gt; supplier=employee1::getName; String s = supplier.get(); //输出：louchen System.out.println(s); } 2、类::静态方法12345678910111213public class Demo { @Test public void test() { List&lt;String&gt; list = Arrays.asList(\"aaaa\", \"bbbb\", \"cccc\"); //静态方法语法 ClassName::methodName list.forEach(Demo::print); } public static void print(String content){ System.out.println(content); }} 123456789101112131415public static void main(String[] args) {// 1、lambda形式 Comparator&lt;Integer&gt; comparator = (a, b) -&gt; a.compareTo(b); int compare = comparator.compare(2, 6); //输出： -1 System.out.println(compare);// 2、::形式// Comparator 使用的参数列表 int compare(T o1, T o2);// Integer.compare方法的参数列表 public static int compare(int x, int y)// 都是相同参数列表，相同返回值 即可使用 :: Comparator&lt;Integer&gt; comparator1=Integer::compare; int compare1 = comparator1.compare(2, 1); System.out.println(compare1);} 3、类对象:实例方法123456789101112public static void main(String[] args) { String[] array = {\"aaaa\", \"bbbb\", \"cccc\"}; List&lt;String&gt; list = Arrays.asList(array); //Java 7 for(String s:list){ System.out.println(s); } //Java 8 PrintStream out = System.out; list.forEach(out::print); } 我们可以发现forEach中提供的是一个消费型接口(有参无返) void accept(T t); 所以在我们在println()方法中也是一个 public void println(String x){}; 有参无返方法可以直接使用 :: 代替 有一个疑问： 我们把 Comparator&lt;Integer&gt; comparator1=Integer::compare; 修改为==&gt; Comparator&lt;Integer&gt; comparator1=Integer::compareTo; 为什么还是可以使用呢？ 实例方法中的参数列表： public int compareTo(Integer anotherInteger) { } 接口中的参数列表：int compare(T o1, T o2); 得出结论： 若我们接口的中的方法的一个参数是实例的调用者，第二个参数为实例方法的参数时，我们可以直接使用ClassName::method的形式 即Lambda形式的：Comparator&lt;Integer&gt; comparator = (a, b) -&gt; a.compareTo(b); 可替换为：Comparator&lt;Integer&gt; comparator1=Integer::compareTo; 二、构造器引用注意构造器的参数列表要与函数式接口中的抽象方法的参数类别保持一致，使用哪个构造器和接口中的抽象方法有关 1、类名:new1234567891011121314151617181920public class Employee { private String name; private Integer age; private Double salary; public Employee() { } public Employee(Integer age) { this.age = age; } public Employee(String name, Integer age) { this.name = name; this.age = age; } //getter //setter //tostring} 123456789101112131415161718192021222324public static void main(String[] args) {// 生产型接口： lambda形式生成Employee对象 Supplier&lt;Employee&gt; supplier=()-&gt;new Employee(); Employee employee = supplier.get();// 生产型接口：// 这里我们new的为无参构造器。因为接口中的为无参列表 Supplier&lt;Employee&gt; supplier1=Employee::new; Employee employee1 = supplier1.get(); //方法型接口，传入Integer类型，返回Employe对象// 这里我们使用的为一个参数(Integer)的构造器，因为接口中的为一个参数的列表 Function&lt;Integer,Employee&gt; function=Employee::new; Employee apply = function.apply(20);// 输出： Employee{name='null', age=20, salary=null} System.out.println(apply); //这里我们使用String,Integer类型作为参数列表，返回Employee对象// 即使用两个参数列表的构造器 BiFunction&lt;String,Integer,Employee&gt; function1=Employee::new; Employee employee2 = function1.apply(\"张三\", 20);// 输出：Employee{name='张三', age=20, salary=null} System.out.println(employee2);} BiFunction函数接口： 12345@FunctionalInterfacepublic interface BiFunction&lt;T, U, R&gt; { R apply(T t, U u);} 三、数组引用1、Type[]:new12345678910111213public static void main(String[] args) {// 1、函数型接口：lambda形式创建一个值得大小的字符串数组 Function&lt;Integer, String[]&gt; function = (n) -&gt; new String[n]; String[] apply = function.apply(10);// 10 System.out.println(apply.length);// 2、::形式 Function&lt;Integer,String[]&gt; function1=String[]::new; String[] apply1 = function1.apply(20);// 20 System.out.println(apply1.length); } 五、Stream1、什么是Stream是数据渠道，用于操作数据源(集合、数组等)所生成的元素序列 集合讲的是数据，流讲的是计算 注意： ①Stream 自己不会存储元素 ②Stream 不会改变源对象。相反，他们返回一个持有结果的新Stream ③Stream 操作是延迟执行的。这意味着他们会等到需要结果的时候才执行 2、Steam操作的步骤①创建Stream一个数据源(如：集合，数组)，获取一个流 ②中间操作一个中间操作链，对数据源的数据进行处理 ③终止操作(终端操作)一个终止操作，执行中间操作链，并产生结果。 3、创建Stream1234567891011121314151617181920212223242526272829public static void main(String[] args) {// 1、通过Collection系列集合提供的stream() 或 parallelStream() 并行流 List&lt;String&gt; list=new ArrayList&lt;&gt;();// 得到Stream对象 Stream&lt;String&gt; stream = list.stream();// 2、通过Arrays 中的静态方法stream() 获取数组流 Employee[] employees = new Employee[10]; Stream&lt;Employee&gt; stream1 = Arrays.stream(employees);// 3、通过Stream类中的静态方法of() Stream&lt;String&gt; stream2 = Stream.of(\"aa\", \"bb\", \"cc\", \"dd\");// 4、创建无限流 无限迭代// 开始的元素； 对元素的操作 Stream&lt;Integer&gt; stream3 = Stream.iterate(0, (x) -&gt; x + 2);// 无线循环打印// stream3.forEach(System.out::println);// 打印10条 stream3.limit(10).forEach(System.out::println);// 4、生成无限流 Stream&lt;Double&gt; generate = Stream.generate(() -&gt; Math.random() * 10);// 无线循环打印// generate.forEach(System.out::println);// 打印5条 generate.limit(5).forEach(System.out::println); } 123456789101112131415160246810121416188.0639977262448072.4732074180807239.473970433973959.9985284800501331.0465136543742837 4、中间操作 多个中间操作可以连接起来形成一个流水线，除非流水线上触发终止操作，否则中间操作不会执行任何的处理。而在终止操作时一次性全部处理。称为“惰性求值”。 只要没有执行终止操作，中间操作就不会执行。 中间操作的返回值还是中间操作 ① 筛选与切片12345678910111213public class Employee { private String name; private Integer age; private Double salary; public Employee(String name, Integer age, Double salary) { this.name = name; this.age = age; this.salary = salary; } //getter //setter //tostring} 12345678910public class T2 { static List&lt;Employee&gt; list= Arrays.asList( new Employee(\"张三\",10,2000.0), new Employee(\"李四\",20,3000.0), new Employee(\"王五\",30,4000.0), new Employee(\"赵六\",40,5000.0), new Employee(\"田七\",50,6000.0), new Employee(\"钱八\",60,7000.0) );} filter接收lambda,从流中排除一些元素 里面对满足条件的boolean为true的元素才返回 Stream API帮我们操作的过程 也叫内部迭代 1234567 public static void main(String[] args) { Stream&lt;Employee&gt; stream = list.stream();// 中间操作 只要没有执行终止操作，中间操作就不会执行 stream.filter((e) -&gt; e.getAge() &gt; 30)// 终止操作 .forEach(System.out::println); } 123Employee{name='赵六', age=40, salary=5000.0}Employee{name='田七', age=50, salary=6000.0}Employee{name='钱八', age=60, salary=7000.0} 外部迭代： 123456public void outIterator(){ Iterator&lt;Employee&gt; iterator = list.iterator(); while (iterator.hasNext()) { System.out.println(iterator.next()); }} limit截断流，是元素不超过给定数量 1234567Stream&lt;Employee&gt; stream = list.stream();// 中间操作 stream.filter((e) -&gt; e.getAge() &gt; 30) //中间操作 .limit(2)// 终止操作 .forEach(System.out::println); 12Employee{name='赵六', age=40, salary=5000.0}Employee{name='田七', age=50, salary=6000.0} skip(n)跳过当前满足条件的n个元素，输出跳过满足n个条件后的所有元素 若流中的元素不足n个，则返回一个空流。与limit(n)互补 123456789public static void main(String[] args) { Stream&lt;Employee&gt; stream = list.stream();// 中间操作 stream.filter((e) -&gt; e.getSalary() &gt;= 2000)// 中间操作 跳过操作 .skip(2)// 终止操作 .forEach(System.out::println);} distinct通过流所生成元素的hashCode()和equals()去除重复元素 这里的distinct去重的是上一个加工后的steam中的内容 12345678910111213141516171819202122public class Employee { private String name; private Integer age; private Double salary; @Override public boolean equals(Object o) { if (this == o) { return true; } if (o == null || getClass() != o.getClass()) { return false; } Employee employee = (Employee) o; return Objects.equals(name, employee.name) &amp;&amp; Objects.equals(age, employee.age) &amp;&amp; Objects.equals(salary, employee.salary); } //getter //setter //toString} 123456789101112public class T2 { static List&lt;Employee&gt; list= Arrays.asList( new Employee(\"张三\",10,2000.0), new Employee(\"李四\",20,3000.0), new Employee(\"王五\",30,4000.0), new Employee(\"赵六\",40,5000.0), new Employee(\"田七\",50,6000.0), new Employee(\"钱八\",60,7000.0), new Employee(\"钱八\",60,7000.0), new Employee(\"钱八\",60,7000.0) );} 1234567891011public static void main(String[] args) { Stream&lt;Employee&gt; stream = list.stream();// 中间操作 stream.filter((e) -&gt; e.getSalary() &gt;= 2000)// 中间操作 跳过 .skip(2)// 中间操作 去重 (必须重写hashcode 和 equals) .distinct()// 终止操作 .forEach(System.out::println); } 1234Employee{name='王五', age=30, salary=4000.0}Employee{name='赵六', age=40, salary=5000.0}Employee{name='田七', age=50, salary=6000.0}Employee{name='钱八', age=60, salary=7000.0} ②映射12345678910111213public class Employee { private String name; private Integer age; private Double salary; public Employee(String name, Integer age, Double salary) { this.name = name; this.age = age; this.salary = salary; } //getter //setter //tostring} 12345678910111213141516171819202122public class T3 { static List&lt;Employee&gt; employeeList= Arrays.asList( new Employee(\"张三\",10,2000.0), new Employee(\"李四\",20,3000.0), new Employee(\"王五\",30,4000.0), new Employee(\"赵六\",40,5000.0), new Employee(\"田七\",50,6000.0), new Employee(\"钱八\",70,7000.0), new Employee(\"钱八\",80,7000.0), new Employee(\"钱八\",60,7000.0) } List&lt;String&gt; list = Arrays.asList(\"a\", \"bb\", \"ccc\", \"dddd\"); // 获得传入字符中的所有字符 public static Stream&lt;Character&gt; getAllCharacter(String str) { List&lt;Character&gt; list=new ArrayList&lt;&gt;(); for(Character c:str.toCharArray()){ list.add(c); } return list.stream(); } } map接收lambda,将元素转换成其他形式或提取信息。接收一个函数作为参数，该函数会被应用到每个元素上，并将其映射成一个新的元素 相当于映射出一个元素属性 123456789101112//1、将字符串全部转为为小写 List&lt;String&gt; list = Arrays.asList(\"a\", \"bb\", \"ccc\", \"dddd\"); list.stream() .map(s-&gt;s.toUpperCase()) .forEach(System.out::println);//2、获取所有员工的姓名 Stream&lt;Employee&gt; stream = T3.employeeList.stream(); stream.map(e -&gt; e.getName())// 去重(只是对name去重) .distinct() .forEach(System.out::println); 1234567891011ABBCCCDDDD张三李四王五赵六田七钱八 12345678 //3、因为中间操作Stream&lt;T&gt;中的T是map操作中getAllCharacter的返回值 Stream&lt;Stream&lt;Character&gt;&gt; streamStream = list.stream() .map(T3::getAllCharacter); //遍历得到Stream&lt;Character&gt; streamStream.forEach(s-&gt;{// 再次遍历得到character s.forEach(System.out::println); }); 12345678910abbcccdddd 我们看Stream中的map源码发现： 1&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper); 我们传入一个字符串参数T，返回的是一个Stream&lt;Character&gt;流，所以这里的R即为Stream&lt;Character&gt; 所以map方法在上述例子的返回值为 Stream&lt;Stream&lt;Character&gt;&gt; 即把每一个字符串拆分后的小流放入一个大流中存储。所以需要遍历两次。 flatmap(平行流，将流展开)接收一个函数作为参数，将流中的每个值都换成另一个流，然后把所有流连接成一个流 把许多小流中的元素直接拿出来放入大流中 12Stream&lt;Character&gt; characterStream = list.stream().flatMap(T3::getAllCharacter);characterStream.forEach(System.out::println); 我们看Stream中的flatMap源码可发现： 1&lt;R&gt; Stream&lt;R&gt; flatMap(Function&lt;? super T, ? extends Stream&lt;? extends R&gt;&gt; mapper); 我们传入一个字符串参数T,返回一个Stream&lt;Character&gt;流，注意这里的R为返回流中的泛型参数类型，所以这里的R即为Character,所以flatmap的返回类型为Stream&lt;Character&gt; ③排序sorted自然排序(comparable)要排序的对象需要实现comparable接口 1234567891011public class Employee implements Comparable&lt;Employee&gt;{ private String name; private Integer age; private Double salary; //getter setter tostring @Override public int compareTo(Employee o) { //按照姓名 升序排列 return this.name.compareTo(o.name); }} 123456789101112131415static List&lt;Employee&gt; employeeList= Arrays.asList( new Employee(\"a\",20,3000.0), new Employee(\"c\",30,4000.0), new Employee(\"g\",10,2000.0), new Employee(\"f\",60,7000.0), new Employee(\"g\",40,5000.0), new Employee(\"q\",70,7000.0), new Employee(\"t\",50,6000.0), new Employee(\"g\",80,7000.0) ); public static void main(String[] args) { employeeList.stream() .sorted() .forEach(System.out::println); } 12345678Employee{name='a', age=20, salary=3000.0}Employee{name='c', age=30, salary=4000.0}Employee{name='f', age=60, salary=7000.0}Employee{name='g', age=10, salary=2000.0}Employee{name='g', age=40, salary=5000.0}Employee{name='g', age=80, salary=7000.0}Employee{name='q', age=70, salary=7000.0}Employee{name='t', age=50, salary=6000.0} 定制排序(comparator)注意：这里的定制排序的规则高于自然排序的规则 1234567891011121314public static void main(String[] args) { employeeList.stream() .sorted((a,b)-&gt;{// 如果姓名相同 if (a.getName() == b.getName()) {// 如果姓名相同 按照年龄降序排序 return b.getAge().compareTo(a.getAge()); }else{// 姓名不相同，按照年龄升序排列 return a.getName().compareTo(b.getName()); } }) .forEach(System.out::println); } 12345678Employee{name='a', age=20, salary=3000.0}Employee{name='c', age=30, salary=4000.0}Employee{name='f', age=60, salary=7000.0}Employee{name='g', age=80, salary=7000.0}Employee{name='g', age=40, salary=5000.0}Employee{name='g', age=10, salary=2000.0}Employee{name='q', age=70, salary=7000.0}Employee{name='t', age=50, salary=6000.0} 5、终止操作​ 数据经过中间加工操作，就轮到终止操作符上场了；终止操作符就是用来对数据进行收集或者消费的，数据到了终止操作这里就不会向下流动了，终止操作符只能使用一次。 ①查找与匹配12345678910111213public class Employee{ private String name; private Integer age; private Double salary; private Status status; //getter setter tostring public enum Status{ FREE, BUSY, VOCATION; }} 123456789101112public class T5 { static List&lt;Employee&gt; employeeList= Arrays.asList( new Employee(\"a\",20,3000.0, Status.BUSY), new Employee(\"c\",30,4000.0,Status.FREE), new Employee(\"g\",10,2000.0,Status.BUSY), new Employee(\"f\",60,7000.0,Status.VOCATION), new Employee(\"g\",40,5000.0,Status.VOCATION), new Employee(\"q\",70,7000.0,Status.BUSY), new Employee(\"t\",50,6000.0,Status.VOCATION), new Employee(\"g\",80,7000.0,Status.FREE) );} allMatch检查给定的条件是否匹配所有元素 返回一个boolean 12345678public static void main(String[] args) { boolean b = employeeList.stream() //传入一个断言型接口 //判断使用所有的age是否都大于等于10 .allMatch(e -&gt; e.getAge() &gt;= 10); //true System.out.println(b);} anyMatch检查是否至少匹配一个元素 返回一个boolean 123456 //传入一个断言型接口 boolean b1 = employeeList.stream()// 是否匹配至少一个age为80的元素 .anyMatch(e -&gt; e.getAge().equals(80)); //true System.out.println(b1); noneMatch检查是否没有匹配 所指定的条件的元素 返回boolean 123456 boolean a = employeeList.stream()// 传入断言型接口 //是否没有匹配姓名为t的 .noneMatch(e -&gt; e.getName().equals(\"t\")); //false System.out.println(a); findFirst返回满足条件的第一个元素 一般我们排序之后取的第一个元素 123456789 Optional&lt;Employee&gt; first = employeeList.stream()// 传入一个比较器接口// 按照薪资从大到小排序 .sorted((c,d)-&gt;-c.getSalary().compareTo(d.getSalary()))// 返回第一个元素 .findFirst();// 从Optional接口中取出元素//Employee{name='f', age=60, salary=7000.0, status=VOCATION} System.out.println(first.get()); findAny返回匹配流中的任意一个元素 注意这里我们获取流：employeeList.stream() 为串型流，会阻塞线程 employeeList.parallelStream()为平行流，不会阻塞线程。同时多个线程匹配返回 123456Optional&lt;Employee&gt; any = employeeList.stream() //过滤status为VOCATION的元素 .filter(e -&gt; e.getStatus().equals(Status.VOCATION)) //返回任意一个 .findAny();System.out.println(any.get()); sumint、double、long: 1double max = list.stream().mapToDouble(User::getHeight).sum(); BigDecimal: 1BigDecimal bb=list.stream().map(Plan::getAmount).reduce(BigDecimal.ZERO,BigDecimal::add); count返回匹配的所有元素的个数 123456 long count = employeeList.stream() //过滤薪资大于3000的元素 .filter(r-&gt;r.getSalary()&gt;3000) .count();// 8 System.out.println(count); max返回流中的最大值 123456 Optional&lt;Employee&gt; max = employeeList.stream()// 必须有在max中实现一个比较的接口器 // 按照年龄排序后，取出年龄最大的 .max((e, f) -&gt; e.getAge().compareTo(f.getAge())); //Employee{name='a', age=80, salary=7000.0, status=VOCATION} System.out.println(max.get()); min返回流中的最小值 12345678910 Optional&lt;Double&gt; min = employeeList.stream()// 得到所有薪资值// 这里我们使用Function中的 R apply(T t); 方法。 T为传入的参数:Employee R为返回的值// 我们已经传入了T，现在只需要传入R即可 ；可以直接使用Employee中的getSalary()返回Double即可 .map(Employee::getSalary)// //必须有在max中实现一个比较的接口器// 求出薪资最少的 .min(Double::compare); //2000.0 System.out.println(min.get()); 注意这里的min和max里面的排序规则必须为升序，否则得出的结果会相反②规约12345678910111213public class Employee{ private String name; private Integer age; private Double salary; private Status status; public enum Status{ FREE, BUSY, VOCATION; } //getter setter tostring} 1234567891011public class T6 { static List&lt;Employee&gt; employeeList= Arrays.asList( new Employee(\"a\",20,3000.0, Status.BUSY), new Employee(\"c\",30,4000.0,Status.FREE), new Employee(\"g\",10,2000.0,Status.BUSY), new Employee(\"f\",60,7000.0,Status.VOCATION), new Employee(\"g\",40,5000.0,Status.VOCATION), new Employee(\"q\",70,7000.0,Status.BUSY), new Employee(\"t\",50,6000.0,Status.VOCATION), new Employee(\"g\",80,7000.0,Status.FREE) ); reduce方法一：可以将流中元素反复结合起来，得到一个值。返回T 注意：注意该值不可能为空，因为我们使用的时候会传入一个初始值identity 1T reduce(T identity, BinaryOperator&lt;T&gt; accumulator); 方法二：可以将流中元素反复结合起来，得到一个值。返回Optional&lt;T&gt; 1Optional&lt;T&gt; reduce(BinaryOperator&lt;T&gt; accumulator); 注意：这里没有初始值，所以我们的类型会可能出现null的情况，所以我们需要用Optional&lt;T&gt;来处理 BinaryOperator接口： 12public interface BinaryOperator&lt;T&gt; extends BiFunction&lt;T,T,T&gt; {} BiFunction接口： 123public interface BiFunction&lt;T, U, R&gt; { R apply(T t, U u);} 12345678910public static void main(String[] args) { //相加等于51 List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 5, 6, 7, 8, 9, 10); Integer reduce = list.stream() //默认初始值1; 传入BinaryOperator&lt;T&gt;接口。接口中的方法 R apply(T t, U u); .reduce(1, (a, b) -&gt; a + b); //51 总的值加上初始值1 System.out.println(reduce); } 累加原理 ： 初始值加上第一个元素(1+1=2) 得到的结果加上第二元素(2+2=4) 得到的结果加上第三个元素(4+3) ……. 1234567Optional&lt;Double&gt; reduce1 = employeeList.stream() //过滤出所有的薪资 .map(Employee::getSalary) //Double中的sum静态方法 .reduce(Double::sum); //41000.0 System.out.println(reduce1.get()); ③收集1234567891011public class T7 { static List&lt;Employee&gt; employeeList= Arrays.asList( new Employee(\"a\",20,3000.0, Status.BUSY), new Employee(\"c\",30,4000.0,Status.FREE), new Employee(\"g\",10,2000.0,Status.BUSY), new Employee(\"f\",60,7000.0,Status.VOCATION), new Employee(\"g\",40,5000.0,Status.VOCATION), new Employee(\"q\",70,7000.0,Status.BUSY), new Employee(\"t\",50,6000.0,Status.VOCATION), new Employee(\"g\",80,7000.0,Status.FREE) ); 12345678910111213public class Employee{ private String name; private Integer age; private Double salary; private Status status; //getter setter tostring public enum Status{ FREE, BUSY, VOCATION; }} collect将流转换为其他形式。接收一个Collector接口的实现，用于给Stream中元素做汇总的方法 1&lt;R, A&gt; R collect(Collector&lt;? super T, A, R&gt; collector); Collector 接口中的方法实现决定了如何对流执行收集操作(如收集到List、Set、Map)。但是Collectors工具类提供了很多对Collector 中接口实现的静态方法，可以方便地创建常见收集器实例 基本操作：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public static void main(String[] args) {// 一、将集合中的所有员工姓名加入到一个list集合中 List&lt;String&gt; collect = employeeList.stream()// 映射出姓名 .map(Employee::getName)// 收集该元素，加到list结合中 .collect(Collectors.toList());// [a, c, g, f, g, q, t, g] System.out.println(collect);// 二、将集合中的所有员工姓名加入到一个set集合中 Set&lt;String&gt; collect1 = employeeList.stream() .map(Employee::getName) .collect(Collectors.toSet());// [a, q, c, t, f, g] System.out.println(collect1);// 三、将集合中的所有员工姓名加入到一个自定义集合中 HashSet&lt;String&gt; collect2 = employeeList.stream() .map(Employee::getName) .collect(Collectors.toCollection(HashSet::new));// [a, q, c, t, f, g] System.out.println(collect2);// 四、收集集合中元素的个数 Long collect3 = employeeList.stream() .collect(Collectors.counting());// 8 System.out.println(collect3);// 五、求集合中工资的平均值 Double collect4 = employeeList.stream() .collect(Collectors.averagingDouble(Employee::getSalary));// 5125.0 System.out.println(collect4);// 六、求工资总和 Double collect5 = employeeList.stream() .collect(Collectors.summingDouble(Employee::getSalary));// 41000.0 System.out.println(collect5);// 七、求工资最大值的对象 注意这里要排序 Optional&lt;Employee&gt; collect6 = employeeList.stream() .collect(Collectors.maxBy((a, b) -&gt; a.getSalary().compareTo(b.getSalary())));// Employee{name='f', age=60, salary=7000.0, status=VOCATION} System.out.println(collect6.get());// 八、求工资的最小值 Optional&lt;Double&gt; collect7 = employeeList.stream() .map(Employee::getSalary) .collect(Collectors.minBy((a, b) -&gt; a.compareTo(b)));// 2000.0 System.out.println(collect7.get()); } 分组：12345// 1、按照员工的状态进行分组 Map&lt;Status, List&lt;Employee&gt;&gt; collect = employeeList.stream() .collect(Collectors.groupingBy(Employee::getStatus)); String s = new Gson().toJson(collect); System.out.println(s); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556{ \"FREE\": [ { \"name\": \"c\", \"age\": 30, \"salary\": 4000, \"status\": \"FREE\" }, { \"name\": \"g\", \"age\": 80, \"salary\": 7000, \"status\": \"FREE\" } ], \"VOCATION\": [ { \"name\": \"f\", \"age\": 60, \"salary\": 7000, \"status\": \"VOCATION\" }, { \"name\": \"g\", \"age\": 40, \"salary\": 5000, \"status\": \"VOCATION\" }, { \"name\": \"t\", \"age\": 50, \"salary\": 6000, \"status\": \"VOCATION\" } ], \"BUSY\": [ { \"name\": \"a\", \"age\": 20, \"salary\": 3000, \"status\": \"BUSY\" }, { \"name\": \"g\", \"age\": 10, \"salary\": 2000, \"status\": \"BUSY\" }, { \"name\": \"q\", \"age\": 70, \"salary\": 7000, \"status\": \"BUSY\" } ]} 多级分组：12345678910111213// 2、先按照员工状态分组，再按照工资分组 Map&lt;Status, Map&lt;String, List&lt;Employee&gt;&gt;&gt; collect1 = employeeList.stream() .collect(Collectors.groupingBy(Employee::getStatus, Collectors.groupingBy(a -&gt; { if (a.getSalary() &lt;= 3000) { return \"码农\"; } else if (a.getSalary() &lt;= 5000) { return \"高级码农\"; } else { return \"工程师\"; } }))); String s1 = new Gson().toJson(collect1); System.out.println(s1); 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768{ \"FREE\": { \"高级码农\": [ { \"name\": \"c\", \"age\": 30, \"salary\": 4000, \"status\": \"FREE\" } ], \"工程师\": [ { \"name\": \"g\", \"age\": 80, \"salary\": 7000, \"status\": \"FREE\" } ] }, \"VOCATION\": { \"高级码农\": [ { \"name\": \"g\", \"age\": 40, \"salary\": 5000, \"status\": \"VOCATION\" } ], \"工程师\": [ { \"name\": \"f\", \"age\": 60, \"salary\": 7000, \"status\": \"VOCATION\" }, { \"name\": \"t\", \"age\": 50, \"salary\": 6000, \"status\": \"VOCATION\" } ] }, \"BUSY\": { \"码农\": [ { \"name\": \"a\", \"age\": 20, \"salary\": 3000, \"status\": \"BUSY\" }, { \"name\": \"g\", \"age\": 10, \"salary\": 2000, \"status\": \"BUSY\" } ], \"工程师\": [ { \"name\": \"q\", \"age\": 70, \"salary\": 7000, \"status\": \"BUSY\" } ] }} 分区(true/false)：1234// 3、按照年龄区 true/false Map&lt;Boolean, List&lt;Employee&gt;&gt; collect2 = employeeList.stream() .collect(Collectors.partitioningBy(e -&gt; e.getAge() &gt;= 40)); System.out.println(new Gson().toJson(collect2)); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354{ \"false\": [ { \"name\": \"a\", \"age\": 20, \"salary\": 3000, \"status\": \"BUSY\" }, { \"name\": \"c\", \"age\": 30, \"salary\": 4000, \"status\": \"FREE\" }, { \"name\": \"g\", \"age\": 10, \"salary\": 2000, \"status\": \"BUSY\" } ], \"true\": [ { \"name\": \"f\", \"age\": 60, \"salary\": 7000, \"status\": \"VOCATION\" }, { \"name\": \"g\", \"age\": 40, \"salary\": 5000, \"status\": \"VOCATION\" }, { \"name\": \"q\", \"age\": 70, \"salary\": 7000, \"status\": \"BUSY\" }, { \"name\": \"t\", \"age\": 50, \"salary\": 6000, \"status\": \"VOCATION\" }, { \"name\": \"g\", \"age\": 80, \"salary\": 7000, \"status\": \"FREE\" } ]} 汇总操作：1234567891011// 九、对员工年龄汇总操作 IntSummaryStatistics collect8 = employeeList.stream() .collect(Collectors.summarizingInt(Employee::getAge)); //80 //45.0 //10 //8 System.out.println(collect8.getMax()); System.out.println(collect8.getAverage()); System.out.println(collect8.getMin()); System.out.println(collect8.getCount()); 字符串连接操作：12345678910111213 String collect9 = employeeList.stream() .map(Employee::getName) .collect(Collectors.joining());// acgfgqtg System.out.println(collect9);// 加入指定连接符 String collect10 = employeeList.stream() .map(Employee::getName)// 每个元素的连接符; 前缀; 后缀 .collect(Collectors.joining(\",\",\"[\",\"]\"));// [a,c,g,f,g,q,t,g] System.out.println(collect10); 6、Stream练习12345678910111213public class Employee{ private String name; private Integer age; private Double salary; private Status status; //getter setter tostring public enum Status{ FREE, BUSY, VOCATION; }} 12345678910static List&lt;Employee&gt; employeeList= Arrays.asList( new Employee(\"a\",20,3000.0,Status.BUSY), new Employee(\"c\",30,4000.0,Status.FREE), new Employee(\"g\",10,2000.0,Status.BUSY), new Employee(\"f\",60,7000.0,Status.VOCATION), new Employee(\"g\",40,5000.0,Status.VOCATION), new Employee(\"q\",70,7000.0,Status.BUSY), new Employee(\"t\",50,6000.0,Status.VOCATION), new Employee(\"g\",80,7000.0,Status.FREE)); 1、给定一个数字列表，如何返回一由每个数的平方构成的列表呢？ [1,2,3,4,5] 返回 [1,4,9,16,25] 1234Integer[] integers=new Integer[]{1,2,3,4,5};Stream&lt;Integer&gt; stream = Arrays.stream(integers);stream.map(i -&gt; i * i) .forEach(System.out::println); 2、使用reduce和map统计流中有多少个Employee对象 12345Optional&lt;Integer&gt; reduce = employeeList.stream() .map((e) -&gt; 1) .reduce((a, b) -&gt; a + b); //8 System.out.println(reduce.get()); 其他练习： Trader 交易员 12345public class Trader { private String name; private String city; //getter setter} Transaction 交易 123456public class Transaction { private Trader trader; int year; int value; //getter setter} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889public class T9 { static Trader zs=new Trader(\"Zss\", \"北京\"); static Trader ls=new Trader(\"Lsl\", \"上海\"); static Trader ww=new Trader(\"Wwv\", \"武汉\"); static Trader zl=new Trader(\"Zlz\", \"武汉\"); static List&lt;Transaction&gt; transactions= Arrays.asList( new Transaction(zs,2018,1300), new Transaction(zs,2019,3200), new Transaction(ls,2019,3200), new Transaction(ww,2018,3100), new Transaction(ww,2018,300), new Transaction(ls,2019,1000), new Transaction(zl,2018,800) ); public static void main(String[] args) {// 1、找出2018的交易额 并从大到小排序 transactions.stream() .filter(e -&gt; e.getYear() == 2018) .sorted((a, b) -&gt; Integer.compare(b.getValue(), a.getValue())) .forEach(System.out::println);// 2、交易员都在哪些城市工作过 transactions.stream() .map(t-&gt;t.getTrader().getCity()) .distinct() .forEach(System.out::println);// 3、查找来自武汉的交易员，并按照姓名排序 transactions.stream() .filter(c-&gt;c.getTrader().getCity().equals(\"武汉\")) .map(Transaction::getTrader) .distinct() .sorted((d,e)-&gt;d.getName().compareTo(e.getName())) .forEach(System.out::println);// 4、返回所有交易员的姓名字符串，按字母顺序排列// ①按照每个名称作为字符串拼接 String reduce = transactions.stream() .map(f -&gt; f.getTrader().getName()) .distinct() .sorted()// 拼接字符串 .reduce(\"\", String::concat);// LslWwvZlzZss System.out.println(reduce);// ②按照字符 排序忽略大小写 transactions.stream() .map(g-&gt;g.getTrader().getName()) .distinct() .flatMap(T9::getStrChar) .sorted(String::compareToIgnoreCase) .forEach(System.out::print); System.out.println(\"\\n--------\");// 5、有没有交易员在上海工作 boolean re = transactions.stream() .anyMatch(h -&gt; h.getTrader().getCity().equals(\"上海\")); System.out.println(re);// 6、查询生活在武汉的交易员的所有交易额 Integer re1 = transactions.stream() .filter(i -&gt; i.getTrader().getCity().equals(\"武汉\")) .map(j -&gt; j.getValue()) .reduce(0, Integer::sum); System.out.println(re1);// 7、在所有的交易额中，最高的是？ Optional&lt;Integer&gt; max = transactions.stream() .map(k -&gt; k.getValue()) .max(Integer::compareTo); System.out.println(max.get());// 8、最小的交易? 即整个对象 Optional&lt;Transaction&gt; min = transactions.stream() .min((l, m) -&gt; Integer.compare(l.getValue(), m.getValue())); System.out.println(min.get()); } static Stream&lt;String&gt; getStrChar(String s) { List&lt;String&gt; list=new ArrayList&lt;&gt;(); for (Character ch:s.toCharArray()) { list.add(String.valueOf(ch)); } return list.stream(); }} 7、并行流和顺序(串行)流当我们计算一个1到100亿的累加操作 默认采用顺序流： 12345678public static void main(String[] args) { Instant start=Instant.now(); LongStream.range(0, 10000000000L) .reduce(0,Long::sum); Instant end=Instant.now(); //相加所用时间:4029 毫秒 System.out.println(\"相加所用时间:\"+ Duration.between(start, end).toMillis());} 采用并行流： 123456789public static void main(String[] args) { Instant start=Instant.now(); LongStream.range(0, 10000000000L) .parallel() .reduce(0,Long::sum); Instant end=Instant.now(); //相加所用时间:1212 毫秒 System.out.println(\"相加所用时间:\"+ Duration.between(start, end).toMillis()) } 所谓并行流：并行流就是把一个内容分成多个数据块，并用不同的线程分别处理每个数据块的流。 https://www.jianshu.com/p/19ffb2c9438a Java8中将并行进行了优化，我们可以很容易地对数据进行行操作。Stream API可以声明性地通过parallel()与sequential()在并行流与顺序流之间进行切换。 其实我们的并行流，底层还是采用的是Fork/Join框架： ​ Fork/Join框架采用“工作窃取”模式：当执行新的任务时，它可以将其拆分成更小的任务执行，并将小任务加到线程队列中。如果线程获取不到任务，它不会闲着，会从一个随机线程的队列中偷一个并把它放在自己的队列中，保证尽可能地利用CPU的资源。 8、Optional类Optional主要为我们解决空指针的异常 Optional.of(T t)创建一个Optional实例 12345678 public static void main(String[] args) { // NullPointerException 传null直接在该行抛空指针 Optional&lt;Employee&gt; optionalEmployee = Optional.of(null); Optional&lt;Employee&gt; optionalEmployee1 = Optional.of(new Employee());// Employee{name='null', age=null, salary=null, status=null} System.out.println(optionalEmployee1.get()); } Optional.empty()创建一个空的Optional实例 123456public static void main(String[] args) { //不会抛出空指针 Optional&lt;Employee&gt; empty = Optional.empty(); //获取元素 NoSuchElementException System.out.println(empty.get());} Optional.ofNullable(T t)若t不为null，创建Optional实例，否则创建空实例 相当于 Optional.of(T t) 与 Optional.ofNullable(T t) 的结合 123456789public static void main(String[] args) { Optional&lt;Employee&gt; empty = Optional.ofNullable(new Employee()); System.out.println(empty.get()); //若传入空对象 则创建空Optional实例 Optional&lt;Employee&gt; empty1 = Optional.ofNullable(null); //但是获取元素 NoSuchElementException System.out.println(empty.get());} isPresent()判断是否包含空值 1234567public static void main(String[] args) { Optional&lt;Employee&gt; empty = Optional.ofNullable(new Employee(\"louchen\",10,1000.0,Status.VOCATION));// 判断Optional容器中是否有元素 if(empty.isPresent()) { System.out.println(empty.get()); } } orElse(T t)如果调用对象包含值，返回该值，否则返回t 123456789 public static void main(String[] args) { Employee employee=null;// 传入的为空 Optional&lt;Employee&gt; empty = Optional.ofNullable(employee);// 若为空 则使用创建的对象 否则使用ofNullable传入的。 Employee employee1 = empty.orElse(new Employee());// Employee{name='null', age=null, salary=null, status=null} System.out.println(employee1); } orElseGet(Supplier s)如果调用对象包含值，返回该值，否则s获取的值 12345678 public static void main(String[] args) { Employee employee=null;// 传入的为空 Optional&lt;Employee&gt; empty = Optional.ofNullable(employee);// 若为空 则使用传入的供给型Supplier接口。 否则使用ofNullable传入的。 Employee employee1 = empty.orElseGet(()-&gt;new Employee()); System.out.println(employee1); }SS map(Function f)如果有值对其处理，并返回处理后的Optional，否则返回Optional.empty() 12345678 public static void main(String[] args) { Employee employee=new Employee(\"louchen\",10,1000.0,Status.VOCATION); Optional&lt;Employee&gt; empty = Optional.ofNullable(employee);// 获取元素的name属性 Optional&lt;String&gt; s = empty.map((a) -&gt; a.getName());// louchen System.out.println(s.get()); } flatMap(Function mapper)与mapper类似，要求返回值必须是Optional 12345678 public static void main(String[] args) { Employee employee=new Employee(\"louchen\",10,1000.0,Status.VOCATION); Optional&lt;Employee&gt; empty = Optional.ofNullable(employee);// 获取元素的name属性 Optional&lt;String&gt; o = empty.flatMap((a) -&gt; Optional.ofNullable(a.getName()));// louchen System.out.println(o.get()); } 六、对日期的处理1、LocalDateTime/LocalDate/LocalTimeLocalDateTime: 对时间日期操作 LocalDate：对日期操作 LocalTime：对时间操作 这里我们只介绍LocalDateTime。LocalDate/LocalTime用法和LocalDateTime一致。 1234567891011121314151617181920212223242526272829303132// 1、LocalDateTime 时间日期操作// ①获取当前日期时间 LocalDateTime ldt=LocalDateTime.now();// 2020-05-11T19:25:27.520 System.out.println(ldt);// ②根据年月日时分秒 生成指定的日期时间 LocalDateTime ldt1=LocalDateTime.of(2020, 1, 31, 18, 11,12);// 2020-01-31T18:11:12 System.out.println(ldt1);// ③加上指定年份 LocalDateTime ldt2=ldt.plusYears(2);// 并格式化日期 2022-05-11 19:33:26 System.out.println(ldt2.format(DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\")));// ④减上指定月份 LocalDateTime ldt3=ldt.minusMonths(3);// 2020/02/11 19:36:19 System.out.println(ldt3.format(DateTimeFormatter.ofPattern(\"yyyy/MM/dd HH:mm:ss\")));// ⑤分别获取 年月日时分秒 System.out.println(ldt.getYear()); System.out.println(ldt.getMonth()); System.out.println(ldt.getDayOfMonth()); System.out.println(ldt.getHour()); System.out.println(ldt.getMinute()); System.out.println(ldt.getSecond());// 2、LocalTime 时间操作// 3、LocalDate 日期操作// 与LocalDateTime操作类似 2、Instant 时间戳12345678910111213141516171819// 4、Instant: 时间戳(以Unix元年：1970年1月1日00:00:00到某个时间之间的毫秒数) Instant ins=Instant.now();// 默认使用的是UTC时区的时间(本初子午线)。与中国时差为8小时 System.out.println(ins);// 修正为中国时区 OffsetDateTime offsetDateTime = ins.atOffset(ZoneOffset.ofHours(8));// 2020-05-11T20:12:35.134+08:00 即UTC时区加了8个小时 System.out.println(offsetDateTime);// 获取时间戳(毫秒) 当前时间与UTC 1970年1月1日午夜之间的时差（以毫秒为单位） System.out.println(ins.toEpochMilli());// 与这个System中获取时间戳一致 System.out.println(System.currentTimeMillis());// 相对于UTC(1970-01-01)时间进行的时间累加操作 Instant instant = Instant.ofEpochSecond(60);// 1970-01-01T00:01:00Z System.out.println(instant); 3、Durartion/PeriodDurartion: 计算两个 “时间” 之间的间隔Period: 计算两个 “日期” 之间的间隔 123456789101112131415161718192021222324// ①查看时间间隔 Instant ins1=Instant.now(); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } Instant ins2=Instant.now(); Duration between = Duration.between(ins1, ins2);// 查看相隔的秒数 System.out.println(between.getSeconds());// 查看相隔的毫秒数 System.out.println(between.toMillis());// ②查看日期间隔 LocalDate ld1 = LocalDate.of(2010, 10, 25); LocalDate ld2=LocalDate.now(); Period between1 = Period.between(ld1, ld2);// P9Y6M16D System.out.println(between1);// 分别获取相距的 年月日 System.out.println(between1.getYears()); System.out.println(between1.getMonths()); System.out.println(between1.getDays()); 4、TemporaAdjuster时间校正器 12345678910111213141516171819202122232425262728293031323334// 当前日期 LocalDateTime ldt4=LocalDateTime.now();// 2020-05-11T22:26:27.874 System.out.println(ldt4);// ①对已有的日期进行重新指定。对日指定为1 LocalDateTime ldt5 = ldt4.withDayOfMonth(1);// 2020-05-01T22:26:27.874 System.out.println(ldt5);// ②从TemporalAdjusters工具类中获取其他指定日期// 获取下个星期六的时间 LocalDateTime with = ldt4.with(TemporalAdjusters.next(DayOfWeek.SATURDAY));// 2020-05-16T22:31:10.829 System.out.println(with);// ③计算下个工作日日期 (星期一到星期五为工作日) LocalDateTime ldt6= ldt4.with(t-&gt;{// 获取当前日期对象 LocalDateTime ldt7=(LocalDateTime)t;// 获取该周的星期 DayOfWeek dayOfMonth = ldt7.getDayOfWeek();// 若为星期五 if(dayOfMonth.equals(DayOfWeek.FRIDAY)){// 则给当前日期加3天 return ldt7.plusDays(3); }else if(dayOfMonth.equals(DayOfWeek.SATURDAY)){// 若为星期六 加2天 return ldt7.plusDays(2); }else{// 其他加1天 即为下一个工作日 return ldt7.plusDays(1); } }); System.out.println(ldt6); 5、DateTimeFormatter12345678910111213// 1、DateTimeFormatter 格式化日期 LocalDateTime ldt=LocalDateTime.now();// ①LocalDateTime日期转换为自定义格式的日期字符串 DateTimeFormatter dtf=DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\"); String format = ldt.format(dtf);// 2020-05-12 09:58:04 System.out.println(format);// ②将字符串日期格式化日期LocalDateTime LocalDateTime parse = LocalDateTime.parse(format, dtf);// 2020-05-12T10:01:07 System.out.println(parse); 6、Zone123456789101112131415161718// 2、带时区的日期时间// ①获取所有时区 Set&lt;String&gt; availableZoneIds = ZoneId.getAvailableZoneIds();// Australia/Eucla// Asia/Shanghai// .......// availableZoneIds.forEach(System.out::println);// ②获取指定时区的时间 LocalDateTime ldt1=LocalDateTime.now(ZoneId.of(\"Australia/Eucla\"));// 2020-05-12T10:57:50.461 System.out.println(ldt1);// ③获取带 时区和时间日期 LocalDateTime ldt2=LocalDateTime.now(ZoneId.of(\"Asia/Shanghai\")); ZonedDateTime zonedDateTime = ldt2.atZone(ZoneId.of(\"Asia/Shanghai\"));// 2020-05-12T10:12:50.461+08:00[Asia/Shanghai] 上海与utc时差为8小时 System.out.println(zonedDateTime);","link":"/2020/07/24/javase/JDK1.8%E8%AF%A6%E8%A7%A3/"},{"title":"SpringMVC知识梳理","text":"一、SpringMVC执行流程https://www.cnblogs.com/myitnews/p/11565941.html 第一步：发起请求到前端控制器(DispatcherServlet) 第二步：前端控制器请求HandlerMapping查找 Handler （可以根据xml配置、注解进行查找） 第三步：处理器映射器HandlerMapping向前端控制器返回Handler，HandlerMapping会把请求映射为HandlerExecutionChain对象（包含一个Handler处理器（页面控制器）对象，多个HandlerInterceptor拦截器对象），通过这种策略模式，很容易添加新的映射策略 第四步：前端控制器调用处理器适配器去执行Handler 第五步：处理器适配器HandlerAdapter将会根据适配的结果去执行Handler 第六步：Handler执行完成给适配器返回ModelAndView 第七步：处理器适配器向前端控制器返回ModelAndView （ModelAndView是springmvc框架的一个底层对象，包括 Model和view） 第八步：前端控制器请求视图解析器去进行视图解析 （根据逻辑视图名解析成真正的视图(jsp)），通过这种策略很容易更换其他视图技术，只需要更改视图解析器即可 第九步：视图解析器向前端控制器返回View 第十步：前端控制器进行视图渲染 （视图渲染将模型数据(在ModelAndView对象中)填充到request域） 第十一步：前端控制器向用户响应结果 下面我们对出现的一些组件进行详细的介绍： (1) 前端控制器DispatcherServlet（不需要程序员开发）。 作用：接收请求，响应结果，相当于转发器，中央处理器。有了DispatcherServlet减少了其它组件之间的耦合度。(2) 处理器映射器HandlerMapping（不需要程序员开发）。 作用：根据请求的url查找Handler。(3) 处理器适配器HandlerAdapter（不需要程序员开发）。 作用：按照特定规则（HandlerAdapter要求的规则）去执行Handler。(4) 处理器Handler（需要程序员开发）。 注意：编写Handler时按照HandlerAdapter的要求去做，这样适配器才可以去正确执行Handler(5) 视图解析器ViewResolver（不需要程序员开发）。 作用：进行视图解析，根据逻辑视图名解析成真正的视图（view）(6) 视图View（需要程序员开发jsp）。 注意：View是一个接口，实现类支持不同的View类型（jsp、freemarker、pdf…） 二、前端控制器中的 / 和 /*的区别tomcat配置的web.xml中 有DefaultServlet默认的对所有的请求的拦截，有JspServlet对*.jsp结尾的请求的拦截。 先走JspServlet路径下的映射规则，最后匹配DefaultServlet下的默认映射规则，匹配找不到资源则404 DefaultServlet是tomcat中处理静态资源的 当请求index.html时，属于静态资源，tomcat就会在服务器下找到这个请求资源并返回 12345678910111213141516171819202122232425262728293031323334353637383940 &lt;servlet&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.catalina.servlets.DefaultServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;debug&lt;/param-name&gt; &lt;param-value&gt;0&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;listings&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet&gt; &lt;servlet-name&gt;jsp&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.jasper.servlet.JspServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;fork&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;xpoweredBy&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;3&lt;/load-on-startup&gt; &lt;/servlet&gt;&lt;!-- The mapping for the default servlet --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!-- The mappings for the JSP servlet --&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;jsp&lt;/servlet-name&gt; &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; &lt;url-pattern&gt;*.jspx&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 项目中编写的web.xml相当于继承了tomcat中的web.xml 12345678910&lt;!--配置前端控制器 拦截的路径--&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;!--拦截所有--&gt; &lt;!-- /和/* 都是拦截所有请求; /会拦截所有请求，但是不会拦截 *.jsp 。保证jsp的访问正常 /* 拦截的范围更大，会拦截到 *.jsp的请求，导致jsp页面不能正常显示 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; 拦截所有请求 不会拦截到 *.jsp的地址(tomcat默认帮我们配置)，但会拦截包括不在web.xml配置的其他请求，诸如：index.html，index.js 等静态资源 &lt;url-pattern&gt;/*&lt;/url-pattern&gt; 拦截任意路径资源 当我们在项目中的web.xml映射路径为 &lt;url-pattern&gt;/&lt;/url-pattern&gt;时，会覆盖tomcat中默认的拦截规则 当请求index.html页面时，当做静态资源处理，请求来到tomcat时，前端控制器会从@RequestMapping下找到指定为这个请求的路径。找到则返回，找不到则404 而我们没有覆盖.jsp的配置，在tomcat中的web.xml已经帮我们 \\.jsp请求的拦截与处理。 若我们在项目中的路径为&lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt;则会覆盖tomcat中的配置，当我们请求index.jsp时，也会通过前端控制器去找@RequestMapping指定请求，找到则返回，找不到则404. 三、常用注解和其他配置详解1234567891011121314151617181920212223@Target({ElementType.TYPE, ElementType.METHOD})@Retention(RetentionPolicy.RUNTIME)@Documented@Mappingpublic @interface RequestMapping { String name() default \"\"; //请求地址 @AliasFor(\"path\") String[] value() default {}; //请求地址 @AliasFor(\"value\") String[] path() default {}; //请求方式：【GET】【DELTE】【PUT】【POST】 RequestMethod[] method() default {}; String[] params() default {}; String[] headers() default {}; String[] consumes() default {}; String[] produces() default {};} 1、@RequestMapping属性详解 path/value 代表请求路径 @RequestMapping(value = &quot;/hello&quot; ) 或 @RequestMapping(path= &quot;/hello&quot; ) method 请求类型【GET】【DELTE】【PUT】【POST】 @RequestMapping(value = &quot;/hello&quot;,method = RequestMethod.POST) params 规定请求参数 @RequestMapping(value = &quot;/hello&quot;,params = {&quot;username&quot;}) 请求必须携带username参数，没带404 @RequestMapping(value = &quot;/hello&quot;,params = {&quot;!username&quot;} 请求不能携带username参数，带了404 @RequestMapping(value = &quot;/hello&quot;,params = {&quot;username=123&quot;} 请求携带的参数的uername值必须为123，否则404 @RequestMapping(value = &quot;/hello&quot;,params = {&quot;username!=123&quot;} 请求携带的参数username(传空值或者不传该参数都可以)值不是123，否则404 ``@RequestMapping(value = “/hello”,params = {“username!=123”,”pwd”,”!age”}请求携带的参数username不能为123，必须携带pwd参数，不能携带age`参数。必须同时满足请求才能成功。 headers 规定请求头 //指定该请求只能是 Chrom刘浏览器才能访问 @RequestMapping(value = \"/hello\",headers = {\"User-Agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.90 Safari/537.36\"}) &lt;!--￼3--&gt; 请求路径 /hello/11, 则我们通过url地址的id变量赋值到被@PathVariable注解的参数上。 我们的RESTful的一般设计规则： /book/1 【GET】请求， 查询图书 /book/1 【POST】请求 ，添加图书 /book/1 【PUT】请求，修改图书 /book/1 【DELETE】请求，删除图书 4、@GetMapping/@PostMapping @DeleteMapping(“/hello”) 等价于@RequestMapping(value = “/hello”,method = RequestMethod.DELETE) @PostMapping(“/hello”) 等价于@RequestMapping(value = “/hello”,method = RequestMethod.POST) @GetMapping(“/hello”) 等价于@RequestMapping(value = “/hello”,method = RequestMethod.GET) @PutMapping(“/hello”) 等价于@RequestMapping(value = “/hello”,method = RequestMethod.PUT) 5、使form表单能够发送DELET和PUT请求Spring为我们提供一个过滤器，将请求中的方法类型转换我们给定的请求类型。 web.xml 12345678910&lt;!--使form表单支持 delet和put请求--&gt;&lt;filter&gt; &lt;filter-name&gt;hiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;hiddenHttpMethodFilter&lt;/filter-name&gt; &lt;!--拦截所有请求--&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 1)设置form表单的请求类型为POST 2)表单项携带一个 name为_method的参数，value为请求类型 12345&lt;!--发送delete请求--&gt;&lt;form action=\"/hello/1\" method=\"post\"&gt; &lt;input name=\"_method\" value=\"delete\"&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt; 1234567@DeleteMapping(value = \"/hello/{id}\")public String hello(@PathVariable(\"id\")String i) { //1 System.out.println(i); System.out.println(\"收到请求\"); return \"success\";} 6、@RequestParam获取请求的参数，默认的参数为必须，若没传入指定的参数则报错 1234567891011@Target({ElementType.PARAMETER})@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface RequestParam { @AliasFor(\"name\") String value() default \"\"; @AliasFor(\"value\") String name() default \"\"; boolean required() default true; String defaultValue() default \"\\n\\t\\t\\n\\t\\t\\n\\ue000\\ue001\\ue002\\n\\t\\t\\t\\t\\n\";} value/name 指定参数的名称 required 指定参数是否必须 defaultValue 若参数为空或者没传入该参数，指定的默认值 123456@GetMapping(\"/hello\")public String hello1(@RequestParam(required = false,defaultValue = \"123\") String username) { System.out.println(\"username:\"+username); System.out.println(\"收到请求\"); return \"success\";} 7、@ReuestHeader获取请求头的内容，默认的请求头内容为必须 1234567891011121314@Target({ElementType.PARAMETER})@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface RequestHeader { @AliasFor(\"name\") String value() default \"\"; @AliasFor(\"value\") String name() default \"\"; boolean required() default true; String defaultValue() default \"\\n\\t\\t\\n\\t\\t\\n\\ue000\\ue001\\ue002\\n\\t\\t\\t\\t\\n\";} 123456789 @GetMapping(\"/hello\") public String hello1(@RequestHeader(value = \"User-Agent\",required = false) String userAgent) { //以谷歌为例 //userAgent:Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.90 Safari/537.36收到请求 System.out.println(\"userAgent:\"+userAgent); System.out.println(\"收到请求\"); return \"success\"; } 8、@CookieValue获取cookie的sessionid,默认为必须 1234567@GetMapping(\"/hello\")public String hello1(@CookieValue(value = \"JSESSIONID\",required = false) String sessionid) { //sessionid:3910DFECD2374747C93B3F42B73495A5 System.out.println(\"sessionid:\"+sessionid); System.out.println(\"收到请求\"); return \"success\";} 9、POJO属性自动封装12345678@Getter@Setter@ToStringpublic class User { private String id; private String username; private int age;} 1234567@PostMapping(\"/user\")public String user(User user) { //user:User(id=1001, username=zs, age=20) System.out.println(\"user:\"+user); System.out.println(\"收到请求\"); return \"success\";} 123456&lt;form action=\"user\" method=\"post\"&gt; &lt;input type=\"text\" name=\"id\"/&gt; &lt;input type=\"text\" name=\"username\"/&gt; &lt;input type=\"text\" name=\"age\"/&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt; 10、传入原生API(request,response,session)1234567891011@PostMapping(\"/handler\")public String user1(HttpSession httpSession, HttpServletRequest request, HttpServletResponse response) throws IOException { ServletInputStream inputStream = request.getInputStream(); ServletOutputStream outputStream = response.getOutputStream(); //得到字符流 BufferedReader reader = request.getReader(); //打印流 PrintWriter writer = response.getWriter(); System.out.println(\"收到请求\"); return \"success\";} 11、处理请求乱码12345678910111213141516171819202122232425&lt;!--解决中文乱码 注意过滤器的配置顺序 我们解决中文乱码的过滤器一般放在所有过滤器之前--&gt;&lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;!--设置编码为utf-8--&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;!--设置强制解决请求乱码--&gt; &lt;param-name&gt;forceRequestEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;!--设置强制解决响应乱码--&gt; &lt;param-name&gt;forceResponseEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;!--指定所有请求--&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 12、设置响应参数和返回指定视图1)通过Map，Model，ModelMap设置的参数都被封装到请求对象参数中，前端通过request.getAttribute(&quot;&quot;)即可获取 @GetMapping(\"/handler1\") public String hander1(Map&lt;String,Object&gt; map) throws IOException { map.put(\"username\", \"张三\"); return \"success\"; } &lt;!--￼17--&gt; @GetMapping(\"/handler1\") public String hander1(ModelMap model) throws IOException { model.addAttribute(\"username\",\"李四\"); return \"success\"; } &lt;!--￼18--&gt; 2)设置返回视图，并指定返回参数 12345678@GetMapping(\"/handler1\")public ModelAndView hander1() throws IOException { //设置视图名称 ModelAndView modelAndView = new ModelAndView(\"success\"); //设置响应参数 modelAndView.addObject(\"username\", \"王五\"); return modelAndView;} 12345678910&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;成功！&lt;/h1&gt;request:&lt;%=request.getAttribute(\"username\")%&gt;&lt;/body&gt;&lt;/html&gt; 13、使用forward转发123456@GetMapping(\"/hello1\")public String hello1() { System.out.println(\"收到请求\"); //转发到 根路径下的test.jsp页面 return \"forward:/test.jsp\";} 通过forward转发的页面不会通过视图解析器进行加前缀和后缀的处理，可以直接写 / 代表项目路径(http://localhost:8080/项目名/)。 也可以通过forward转发到指定请求 14、使用redirect重定向12345@GetMapping(\"/hello1\")public String hello1() { System.out.println(\"收到请求\"); return \"redirect:/test.jsp\";} 通过redirect转发的页面不会通过视图解析器进行加前缀和后缀的处理，可以直接写 / 代表项目路径(http://localhost:8080/项目名/)。 也可以通过redirect重定向到其他请求 15、使用mvc直接通过请求映射一个页面当我们要访问一个WEB/INF下的页面时，不能在前端直接通过url地址进行访问，需要在控制器进行请求处理转发到WEB/INF下的位置。我们可以使用在xml配置完成WEB/INF下页面的访问 1234567891011121314&lt;!--配置视图解析器--&gt;&lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;!--配置视图返回时的前缀--&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/page/\"&gt;&lt;/property&gt; &lt;!--视图返回的后缀--&gt; &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--path: 指定通过前端直接访问的请求--&gt;&lt;!--view-name：指定视图名称--&gt;&lt;mvc:view-controller path=\"/toSuccess\" view-name=\"success\"&gt;&lt;/mvc:view-controller&gt;&lt;!--若配置上面的mvc视图映射，则其他请求会失效需要开启基于注解的驱动--&gt;&lt;mvc:annotation-driven/&gt; 通过&lt;mvc:view-controller path=&quot;/toSuccess&quot; view-name=&quot;success&quot;&gt;&lt;/mvc:view-controller&gt; 配置的视图映射处理器，中的view-name的视图名称必须是视图解析器后的 前缀地址下的文件 ，即指定的视图名为 /WEB-INF/page/ 下的文件名。视图解析器会自动帮我们加前缀和后缀处理 当我们&lt;mvc:view-controller path=&quot;/toSuccess&quot; view-name=&quot;forward:/index.jsp&quot;&gt;&lt;/mvc:view-controller&gt; 进行forwar转发时，转发请求并不会 通过视图解析器进行加前缀和后缀。这里访问的为项目根目录下的 index.jsp文件 16、自定义视图解析器 自定义请求返回的解析类型 12345678910111213@Controllerpublic class MyViewResovlerController { @RequestMapping(\"/handleplus\") public String handler(Model model) { List&lt;String&gt; image=new ArrayList&lt;&gt;(); image.add(\"1.jpg\"); image.add(\"2.jpg\"); model.addAttribute(\"images\", image); return \"down:/downloadImg\"; }} 自定义返回视图的对象 1234567891011121314151617181920//自定义视图public class MyView implements View { /** * 返回的内容类型 * @return */ @Override public String getContentType() { return \"text/html\"; } @Override public void render(Map&lt;String, ?&gt; map, HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws Exception { System.out.println(\"之前保存的数据：\"+map); List&lt;String&gt; o = (List&lt;String&gt;)map.get(\"images\"); httpServletResponse.setContentType(\"text/html\"); httpServletResponse.getWriter().write(\"&lt;h1&gt;即将显示精彩内容...&lt;/h1&gt;\"); httpServletResponse.getWriter().write(\"&lt;h2&gt;\"+o.toString()+\"&lt;/h2&gt;\"); }} 自定义视图解析器 12345678910111213141516171819202122232425262728293031//自定义视图解析器public class DownloadResolver implements ViewResolver, Ordered { //通过xml设置视图解析器的优先级 private int order; /** * 根据视图名返回视图对象 * @param s * @param locale * @return * @throws Exception */ @Override public View resolveViewName(String s, Locale locale) throws Exception { if (s.startsWith(\"down:\")) { return new MyView(); } return null; } @Override public int getOrder() { return order; } public void setOrder(int order) { this.order=order; }} 将自定义的视图解析器加入到IOC容器 12345&lt;!--将自定义的视图解析器放在IOC容器中--&gt; &lt;bean class=\"org.lc.view.DownloadResolver\"&gt; &lt;!--让我们自定义的视图解析器 优先于spring中默认的视图解析器优先执行--&gt; &lt;property name=\"order\" value=\"1\"&gt;&lt;/property&gt; &lt;/bean&gt; 17、静态资源文件访问1234&lt;!--告诉springmvc 自己映射的请求自己处理，不能处理的请求交由tomcat处理--&gt;&lt;!--需要在后面配置基于注解的驱动 &lt;mvc:annotation-driven/&gt;--&gt;&lt;mvc:default-servlet-handler/&gt;&lt;mvc:annotation-driven/&gt; 18、HttpEntity&lt;String&gt;@ResponBody可以获取请求体的所有信息，但是只是获取一个字符串，里面包含所有 @RequestHeader 可以获取请求头中的某一个头信息 HttpEntity&lt;String&gt;可以获取请求头的所有信息** 123456@GetMapping(\"/test\") @ResponseBody public String getAjaxAllUser1(HttpEntity&lt;String&gt; httpEntity) { System.out.println(httpEntity); return \"success\"; } 1&lt;[host:\"localhost:8080\", connection:\"keep-alive\", upgrade-insecure-requests:\"1\", user-agent:\"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/77.0.3865.90 Safari/537.36\", sec-fetch-mode:\"navigate\", sec-fetch-user:\"?1\", accept:\"text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3\", sec-fetch-site:\"same-origin\", referer:\"http://localhost:8080/ssm/\", accept-encoding:\"gzip, deflate, br\", accept-language:\"zh-CN,zh;q=0.9,en;q=0.8\", cookie:\"JSESSIONID=50782912CF4054A36CA4AB8553E368E0\"]&gt; 19、ResponseEntity&lt;String&gt;我们可以通过 @ResponseBody 将返回数据放在响应体中 这里我们可以通过ResponseEntity&lt;String&gt;定制响应头，响应体，状态码等信息 12345678910@GetMapping(\"/test1\")public ResponseEntity&lt;String&gt; test1( ) { //定制响应头 MultiValueMap&lt;String,String&gt; headers=new HttpHeaders(); headers.add(\"Set-Cookie\",\"username=lc\"); //定制响应体 String body = \"&lt;h1&gt;success&lt;/h1&gt;\"; ResponseEntity&lt;String&gt; responseEntity = new ResponseEntity&lt;&gt;(body, headers, HttpStatus.OK); return responseEntity;} 20、@RestController加在类上 等同于： @Controller+@ResponseBody 该控制器下的所有请求方法 都以响应体的方式输出 三、自定义类型转换器(转换日期)1、使用只带转换器的ConversionService(格式化的功能会失效)有时候我们前端过来的日期格式类型的字符串想要自动映射为后端的请求参数，我们需要自定义类型转换器 1)实现一个 Converter&lt;S, T&gt; 接口 2)将我们自定义的类型转换器加入到ConversionServiceFactoryBean中 3)告诉我们的springmvc使用哪个conversion-service 自定义类型转换器 1234567891011121314//实现自定义转换器//将 字符串类型 自动转换为 日期类型public class DateConverter implements Converter&lt;String, Date&gt; { private SimpleDateFormat simpleDateFormat=new SimpleDateFormat(\"yyyy-MM-dd\"); @Override public Date convert(String s) { try { return simpleDateFormat.parse(s); } catch (ParseException e) { e.printStackTrace(); } return null; }} 注册该转换器 使用ConversionServiceFactoryBean转换器 1234567891011121314 &lt;!--告诉springmvc 使用哪个类型转换器ConversionService --&gt;&lt;mvc:annotation-driven conversion-service=\"conversionService\"/&gt; &lt;!--告诉springmvc别用默认的类型转换器ConversionService 而用我们自定义的ConversionService，加入我们自定义的Converter转换器 --&gt; &lt;bean class=\"org.springframework.context.support.ConversionServiceFactoryBean\"&gt; &lt;property name=\"converters\"&gt; &lt;set&gt; &lt;!--添加我们自定义的类型转换器--&gt; &lt;bean class=\"org.lc.converter.DateConverter\"&gt;&lt;/bean&gt; &lt;/set&gt; &lt;/property&gt; &lt;/bean&gt; 控制器 123456@PostMapping(\"/user\")public String user(@RequestParam(\"birthday\") Date birthday) { System.out.println(\"birthday:\" + new SimpleDateFormat(\"yyyy-MM-dd\").format(birthday)); System.out.println(\"收到请求\"); return \"success\";} 前端 1234&lt;form action=\"user\" method=\"post\"&gt; 输入日期:&lt;input type=\"text\" name=\"birthday\"/&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt; 输入的日期格式必须为符合自定义转换器中的规则，否则会转换失败 满足 我们转换器中的定义的日期格式：yyyy-MM-dd 2、使用带格式化和转换器的ConversionService（一般我们使用这种） 使用 FormattingConversionServiceFactoryBean 转换器 12345678910111213&lt;mvc:annotation-driven conversion-service=\"conversionService\"/&gt;&lt;!--告诉springmvc别用默认的类型转换器ConversionService 而用我们自定义的ConversionService，加入我们自定义的Converter转换器 --&gt;&lt;bean id=\"conversionService\" class=\"org.springframework.format.support.FormattingConversionServiceFactoryBean\"&gt; &lt;property name=\"converters\"&gt; &lt;set&gt; &lt;!--添加我们自定义的其他类型转换器--&gt; &lt;bean class=\"org.lc.converter.xxxx\"&gt;&lt;/bean&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt; 使用@DateTimeFormat注解 (将请求参数的字符串转换为日期类型)。可以无需上述配置 12345678910@Getter@Setter@ToStringpublic class User { private String id; private String username; private int age; @DateTimeFormat(pattern = \"yyyy-MM-dd\") private Date birthday;} 123456@PostMapping(\"/user\")public String user(User user) { System.out.println(\"user:\" + user); System.out.println(\"收到请求\"); return \"success\";} 1234&lt;form action=\"user\" method=\"post\"&gt; 输入日期:&lt;input type=\"text\" name=\"birthday\"/&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt; 只能输入和注解匹配的日期格式 pattern = &quot;yyyy-MM-dd&quot; 四、 &lt;mvc:default-servlet-handler/&gt;与&lt;mvc:annotation-driven/&gt;&lt;mvc:default-servlet-handler/&gt;： 告诉springmvc如果我们的请求处理静态资源，则交由tomcat处理。但是只配置 &lt;mvc:default-servlet-handler/&gt;注解，但是会把所以的请求交由tomcat处理，需要配置&lt;mvc:annotation-driven/&gt;，让@RequestMapping动态请求也能访问 当我们没有加 &lt;mvc:default-servlet-handler/&gt;静态资源处理器的时候，默认只能访问通过@RequestMapping的请求信息和默认在tomcat中的web.xml中默认配置的*.jsp的请求。一切静态资源都不能访问，例如：html,css,js等 这两个配置一般同时加上 五、jackson的应用1、各种类型转换12345678910111213141516&lt;!--jackson依赖--&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.11.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.11.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.11.0&lt;/version&gt;&lt;/dependency&gt; 12345678910111213141516@Getter@Setter@ToString@AllArgsConstructor@NoArgsConstructorpublic class User { private Integer id; private String username; @JsonIgnore private String password; private String email; private int age; @JsonFormat(pattern = \"yyyy-MM-dd\",timezone = \"Asia/Shanghai\") @DateTimeFormat(pattern = \"yyyy-MM-dd\") private Date birthday;} ①json字符串和对象转换123456789101112User user = new User(1, \"张三\", \"123456\", \"123@qq.com\", 22, new Date());ObjectMapper objectMapper=new ObjectMapper();//将 对象 转换为json字符串String s = objectMapper.writeValueAsString(user);//{\"id\":1,\"username\":\"张三\",\"email\":\"123@qq.com\",\"age\":22,\"birthday\":\"2020-07-16\"}System.out.println(s);//将json字符串转换为 对象User user1 = objectMapper.readValue(s, User.class);//User(id=1, username=张三, password=null, email=123@qq.com, age=22, birthday=Thu Jul 16 00:00:00 GMT+08:00 2020)System.out.println(user1); ②list集合和json转换123456789101112131415List&lt;User&gt; list=new ArrayList&lt;&gt;();list.add(new User(1, \"张三\", \"123456\", \"123@qq.com\", 22, new Date()));list.add(new User(2, \"李四\", \"12356\", \"123@qq.com\", 16, new Date()));ObjectMapper objectMapper=new ObjectMapper();//list集合转 jsonString writeValueAsString = objectMapper.writeValueAsString(list);//[{\"id\":1,\"username\":\"张三\",\"email\":\"123@qq.com\",\"age\":22,\"birthday\":\"2020-07-16\"},{\"id\":2,\"username\":\"李四\",\"email\":\"123@qq.com\",\"age\":16,\"birthday\":\"2020-07-16\"}]System.out.println(writeValueAsString);//json转 list集合JavaType javaType = objectMapper.getTypeFactory().constructParametricType(ArrayList.class, User.class);List&lt;User&gt; list1 = objectMapper.readValue(writeValueAsString, javaType);//[User(id=1, username=张三, password=null, email=123@qq.com, age=22, birthday=Thu Jul 16 00:00:00 GMT+08:00 2020), User(id=2, username=李四, password=null, email=123@qq.com, age=16, birthday=Thu Jul 16 00:00:00 GMT+08:00 2020)]System.out.println(list1); ③map集合和json转换123456789101112131415HashMap&lt;String,User&gt; map=new HashMap&lt;&gt;();map.put(\"p1\",new User(1, \"张三\", \"123456\", \"123@qq.com\", 22, new Date()));map.put(\"p2\",new User(2, \"李四\", \"12356\", \"123@qq.com\", 16, new Date()));ObjectMapper objectMapper=new ObjectMapper();//map集合转json字符串String s = objectMapper.writeValueAsString(map);//{\"p1\":{\"id\":1,\"username\":\"张三\",\"email\":\"123@qq.com\",\"age\":22,\"birthday\":\"2020-07-16\"},\"p2\":{\"id\":2,\"username\":\"李四\",\"email\":\"123@qq.com\",\"age\":16,\"birthday\":\"2020-07-16\"}}System.out.println(s);//json字符串 转map集合JavaType javaType =objectMapper.getTypeFactory().constructParametricType(HashMap.class,String.class,User.class);HashMap&lt;String, User&gt; stringUserHashMap = (HashMap&lt;String, User&gt;) objectMapper.readValue(s, javaType);//{p1=User(id=1, username=张三, password=null, email=123@qq.com, age=22, birthday=Thu Jul 16 00:00:00 GMT+08:00 2020), p2=User(id=2, username=李四, password=null, email=123@qq.com, age=16, birthday=Thu Jul 16 00:00:00 GMT+08:00 2020)}System.out.println(stringUserHashMap); 2、@JsonFormat与@JsonIgnore使用@ResponseBody时，jackson自动将我们的Map集合，List集合转换为json字符串返回给前端。 @JsonFormat(pattern = &quot;yyyy-MM-dd&quot;,timezone = &quot;Asia/Shanghai&quot;) 将日期类型格式化后再返回给前端 @JsonIgnore 忽略被该注解标识的字段 12345678910111213141516@Getter@Setter@ToString@AllArgsConstructor@NoArgsConstructorpublic class User { private Integer id; private String username; @JsonIgnore private String password; private String email; private int age; @JsonFormat(pattern = \"yyyy-MM-dd\",timezone = \"Asia/Shanghai\") @DateTimeFormat(pattern = \"yyyy-MM-dd\") private Date birthday;} 12345678910@GetMapping(\"/getAllUser\") @ResponseBody public List&lt;User&gt; getAllUser() throws JsonProcessingException { List&lt;User&gt; list=new ArrayList&lt;&gt;(); list.add(new User(1, \"张三\", \"123456\", \"123@qq.com\", 22, new Date())); list.add(new User(2, \"李四\", \"12356\", \"123@qq.com\", 16, new Date())); list.add(new User(3, \"王五\", \"12456\", \"123@qq.com\", 14, new Date())); list.add(new User(4, \"赵六\", \"12356\", \"123@qq.com\", 13, new Date())); return list; } 3、ajax请求12345678910@GetMapping(\"/getAjaxUser\") @ResponseBody public List&lt;User&gt; getAjaxAllUser() throws JsonProcessingException { List&lt;User&gt; list=new ArrayList&lt;&gt;(); list.add(new User(1, \"张三\", \"123456\", \"123@qq.com\", 22, new Date())); list.add(new User(2, \"李四\", \"12356\", \"123@qq.com\", 16, new Date())); list.add(new User(3, \"王五\", \"12456\", \"123@qq.com\", 14, new Date())); list.add(new User(4, \"赵六\", \"12356\", \"123@qq.com\", 13, new Date())); return list; } 1234567891011121314151617181920212223&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script type=\"text/javascript\" src=\"js/jquery/3.4.1/jquery.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=\"#\"&gt;获取所有用户&lt;/a&gt;&lt;script&gt; $(function () { $(\"a:first\").click(function () { $.ajax({ url:\"getAjaxUser\", type:\"GET\", success:function (data) { console.log(data); } }) }) })&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 六、@ResponseBody和@RequestBody@ResponseBody： 将返回的数据放在响应体中 @RequestBody：前端使用 application/json 类型的json字符串传给后端接收。 123456@PostMapping(\"/putUser\")@ResponseBodypublic String getAjaxAllUser1(@RequestBody User user) { System.out.println(user); return \"success\";} 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;%@ taglib prefix=\"form\" uri=\"http://www.springframework.org/tags/form\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"js/jquery/3.4.1/jquery.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=\"handleplus\"&gt;发送get请求&lt;/a&gt;&lt;form action=\"user\" method=\"post\"&gt; id: &lt;input type=\"text\" name=\"id\"/&gt;&lt;br/&gt; 用户名: &lt;input type=\"text\" name=\"username\"/&gt;&lt;br/&gt; 生日:&lt;input type=\"text\" name=\"birthday\"/&gt;&lt;br/&gt; 邮箱:&lt;input type=\"text\" name=\"email\"/&gt;&lt;br/&gt; 年龄:&lt;input type=\"text\" name=\"age\"/&gt;&lt;br/&gt; &lt;input type=\"button\" onclick=\"sub()\" value=\"提交\"&gt;&lt;/form&gt;&lt;script&gt; $(function () { }) function sub() { //只有get无请求体，请求参数只能在 地址栏中传输 //其他请求有请求体，可以指定将请求参数以json字符串的形式放在data请求体中 //注意：当后端使用@RequestBody接收application/json的json字符串时， //data必须为字符串，且需要指定contentType:\"application/json\", let user='{\"username\":\"张三\",\"age\":12}'; $.ajax({ url:\"putUser\", type:\"POST\", //默认为 application/x-www-form-urlencoded contentType:\"application/json\", data:user, success:function (data) { alert(data) } }) }&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 七、SpringMVC文件下载123456789101112131415@GetMapping(\"/download\")public ResponseEntity&lt;byte[]&gt; test2(HttpServletRequest request) throws IOException { //通过HttpServletRequest获取我们要下载文件的绝对路径 String realPath = request.getServletContext().getRealPath(\"/upload/1.jpg\"); FileInputStream fileInputStream = new FileInputStream(realPath); //将数组的大小 设置为文件的最大大小 byte[] bytes = new byte[fileInputStream.available()]; fileInputStream.read(bytes); fileInputStream.close(); MultiValueMap&lt;String,String&gt; headers=new HttpHeaders(); headers.add(\"Content-Disposition\",\"attachment;filename=\"+\"1.jpg\"); ResponseEntity&lt;byte[]&gt; responseEntity = new ResponseEntity&lt;&gt;(bytes, headers, HttpStatus.OK); return responseEntity;} 八、SpringMVC文件上传123456789101112&lt;!--文件上传--&gt; &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt; &lt;/dependency&gt;&lt;!--注意 必须为commons-io下的包--&gt; &lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt; &lt;/dependency&gt; 配置文件上传解析器 12345678&lt;!--配置文件上传解析器--&gt; &lt;!--id必须为multipartResolver--&gt; &lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt; &lt;!--配置默认编码--&gt; &lt;property name=\"defaultEncoding\" value=\"utf-8\"&gt;&lt;/property&gt; &lt;!--最大文件的上传大小 单位为KB 这里我们指定20MB--&gt; &lt;property name=\"maxUploadSize\" value=\"#{1024*1024*20}\"&gt;&lt;/property&gt; &lt;/bean&gt; 1、单文件上传12345678910111213141516171819202122@RequestMapping(\"/file\")@Controllerpublic class FileUploadController { @PostMapping(\"/upload\") public String upload(Model model, @RequestParam(value = \"username\",required = false) String username, @RequestParam(\"headerImg\")MultipartFile multipartFile) { //获取input标签中的name值 System.out.println(\"文件的名称:\"+multipartFile.getName()); //获取文件的名称 System.out.println(\"文件的名称:\"+multipartFile.getOriginalFilename()); //文件保存 try { multipartFile.transferTo(new File(\"F:\\\\upload\\\\\"+multipartFile.getOriginalFilename())); model.addAttribute(\"msg\", \"文件上传成功\"); } catch (IOException e) { e.printStackTrace(); model.addAttribute(\"msg\", \"文件上传失败\"); } return \"forward:/fileupload.jsp\"; }} 1234567891011121314&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;上传状态:${msg}&lt;form action=\"file/upload\" method=\"post\" enctype=\"multipart/form-data\"&gt; 用户名: &lt;input type=\"text\" name=\"username\"&gt;&lt;br&gt; 头像:&lt;input type=\"file\" name=\"headerImg\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 2、多文件上传12345678910111213141516171819@PostMapping(\"/multipleUpload\")public String upload1(Model model, @RequestParam(value = \"username\",required = false) String username, @RequestParam(\"headerImg\")MultipartFile[] multipartFile) { for (MultipartFile multipartFile1 : multipartFile) { //判断是否选择了文件 if (!multipartFile1.isEmpty()) { //文件保存 try { multipartFile1.transferTo(new File(\"F:\\\\upload\\\\\"+multipartFile1.getOriginalFilename())); model.addAttribute(\"msg\", \"文件上传成功\"); } catch (IOException e) { e.printStackTrace(); model.addAttribute(\"msg\", \"文件上传失败\"); } }else{ model.addAttribute(\"msg\", \"请选择文件！！\"); } } return \"forward:/fileupload.jsp\";} 12345678910111213141516&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;上传状态:${msg}&lt;form action=\"file/multipleUpload\" method=\"post\" enctype=\"multipart/form-data\"&gt; 用户名: &lt;input type=\"text\" name=\"username\"&gt;&lt;br&gt; 头像1:&lt;input type=\"file\" name=\"headerImg\"&gt;&lt;br&gt; 头像2:&lt;input type=\"file\" name=\"headerImg\"&gt;&lt;br&gt; 头像3:&lt;input type=\"file\" name=\"headerImg\"&gt;&lt;br&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 九、拦截器SpringMVC提供拦截器机制，允许允许的目标方法之前进行一些拦截工作，或者目标方法完成之后进行的一些处理 1、基本配置流程123456789101112131415161718192021222324252627282930313233343536373839404142public class MyInterceptor implements HandlerInterceptor { /** * 目标方法执行之前调用 * @param request * @param response * @param handler * @return 返回true,放行该方法。返回false,不放行。 * @throws Exception */ @Override public boolean preHandle(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response, Object handler) throws Exception { System.out.println(\"preHandle....\"); return true; } /** * 在目标方法运行之后调用 * @param request * @param response * @param handler * @param modelAndView * @throws Exception */ @Override public void postHandle(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\"postHandle.....\"); } /** * 在整个请求完成之后，即响应完成之后，调用该方法 * @param request * @param response * @param handler * @param ex * @throws Exception */ @Override public void afterCompletion(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(\"afterCompletion.....\"); }} xml配置 1234567891011&lt;!--配置拦截器--&gt;&lt;mvc:interceptors&gt; &lt;!--拦截所有请求--&gt; &lt;!--&lt;bean class=\"org.lc.interceptor.MyInterceptor\"&gt;&lt;/bean&gt;--&gt; &lt;mvc:interceptor&gt; &lt;!--拦截所有请求--&gt; &lt;mvc:mapping path=\"/*\"/&gt; &lt;bean class=\"org.lc.interceptor.MyInterceptor\"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; 12345678@Controllerpublic class InterceptorController { @GetMapping(\"/interceptor\") public String interceptor() { System.out.println(\"目标方法.....\"); return \"success\"; }} 执行结果 12345preHandle....目标方法.....postHandle.....来到success页面...afterCompletion..... 2、单个拦截器执行流程 当preHandle放行 (true)： preHandle –&gt; 目标方法 –&gt; postHandle –&gt; 页面响应完成之后 –&gt; afterCompletion 当preHandle不放行 (false)： preHandle 执行完成之后，后续流程都不执行 当preHandle放行之后，若执行目标方法出现异常 preHandle –&gt; 目标方法异常(来到错误页面) –&gt; afterCompletion 即只要放行了，无论是否异常 afterCompletion 都会执行 3、多拦截器配置 拦截器1 123456789101112131415public class MyInterceptor implements HandlerInterceptor { @Override public boolean preHandle(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response, Object handler) throws Exception { System.out.println(\"preHandle....\"); return true; } @Override public void postHandle(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\"postHandle.....\"); } @Override public void afterCompletion(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(\"afterCompletion.....\"); }} 拦截器2 12345678910111213141516public class MyInterceptro2 implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\"preHandle2...\"); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\"postHandle2....\"); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(\"afterCompletion2....\"); }} xml配置 1234567891011121314&lt;!--配置拦截器--&gt;&lt;mvc:interceptors&gt; &lt;!-- 配置多拦截器 是按照配置的流程来执行--&gt; &lt;mvc:interceptor&gt; &lt;!--拦截所有请求--&gt; &lt;mvc:mapping path=\"/*\"/&gt; &lt;bean class=\"org.lc.interceptor.MyInterceptor\"&gt;&lt;/bean&gt; &lt;/mvc:interceptor&gt; &lt;!--拦截所有请求--&gt; &lt;bean class=\"org.lc.interceptor.MyInterceptro2\"&gt;&lt;/bean&gt;&lt;/mvc:interceptors&gt; 12345678@Controllerpublic class InterceptorController { @GetMapping(\"/interceptor\") public String interceptor() { System.out.println(\"目标方法.....\"); return \"success\"; }} 12345678preHandle....preHandle2...目标方法.....postHandle2....postHandle.....来到success页面...afterCompletion2....afterCompletion..... 4、多拦截器执行流程和过滤器一致，先进行的先执行，但是最后出去，后执行的拦截器先出去 拦截器的preHandle：按照顺序执行 拦截器的postHandle:按照逆序执行 拦截器afterCompletion:按照逆序执行 只要拦截器都会执行对应拦截器的afterCompletion方法 只要先进入的拦截器不放行，那么后续的其他拦截器也不会执行 十、拦截器与过滤器的区别①：拦截器是基于java的反射机制的，而过滤器是基于函数的回调。②：拦截器不依赖于servlet容器，而过滤器依赖于servlet容器。③：拦截器只对action请求起作用，而过滤器则可以对几乎所有的请求起作用。④：拦截器可以访问action上下文、值、栈里面的对象，而过滤器不可以。⑤：在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次。⑥：拦截器可以获取IOC容器中的各个bean，而过滤器不行，这点很重要，在拦截器里注入一个service，可以调用业务逻辑。 https://blog.csdn.net/weixin_44502804/article/details/93139550 十一、异常处理1、只处理本控制器类异常12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Controller@RequestMapping(\"/\")public class ExceptionController { @ResponseBody @GetMapping(\"/handler1\") public String handler1(@RequestParam(\"i\") Integer i) { System.out.println(\"handler...\"); int a = 10 / i; return \"success\"; } @GetMapping(\"/handler2\") public String handler2(@RequestParam(value = \"i\",required = false) Integer i) { System.out.println(\"handler...\"); int a = 10 / i; return \"success\"; } //放在该请求控制器下的只能处理 前控制器下的异常 //以响应体的方式输出 @ResponseBody //指定处理错误的类型 @ExceptionHandler(ArithmeticException.class) public String hander1Exception(Exception e) { //获取错误消息 String message = e.getMessage(); return \"error:\"+ message; } //返回到指定页面 //指定处理错误的类型 // @ExceptionHandler(Exception.class) // public String hander2Exception(Exception e) { // //由视图解析器拼串处理 // return \"error\"; // } //返回指定视图并携带参数 // 指定处理错误的类型 @ExceptionHandler(Exception.class) public ModelAndView hander2Exception(Exception e) { ModelAndView modelAndView = new ModelAndView(\"error\"); modelAndView.addObject(\"msg\",e); return modelAndView; } } 2、处理全局异常 @RestControllerAdvice == @ControllerAdviced + @ResponseBody 若响应的信息需要直接输为到响应体，则直接在全局异常控制器上加该注解，里面所有的 异常处理方法的返回值都以 响应体的形式输出 @ControllerAdviced 的使用 若全局异常处理和本控制器异常都存在，则优先使用 本控制器的异常处理机制 若多个异常处理器同时捕获到该异常，则优先使用精确的异常处理器 若@ResponseBody返回中文乱码： 12345678&lt;mvc:annotation-driven&gt; &lt;!-- 消息转换器 --&gt; &lt;mvc:message-converters register-defaults=\"true\"&gt; &lt;bean class=\"org.springframework.http.converter.StringHttpMessageConverter\"&gt; &lt;property name=\"defaultCharset\" value=\"UTF-8\"/&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; 全局异常处理： 123456789101112131415161718192021222324@ControllerAdvicepublic class GlobalExceptionController { //1、返回到指定视图 @ExceptionHandler(Exception.class) public String handler1(Exception e) { return \"error\"; } //2、返回到指定视图并携带异常参数 // @ExceptionHandler(Exception.class) // public ModelAndView handler2(Exception e) { // ModelAndView modelAndView = new ModelAndView(\"error\"); // modelAndView.addObject(\"msg\",e); // return modelAndView; // } //3、返回为响应体 @ResponseBody @ExceptionHandler(NullPointerException.class) public String handler3(Exception e) { return \"{'error':'异常','statusCode':1010,'msg':\"+e+\"}\"; }} 本控制器异常处理 1234567891011121314151617181920212223@Controller@RequestMapping(\"/\")public class ExceptionController { @GetMapping(\"/handler2\") public String handler2(@RequestParam(value = \"i\",required = false) Integer i) { System.out.println(\"handler...\"); int a = 10 / i; return \"success\"; } //放在该请求控制器下的只能处理 前控制器下的异常 //以响应体的方式输出 @ResponseBody //指定处理错误的类型 @ExceptionHandler(ArithmeticException.class) public String hander1Exception(Exception e) { //获取错误消息 String message = e.getMessage(); return \"error:\"+ message; } } 十二、SpringMVC+Spring整合要使我们的Spring和SpringMVC各司其职 Spring管理业务逻辑组件—–IOC容器 SpringMVC管理控制器—–前端控制器 当我们有两个容器同时存在时，spring作为父容器，springmvc作为子容器。 当我们的父容器的service要使用子容器的controller则不行 当我们的子容器controller要使用父容器的service则可以。 web.xml配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!--配置spring--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!--项目一启动就 创建IOC容器--&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!--配置springmvc--&gt; &lt;!--配置前端控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;!--前端控制器的全路径名--&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;!--指定springmvc配置文件位置--&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--服务器启动的时候就创建对象--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!--配置前端控制器 拦截的路径--&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;!--拦截所有--&gt; &lt;!-- /和/* 都是拦截所有请求; /会拦截所有请求，但是不会拦截 *.jsp 。保证jsp的访问正常 /* 拦截的范围更大，会拦截到 *.jsp的请求，导致jsp页面不能正常显示 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--解决中文乱码 注意过滤器的配置顺序 我们解决中文乱码的过滤器一般放在所有过滤器之前--&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;!--设置编码为utf-8--&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;utf-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;!--设置强制解决请求乱码--&gt; &lt;param-name&gt;forceRequestEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;!--设置强制解决响应乱码--&gt; &lt;param-name&gt;forceResponseEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;!--指定所有请求--&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!--使form表单支持 delet和put请求--&gt; &lt;filter&gt; &lt;filter-name&gt;hiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;hiddenHttpMethodFilter&lt;/filter-name&gt; &lt;!--拦截所有请求--&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt;&lt;/web-app&gt; Spring容器 123456789101112131415&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!--让spring只管理我们的业务组件--&gt; &lt;context:component-scan base-package=\"org.lc\"&gt; &lt;!--除了被controller标了注解不扫描外，其余的都扫描--&gt; &lt;context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt; &lt;/context:component-scan&gt;&lt;/beans&gt; SpringMVC容器 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!--使springmvc只管理我们的控制器--&gt; &lt;!--禁用默认扫所有的规则--&gt; &lt;context:component-scan base-package=\"org.lc\" use-default-filters=\"false\"&gt; &lt;!--只扫描包含controller注解的控制器--&gt; &lt;context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt; &lt;/context:component-scan&gt;&lt;/beans&gt;","link":"/2020/07/24/ssm/SpringMVC/"},{"title":"springboot基本配置","text":"一、springboot基本配置1234567#设置端口server.port=8081#设置上下文路径 (即请求包含的前缀)server.servlet.context-path=/lc#配置内嵌的tomcat编码server.tomcat.uri-encoding=UTF-8#还可以配置其他jetty相关的属性 12345678910111213141516171819&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;!--排除内部的tomcat--&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!--排除tomcat服务器后，使用jetty服务器--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 1、关于springboot启动类1234567@SpringBootApplicationpublic class TomcatApplication { public static void main(String[] args) { SpringApplication.run(TomcatApplication.class, args); }} @SpringBootApplication===&gt; 1234567891011@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan( excludeFilters = {@Filter( type = FilterType.CUSTOM, classes = {TypeExcludeFilter.class}), @Filter( type = FilterType.CUSTOM, classes = {AutoConfigurationExcludeFilter.class})}) ①@ComponentScan12@Service,@Repository,@Component,@Controller用来定义一个bean.@ComponentScan注解就是用来自动扫描被这些注解标识的类，最终生成ioc容器里的bean．可以通过设置@ComponentScan(basePackages，includeFilters，excludeFilters)属性来动态确定自动扫描范围，类型以及不扫描的类型． 默认情况下:它扫描所有类型，并且扫描范围是@ComponentScan注解所在配置类包及子包的类 ②@SpringBootConfiguration1这个注解的作用与@Configuration作用相同，都是用来声明当前类是一个配置类．可以通过＠Bean注解生成IOC容器管理的bean. ③@EnableAutoConfiguration12@EnableAutoConfiguration是springboot实现自动化配置的核心注解，通过这个注解把spring应用所需的bean注入容器中．@EnableAutoConfiguration源码通过@Import注入了一个ImportSelector的实现类AutoConfigurationImportSelector,这个ImportSelector最终实现根据我们的配置，动态加载所需的bean. 2、maven中的 parent1234567891011121314 &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.2.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 这里查看源我们可以发现，它自动帮我们定义了一系列的引用的版本号。我们去引用其他依赖时，不需要定义额外的版本号（这里的依赖必须是org.springframework.boot中，否则还是要加版本号） 3、花里胡哨的banner在resources下添加banner.txt http://patorjk.com/software/taag http://www.network-science.de/ascii/ 123456789101112131415161718192021////////////////////////////////////////////////////////////////////// _ooOoo_ //// o8888888o //// 88&quot; . &quot;88 //// (| ^_^ |) //// O\\ = /O //// ____/`---'\\____ //// .' \\\\| |// `. //// / \\\\||| : |||// \\ //// / _||||| -:- |||||- \\ //// | | \\\\\\ - /// | | //// | \\_| ''\\---/'' | | //// \\ .-\\__ `-` ___/-. / //// ___`. .' /--.--\\ `. . ___ //// .&quot;&quot; '&lt; `.___\\_&lt;|&gt;_/___.' &gt;'&quot;&quot;. //// | | : `- \\`.;`\\ _ /`;.`/ - ` : | | //// \\ \\ `-. \\_ __\\ /__ _/ .-` / / //// ========`-.____`-.___\\_____/___.-`____.-'======== //// `=---=' //// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ //// 佛祖保佑 永不宕机 永无BUG // 禁用banner 123456789@SpringBootApplicationpublic class TomcatApplication { public static void main(String[] args) { SpringApplicationBuilder builder = new SpringApplicationBuilder(TomcatApplication.class); SpringApplication build = builder.build(); build.setBannerMode(Banner.Mode.OFF); build.run(args); }} 4、单元测试添加123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;!--只会在测试时使用 不会被打包--&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; test主文件： 12345678@RunWith(SpringRunner.class)//启动类@SpringBootTest(classes = JDBCTemplateApplication.class))public class PropertyApplicationTests { @Test public void contextLoads(){ }} 5、自定义属性配置及加载properties①@PropertySource(“classpath:person.properties”)导入properties文件 ②@ConfigurationProperties(prefix = “person”)定义前缀person ③@Value(“${name:xxx}”)属性上加@value可不用定义该属性的get,set方法，否则要加get,set方法 定义实体对应的properties文件中的属性 定义默认值：xxx 配置实体,定义为组件： 1234567891011121314@Component@PropertySource(\"classpath:person.properties\")@ConfigurationProperties(prefix = \"person\")public class Person { @Value(\"${name:xxx}\") private String name; private Integer age; private String gender; //getter... //setter... //toString...} properties文件==&gt; 123person.name=张三person.age=10person.gender=男 使用==&gt; 注入即用: 12345678910@RunWith(SpringRunner.class)@SpringBootTestpublic class PropertyApplicationTests { @Autowired private Person person; @Test public void contextLoads(){ System.out.println(person); }} 6、yaml/yml配置注意：在yaml中，最好不要写大写的属性名称，大写前面加字母前加 - 后转小写 1、yaml是配置是有序的，properties是无序的 2、自定义的yaml目前暂不支持使用注解的方式注入到springboot项目中 3、注意每个属性的冒号： 后需要加一个空格 注入集合字符串，注入集合对象123456789101112131415161718192021server: port: 8081 servlet: context-path: /lcredis: port: 6379# 注入集合字符串 hosts: - 192.169.22.33 - 192.169.22.34 - 192.169.22.35 - 192.169.22.36 - 192.169.22.37# 注入集合对象 redisList: #一个 -组 代表一个对象 - port: 6379 host: 192.168.22.38 - port: 6379 host: 192.168.22.39 1234567public class Redis { private Integer port; private String host; //getter... //setter... //toString...} 12345678910@Component@ConfigurationProperties(prefix = \"redis\")public class RedisCluster { private Integer port; private List&lt;String&gt; hosts; private List&lt;Redis&gt; redisList; //getter... //setter... //toString...} 7、多环境的yaml/properties配置我们可以定义诸如：application-xxx.yaml application-test.yaml application-dev.yaml application-prod.yaml 多种环境的配置，在application.yaml中激活即可: 1spring.profiles.active=prod 会覆盖application.yaml中本身内容 8、访问static下的所有资源(html)1234567891011121314151617&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;includes&gt; &lt;include&gt;**/**&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 二、springboot整合视图层框架1、整合Freemarker依赖==&gt; 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;&lt;/dependency&gt; 123456789public class User { private String id; private String username; private String password; private String address; //getter //setter //toString} 1234567891011121314151617@Controllerpublic class UserController { @GetMapping(\"/user\") public String user(Model model) { List&lt;User&gt; list = new ArrayList&lt;&gt;(); for (int i = 1; i &lt; 6; i++) { User user=new User(); user.setId(i+\"\"); user.setUsername(\"cl\"+i); user.setPassword(\"123456\"); user.setAddress(\"pengx\"); list.add(user); } model.addAttribute(\"users\", list); return \"user\"; }} 模板引擎==&gt; 注意：此文件的后缀为 .ftlh 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;用户信息&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table border=\"1\" cellspacing=\"0\"&gt; &lt;tr&gt; &lt;td&gt;编号&lt;/td&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;地址&lt;/td&gt; &lt;/tr&gt; &lt;#list users as u&gt; &lt;tr&gt; &lt;td&gt;${u.id}&lt;/td&gt; &lt;td&gt;${u.username}&lt;/td&gt; &lt;td&gt;${u.password}&lt;/td&gt; &lt;td&gt;${u.address}&lt;/td&gt; &lt;/tr&gt; &lt;/#list&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; yaml配置==&gt; 12345678spring: freemarker: #自定义模板文件的加载位置 template-loader-path: classpath:/templates #是否开启缓存 cache: false #上下文类型 content-type: text/html 更多属性的更改参考 FreeMarkerProperties中的默认配置 12345678910public class FreeMarkerProperties extends AbstractTemplateViewResolverProperties { public static final String DEFAULT_TEMPLATE_LOADER_PATH = \"classpath:/templates/\"; public static final String DEFAULT_PREFIX = \"\"; public static final String DEFAULT_SUFFIX = \".ftlh\"; private Map&lt;String, String&gt; settings = new HashMap(); private String[] templateLoaderPath = new String[]{\"classpath:/templates/\"}; private boolean preferFileSystemAccess = true; //..... //.....} 2、整合thymeleaf1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 12345678910111213141516171819@Controllerpublic class UserController { @GetMapping(\"/user\") public String user(Model model) { List&lt;User&gt; list = new ArrayList&lt;&gt;(); for (int i = 1; i &lt; 6; i++) { User user=new User(); user.setId(i+\"\"); user.setUsername(\"cl\"+i); user.setPassword(\"123456\"); user.setAddress(\"pengx\"); list.add(user); } model.addAttribute(\"users\", list); return \"User\"; }} 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;用户信息&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table border=\"1\" cellspacing=\"0\"&gt; &lt;tr&gt; &lt;td&gt;编号&lt;/td&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;地址&lt;/td&gt; &lt;/tr&gt; &lt;tr th:each=\"user :${users}\"&gt; &lt;td th:text=\"${user.id}\"&gt;&lt;/td&gt; &lt;td th:text=\"${user.username}\"&gt;&lt;/td&gt; &lt;td th:text=\"${user.password}\"&gt;&lt;/td&gt; &lt;td th:text=\"${user.address}\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 更多配置请看源码 ThymeleafProperties: 1234567891011121314151617181920public class ThymeleafProperties { private static final Charset DEFAULT_ENCODING; public static final String DEFAULT_PREFIX = \"classpath:/templates/\"; public static final String DEFAULT_SUFFIX = \".html\"; private boolean checkTemplate = true; private boolean checkTemplateLocation = true; private String prefix = \"classpath:/templates/\"; private String suffix = \".html\"; private String mode = \"HTML\"; private Charset encoding; private boolean cache; private Integer templateResolverOrder; private String[] viewNames; private String[] excludedViewNames; private boolean enableSpringElCompiler; private boolean renderHiddenMarkersBeforeCheckboxes; private boolean enabled; private final ThymeleafProperties.Servlet servlet; private final ThymeleafProperties.Reactive reactive;} 3、整合jsp①pom.xml123456789&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt; ②配置视图解析器 WebMvcConfigurer在src/main/webapp/page/...... 增加webapp文件夹，并指定存放jsp的位置 1234567@Configurationpublic class WebMvcConfig implements WebMvcConfigurer { @Override public void configureViewResolvers(ViewResolverRegistry registry) { registry.jsp(\"/page/\", \".jsp\"); }} ③控制器1234567891011121314151617@Controllerpublic class UserController { @GetMapping(\"/user\") public String user(Model model) { List&lt;User&gt; list = new ArrayList&lt;&gt;(); for (int i = 1; i &lt; 6; i++) { User user=new User(); user.setId(i+\"\"); user.setUsername(\"cl\"+i); user.setPassword(\"123456\"); user.setAddress(\"pengx\"); list.add(user); } model.addAttribute(\"users\", list); return \"User\"; }} ④视图12345678910111213141516171819202122232425&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table border=\"1\" cellspacing=\"0\"&gt; &lt;tr&gt; &lt;td&gt;编号&lt;/td&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;地址&lt;/td&gt; &lt;/tr&gt; &lt;c:forEach var=\"user\" items=\"${users}\"&gt; &lt;tr&gt; &lt;td&gt;${user.id}&lt;/td&gt; &lt;td&gt;${user.username}&lt;/td&gt; &lt;td&gt;${user.password}&lt;/td&gt; &lt;td&gt;${user.address}&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 三、springboot整合web开发1、HttpMessageConverter注：以下例子只是实体响应日期类型的格式转换 (1)功能①将服务端返回的对象序列化成JOSN字符串 ②将前端传来的JSON字符串反序列化成java对象 (2)Jackson和Gson自动化配置和手动配置所有的JSON生成都离不开HttpMessageConverter SpringMvc自动配置了Jackson和Gson的HttpMessageConverter, springboot对此做了自动化配置 ①Jacksonspring-boot-starter-web中默认使用的是jsckson 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 方式一：自动配置==&gt; 如果我们没有配置MappingJackson2HttpMessageConverter，则springboot帮我们自动配置 org.springframework.boot.autoconfigure.http.JacksonHttpMessageConvertersConfiguration==&gt; 12345678@Bean @ConditionalOnMissingBean( value = {MappingJackson2HttpMessageConverter.class}, ignoredType = {\"org.springframework.hateoas.server.mvc.TypeConstrainedMappingJackson2HttpMessageConverter\", \"org.springframework.data.rest.webmvc.alps.AlpsJsonHttpMessageConverter\"} ) MappingJackson2HttpMessageConverter mappingJackson2HttpMessageConverter(ObjectMapper objectMapper) { return new MappingJackson2HttpMessageConverter(objectMapper); } 手动配置==&gt; 如果我们配置了MappingJackson2HttpMessageConverter类,则自动配置失效 WebMvcConfig.java: 1234567891011@Configurationpublic class WebMvcConfig { @Bean public MappingJackson2HttpMessageConverter mappingJackson2HttpMessageConverter() { MappingJackson2HttpMessageConverter converter=new MappingJackson2HttpMessageConverter(); ObjectMapper mapper=new ObjectMapper(); mapper.setDateFormat(new SimpleDateFormat(\"yyyy-MM-dd\")); converter.setObjectMapper(mapper); return converter;` }} 方式二：自动配置==&gt; org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration 123456@Bean @Primary @ConditionalOnMissingBean ObjectMapper jacksonObjectMapper(Jackson2ObjectMapperBuilder builder) { return builder.createXmlMapper(false).build(); } 手动配置==&gt; 配置ObjectMapper使其自动配置失效 WebMvcConfig.java: 123456789@Configurationpublic class WebMvcConfig { @Bean public ObjectMapper objectMapper(){ ObjectMapper mapper=new ObjectMapper(); mapper.setDateFormat(new SimpleDateFormat(\"yyyy-MM-dd\")); return mapper; }} ②Gson排除spring-boot-starter-web中原有的jackson。 新增gson依赖 方式一：123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-json&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt;&lt;/dependency&gt; 自动配置：==&gt; 同理，如果我们没有配置HttpMessageConverter，则springboot帮我们自动配置 org.springframework.boot.autoconfigure.http.GsonHttpMessageConvertersConfiguration==&gt; 1234567@Bean @ConditionalOnMissingBean GsonHttpMessageConverter gsonHttpMessageConverter(Gson gson) { GsonHttpMessageConverter converter = new GsonHttpMessageConverter(); converter.setGson(gson); return converter; } 手动配置：==&gt; 123456789@Configurationpublic class WebMvcConfig { @Bean GsonHttpMessageConverter gsonHttpMessageConverter() { GsonHttpMessageConverter converter = new GsonHttpMessageConverter(); converter.setGson(new GsonBuilder().setDateFormat(\"yyyy-MM-dd\").create()); return converter; }} 方式二：自动配置==&gt; org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration==&gt; 12345@Bean @ConditionalOnMissingBean public Gson gson(GsonBuilder gsonBuilder) { return gsonBuilder.create(); } 手动配置==&gt; 1234567@Configurationpublic class WebMvcConfig { @Bean Gson gson() { return new GsonBuilder().setDateFormat(\"yyyy-MM-dd\").create(); }} (3)fastjson手动配置12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-json&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.58&lt;/version&gt; &lt;/dependency&gt; 1234567891011@Configurationpublic class WebMvcConfig { @Bean FastJsonHttpMessageConverter fastJsonHttpMessageConverter() { FastJsonHttpMessageConverter converter=new FastJsonHttpMessageConverter(); FastJsonConfig fastJsonConfig=new FastJsonConfig(); fastJsonConfig.setDateFormat(\"yyyy-MM-dd\"); converter.setFastJsonConfig(fastJsonConfig); return converter; }} 2、springboot静态资源管理(1)默认的自动配置在源码中，我们可以看出，springboot帮我们自动做了一些配置 org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfigurati==&gt; 12345678910111213141516public void addResourceHandlers(ResourceHandlerRegistry registry) { if (!this.resourceProperties.isAddMappings()) { logger.debug(\"Default resource handling disabled\"); } else { Duration cachePeriod = this.resourceProperties.getCache().getPeriod(); CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl(); if (!registry.hasMappingForPattern(\"/webjars/**\")) { this.customizeResourceHandlerRegistration(registry.addResourceHandler(new String[]{\"/webjars/**\"}).addResourceLocations(new String[]{\"classpath:/META-INF/resources/webjars/\"}).setCachePeriod(this.getSeconds(cachePeriod)).setCacheControl(cacheControl)); } String staticPathPattern = this.mvcProperties.getStaticPathPattern(); if (!registry.hasMappingForPattern(staticPathPattern)) { this.customizeResourceHandlerRegistration(registry.addResourceHandler(new String[]{staticPathPattern}).addResourceLocations(WebMvcAutoConfiguration.getResourceLocations(this.resourceProperties.getStaticLocations())).setCachePeriod(this.getSeconds(cachePeriod)).setCacheControl(cacheControl)); } } } org.springframework.boot.autoconfigure.web.ResourceProperties==&gt; 1private static final String[] CLASSPATH_RESOURCE_LOCATIONS = new String[]{\"classpath:/META-INF/resources/\", \"classpath:/resources/\", \"classpath:/static/\", \"classpath:/public/\"}; 我们可以发现，springboot帮我们配置了一些静态资源的处理路径，按照顺序依次在resources文件夹下查找静态资源文件 classpath:/META-INF/resources/“ classpath:/resources/ classpath:/static/ classpath:/public/ 注意：在请求的时候我们就可以省略定义的文件夹名了 (2)自定义访问目录①yaml配置12345678910spring: resources: #静态资源的位置 static-locations: classpath:/lc/ mvc: #静态资源的请求规则 #不配置规则（任意规则）# static-path-pattern: /** #请求静态资源时必须加 /hh/ 前缀再加文件夹或者文件路径 static-path-pattern: /hh/** ②配置文件配置addResourceHandler(&quot;/**&quot;) 静态资源请求规则 addResourceLocations(&quot;classpath:/lc/&quot;) 静态资源位置 1234567@Configurationpublic class WebMvcConfig implements WebMvcConfigurer { @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { registry.addResourceHandler(\"/**\").addResourceLocations(\"classpath:/lc/\"); }} 例如：–resources ​ –lc ​ –java ​ –hello.js 无访问规则：==&gt; 访问路径为 http://localhost:8080/java/hello.js 有访问规则（/hh/**）==&gt; 访问路径为 http://localhost:8080/hh/java/hello.js 3、springBoot实现文件上传（1）form形式在springboot中我们直接使用MultipartFile接口中的org.springframework.web.multipart.support.StandardMultipartHttpServletRequest.StandardMultipartFile实现类 自动配置==&gt; org.springframework.boot.autoconfigure.web.servlet.MultipartProperties==&gt; 12345678910111213141516171819@ConfigurationProperties( prefix = \"spring.servlet.multipart\", ignoreUnknownFields = false)public class MultipartProperties { //是否开启上传 private boolean enabled = true; //临时存储位置 private String location; //上传大小限制 private DataSize maxFileSize = DataSize.ofMegabytes(1L); //上传文件（多个）总大小 private DataSize maxRequestSize = DataSize.ofMegabytes(10L); //文件上传的阈值（上传多少文件时，不能往内存中写，需要转换处理） private DataSize fileSizeThreshold = DataSize.ofBytes(0L); private boolean resolveLazily = false; //...... //......} 12345spring: servlet: multipart:# 定义文件的上传大小限制 这里需要大写KB max-file-size: 1KB ①单文件123456789101112131415161718192021222324252627282930313233@RestControllerpublic class FileUploadController { SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"/yyyy/MM/dd/\"); @PostMapping(\"/upload\") public String hello(MultipartFile file, HttpServletRequest req) { String format = simpleDateFormat.format(new Date());// 自定义：获取上传的文件的真正路径/img/yyyy/MM/dd/ String realPath = req.getServletContext().getRealPath(\"/img\") + format; File folder = new File(realPath);// 若定义的文件夹不存在 if (!folder.exists()) {// 创建该文件夹 folder.mkdirs(); }// 获得上传的文件名称 String oldName = file.getOriginalFilename();// 截图文件的后缀，并加上生成的uuid作为文件名 String newName = UUID.randomUUID().toString() + oldName.substring(oldName.lastIndexOf(\".\")); try {// 文件转换 上传到内存中// 重新定义其文件路径 及 文件名 file.transferTo(new File(folder, newName));// 返回路径：协议://服务器名称:端口/img//yyyy/MM/dd/+新的文件名 String url = req.getScheme() + \"://\" + req.getServerName() + \":\" + req.getServerPort() + \"/img\" + format + newName;// 返回该url return url; } catch (IOException e) { } return \"error\"; }} 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"file\" name=\"file\"/&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; ②多文件注意：这里的files为一个数组，为前端的 的name名称。 若有多个input标签，则只需要在后端请求参数上多加个MultipartFile file1,MultipartFile file2即可 123456789101112131415161718192021222324252627282930 @PostMapping(\"/uploads\") public String uploads(MultipartFile[] files, HttpServletRequest req) { String format = simpleDateFormat.format(new Date());// 自定义：获取上传的文件的真正路径/img/yyyy/MM/dd/ String realPath = req.getServletContext().getRealPath(\"/img\") + format; File folder = new File(realPath);// 若定义的文件夹不存在 if (!folder.exists()) {// 创建该文件夹 folder.mkdirs(); } //循环遍历存储 for (MultipartFile file : files) {// 获得上传的文件名称 String oldName = file.getOriginalFilename();// 截图文件的后缀，并加上生成的uuid作为文件名 String newName = UUID.randomUUID().toString() + oldName.substring(oldName.lastIndexOf(\".\")); try {// 文件转换 上传到内存中 // 重新定义其文件路径 及 文件名 file.transferTo(new File(folder, newName));// 返回路径：协议://服务器名称:端口/img//yyyy/MM/dd/+新的文件名 String url = req.getScheme() + \"://\" + req.getServerName() + \":\" + req.getServerPort() + \"/img\" + format + newName;// 输出该url System.out.println(url); } catch (IOException e) { } } return \"success\"; } 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"/uploads\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"file\" name=\"files\" multiple/&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; （2）ajax形式①单文件后端和form单文件上传一致 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"jquery-3.4.1.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"result\"&gt;&lt;/div&gt; &lt;input type=\"file\" id=\"file\"/&gt; &lt;input type=\"button\" value=\"提交\" onclick=\"upload()\"&gt; &lt;script type=\"text/javascript\"&gt; function upload() { //获取第一个文件 （这是个数组，可以多文件上传） var file = $(\"#file\")[0].files[0]; var formData = new FormData(); formData.append(\"file\", file); $.ajax({ type: \"post\", url: \"/upload\", //使数据不做处理 processData:false, //不要设置Content-Type请求头 contentType:false, data:formData, success:function (msg) { $(\"#result\").text(msg) } }) } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ②多文件后端和form 多文件上传一致 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"jquery-3.4.1.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"result\"&gt;&lt;/div&gt; &lt;input type=\"file\" id=\"file1\"/&gt; &lt;input type=\"file\" id=\"file2\"/&gt; &lt;input type=\"button\" value=\"提交\" onclick=\"upload()\"&gt; &lt;script type=\"text/javascript\"&gt; function upload() { var formData = new FormData(); //获取第一个文件 （这是个数组，可以多文件上传） var file1 = $(\"#file1\")[0].files[0]; var file2 = $(\"#file2\")[0].files[0]; formData.append(\"files\", file1); formData.append(\"files\", file2); $.ajax({ type: \"post\", url: \"/uploads\", //使数据不做处理 processData:false, //不要设置Content-Type请求头 contentType:false, data:formData, success:function (msg) { $(\"#result\").text(msg) } }) } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4、@ControllerAdvice的使用(1)全局异常处理@RestControllerAdvice ==&gt; 12@ControllerAdvice@ResponseBody @ExceptionHandler 指定拦截的异常类型 若有返回值，则直接返回定义的异常bean即可，加上@RestControllerAdvice ①无返回值12345678910111213@ControllerAdvicepublic class CustomExceptionHandler {// @ExceptionHandler拦截指定异常// 这里我们可以返回任意值，或者不返回。 @ExceptionHandler(MaxUploadSizeExceededException.class) public void uploadFileException(MaxUploadSizeExceededException e, HttpServletResponse res) throws IOException { res.setContentType(\"text/html;charset=utf-8\"); PrintWriter printWriter = res.getWriter(); printWriter.write(\"文件大小超出限制！\"); printWriter.flush(); printWriter.close(); }} ②返回视图这里我们用的thymeleaf 1234567891011@ControllerAdvicepublic class CustomExceptionHandler { // 定义返回的视图 @ExceptionHandler(MaxUploadSizeExceededException.class) public ModelAndView uploadFileException(MaxUploadSizeExceededException e){ //新建视图并设定名称 ModelAndView modelAndView =new ModelAndView(\"exception\"); modelAndView.addObject(\"error\", \"文件大小超出限制！\"); return modelAndView; }} ③常用形式 返回自定义bean123456789101112131415@RestControllerAdvicepublic class GlobalExceptionHandler { private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);// 处理SQLException该异常的方法 @ExceptionHandler(SQLException.class) public ResponseBean sqlException(SQLException e){ //判断是否为其类和及其子类 if(e instanceof MySQLIntegrityConstraintViolationException){ return ResponseBean.error(\"该数据有关联的数据，操作失败！\"); } logger.error(e.getMessage()); return ResponseBean.error(\"数据库操作异常，操作失败！\"); }} (2)预设全局数据12345678910@ControllerAdvicepublic class GlobalData { @ModelAttribute(value = \"info\") public Map&lt;String, Object&gt; mydata() { Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"name\", \"louchen\"); map.put(\"address\", \"www.louchen.top\"); return map; }} 1234567891011121314@RestControllerpublic class UserController { @GetMapping(\"/hello\") public String hello(Model model) { //转为map集合 Map&lt;String,Object&gt; map = model.asMap();// 获取所有的key Set&lt;String&gt; keySet = map.keySet(); for (String key : keySet) { System.out.println(\"key:\"+map.get(key)); } return \"success\"; }} 这里的map集合中===&gt; key为 @ModelAttribute(value = “info”)中的value值 value为定义在map中的所有值 1key:{address=www.louchen.top, name=louchen} (3)请求参数预处理当遇到参数需要处理的时候，例如多个对象的重复属性等其他情况 12345678public class Cat { private String id; private String name; private Integer age; //getter //setter //toString} 12345public class Doctor { private String id; private String name; private Integer age;} 12345678910111213141516@ControllerAdvicepublic class InitData { @InitBinder(\"doctor\") public void initDoctor(WebDataBinder binder){ //参数请求的时候的需要加的前缀 binder.setFieldDefaultPrefix(\"doc.\"); } @InitBinder(\"cat\") public void initCat(WebDataBinder binder){ //参数请求的时候的需要加的前缀 binder.setFieldDefaultPrefix(\"cat.\"); }} 123456789@RestControllerpublic class InitDataController { @PostMapping(\"/add\") //这里的@ModelAttribute中为@InitBinder中绑定的值 public void addDocAndCat(@ModelAttribute(\"doctor\")Doctor doctor, @ModelAttribute(\"cat\")Cat cat){ System.out.println(doctor.toString()); System.out.println(cat.toString()); }} 请求参数：post： http://localhost:8080/add doc.id ==&gt; doc.name ==&gt; doc.age ==&gt; cat.id ==&gt; cat.name ==&gt; cat.age ==&gt; 5、自定义错误页面(1)错误页面模板加载顺序在springboot中，程序发生错误的时候会自动寻找自动配置的错误页面 –resources ​ –static ​ –error ===&gt;404.html,4xx.html,500.html,5xx.html ​ –templates ​ –error ===&gt;404.html,4xx.html,500.html,5xx.html 在此目录下: 按照全匹配的优先规则依次从动态页面templates/error下寻找，再从静态页面static/error下寻找 在按照模糊匹配的优先规则依次从动态页面templates/error下寻找，再从静态页面static/error下寻找 (2)自定义异常数据自动配置==&gt; org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration==&gt; 12345678@Bean @ConditionalOnMissingBean( value = {ErrorAttributes.class}, search = SearchStrategy.CURRENT ) public DefaultErrorAttributes errorAttributes() { return new DefaultErrorAttributes(this.serverProperties.getError().isIncludeException()); } 手动配置==&gt; 123456789@Componentpublic class MyErrorAttribute extends DefaultErrorAttributes { @Override public Map&lt;String, Object&gt; getErrorAttributes(WebRequest webRequest, boolean includeStackTrace) { Map&lt;String, Object&gt; errorAttributes = super.getErrorAttributes(webRequest, includeStackTrace); errorAttributes.put(\"myerror\", \"自定义的异常信息\"); return errorAttributes; }} 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table border=\"1\" cellspacing=\"0\"&gt; &lt;tr&gt; &lt;td&gt;path&lt;/td&gt; &lt;td th:text=\"${path}\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;timestamp&lt;/td&gt; &lt;td th:text=\"${timestamp}\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;message&lt;/td&gt; &lt;td th:text=\"${message}\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;error&lt;/td&gt; &lt;td th:text=\"${error}\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;path&lt;/td&gt; &lt;td th:text=\"${path}\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;status&lt;/td&gt; &lt;td th:text=\"${status}\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;myerror&lt;/td&gt; &lt;td th:text=\"${myerror}\"&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; path /111 timestamp Mon Mar 16 21:31:50 GMT+08:00 2020 message No message available error Not Found path /111 status 404 myerror 自定义的异常信息 (3)自定义异常视图自动配置==&gt; org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration==&gt; 123456@Bean @ConditionalOnBean({DispatcherServlet.class}) @ConditionalOnMissingBean({ErrorViewResolver.class}) DefaultErrorViewResolver conventionErrorViewResolver() { return new DefaultErrorViewResolver(this.applicationContext, this.resourceProperties); } 手动配置==&gt; 注意：这里的视图名称在templates文件夹下的任意目录即可 1234567891011121314151617@Componentpublic class MyErrorViewResolver extends DefaultErrorViewResolver { public MyErrorViewResolver(ApplicationContext applicationContext, ResourceProperties resourceProperties) { super(applicationContext, resourceProperties); } @Override public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model) { ModelAndView modelAndView = super.resolveErrorView(request, status, model); //视图的名称 modelAndView.setViewName(\"lc.html\"); modelAndView.addObject(model);// 该Map&lt;String, Object&gt; model不可修改。// 如果我们新增其他的属性 我们可以遍历此map数据取出，然后定义新的map放进ModelAndView中 return modelAndView; }} 视图模板内容和上面的一致 6、springboot跨域问题https://segmentfault.com/a/1190000019550329?utm_source=tag-newest (1)背景​ Same Origin Policy，译为“同源策略”。它是对于客户端脚本（尤其是JavaScript）的重要安全度量标准，其目的在于防止某个文档或者脚本从多个不同“origin”（源）装载。它认为自任何站点装载的信赖内容是不安全的。当被浏览器半信半疑的脚本运行在沙箱时，它们应该只被允许访问来自同一站点的资源，而不是那些来自其它站点可能怀有恶意的资源。​ 注：具有相同的Origin，也即是拥有相同的协议、主机地址以及端口。一旦这三项数据中有一项不同，那么该资源就将被认为是从不同的Origin得来的，进而不被允许访问。 (2)CORS简介​ CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨源(协议 + 域名 + 端口)服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。CORS需要浏览器和服务器同时支持。它的通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX/Fetch通信没有差别，代码完全一样。浏览器一旦发现请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。​ 因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。 浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。 简答请求（HEAD、GET、POST）：不需要试探请求 非简单请求（DELETE,PUT）：Request Method: OPTIONS 需要进行一次试探请求。在正式通信之前，增加一次OPTIONS查询请求，称为”预检”请求（preflight）。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。 详解响应头： Access-Control-Allow-Origin 该字段必填。它的值要么是请求时Origin字段的具体值，要么是一个*，表示接受任意域名的请求。 Access-Control-Allow-Methods该字段必填。它的值是逗号分隔的一个具体的字符串或者*，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。 Access-Control-Expose-Headers该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。 Access-Control-Allow-Credentials该字段可选。它的值是一个布尔值，表示是否允许发送Cookie.默认情况下，不发生Cookie，即：false。对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json，这个值只能设为true。如果服务器不要浏览器发送Cookie，删除该字段即可。 Access-Control-Max-Age该字段可选，用来指定本次预检请求的有效期，单位为秒。在有效期间，不用发出另一条预检请求。 顺便提一下，如果在开发中，发现每次发起请求都是两条，一次OPTIONS，一次正常请求，注意是每次，那么就需要配置Access-Control-Max-Age，避免每次都发出预检请求。 (3)实现跨域的方法①最小粒度的cors控制，精确到单个请求级别。@CrossOrigin(&quot;*&quot;) 允许所有请求 @CrossOrigin(&quot;http:localhost:8080&quot;) 只允许http:localhost:8080 123456789@RestControllerpublic class CORSController { @CrossOrigin(\"*\") @GetMapping(\"/doget\") public String doGet(){ return \"doGet\"; }} 从@CrossOrigin注解中==&gt; 该注解可以用于方法上和类上，用于类上，所有该类下的请求都支持该跨域请求。用于方法上，只有该请求支持跨域 123456@Target({ElementType.TYPE, ElementType.METHOD})@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface CrossOrigin { //....} ②全局配置1234567891011121314151617@Configurationpublic class WebMvcConfig implements WebMvcConfigurer { @Override public void addCorsMappings(CorsRegistry registry) {// 哪些请求能够跨域(所有) registry.addMapping(\"/**\")// 哪些域能够访问(所有) .allowedOrigins(\"*\")// 哪些请求头(所有) .allowedHeaders(\"*\")// 允许的请求方法类型(所有) .allowedMethods(\"*\")// 会首先发送一个探测请求(若探测许可,即发送真正的请求，否则返回请求失败)// 设定发送探测请求的时间间隔(30s，单位秒) .maxAge(30); }} 1234567891011@RestControllerpublic class CORSController { @GetMapping(\"/doget\") public String doGet(){ return \"doGet\"; } @PutMapping(\"/dopost\") public String doPut(){ return \"doPut\"; }} 另一个域的请求视图==&gt; 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;CORS&lt;/title&gt; &lt;script src=\"jquery-3.4.1.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"result\"&gt;&lt;/div&gt; &lt;input type=\"button\" value=\"GET\" onclick=\"getData()\"&gt; &lt;input type=\"button\" value=\"PUT\" onclick=\"putData()\"&gt; &lt;script&gt; function getData() { $.get('http://localhost:8081/doget',function (msg) { $(\"#result\").text(msg); }) } function putData() { $.ajax({ type:'PUT', url:'http://localhost:8081/dopost', success:function (msg) { $(\"#result\").text(msg); } }) } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;d ③过滤器形式配置1234567891011121314@WebFilter(filterName = \"CorsFilter \")@Configurationpublic class CorsFilter implements Filter { @Override public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException { HttpServletResponse response = (HttpServletResponse) res; response.setHeader(\"Access-Control-Allow-Origin\",\"*\"); response.setHeader(\"Access-Control-Allow-Credentials\", \"true\"); response.setHeader(\"Access-Control-Allow-Methods\", \"POST, GET, PATCH, DELETE, PUT\"); response.setHeader(\"Access-Control-Max-Age\", \"3600\"); response.setHeader(\"Access-Control-Allow-Headers\", \"Origin, X-Requested-With, Content-Type, Accept\"); chain.doFilter(req, res); }} 7、springboot加载xml配置文件resources==&gt; 12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean class=\"org.lc.xml.controller.HelloController\" id=\"sayHello\"&gt;&lt;/bean&gt;&lt;/beans&gt; 12345@Configuration//加载bean.xml配置文件，注入到spring容器中@ImportResource(locations = \"classpath:beans.xml\")public class WebMvcConfig {} 12345public class HelloController { public String sayHello() { return \"say hello\"; }} Test==&gt; 1234567891011@RunWith(SpringRunner.class)@SpringBootTestpublic class XmlTest { @Autowired private HelloController helloController; @Test public void Test1() { String s = helloController.sayHello(); System.out.println(s); }} 9、springboot中使用拦截器定义拦截执行的方法（内容）==&gt; 1234567891011121314151617public class MyInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\"执行之前\"); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\"执行中\"); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(\"执行后\"); }} 注入容器中，并添加新的拦截器==&gt; 12345678910111213@Configurationpublic class WebMvcConfig implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { //添加拦截器，拦截所有请求 registry.addInterceptor(myInterceptor()).addPathPatterns(\"/**\"); } @Bean MyInterceptor myInterceptor(){ return new MyInterceptor(); }} 使用更多配置==&gt; org.springframework.web.servlet.config.annotation.InterceptorRegistration==&gt; 12345678910public class InterceptorRegistration { private final HandlerInterceptor interceptor; private final List&lt;String&gt; includePatterns = new ArrayList(); private final List&lt;String&gt; excludePatterns = new ArrayList(); @Nullable private PathMatcher pathMatcher; private int order = 0; //...... //......} 10、springboot实现系统启动任务注意：两种接口可混用，不冲突 (1)实现CommandLineRunner接口@order(100) 的使用： 默认为最大值2^31-1，即int的范围。 默认最大值表示优先级最低，即执行的顺序 值越大优先级越低，反之值越小优先级越高 1234567891011121314@Component@Order(100)public class MyCommondLineRunnerOne implements CommandLineRunner { /** * 获得启动程序的初始参数 * @param args * @throws Exception */ @Override public void run(String... args) throws Exception { System.out.println(\"MyCommondLineRunnerOne==&gt;&gt;\"+Arrays.toString(args)); }} 1234567891011121314@Component@Order(99)public class MyCommondLineRunnerTwo implements CommandLineRunner { /** * 获得启动程序的初始参数 * @param args * @throws Exception */ @Override public void run(String... args) throws Exception { System.out.println(\"MyCommondLineRunnerTwo==&gt;&gt;\"+Arrays.toString(args)); }} 添加启动参数：①在主程序中,写死即可 123456789@SpringBootApplicationpublic class XmlApplication { public static void main(String[] args) { args=new String[]{ \"org.lc\",\"louchen\" }; SpringApplication.run(XmlApplication.class,args); }} ==&gt; 12MyCommondLineRunnerTwo==&gt;&gt;[org.lc, louchen]MyCommondLineRunnerOne==&gt;&gt;[org.lc, louchen] ②在idea启动的时候配置参数 Edit Configurations =&gt;Environment=&gt;Program agruments 添加参数即可： aaa bbb ==&gt; 12MyCommondLineRunnerTwo==&gt;&gt;[aaa, bbb]MyCommondLineRunnerOne==&gt;&gt;[aaa, bbb] ③以jar包的方式加入启动参数 注意参数之间的空格 java -jar xml-1.0-SNAPSHOT.jar ccc ddd ==&gt; 12MyCommondLineRunnerTwo==&gt;&gt;[ccc, ddd]MyCommondLineRunnerOne==&gt;&gt;[ccc, ddd] (2)实现ApplicationRunner接口123456789101112131415161718192021@Component@Order(102)public class MyApplicationRunnerOne implements ApplicationRunner { @Override public void run(ApplicationArguments args) throws Exception { //获取所有的值 String[] sourceArgs = args.getSourceArgs(); System.out.println(Arrays.toString(sourceArgs)); //获取所有没有键的数据 List&lt;String&gt; nonOptionArgs = args.getNonOptionArgs(); System.out.println(nonOptionArgs); //获取所有的键值对 Set&lt;String&gt; optionNames = args.getOptionNames(); //通过键获取值 //args.getOptionValues(optionName) for (String optionName : optionNames) { System.out.println(optionName+\":\"+args.getOptionValues(optionName)); } System.out.println(\"-------------------MyApplicationRunnerOne------------------------------\"); }} 123456789101112131415161718192021@Component@Order(101)public class MyApplicationRunnerTwo implements ApplicationRunner { @Override public void run(ApplicationArguments args) throws Exception { //获取所有的值 String[] sourceArgs = args.getSourceArgs(); System.out.println(Arrays.toString(sourceArgs)); //获取所有没有键的数据 List&lt;String&gt; nonOptionArgs = args.getNonOptionArgs(); System.out.println(nonOptionArgs); //获取所有的键值对 Set&lt;String&gt; optionNames = args.getOptionNames(); //通过键获取值 //args.getOptionValues(optionName) for (String optionName : optionNames) { System.out.println(optionName+\":\"+args.getOptionValues(optionName)); } System.out.println(\"-------------------MyApplicationRunnerTwo------------------------------\"); }} 添加启动参数：这里我们只采用jar的形式添加参数，其他的方式和上面类似 注意：键值对的参数要 在前面加两个 - java -jar xml-1.0-SNAPSHOT.jar --name=louchen --address=hubei 张三 李四 ==&gt; 12345678910[--name=louchen, --address=hubei, 张三, 李四][张三, 李四]address:[hubei]name:[louchen]-------------------MyApplicationRunnerTwo------------------------------[--name=louchen, --address=hubei, 张三, 李四][张三, 李四]address:[hubei]name:[louchen]-------------------MyApplicationRunnerOne------------------------------ 11、springboot中的restful请求类型https://www.jianshu.com/p/4981911d5e15 @RequestBody与@RequestParam作用与GET,POST,DELETE,PUT请求上不同 加上@RequestBody的参数注解必须以application/json形式传输参数 一个请求体中的所以数据只在被@RequestBody标记中的有效 加上@RequestParam的参数注解必须以url的形式传输参数 (1)GET请求（默认url传参）①无@RequestBody因为GET请求无请求体，所有传输的参数必须以url形式传输参数 请求形式：localhost:8080/hello/?id=1&amp;name=张三&amp;uid=1001 123456789@RestControllerpublic class UserController { @GetMapping(\"/hello\") public User sayGet(User user,String uid) { System.out.println(user); System.out.println(\"uid:\"+uid); return user; }} ②有@RequestBody没有声明在@RequestBody中的参数必须以url形式传参 声明在@RequestBody中的参数必须以请求体的形式传输 请求形式：content-type:application/json localhost:8080/hello/?uid=1001 1234{ \"id\":2, \"name\":\"李四\"} 1234567@GetMapping(\"/hello\") public User sayGet(@RequestBody User user,@RequestParam(\"uid\") String uid) { System.out.println(user); System.out.println(\"uid:\"+uid); return user; }} (2)POST请求(默认x-www-form-urlencoded)①有@RequestBody被@RequestBody标记必须以json的形式传参 没有被@RequestBody标记必须以url的形式传参 请求形式：content-type:application/json localhost:8080/hello/?uid=222 12345{ \"id\":2, \"name\":\"李四\" } 1234567 @PostMapping(\"/hello\") public User sayPost(@RequestBody User user,@RequestParam(\"uid\") String uid){ System.out.println(user); System.out.println(\"uid:\"+uid); return user; }} ②无@RequestBody默认类型content-type:x-www-form-urlencoded 这种类型只是将参数编码放在url地址栏中 所以请求参数放在url中也可以，当是编码content-type:x-www-form-urlencoded过后再放更合理 key value id 3 name 王五 uid 1000 请求参数：:localhost:8080/hello 1234567@PostMapping(\"/hello\") public User sayPost(User user, @RequestParam(\"uid\")String uid){ System.out.println(user); System.out.println(\"uid:\"+uid); return user; }} (3)PUT请求(默认x-www-form-urlencoded)①有@RequestBody请求类型：content-type:application/json 和POST请求方式一致，被标记的参数只能以application/json参数传递，非标记的以url形式传输参数 ②无@RequestBody请求类型：content-type:x-www-form-urlencoded 与POST请求方式一致，只能以x-www-form-urlencoded形式传参。 所以参数编码后放入url地址栏中。 (4)DELETE请求(默认x-www-form-urlencoded)①有@RequestBody请求类型content-type:application/json 和POST请求方式一致，被标记的参数只能以application/json参数传递，非标记的以url形式传输参数 ②无@RequestBody请求类型content-type:x-www-form-urlencoded 与POST请求方式一致，只能以x-www-form-urlencoded形式传参。 所以参数编码后放入url地址栏中。 (5)总结①从content-type方面：form-data、x-www-form-urlencoded：不可以用@RequestBody。可以用@RequestParam。这种请求类型只是将参数编码放入url地址栏中 application/json：json字符串部分可以用@RequestBody；url中的?后面参数可以用@RequestParam。 ②从注解方面@RequestBody 1234(@RequestBody Map map)(@RequestBody Object object)application/json时候可用form-data、x-www-form-urlencoded时候不可用 @RequestParam 12(@RequestParam Map map)application/json时候，json字符串部分不可用，url中的?后面添加参数即可用 12(@RequestParam Object object)不管application/json、form-data、x-www-form-urlencoded都不可用 12、springboot整合servlet,filter,lister(web基础组件)定义servlet==&gt; 12345678910111213// 映射/myservlet请求@WebServlet(urlPatterns = \"/myservlet\")public class MyServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"myServlet\"); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { super.doPost(req, resp); }} 定义过滤器==&gt; 123456789//过滤拦截所有请求@WebFilter(urlPatterns = \"/*\")public class MyFilter implements Filter { @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(\"myFilter\"); filterChain.doFilter(servletRequest, servletResponse); }} 定义监听器==&gt; 123456789101112131415//标记此类为监听器//根据监听器的不同类型实现不同的监听器的接口//实现请求的监听器@WebListenerpublic class MyRequestListener implements ServletRequestListener { @Override public void requestDestroyed(ServletRequestEvent sre) { System.out.println(\"requestListenerDestroyed\"); } @Override public void requestInitialized(ServletRequestEvent sre) { System.out.println(\"requestListenerInitialized\"); }} 扫描servlet,listener,filter @ServletComponentScan(basePackages = &quot;org.lc.xml.servlet&quot;) 扫描指定包下servlet组件 12345678@SpringBootApplication//扫描所有的servlet,filter,listener@ServletComponentScan(basePackages = \"org.lc.xml.servlet\")public class XmlApplication { public static void main(String[] args) { SpringApplication.run(XmlApplication.class,args); }} 请求路径：http://localhost:8080/myservlet 输出顺序: ServletRequestListener监听器请求初始化=&gt; 过滤器执行==&gt; Servlet执行=&gt; ServletRequestListener监听器请求销毁 1234requestListenerInitializedmyFiltermyServletrequestListenerDestroyed 当有springboot中的拦截器时： 注意:这里的拦截器只对controller中的请求有效，对servlet中定义的请求无效 1234567891011121314151617public class MyInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\"执行之前\"); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\"执行中\"); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(\"执行后\"); }} 123456789101112@Configurationpublic class WebMvcConfig implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(myInterceptor()).addPathPatterns(\"/**\"); } @Bean MyInterceptor myInterceptor(){ return new MyInterceptor(); }} srtvlet请求:http://localhost:8080/myservlet 1234requestListenerInitializedmyFiltermyServletrequestListenerDestroyed controller请求：http://localhost:8080/say 请求结果==&gt; 123456requestListenerInitializedmyFilter执行之前执行中执行后requestListenerDestroyed 12345678@RestControllerpublic class UserController { @GetMapping(\"/say\") public String sayHello(){ return \"say hello\"; }} 13、springboot中的路径映射当我们只需要返回一个页面时，通常做法,使用控制器返回一个页面（这里使用thmeleaf模板引擎） 1234567@Controllerpublic class LoginController { @GetMapping(\"/login\") public String loginView() { return \"login\"; }} 这里我们摒弃上面的这个做法： 只需要实现WebMvcConfigurer接口即可 123456789@Configurationpublic class WebMvcConfig implements WebMvcConfigurer { @Override public void addViewControllers(ViewControllerRegistry registry) { //添加请求的路径 响应的视图名称 registry.addViewController(\"/login\").setViewName(\"login\"); registry.addViewController(\"/register\").setViewName(\"register\"); }} 14、springboot中使用类型转换器其中S代表需要转换的参数类型 T代表要转成的目标参数类型 12345@FunctionalInterfacepublic interface Converter&lt;S, T&gt; { @Nullable T convert(S var1);} 实现转换器接口==&gt; 1234567891011121314151617@Componentpublic class DateConventer implements Converter&lt;String, Date&gt; { private SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd\"); @Override public Date convert(String s) { if (s != null &amp;&amp; !s.equals(\"\")) { try { return simpleDateFormat.parse(s); } catch (ParseException e) { e.printStackTrace(); } } return null; }} 1234567@RestControllerpublic class LoginController { @GetMapping(\"/birthday\") public void sayHello(Date date) { System.out.println(date); }} 请求：http://localhost:8080/birthday/?date=2019-01-01 15、springboot使用AOP1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt; 1234567891011@Servicepublic class EmpService { public String getAllEmp(){ System.out.println(\"getAllEmp--service\"); return \"查询所有成功\"; } public String deleteEmpById(Integer id){ System.out.println(\"deleteEmpById--service\"); return \"修改成功\"; }} 1234567891011121314151617@RestControllerpublic class EmpController { @Autowired private EmpService empService; @GetMapping(\"/allEmp\") public String getAllEmp(){ String allEmp = empService.getAllEmp(); System.out.println(allEmp); return \"getAllEmp--controller\"; } @DeleteMapping(\"/delEmp\") public String deleteEmp(){ String s = empService.deleteEmpById(12); System.out.println(s); return \"deleteEmp--controller\"; }} 定义切面文件==&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495@Component//定义类为切面(切点和通知的结合)@Aspectpublic class AopLogger { /** * 定义切点表达式 用来确定哪些类需要代理 * 切点表达式定义：==&gt; * ①方法的可见性 如public，protected；（可省略） （不可用*表示，但是可省略） * ②方法的返回类型 如int，void等；（*代表任意类型） * ③方法所在类的全包名，如com.spring.Aspect； * ④所在类的全名；（*代表该包下的所有类） * ⑤所在类的方法全名 （*代表该类下的所有方法） * ⑥方法的个数 （..代表0个或多个） */ @Pointcut(\"execution(public * org.lc.xml.service.*.*(..))\") public void pc1(){ }// 定义通知// 即对拦截的方法的处理方式（时机） /** * 定义前置通知（代理的方法执行之前的通知） * @param joinPoint JoinPoint对象封装了SpringAop中切面方法的信息, * 在切面方法中添加JoinPoint参数,就可以获取到封装了该方法信息的JoinPoint对象. */ @Before(\"pc1()\") public void before(JoinPoint joinPoint) { String name = joinPoint.getSignature().getName(); System.out.println(\"前置通知执行的方法:\"+name); } /** * 定义后置通知（代理方法执行之后执行的通知） * @param joinPoint */ @After(\"pc1()\") public void after(JoinPoint joinPoint) { String name = joinPoint.getSignature().getName(); System.out.println(\"后置通知执行的方法:\"+name); } /** * 定义返回通知（方法执行完毕执行的通知） * @param joinPoint * @param result 该代理的方法的返回值 * 在注解上的returning = \"result\"则只会匹配只有返回值的方法 */ @AfterReturning(value = \"pc1()\", returning = \"result\") public void afterReturning(JoinPoint joinPoint, Object result) { String name = joinPoint.getSignature().getName(); System.out.println(\"返回通知执行的方法:\"+name+\",该代理方法的返回值为:\"+result); } /** * 定义异常通知（方法执行异常之后的通知） * @param joinPoint * @param e */ @AfterThrowing(value = \"pc1()\",throwing = \"e\") public void afterThrowing(JoinPoint joinPoint,Exception e) { String name = joinPoint.getSignature().getName(); System.out.println(\"异常通知执行的方法:\"+name+\",该方法的异常为:\"+e.getMessage()); } /** * 定义环绕通知 (可同时使用上面的四种通知) * proceedingJoinPoint.proceed();代表执行代理的该方法 */ @Around(value = \"pc1()\") public Object around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable { //调用该方法之前的处理的代码（相当于前置通知） System.out.println(\"------前置通知-around\"); Object proceed = null; try { proceed = proceedingJoinPoint.proceed(); //注意这里的后置通知只是在环绕通知中代理方法的返回之前提前处理了 // 实际在@After是在@AfterReturning之前执行的 //使用该proceed变量，对其进行处理的代码。（相当于返回通知） System.out.println(\"-------返回通知-around\"); } catch (Throwable throwable) { //对异常处理的代码（相当于异常通知） System.out.println(\"------异常通知-around\"); throwable.printStackTrace(); }// 注意：这里的后置通知只是在环绕通知中代理方法的返回之前提前处理了// 实际在@After是在@AfterReturning之前执行的 //调用该方法之后之后处理的代码（相当于后置通知） System.out.println(\"-------后置通知---around\"); //该返回语句执新之前的所有代码 都是未正真正执行的。 return proceed; }} 执行的结果为==&gt; 12345678------前置通知-around前置通知执行的方法:getAllEmpgetAllEmp--service-------返回通知-around-------后置通知---around后置通知执行的方法:getAllEmp返回通知执行的方法:getAllEmp,该代理方法的返回值为:查询所有成功查询所有成功 总结执行的顺序==&gt; 123456789101112@Around先进入环绕通知==&gt;处理环绕通知proceed = proceedingJoinPoint.proceed()方法之前的代码（相当于前置通知）@After进入前置通知@Around处进入环绕通知proceed = proceedingJoinPoint.proceed()方法之后的代码（相当于后置通知和返回通知）若出现异常则直接执行@Around中catch的代码（相当于异常通知）@After进入后置通知@AfterReturning进入返回通知 16、springboot自定义欢迎页这里我们使用thmeleaf 1234567@Controllerpublic class IndexController { @GetMapping(\"/index\") public String index() { return \"index\"; }} 默认启动服务器：localhost:8080 首先访问static中的index.html页面 再访问templates中的index.html页面 17、springboot自定义favicon.icohttps://tool.lu/favicon/ 将favicon.ico放在resources下或static下即可 static下的优先级高于resources 当出现无法访问图标的时候： 12345678910@Configurationpublic class WebMvcConfig implements WebMvcConfigurer { @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { //放在resources下 registry.addResourceHandler(\"/favicon.ico\").addResourceLocations(\"classpath:/\"); //放在static下 //registry.addResourceHandler(\"/favicon.ico\").addResourceLocations(\"classpath:/static/\"); }} 18、springboot排除自动配置排除不需要的自动配置(所有自动配置全部失效) 123456@SpringBootApplication(exclude = WebMvcAutoConfiguration.class)public class XmlApplication { public static void main(String[] args) { SpringApplication.run(XmlApplication.class,args); }} 或者==&gt; 123spring: autoconfigure: exclude: org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration 注解①@ResponseBody响应json数据 ②@RestController@Controller@ResponseBody ③@JsonFormat(pattern = “yyyy-MM-dd”,timezone = “GMT+8”)④@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)注解@JsonFormat主要是后台到前台的时间格式的转换 注解@DataFormAT主要是前后到后台的时间格式的转换 123@DateTimeFormat(pattern = \"yyyy-MM-dd\") @JsonFormat(pattern = \"yyyy-MM-dd\",timezone = \"GMT+8\") private Date birthday; ⑤@configuration和@component的区别总结：@configuration+@Bean（注入的单例） @component+@Bean（注入的多例） https://blog.csdn.net/long476964/article/details/80626930 @Configuration是随容器启动开始加载的,始终存在的单例模式。 @Component中的bean使用一次即实例化一次 @configuration使用cglid动态代理==&gt; 12345678910111213@Configurationpublic class MyBeanConfig { @Bean public Country country(){ return new Country(); } @Bean public UserInfo userInfo(){ return new UserInfo(country()); }} 直接调用 country() 方法返回的是同一个实例 @Component 注解并没有通过 cglib 来代理@Bean 方法的调用==&gt; 12345678910111213@Componentpublic class MyBeanConfig { @Bean public Country country(){ return new Country(); } @Bean public UserInfo userInfo(){ return new UserInfo(country()); }} 每次调用country(),每次都会创建一个实例 ⑥@PropertySource(“classpath:person.properties”)导入properties文件 ⑦@ImportResource(locations = “classpath:beans.xml”)导入配置的xml文件 ⑧@Bean @scope(“singleton”)在Spring中，bean可以被定义为两种模式：prototype（多例）和singleton（单例） singleton（单例）：只有一个共享的实例存在，所有对这个bean的请求都会返回这个唯一的实例。 prototype（多例）：对这个bean的每次请求都会创建一个新的bean实例，类似于new。 Spring bean 默认是单例模式。 123456789101112131415161718191.singleton单例模式, 全局有且仅有一个实例2.prototype原型模式， 每次获取Bean的时候会有一个新的实例3.request request表示该针对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP request内有效，4.session session作用域表示该针对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP session内有效5.global sessionglobal session作用域类似于标准的HTTP Session作用域，不过它仅仅在基于portlet的web应用中才有意义。Portlet规范定义了全局Session的概念，它被所有构成某个 portlet web应用的各种不同的portlet所共享。在global session作用域中定义的bean被限定于全局portlet Session的生命周期范围内。如果你在web中使用global session作用域来标识bean，那么web会自动当成session类型来使用。 ⑨容器的单例和多例@Component注解默认实例化的对象是单例，如果想声明成多例对象可以使用@Scope(“prototype”) @Repository默认单例 @Service默认单例 @Controller默认多例 ⑩@order(100)默认为最大值2^31-1，即int的范围。 默认最大值表示优先级最低，即执行的顺序 值越大优先级越低，反之值越小优先级越高 ⑪@RequestBody @RequestParam@RequestBody==&gt; 顾明思意，请求必须是以请求体的形式接受参数 @RequestParam==&gt; 以url传参 ⑫import(configuration.class)导入java的配置文件 被@Configuration标记的文件 ⑬@ConfigurationProperties(prefix = “person”)yaml,properties文件属性配置注入 ⑭@Configuration详解https://www.cnblogs.com/duanxz/p/7493276.html 从Spring3.0，@Configuration用于定义配置类，可替换xml配置文件，被注解的类内部包含有一个或多个被@Bean注解的方法，这些方法将会被AnnotationConfigApplicationContext或AnnotationConfigWebApplicationContext类进行扫描，并用于构建bean定义，初始化Spring容器。 注意：@Configuration注解的配置类有如下要求： @Configuration不可以是final类型； @Configuration不可以是匿名类； 嵌套的configuration必须是静态类。 一、用@Configuration加载spring1.1、@Configuration配置spring并启动spring容器1.2、@Configuration启动容器+@Bean注册Bean1.3、@Configuration启动容器+@Component注册Bean1.4、使用 AnnotationConfigApplicationContext 注册 AppContext 类的两种方法**1.5、配置Web应用程序(web.xml中配置AnnotationConfigApplicationContext)** 二、组合多个配置类2.1、在@configuration中引入spring的xml配置文件2.2、在@configuration中引入其它注解配置2.3、@configuration嵌套（嵌套的Configuration必须是静态类）三、@EnableXXX注解四、@Profile逻辑组配置五、使用外部变量 @ConditionalOnProperty(name = “swagger.enable”, havingValue = “true”)@ConditionalOnProperty来控制Configuration是否生效 通过其两个属性name以及havingValue来实现的，其中name用来从application.properties中读取某个属性值。如果该值为空，则返回false;如果值不为空，则将该值与havingValue指定的值进行比较，如果一样则返回true;否则返回false。如果返回值为false，则该configuration不生效；为true则生效。 1swagger.enable=true","link":"/2020/07/24/springboot/springboot%E5%9F%BA%E7%A1%80%E6%95%B4%E5%90%88%E9%85%8D%E7%BD%AE/"},{"title":"SpringBoot整合SpringSecurity","text":"SpringBoot整合SpringSecurity一、SpringSecurity初体验Spring Security 是 Spring 家族中的一个安全管理框架，实际上，在 Spring Boot 出现之前，Spring Security 就已经发展了多年了，但是使用的并不多，安全管理这个领域，一直是 Shiro 的天下。 相对于 Shiro，在 SSM/SSH 中整合 Spring Security 都是比较麻烦的操作，所以，Spring Security 虽然功能比 Shiro 强大，但是使用反而没有 Shiro 多（Shiro 虽然功能没有 Spring Security 多，但是对于大部分项目而言，Shiro 也够用了）。 自从有了 Spring Boot 之后，Spring Boot 对于 Spring Security 提供了 自动化配置方案，可以零配置使用 Spring Security。 因此，一般来说，常见的安全管理技术栈的组合是这样的： SSM + Shiro Spring Boot/Spring Cloud + Spring Security 注意，这只是一个推荐的组合而已，如果单纯从技术上来说，无论怎么组合，都是可以运行的。 1、pom.xmlspring-boot-starter-security 12345678910111213141516171819202122&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2、controller12345678@RestControllerpublic class UserController { @GetMapping(\"/hello\") public String hello(){ return \"hello lc\"; }} 3、默认进入security登录页面在SpringSecurity中，已经对所有接口进行保护。所以首次请求时需要用户名和密码 ，密码由springSecurity动态生成。 用户名： user 密码： Using generated security password: 14404948-b30c-4cf3-8d02-cbb79779ffab 二、 手动配置用户名密码任选其一即可 在我们的yaml配置中，我们的面不需要加密 1、yaml配置用户名密码123456789spring: security: user:# 配置用户名 name: louchen# 配置密码 password: 你的密码# 配置角色 roles: admin 2、配置文件配置用户名密码123456789101112131415161718192021222324@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter {// spring5开始 security中使用配置文件的设置用户密码的必须要加密// 所有这里我们设置密码不加密// 配置密码编码器 @Bean PasswordEncoder passwordEncoder() {// 此方法已过期（这里我们只是测试实验） return NoOpPasswordEncoder.getInstance(); }// 认证管理 @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception {// 在内存中的认证 auth.inMemoryAuthentication()// 设置多个用户名,密码,角色 .withUser(\"lc\").password(\"123456\").roles(\"admin\") .and() .withUser(\"zs\").password(\"123\").roles(\"user\"); }} 三、配置HttpSecurity(拦截规则)1、基本配置①、controller12345678910111213141516171819@RestControllerpublic class UserController { @GetMapping(\"/hello\") public String hello(){ return \"hello lc\"; } @GetMapping(\"/admin/hello\") public String admin(){ return \"hello admin\"; } @GetMapping(\"/user/hello\") public String user(){ return \"hello user\"; }} ②、securityConfig12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter {// spring5开始 security中使用配置文件的设置用户密码的必须要加密// 所有这里我们设置密码不加密// 配置密码编码器 @Bean PasswordEncoder passwordEncoder() {// 此方法已过期（这里我们只是测试实验） return NoOpPasswordEncoder.getInstance(); }// 认证管理 @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception {// 在内存中的认证 auth.inMemoryAuthentication()// 设置多个用户名,密码,角色 .withUser(\"lc\").password(\"123456\").roles(\"admin\") .and() .withUser(\"zs\").password(\"123\").roles(\"user\"); } @Override protected void configure(HttpSecurity http) throws Exception {// 开启授权请求 http.authorizeRequests()// 路径匹配 满足/admin/**路径的 必须要有admin角色 .antMatchers(\"/admin/**\").hasRole(\"admin\")// 路径匹配 满足/user/**路径的 必须要有其中的一个角色即可访问// .antMatchers(\"/user/**\").hasAnyRole(\"admin\",\"user\")// 另一种写法==&gt; 必须要有其中的一个角色即可访问 .antMatchers(\"/user/**\").access(\"hasAnyRole('admin','user')\")// 路径匹配 满足/manager/**路径规则的 必须要同时拥有admin和manager角色 .antMatchers(\"/manager/**\").access(\"hasRole('admin') and hasRole('manager')\")// 其他的请求只要认证即可访问 .anyRequest().authenticated() .and()// 开启表单登录 .formLogin() //处理表单登录的路径 //通过该路径登录的用户名和密码再去请求接口就不会有登录页面的出现,若直接走其他接口则会进入登录页面 //注意这里为post请求 .loginProcessingUrl(\"/doLogin\")// 跟登录有关的接口 直接运行访问 .permitAll() .and()// 关闭crsf攻击（跨站请求伪造）,便于我们测试 .csrf().disable(); }} 2、登录表单的详细配置①、Usercontroller1234567891011121314151617181920212223@RestControllerpublic class UserController {// 登录即可访问 @GetMapping(\"/hello\") public String hello(){ return \"hello lc\"; }// 模拟admin接口 @GetMapping(\"/admin/hello\") public String admin(){ return \"hello admin\"; }// 模拟user接口 @GetMapping(\"/user/hello\") public String user(){ return \"hello user\"; } } ②、LoginController1234//若前后端不分离，设置默认登录成功的路径 我们只需要跳转到主页连接即可(注意:这里的请求只支持post)// .successForwardUrl(\"/index111\")// 若前后端不分离 设置默认登录成功的路径 我们只需要跳转到主页链接即可（注意：这里的请求只支持get）// .defaultSuccessUrl(\"/index111\",true) 123456789101112131415@Controllerpublic class LoginController { //模拟登录成功后跳转的页面 @GetMapping(\"/index111\") public String toIndex() { return \"index11\"; }// 模拟登录的页面 @GetMapping(\"/login\") public String logon() { return \"login\"; }} ③、登录页login.html12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;登录&lt;/h1&gt;&lt;form action=\"/doLogin\" method=\"post\"&gt; &lt;div&gt; 用户名:&lt;input type=\"text\" name=\"uname\" placeholder=\"请输入用户名\"&gt;&lt;/div&gt; &lt;div&gt; 密码:&lt;input type=\"text\" name=\"passwd\" placeholder=\"请输入密码\"&gt;&lt;/div&gt; &lt;div&gt;&lt;input type=\"submit\" value=\"登录\"&gt;&lt;/div&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; ④、主页index11.html12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;主页！！！！&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; ③、SecurityConfig123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter {// spring5开始 security中使用配置文件的设置用户密码的必须要加密// 所有这里我们设置密码不加密// 配置密码编码器 @Bean PasswordEncoder passwordEncoder() {// 此方法已过期（这里我们只是测试实验） return NoOpPasswordEncoder.getInstance(); }// 认证管理 @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception {// 在内存中的认证 auth.inMemoryAuthentication()// 设置多个用户名,密码,角色 .withUser(\"lc\").password(\"123456\").roles(\"admin\") .and() .withUser(\"zs\").password(\"123\").roles(\"user\"); } @Override protected void configure(HttpSecurity http) throws Exception {// 开启授权请求 http.authorizeRequests()// 路径匹配 满足/admin/**路径的 必须要有admin角色 .antMatchers(\"/admin/**\").hasRole(\"admin\")// 路径匹配 满足/user/**路径的 必须要有其中的一个角色即可访问// .antMatchers(\"/user/**\").hasAnyRole(\"admin\",\"user\")// 另一种写法==&gt; 必须要有其中的一个角色即可访问 .antMatchers(\"/user/**\").access(\"hasAnyRole('admin','user')\")// 路径匹配 满足/manager/**路径规则的 必须要同时拥有admin和manager角色 .antMatchers(\"/manager/**\").access(\"hasRole('admin') and hasRole('manager')\")// 其他的请求只要认证即可访问 .anyRequest().authenticated() .and()// 开启表单登录 .formLogin() //处理表单登录的路径 //通过该路径登录的用户名和密码再去请求接口就不会有登录页面的出现,若直接走其他接口则会进入登录页面 //注意这里为post请求 .loginProcessingUrl(\"/doLogin\")// 自定义跳转到的登录页的路径（默认登录页失效）// 在前后端分离的情况下 我们只需要返回json即可 .loginPage(\"/login\")// 设置自定义的登录的用户名的key的名称 .usernameParameter(\"uname\")// 设置自定义的登录的密码的key的名称 .passwordParameter(\"passwd\")// 若前后端不分离，设置默认登录成功的路径 我们只需要跳转到主页连接即可(注意:这里的请求只支持post)// .successForwardUrl(\"/index111\")// 若前后端不分离 设置默认登录成功的路径 我们只需要跳转到主页链接即可（注意：这里的请求只支持get）// .defaultSuccessUrl(\"/index111\",true)// 登录成功的的自定义处理// 若前后端分离 则我们只需要处理是否登录成功返回相应的json即可 .successHandler(new AuthenticationSuccessHandler() {// Authentication用户登录的信息 @Override public void onAuthenticationSuccess(HttpServletRequest req, HttpServletResponse res, Authentication authentication) throws IOException, ServletException {// 设置响应头类型 res.setContentType(\"application/json;charset=utf-8\");// 获取打印输出流 PrintWriter printWriter=res.getWriter();// 响应自定义的数据 Map&lt;String,Object&gt; map=new HashMap&lt;&gt;();// 自定义状态码 map.put(\"status\", 200);// 登录的信息// map.put(\"msg\", authentication.getPrincipal()); //\"msg\": { // \"password\": null, // \"username\": \"lc\", // \"authorities\": [ // { // \"authority\": \"ROLE_admin\" // } // ], // \"accountNonExpired\": true, // \"accountNonLocked\": true, // \"credentialsNonExpired\": true, // \"enabled\": true // },// map.put(\"msg1\", authentication.getDetails()); // \"msg1\": { // \"remoteAddress\": \"0:0:0:0:0:0:0:1\", // \"sessionId\": null // },// map.put(\"msg2\", authentication.getAuthorities()); // \"msg2\": [ // { // \"authority\": \"ROLE_admin\" // } // ],// map.put(\"msg3\", authentication.getCredentials()); //\"msg3\": null,// map.put(\"msg4\", authentication.isAuthenticated()); //\"msg4\": true,// 将map转为json字符串 printWriter.write(new ObjectMapper().writeValueAsString(map)); printWriter.flush(); printWriter.close(); } })// 同理，前后端不分离进入登录失败的处理路径（支持post）// .failureForwardUrl(\"/error\")// 前后端分离 进入登录失败的自定义处理 .failureHandler(new AuthenticationFailureHandler() {// AuthenticationException 验证异常的信息 @Override public void onAuthenticationFailure(HttpServletRequest req, HttpServletResponse res, AuthenticationException e) throws IOException, ServletException {// 设置响应头类型 res.setContentType(\"application/json;charset=utf-8\");// 获取打印输出流 PrintWriter printWriter=res.getWriter();// 响应自定义的数据 Map&lt;String,Object&gt; map=new HashMap&lt;&gt;();// 自定义状态码 map.put(\"status\", 401);// 找到错误的类型 设置错误信息// Credentials 证书 凭证 if(e instanceof LockedException){ map.put(\"msg\", \"账户被锁定，登录失败\"); }else if(e instanceof BadCredentialsException){ map.put(\"msg\", \"用户名或密码输入错误，登录失败！\"); }else if(e instanceof DisabledException){ map.put(\"msg\", \"账号被禁用，登录失败！\"); }else if(e instanceof AccountExpiredException){ map.put(\"msg\", \"账户过期，登录失败！\"); }else if(e instanceof CredentialsExpiredException){ map.put(\"msg\", \"密码过期，登录失败！\"); }else{ map.put(\"msg\", \"登录失败！\"); }// 将map转为json字符串 printWriter.write(new ObjectMapper().writeValueAsString(map)); printWriter.flush(); printWriter.close(); } })// 跟登录有关的接口 直接运行访问 .permitAll() .and()// 关闭crsf攻击（跨站请求伪造）,便于我们测试 .csrf().disable(); }} 3、注销登录配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter {// spring5开始 security中使用配置文件的设置用户密码的必须要加密// 所有这里我们设置密码不加密// 配置密码编码器 @Bean PasswordEncoder passwordEncoder() {// 此方法已过期（这里我们只是测试实验） return NoOpPasswordEncoder.getInstance(); }// 认证管理 @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception {// 在内存中的认证 auth.inMemoryAuthentication()// 设置多个用户名,密码,角色 .withUser(\"lc\").password(\"123456\").roles(\"admin\") .and() .withUser(\"zs\").password(\"123\").roles(\"user\"); } @Override protected void configure(HttpSecurity http) throws Exception {// 开启授权请求 http.authorizeRequests()// 路径匹配 满足/admin/**路径的 必须要有admin角色 .antMatchers(\"/admin/**\").hasRole(\"admin\")// 路径匹配 满足/user/**路径的 必须要有其中的一个角色即可访问// .antMatchers(\"/user/**\").hasAnyRole(\"admin\",\"user\")// 另一种写法==&gt; 必须要有其中的一个角色即可访问 .antMatchers(\"/user/**\").access(\"hasAnyRole('admin','user')\")// 路径匹配 满足/manager/**路径规则的 必须要同时拥有admin和manager角色 .antMatchers(\"/manager/**\").access(\"hasRole('admin') and hasRole('manager')\")// 其他的请求只要认证即可访问 .anyRequest().authenticated() .and()// 开启表单登录 .formLogin() //处理表单登录的路径 //通过该路径登录的用户名和密码再去请求接口就不会有登录页面的出现,若直接走其他接口则会进入登录页面 //注意这里为post请求 .loginProcessingUrl(\"/doLogin\")// 自定义跳转到的登录页的路径（默认登录页失效）// 在前后端分离的情况下 我们只需要返回json即可 .loginPage(\"/login\")// 设置自定义的登录的用户名的key的名称 .usernameParameter(\"uname\")// 设置自定义的登录的密码的key的名称 .passwordParameter(\"passwd\")// 若前后端不分离，设置默认登录成功的路径 我们只需要跳转到主页连接即可(注意:这里的请求只支持post)// .successForwardUrl(\"/index111\")// 若前后端不分离 设置默认登录成功的路径 我们只需要跳转到主页链接即可（注意：这里的请求只支持get）// .defaultSuccessUrl(\"/index111\",true)// 登录成功的的自定义处理// 若前后端分离 则我们只需要处理是否登录成功返回相应的json即可 .successHandler(new AuthenticationSuccessHandler() {// Authentication报错用户登录的信息 @Override public void onAuthenticationSuccess(HttpServletRequest req, HttpServletResponse res, Authentication authentication) throws IOException, ServletException {// 设置响应头类型 res.setContentType(\"application/json;charset=utf-8\");// 获取打印输出流 PrintWriter printWriter=res.getWriter();// 响应自定义的数据 Map&lt;String,Object&gt; map=new HashMap&lt;&gt;();// 自定义状态码 map.put(\"status\", 200);// 登录的信息 map.put(\"msg\", authentication.getPrincipal()); //\"msg\": { // \"password\": null, // \"username\": \"lc\", // \"authorities\": [ // { // \"authority\": \"ROLE_admin\" // } // ], // \"accountNonExpired\": true, // \"accountNonLocked\": true, // \"credentialsNonExpired\": true, // \"enabled\": true // },// map.put(\"msg1\", authentication.getDetails()); // \"msg1\": { // \"remoteAddress\": \"0:0:0:0:0:0:0:1\", // \"sessionId\": null // },// map.put(\"msg2\", authentication.getAuthorities()); // \"msg2\": [ // { // \"authority\": \"ROLE_admin\" // } // ],// map.put(\"msg3\", authentication.getCredentials()); //\"msg3\": null,// map.put(\"msg4\", authentication.isAuthenticated()); //\"msg4\": true,// 将map转为json字符串 printWriter.write(new ObjectMapper().writeValueAsString(map)); printWriter.flush(); printWriter.close(); } })// 同理，前后端不分离进入登录失败的处理路径（支持post）// .failureForwardUrl(\"/error\")// 前后端分离 进入登录失败的自定义处理 .failureHandler(new AuthenticationFailureHandler() {// AuthenticationException 验证异常的信息 @Override public void onAuthenticationFailure(HttpServletRequest req, HttpServletResponse res, AuthenticationException e) throws IOException, ServletException {// 设置响应头类型 res.setContentType(\"application/json;charset=utf-8\");// 获取打印输出流 PrintWriter printWriter=res.getWriter();// 响应自定义的数据 Map&lt;String,Object&gt; map=new HashMap&lt;&gt;();// 自定义状态码 map.put(\"status\", 401);// 找到错误的类型 设置错误信息// Credentials 证书 凭证 if(e instanceof LockedException){ map.put(\"msg\", \"账户被锁定，登录失败\"); }else if(e instanceof BadCredentialsException){ map.put(\"msg\", \"用户名或密码输入错误，登录失败！\"); }else if(e instanceof DisabledException){ map.put(\"msg\", \"账号被禁用，登录失败！\"); }else if(e instanceof AccountExpiredException){ map.put(\"msg\", \"账户过期，登录失败！\"); }else if(e instanceof CredentialsExpiredException){ map.put(\"msg\", \"密码过期，登录失败！\"); }else{ map.put(\"msg\", \"登录失败！\"); }// 将map转为json字符串 printWriter.write(new ObjectMapper().writeValueAsString(map)); printWriter.flush(); printWriter.close(); } })// 跟登录有关的接口 直接运行访问 .permitAll() .and() .logout()// 定义注销的路径 .logoutUrl(\"/logout\")// 自定义注销的处理 .logoutSuccessHandler(new LogoutSuccessHandler() {// authentication 登录用户的信息 @Override public void onLogoutSuccess(HttpServletRequest req, HttpServletResponse res, Authentication authentication) throws IOException, ServletException { // 设置响应头类型 res.setContentType(\"application/json;charset=utf-8\");// 获取打印输出流 PrintWriter printWriter=res.getWriter();// 响应自定义的数据 Map&lt;String,Object&gt; map=new HashMap&lt;&gt;();// 自定义状态码 map.put(\"status\", 200); map.put(\"msg\", \"注销登录成功！\");// 将map转为json字符串 printWriter.write(new ObjectMapper().writeValueAsString(map)); printWriter.flush(); printWriter.close(); } }) .and()// 关闭crsf攻击（跨站请求伪造）,便于我们测试 .csrf().disable(); }} 三、多个httpSecurity配置1、controller123456789101112131415161718192021@RestControllerpublic class UserController {// 登录即可访问 @GetMapping(\"/hello\") public String hello(){ return \"hello lc\"; }// 模拟admin接口 @GetMapping(\"/admin/hello\") public String admin(){ return \"hello admin\"; }// 模拟user接口 @GetMapping(\"/user/hello\") public String user(){ return \"hello user\"; }} 2、SecurityConfig注意： httpSecurity.antMatcher(&quot;/admin/**&quot;).authorizeRequests().anyRequest().hasRole(&quot;admin&quot;) 只是对/admin/\\的形式的路径进行拦截，而不是所有路径** 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Configurationpublic class MultipleHttpSecurity { @Bean PasswordEncoder passwordEncoder() { return NoOpPasswordEncoder.getInstance(); } /** * 认证管理 * @param auth 这里相当于注入 AuthenticationManagerBuilder对象 * @throws Exception */ @Autowired protected void configure(AuthenticationManagerBuilder auth) throws Exception {// 在内存中的认证 auth.inMemoryAuthentication()// 设置多个用户名,密码,角色 .withUser(\"lc\").password(\"111\").roles(\"admin\") .and() .withUser(\"zs\").password(\"222\").roles(\"user\"); } @Configuration// 数字越小优先级越高 @Order(1) public static class AdminSecurityConfig extends WebSecurityConfigurerAdapter{ @Override protected void configure(HttpSecurity httpSecurity) throws Exception {// 表示当前httpsecurity只拦截 /admin/** 路径，并且需要admin角色 httpSecurity.antMatcher(\"/admin/**\").authorizeRequests().anyRequest().hasRole(\"admin\"); } } @Configuration public static class OtherSecurityConfig extends WebSecurityConfigurerAdapter{ @Override protected void configure(HttpSecurity httpSecurity) throws Exception {// 开启授权请求，所有的请求都需要认证即可访问// 这里经过上面的admin的请求后 再拦截其他的所有请求 httpSecurity.authorizeRequests().anyRequest().authenticated() .and() .formLogin() .loginProcessingUrl(\"/doLogin\") .permitAll() .and() .csrf().disable(); } } } 四、BCryptPasswordEncoder密码加密​ spring security中的BCryptPasswordEncoder方法采用SHA-256 +随机盐+密钥对密码进行加密。SHA系列是Hash算法，不是加密算法，使用加密算法意味着可以解密（这个与编码/解码一样），但是采用Hash处理，其过程是不可逆的。 （1）加密(encode)：注册用户时，使用SHA-256+随机盐+密钥把用户输入的密码进行hash处理，得到密码的hash值，然后将其存入数据库中。 （2）密码匹配(matches)：用户登录时，密码匹配阶段并没有进行密码解密（因为密码经过Hash处理，是不可逆的），而是使用相同的算法把用户输入的密码进行hash处理，得到密码的hash值，然后将其与从数据库中查询到的密码hash值进行比较。如果两者相同，说明用户输入的密码正确。 这正是为什么处理密码时要用hash算法，而不用加密算法。因为这样处理即使数据库泄漏，黑客也很难破解密码（破解密码只能用彩虹表）。 12345678910111213141516171819202122232425262728293031@SpringBootTestclass JpaRestApplicationTests { @Test void Test1(){// 可定义循环迭代的强度（默认为10） BCryptPasswordEncoder bCryptPasswordEncoder=new BCryptPasswordEncoder(); String encode=\"\"; for (int i = 0; i &lt; 10; i++) { //加密 encode = bCryptPasswordEncoder.encode(\"111\"); System.out.println(encode); }// 解密// 验证加密的和原密码是否匹配 boolean matches = bCryptPasswordEncoder.matches(\"111\", encode); System.out.println(matches); // 我们可以看到每次加密的密码都不一致 //$2a$10$4f0bp6uBiLdt2mfZcL4ITuolV7C1wNSAvmC5DCkQQ/wIbf0N4aiYu //$2a$10$3J7jUw/4d5tIJc.36e/SMOf3g3SWjFwYnBnc5q90F9jsHkbbfrbWO //$2a$10$oDbDEQonfNF3VccU9rw2u.PCEYgPz7sdEA/Zk3vlhq7nnA6zFptUq //$2a$10$h5mGJ1JleyKqJ0cXThgiv.D6tXWtsJovWCGn3lRC2VKzyHWBrrnSS //$2a$10$005mvGASGZVRgNzm2upYsOXTCgwZPhxhHsJQM50DFE9PTW0GR3hY. //$2a$10$gVbxdtiMstQESB0/EBbZq.4rPWHpgq20AUK.Jlq4xUE.g3jPGa5Mq //$2a$10$HWUDxz8SZYorijp05yeJH.JdkF8Jm.y2/rVnAXEXObprxeBWZYRfa //$2a$10$rpslaqYmHY9VCXY6U94nNO69rzwU34vDDFudW/APYFgLb3oVeVNu6 //$2a$10$7o41f4IV/uNwPmDKd4Rl/ehdPY5FT5uCvt1aofXwqwWTdkOQK/9L. //$2a$10$6NfXSvvKtzpgdjskRhoiMeqq9xTaWsCS7FdDr/I1I3Iy4IeT0tuta } 修改securityconfig配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@Configurationpublic class MultipleHttpSecurity {// 这里我们使用BCryptPasswordEncoder加密 @Bean PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); } /** * 认证管理 * @param auth 这里相当于注入 AuthenticationManagerBuilder对象 * @throws Exception */ @Autowired protected void configure(AuthenticationManagerBuilder auth) throws Exception {// 在内存中的认证 auth.inMemoryAuthentication()// 设置多个用户名,密码,角色 .withUser(\"lc\").password(\"111\").roles(\"admin\") .and() .withUser(\"zs\").password(\"$2a$10$4f0bp6uBiLdt2mfZcL4ITuolV7C1wNSAvmC5DCkQQ/wIbf0N4aiYu\").roles(\"user\"); } @Configuration// 数字越小优先级越高 @Order(1) public static class AdminSecurityConfig extends WebSecurityConfigurerAdapter{ @Override protected void configure(HttpSecurity httpSecurity) throws Exception {// 表示当前httpsecurity只拦截 /admin/** 路径，并且需要admin角色 httpSecurity.antMatcher(\"/admin/**\").authorizeRequests().anyRequest().hasRole(\"admin\"); } } @Configuration public static class OtherSecurityConfig extends WebSecurityConfigurerAdapter{ @Override protected void configure(HttpSecurity httpSecurity) throws Exception {// 开启授权请求，所有的请求都需要认证即可访问// 这里经过上面的admin的请求后 再拦截其他的所有请求 httpSecurity.authorizeRequests().anyRequest().authenticated() .and() .formLogin() .loginProcessingUrl(\"/doLogin\") .permitAll() .and() .csrf().disable(); } }} 五、方法安全管控1、注解详解​ spring security默认禁用注解，要想开启注解，需要在继承WebSecurityConfigurerAdapter的类上加@EnableGlobalMethodSecurity注解，并在该类中将AuthenticationManager定义为bean。 这里springSecurity默认禁用所有方法保护的注解@EnableGlobalMethodSecurity(prePostEnabled = true,securedEnabled = true) prePostEnabled开启 @PreAuthorize和@PostAuthorize 注解securedEnabled 开启@Secured注解 @EnableGlobalMethodSecurity启用注解1、@PreAuthorize在方法执行前判断，可以调用方法参数，主要利用Java8的参数名反射特性，如果没用Java8也可以使用spring security的@P标注参数，或者Spring Data的@Param标注参数。 123//判断用户是否为当前登录用户或拥有ROLE_ADMIN权限@PreAuthorize(\"#userId == authentication.principal.userId or hasAuthority(‘ADMIN’)\")public void changePassword(@P(\"userId\") long userId ){} 2、@PostAuthorize在方法执行后判断，可以调用参数。如果EL为false，虽然方法已经执行完了也可能会回滚，EL变量returnObject表示返回的对象。 3、@Secured只支持字符串形式,且必须要加上前缀ROLE_ 是否有权限访问 2、基本配置①、securityConfig1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@Configuration//这里springSecurity默认禁用所有方法保护的注解//prePostEnabled开启 @PreAuthorize和@PostAuthorize 注解//securedEnabled 开启@Secured注解@EnableGlobalMethodSecurity(prePostEnabled = true,securedEnabled = true)public class MultipleHttpSecurity {// 这里我们使用BCryptPasswordEncoder加密 @Bean PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); } /** * 认证管理 * @param auth 这里相当于注入 AuthenticationManagerBuilder对象 * @throws Exception */ @Autowired protected void configure(AuthenticationManagerBuilder auth) throws Exception {// 在内存中的认证 auth.inMemoryAuthentication()// 设置多个用户名,密码,角色 .withUser(\"lc\").password(\"$2a$10$4f0bp6uBiLdt2mfZcL4ITuolV7C1wNSAvmC5DCkQQ/wIbf0N4aiYu\").roles(\"admin\") .and() .withUser(\"zs\").password(\"$2a$10$4f0bp6uBiLdt2mfZcL4ITuolV7C1wNSAvmC5DCkQQ/wIbf0N4aiYu\").roles(\"user\"); } @Configuration// 数字越小优先级越高 @Order(1) public static class AdminSecurityConfig extends WebSecurityConfigurerAdapter{ @Override protected void configure(HttpSecurity httpSecurity) throws Exception {// 表示当前httpsecurity只拦截 /admin/** 路径，并且需要admin角色 httpSecurity.antMatcher(\"/admin/**\").authorizeRequests().anyRequest().hasRole(\"admin\"); } } @Configuration public static class OtherSecurityConfig extends WebSecurityConfigurerAdapter{ @Override protected void configure(HttpSecurity httpSecurity) throws Exception {// 开启授权请求，所有的请求都需要认证即可访问// 这里经过上面的admin的请求后 再拦截其他的所有请求 httpSecurity.authorizeRequests().anyRequest().authenticated() .and() .formLogin() .loginProcessingUrl(\"/doLogin\") .permitAll() .and() .csrf().disable(); } }} ②、userService123456789101112131415161718192021222324252627282930313233@Servicepublic class UserService { /** * 方法进入前 验证是否有admin角色 * @return */ @PreAuthorize(\"hasRole('admin')\") //同时要有admin和user角色// @PreAuthorize(\"hasRole('admin') and hasRole('user')\") public String admin() { return \"hello admin\"; } /** * 是否有user角色 * @return */ @Secured(\"ROLE_user\") public String user() { return \"hello user\"; } /** * 方法进入前 验证是否有admin或者user角色 * @return */ @PreAuthorize(\"hasAnyRole('admin','user')\") public String hello(){ return \"hello evenyone\"; }} ③、controller123456789101112131415161718@RestControllerpublic class UserController {// 登录即可访问 @GetMapping(\"/hello\") public String hello(){ return \"hello lc\"; }// 模拟admin接口 @GetMapping(\"/admin/hello\") public String admin(){ return \"hello admin\"; }// 模拟user上接口 @GetMapping(\"/user/hello\") public String user(){ return \"hello user\"; }} 六、基于数据库的认证1、sql1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859SET FOREIGN_KEY_CHECKS=0;-- ------------------------------ Table structure for role-- ----------------------------DROP TABLE IF EXISTS `role`;CREATE TABLE `role` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(32) DEFAULT NULL, `nameZh` varchar(32) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;-- ------------------------------ Records of role-- ----------------------------INSERT INTO `role` VALUES ('1', 'dba', '数据库管理员');INSERT INTO `role` VALUES ('2', 'admin', '系统管理员');INSERT INTO `role` VALUES ('3', 'user', '用户');-- ------------------------------ Table structure for user-- ----------------------------DROP TABLE IF EXISTS `user`;CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(32) DEFAULT NULL, `password` varchar(255) DEFAULT NULL, `enabled` tinyint(1) DEFAULT NULL, `locked` tinyint(1) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;-- ------------------------------ Records of user 密码123-- ----------------------------INSERT INTO `user` VALUES ('1', 'root', '$2a$10$RMuFXGQ5AtH4wOvkUqyvuecpqUSeoxZYqilXzbz50dceRsga.WYiq', '1', '0');INSERT INTO `user` VALUES ('2', 'admin', '$2a$10$RMuFXGQ5AtH4wOvkUqyvuecpqUSeoxZYqilXzbz50dceRsga.WYiq', '1', '0');INSERT INTO `user` VALUES ('3', 'sang', '$2a$10$RMuFXGQ5AtH4wOvkUqyvuecpqUSeoxZYqilXzbz50dceRsga.WYiq', '1', '0');-- ------------------------------ Table structure for user_role-- ----------------------------DROP TABLE IF EXISTS `user_role`;CREATE TABLE `user_role` ( `id` int(11) NOT NULL AUTO_INCREMENT, `uid` int(11) DEFAULT NULL, `rid` int(11) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;-- ------------------------------ Records of user_role-- ----------------------------INSERT INTO `user_role` VALUES ('1', '1', '1');INSERT INTO `user_role` VALUES ('2', '1', '2');INSERT INTO `user_role` VALUES ('3', '2', '2');INSERT INTO `user_role` VALUES ('4', '3', '3');SET FOREIGN_KEY_CHECKS=1; 2、pom.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.lc&lt;/groupId&gt; &lt;artifactId&gt;security-db&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;security-db&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.18&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.27&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 3、实体这里提供的UserDetails只是一种规范 123456789101112131415public interface UserDetails extends Serializable { Collection&lt;? extends GrantedAuthority&gt; getAuthorities(); String getPassword(); String getUsername(); boolean isAccountNonExpired(); boolean isAccountNonLocked(); boolean isCredentialsNonExpired(); boolean isEnabled();} ①user 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118public class User implements UserDetails { private Integer id; private String username; private String password; /** * 是否启用 */ private Boolean enabled; /** * 是否锁定 */ private Boolean locked; /** * 一个用户可以包含多个角色 */ private List&lt;Role&gt; roles; public Integer getId() { return id; } public User setId(Integer id) { this.id = id; return this; } public User setUsername(String username) { this.username = username; return this; } public User setPassword(String password) { this.password = password; return this; } public User setEnabled(Boolean enabled) { this.enabled = enabled; return this; } public User setLocked(Boolean locked) { this.locked = locked; return this; } public List&lt;Role&gt; getRoles() { return roles; } public User setRoles(List&lt;Role&gt; roles) { this.roles = roles; return this; } @Override public String getPassword(){ return password; } @Override public String getUsername() { return username; } /** * 返回用户的所有角色 * @return */ @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() { List&lt;SimpleGrantedAuthority&gt; authorities=new ArrayList&lt;&gt;();// 将数据中查询的角色信息查出并传入springsecurity for (Role role : roles) {// 注意若数据中的角色名没有以ROLE_开头，则需要在这动态赋予。否则则不需要 authorities.add(new SimpleGrantedAuthority(\"ROLE_\" + role.getName())); } return authorities; } /** * 账户是否没有未过期 * @return */ @Override public boolean isAccountNonExpired() { return true; } /** * 账户是否未锁定 相当于locked的get方法 * @return */ @Override public boolean isAccountNonLocked() { //这里的数据库中为0，则这里的locked为false; 因为这里问是否未被锁定，所以这里要取反 return !locked; } /** * 凭证(密码)是否未过期 * @return */ @Override public boolean isCredentialsNonExpired() { return true; } /** * 是否可用 相当于enabled的get方法 * @return */ @Override public boolean isEnabled() { return enabled; }} ②role 12345678@Setter@Getter@ToStringpublic class Role { private Integer id; private String name; private String nameZh;} 5、mapper①接口 1234567public interface UserMapper { User loadUserByUsername(String username); //根据用户id查询所有该用户对应的角色 List&lt;Role&gt; getUserRolesById(Integer id);} ②xml 12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" &gt;&lt;mapper namespace=\"com.lc.securitydb.mapper.UserMapper\"&gt; &lt;select id=\"loadUserByUsername\" resultType=\"com.lc.securitydb.bean.User\"&gt; select * from user where username=#{username}; &lt;/select&gt; &lt;select id=\"getUserRolesById\" resultType=\"com.lc.securitydb.bean.Role\"&gt; select * from role where id in(select rid from user_role where uid=#{id}) &lt;/select&gt;&lt;/mapper&gt; 6、service同理，这里我们提供UserDetailsService是一种规范 123public interface UserDetailsService { UserDetails loadUserByUsername(String var1) throws UsernameNotFoundException;} 1234567891011121314151617181920212223@Servicepublic class UserService implements UserDetailsService { @Autowired private UserMapper userMapper; /** * 根据用户名查询用户 这里我们只需要根据用户名查出即可 后面的密码结果系统会去比对 * @param username 登录时的用户名 * @return * @throws UsernameNotFoundException */ @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException { User user=userMapper.loadUserByUsername(username); if (user == null) { throw new UsernameNotFoundException(\"用户不存在\"); }// 查询用户角色 user.setRoles(userMapper.getUserRolesById(user.getId())); return user; }} 7、config①mybatis配置1234@Configuration@MapperScan(basePackages = \"com.lc.securitydb.mapper\")public class MybatisConfig {} ②security配置123456789101112131415161718192021222324252627282930313233343536373839@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter { @Autowired private UserService userService; /** * 进行用户名和密码的配置管理 * @param auth * @throws Exception */ @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.userDetailsService(userService); } /** * 加密器 * @return */ @Bean public BCryptPasswordEncoder bCryptPasswordEncoder() { return new BCryptPasswordEncoder(); } @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers(\"/admin/**\").hasRole(\"admin\") .antMatchers(\"/dba/**\").hasRole(\"dba\") .antMatchers(\"/user/**\").hasRole(\"user\") .anyRequest().authenticated() .and() .formLogin() .permitAll() .and() .csrf().disable(); }} 8、yaml123456spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/securitytest?useUnicode=true&amp;characterEncoding=utf-8 username: root password: 123456 9、controller12345678910111213141516171819202122232425262728293031323334353637383940@RestControllerpublic class HelloController { /** * 登录即可 访问 * @return */ @GetMapping(\"/hello\") public String hello() { return \"hello security\"; } /** * 角色dba访问 * @return */ @GetMapping(\"/dba/hello\") public String dba() { return \"hello dba\"; } /** * 角色admin访问 * @return */ @GetMapping(\"/admin/hello\") public String admin() { return \"hello admin\"; } /** * 角色user访问 * @return */ @GetMapping(\"/user/hello\") public String user() { return \"hello user\"; }} 七、SpringSecurity中的继承关系1、版本化的配置差异①SpringBoot2.0.8(含)之前的写法角色之间的继承关系用 空格 分开 1234567@Bean RoleHierarchy roleHierarchy() { RoleHierarchyImpl roleHierarchy = new RoleHierarchyImpl(); String hierarchy = \"ROLE_dba &gt; ROLE_admin ROLE_admin &gt; ROLE_user\"; roleHierarchy.setHierarchy(hierarchy); return roleHierarchy; } ②SpringBoot2.0.8之后的版本角色之前的继承用 \\n 分开 1234567@Beanpublic RoleHierarchy roleHierarchy() { RoleHierarchyImpl roleHierarchy = new RoleHierarchyImpl(); String hierarchy = \"ROLE_dba &gt; ROLE_admin \\n ROLE_admin &gt; ROLE_user\"; roleHierarchy.setHierarchy(hierarchy); return roleHierarchy;} 拥有dba角色可以访问admin有关的接口，拥有admin角色可以访问user有关的接口，user只能访问自己有关的接口，所以dba可以访问admin和user有关的接口，admin可以访问user的有关接口 2、注意的几个地方：①注意角色前要加 ROLE_ 前缀 ②角色和角色之间的定义 &gt; 前后要加空格 , \\n 前后也要加空格 3、基本配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter { @Autowired private UserService userService; /** * 进行用户名和密码的配置管理 * * @param auth * @throws Exception */ @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.userDetailsService(userService); } /** * 加密器 * * @return */ @Bean public BCryptPasswordEncoder bCryptPasswordEncoder() { return new BCryptPasswordEncoder(); } @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers(\"/admin/**\").hasRole(\"admin\") .antMatchers(\"/dba/**\").hasRole(\"dba\") .antMatchers(\"/user/**\").hasRole(\"user\") .anyRequest().authenticated() .and() .formLogin() .permitAll() .and() .csrf().disable(); } @Bean public RoleHierarchy roleHierarchy() { RoleHierarchyImpl roleHierarchy = new RoleHierarchyImpl(); String hierarchy = \"ROLE_dba &gt; ROLE_admin \\n ROLE_admin &gt; ROLE_user\"; roleHierarchy.setHierarchy(hierarchy); return roleHierarchy; }} 八、动态配置权限1、sql菜单表，菜单角色表，用户表，角色表，用户角色表 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980CREATE TABLE `menu` ( `id` int(11) NOT NULL AUTO_INCREMENT, `pattern` varchar(100) NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4;-- ------------------------------ Records of menu-- ----------------------------INSERT INTO `menu` VALUES ('1', '/dba/**');INSERT INTO `menu` VALUES ('2', '/admin/**');INSERT INTO `menu` VALUES ('3', '/user/**');CREATE TABLE `menu_role` ( `id` int(11) NOT NULL AUTO_INCREMENT, `mid` int(11) DEFAULT NULL, `rid` int(11) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4;-- ------------------------------ Records of menu_role-- ----------------------------INSERT INTO `menu_role` VALUES ('1', '1', '1');INSERT INTO `menu_role` VALUES ('2', '2', '2');INSERT INTO `menu_role` VALUES ('3', '3', '3');CREATE TABLE `role` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(32) DEFAULT NULL, `nameZh` varchar(32) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;-- ------------------------------ Records of role-- ----------------------------INSERT INTO `role` VALUES ('1', 'dba', '数据库管理员');INSERT INTO `role` VALUES ('2', 'admin', '系统管理员');INSERT INTO `role` VALUES ('3', 'user', '用户');-- ------------------------------ Table structure for user-- ----------------------------DROP TABLE IF EXISTS `user`;CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(32) DEFAULT NULL, `password` varchar(255) DEFAULT NULL, `enabled` tinyint(1) DEFAULT NULL, `locked` tinyint(1) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;-- ------------------------------ Records of user 密码123-- ----------------------------INSERT INTO `user` VALUES ('1', 'root', '$2a$10$RMuFXGQ5AtH4wOvkUqyvuecpqUSeoxZYqilXzbz50dceRsga.WYiq', '1', '0');INSERT INTO `user` VALUES ('2', 'admin', '$2a$10$RMuFXGQ5AtH4wOvkUqyvuecpqUSeoxZYqilXzbz50dceRsga.WYiq', '1', '0');INSERT INTO `user` VALUES ('3', 'sang', '$2a$10$RMuFXGQ5AtH4wOvkUqyvuecpqUSeoxZYqilXzbz50dceRsga.WYiq', '1', '0');-- ------------------------------ Table structure for user_role-- ----------------------------DROP TABLE IF EXISTS `user_role`;CREATE TABLE `user_role` ( `id` int(11) NOT NULL AUTO_INCREMENT, `uid` int(11) DEFAULT NULL, `rid` int(11) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;-- ------------------------------ Records of user_role-- ----------------------------INSERT INTO `user_role` VALUES ('1', '1', '1');INSERT INTO `user_role` VALUES ('2', '1', '2');INSERT INTO `user_role` VALUES ('3', '2', '2');INSERT INTO `user_role` VALUES ('4', '3', '3');SET FOREIGN_KEY_CHECKS=1; 2、pom.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;security-dynamic&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;security-dynamic&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.18&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;version&gt;5.1.27&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 3、yaml配置123456spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/securitydy?useUnicode=true&amp;characterEncoding=UTF-8 username: root password: 123456 4、实体配置menu==&gt; 12345678910111213141516@Getter@Setter@ToStringpublic class Menu { private Integer id; /** * 访问此菜单的路径 */ private String pattern; /** * 访问此此单需要的角色 */ private List&lt;Role&gt; roles;} role==&gt; 12345678@Getter@Setter@ToStringpublic class Role { private Integer id; private String name; private String nameZh;} user==&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public class User implements UserDetails { private Integer id; private String username; private String password; private Boolean enabled; private Boolean locked; private List&lt;Role&gt; roles; public List&lt;Role&gt; getRoles() { return roles; } public User setRoles(List&lt;Role&gt; roles) { this.roles = roles; return this; } public Integer getId() { return id; } public User setId(Integer id) { this.id = id; return this; } public User setUsername(String username) { this.username = username; return this; } public User setPassword(String password) { this.password = password; return this; } public User setEnabled(Boolean enabled) { this.enabled = enabled; return this; } public User setLocked(Boolean locked) { this.locked = locked; return this; } @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() { List&lt;SimpleGrantedAuthority&gt; authorities=new ArrayList&lt;&gt;(); for (Role role : roles) {// 此时这里我们不需要加ROLE_前缀 因为数据库中我们的角色名已经加好了前缀 authorities.add(new SimpleGrantedAuthority(role.getName())); } return authorities; } @Override public String getPassword() { return password; } @Override public String getUsername() { return username; } @Override public boolean isAccountNonExpired() { return true; } @Override public boolean isAccountNonLocked() { return !locked; } @Override public boolean isCredentialsNonExpired() { return true; } @Override public boolean isEnabled() { return enabled; }} 5、mapper123public interface MenuMapper { List&lt;Menu&gt; getAllMenus();} 1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" &gt;&lt;mapper namespace=\"org.lc.securitydynamic.mapper.MenuMapper\"&gt; &lt;resultMap id=\"BaseResultMap\" type=\"org.lc.securitydynamic.bean.Menu\"&gt; &lt;id property=\"id\" column=\"id\"/&gt; &lt;result property=\"pattern\" column=\"pattern\"/&gt; &lt;collection property=\"roles\" ofType=\"org.lc.securitydynamic.bean.Role\"&gt; &lt;id property=\"id\" column=\"rid\"/&gt; &lt;result property=\"name\" column=\"rname\"/&gt; &lt;result property=\"nameZh\" column=\"rnameZh\"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=\"getAllMenus\" resultMap=\"BaseResultMap\"&gt; SELECT menu.*, role.id rid, role. NAME rname, role.nameZh rnameZh FROM menu LEFT JOIN menu_role mr ON menu.id = mr.mid LEFT JOIN role ON mr.rid = role.id &lt;/select&gt;&lt;/mapper&gt; 123456public interface UserMapper { User getUserByUsername(String username); List&lt;Role&gt; getRolesByUserId(Integer id);} 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" &gt;&lt;mapper namespace=\"org.lc.securitydynamic.mapper.UserMapper\"&gt; &lt;select id=\"getUserByUsername\" resultType=\"org.lc.securitydynamic.bean.User\"&gt; select * from user where username=#{username} &lt;/select&gt; &lt;select id=\"getRolesByUserId\" resultType=\"org.lc.securitydynamic.bean.Role\"&gt; select * from role where id in(select rid from user_role where uid=#{id}) &lt;/select&gt;&lt;/mapper&gt; 6、service12345678910@Servicepublic class MenuService { @Autowired private MenuMapper menuMapper; public List&lt;Menu&gt; getAllMenus() { return menuMapper.getAllMenus(); }} 12345678910111213141516@Servicepublic class UserService implements UserDetailsService { @Autowired private UserMapper userMapper; @Override public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException { User user= userMapper.getUserByUsername(s); if (user == null) { throw new UsernameNotFoundException(\"用户不存在\"); } user.setRoles(userMapper.getRolesByUserId(user.getId())); return user; }} 7、controller12345678910111213141516171819202122232425262728293031323334353637383940@RestControllerpublic class HelloController { /** * 登录即可访问 * @return */ @GetMapping(\"/hello\") public String hello() { return \"hello security\"; } /** * 模拟 dba角色 * @return */ @GetMapping(\"/dba/hello\") public String dba() { return \"hello dba\"; } /** * 模拟admin角色 * @return */ @GetMapping(\"/admin/hello\") public String admin() { return \"hello admin\"; } /** * 模拟user角色 * @return */ @GetMapping(\"/user/hello\") public String user() { return \"hello user\"; }} 8、核心配置①mybati配置1234@Configuration@MapperScan(basePackages = \"org.lc.securitydynamic.mapper\")public class MybatisConfig {} ②过滤回调配置(筛选请求需要的角色)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263@Componentpublic class MyFilterInvocation implements FilterInvocationSecurityMetadataSource { /** * 匹配ant风格的路径 使用AntPathMatcher类比较两个路径是否匹配 */ AntPathMatcher antPathMatcher=new AntPathMatcher(); @Autowired private MenuService menuService; /** * 这里每一次请求就会查询一遍表 和遍历一遍集合，我们可以放入redis缓存中 * * 根据请求的地址 分析 出需要的角色 * @param o 实际上是一个FilterInvocation对象 请求的相关信息 * @return 返回需要的角色 * @throws IllegalArgumentException */ @Override public Collection&lt;ConfigAttribute&gt; getAttributes(Object o) throws IllegalArgumentException {// 获取当前请求的url String requestUrl = ((FilterInvocation) o).getRequestUrl();// 获取数据库中每个菜单请求对应的访问路径即角色信息 List&lt;Menu&gt; allMenus = menuService.getAllMenus();// 遍历数据库中的菜单 for (Menu menu : allMenus) {// 判断数据库中的菜单路径 是否 和请求的路径匹配 if (antPathMatcher.match(menu.getPattern(), requestUrl)) {// 若匹配 获取该路径下的对应的所有角色信息 List&lt;Role&gt; roles = menu.getRoles();// 定义存放角色的字符串 并指定和list中相同的长度 String[] allRoleList=new String[roles.size()];// 遍历该角色集合 for (int i = 0; i &lt; roles.size(); i++) {// 存放到字符串数组中 allRoleList[i] = roles.get(i).getName(); }// 返回该匹配的请求路径下的所有角色信息 return SecurityConfig.createList(allRoleList); } }// 如果请求的路径没有和数据库中的路径匹配 则返回自定义的角色（这里，我们只作为一个标识，后期根据标识再去处理） return SecurityConfig.createList(\"ROLE_login\"); } @Override public Collection&lt;ConfigAttribute&gt; getAllConfigAttributes() { return null; } /** * 是否支持这种方式 返回true即可 * @param aClass * @return */ @Override public boolean supports(Class&lt;?&gt; aClass) { return true; }} ③存储决定管理器(比对登录用户的角色)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package org.lc.securitydynamic.config;import org.springframework.security.access.AccessDecisionManager;import org.springframework.security.access.AccessDeniedException;import org.springframework.security.access.ConfigAttribute;import org.springframework.security.authentication.AnonymousAuthenticationToken;import org.springframework.security.authentication.InsufficientAuthenticationException;import org.springframework.security.core.Authentication;import org.springframework.security.core.GrantedAuthority;import org.springframework.stereotype.Component;import java.util.Collection;/** * @BelongsProject: security-dynamic * @BelongsPackage: org.lc.securitydynamic.config * @Author: lc * @CreateTime: 2020-03-29 00:19 * @Description: */@Componentpublic class MyAccessDecisionManager implements AccessDecisionManager { /** * @param authentication 当前登录用户的信息 * @param o 当前的请求对象（相当于FilterInvocation对象） * @param collection 我们自定义的FilterInvocationSecurityMetadataSource的返回匹配路径需要的角色对象 * @throws AccessDeniedException * @throws InsufficientAuthenticationException */ @Override public void decide(Authentication authentication, Object o, Collection&lt;ConfigAttribute&gt; collection) throws AccessDeniedException, InsufficientAuthenticationException {// 这里考虑 未登录先直接抛出异常*************** if (authentication instanceof AnonymousAuthenticationToken) { throw new AccessDeniedException(\"未登录,非法请求\"); }// 遍历该请求路径下需要的角色对象 for (ConfigAttribute configAttribute : collection) {// 如果没有任何路径匹配（我们之前定义的没有任何路径能够匹配上，自定义返回的角色） if (\"ROLE_login\".equals(configAttribute.getAttribute())) {// 若登录状态为匿名用户（未登录） 直接抛异常 if (authentication instanceof AnonymousAuthenticationToken) { //RememberMeAuthenticationToken (org.springframework.security.authentication) //TestingAuthenticationToken (org.springframework.security.authentication)// 匿名用户的登录 //AnonymousAuthenticationToken (org.springframework.security.authentication) //RunAsUserToken (org.springframework.security.access.intercept)// 已经进行用户名和密码的登录 //UsernamePasswordAuthenticationToken (org.springframework.security.authentication) //PreAuthenticatedAuthenticationToken (org.springframework.security.web.authentication.preauth) throw new AccessDeniedException(\"非法请求\"); }else{// 已经登录 但是没有匹配数据库中的路径// 可能只要登录即可访问// 直接退出角色寻找 return; } }// 当前登录用户具备的角色 Collection&lt;? extends GrantedAuthority&gt; authorities = authentication.getAuthorities();// 遍历用户具备的角色 for (GrantedAuthority authority : authorities) {// 如果当前登录用户的角色和 该路径下的数据库的角色匹配 if (authority.getAuthority().equals(configAttribute.getAttribute())) {// 直接返回 return; } } }// 若路径匹配但是 没有找到相应的角色 抛出异常 throw new AccessDeniedException(\"权限不足，非法请求\"); } /** * 是否支持这种方式 true * @param configAttribute * @return */ @Override public boolean supports(ConfigAttribute configAttribute) { return true; } /** * 是否支持这种方式 true * @param aClass * @return */ @Override public boolean supports(Class&lt;?&gt; aClass) { return true; }} ④security配置1234567891011121314151617181920212223242526272829303132333435363738394041424344@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter { @Autowired private UserService userService; @Autowired private MyFilterInvocation myFilterInvocation; @Autowired private MyAccessDecisionManager myAccessDecisionManager; @Bean BCryptPasswordEncoder bCryptPasswordEncoder() { return new BCryptPasswordEncoder(); } @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.userDetailsService(userService); } @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests()// 定义请求之前的处理器 .withObjectPostProcessor(new ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() { @Override public &lt;O extends FilterSecurityInterceptor&gt; O postProcess(O o) {// 设置自定义拦截请求需要的角色 o.setSecurityMetadataSource(myFilterInvocation);// 设置自定义角色比对管理器 o.setAccessDecisionManager(myAccessDecisionManager); return o; } }) .and() .formLogin() .permitAll() .and() .csrf().disable(); }} 9 、执行流程分析①首先拦截所有请求通过过滤回调配置文件处理(MyFilterInvocation)，获得当前请求的路径（String requestUrl = ((FilterInvocation) o).getRequestUrl();） ②查找所有的请求路径所需的角色信息，遍历该路径信息，如果找到与请求向匹配的路径，则返回该路径所需要的全部角色信息。若没有匹配上，则返回一个标识角色代表没有匹配上（return SecurityConfig.createList(“ROLE_login”)） ③来到角色比对管理器（MyAccessDecisionManager），首先我们可以直接判断用户是否登录，若未登录，直接抛出非法请求异常（throw new AccessDeniedException(“未登录,请求非法”)）。若进入登录状态验证后，遍历返回的该路径下需要的角色信息，若匹配到我们自定义的标识角色，则代表未匹配路径，则直接返回（代表该路径不需要角色，登录即可访问）。否则代表匹配上指定的路径，那么遍历当前用户登录的角色信息，查看数据库路径下的角色信息是否和当前用户登录所有的角色信息匹配，若匹配到，直接返回。遍历完之后，还没有符合的条件，直接抛出异常。","link":"/2020/07/24/springsecurity/Spring-Security%E9%85%8D%E7%BD%AE/"},{"title":"Servlet详解","text":"一、Servlet作用 接收请求 处理请求 完成响应 二、Servlet创建和使用流程1、创建类继承HttpServlet 12345678public class OneServlet extends HttpServlet { @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { } @Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { }} 2、在web.xml配置Servlet位置和地址映射 12345678910111213141516171819202122232425262728293031&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd\" version=\"4.0\"&gt; &lt;!--tomcat初始化打开的页面--&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;/index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;/index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;!--将servlet接口实现类类路径地址交给tomcat --&gt; &lt;servlet&gt; &lt;!-- 为我们自定义的Servlet起一个名称--&gt; &lt;servlet-name&gt;OneServlet&lt;/servlet-name&gt; &lt;!-- 该servlet具体的包下的地址--&gt; &lt;servlet-class&gt;org.lc.controller.OneServlet&lt;/servlet-class&gt; &lt;!-- load-on-startup元素标记容器是否在启动的时候就加载这个servlet(实例化并调用其init()方法)。 当值小于0或者没有指定时，则表示容器在该Servlet被请求时，才会去加载。 正数的值越小，该Servlet的优先级就越高，应用启动时就优先加载。 当值相同的时候，容器就会自己选择优先加载。--&gt; &lt;!--tomcat启动时就会创建 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;!-- 为自定义servlet配置地址映射--&gt; &lt;servlet-mapping&gt; &lt;!-- 指定servlet--&gt; &lt;servlet-name&gt;OneServlet&lt;/servlet-name&gt; &lt;!-- 指定请求地址--&gt; &lt;url-pattern&gt;/one&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 三、Servlet生命周期1、初始化init()。Servlet对象只会初始化一次 若Servlet指定load-on-startup的配置，则在tomcat服务器启动时 该Servlet即被初始化 若Servlet没有指定load-on-startup配置，则在第一次请求时初始化Servlet &lt;servlet&gt; &lt;!-- 为我们自定义的Servlet起一个名称--&gt; &lt;servlet-name&gt;OneServlet&lt;/servlet-name&gt; &lt;!-- 该servlet具体的包下的地址--&gt; &lt;servlet-class&gt;org.lc.controller.OneServlet&lt;/servlet-class&gt; &lt;!-- load-on-startup元素标记容器是否在启动的时候就加载这个servlet(实例化并调用其init()方法)。 当值小于0或者没有指定时，则表示容器在该Servlet被请求时，才会去加载。 正数的值越小，该Servlet的优先级就越高，应用启动时就优先加载。 当值相同的时候，容器就会自己选择优先加载。--&gt; &lt;!--tomcat启动时就会创建 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; 12345678910111213141516171819202122232425262728293031322、调用service()方法，处理post或者get及其他请求。每次请求都会调用该service方法3、调用destory()方法，当服务区关闭时就会调用此方法。该方法只会在服务器结束时调用一次**注意：**- Servlet为单实例多线程，所有不要在Servlet实例中写共享变量。### 四、HttpServletResponse和HttpServletRequest`HttpServletResponse`封装服务端返回给浏览器的数据`HttpServletRequest`封装客户端请求的数据#### **1、HttpServletResponse**##### ***1)向客户端返回中文数据***浏览器根据不同的响应体中的ContentType类型类解析不同的二进制数据```java@Override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //根据响应体对象返回数据给浏览器 注意：必须先指定字符编码 然后获取PrintWriter流对象。 response.setContentType(&quot;text/html;charset=UTF-8&quot;); PrintWriter printWriter = response.getWriter(); printWriter.write(&quot;hello world&lt;br/&gt;&quot;); printWriter.write(&quot;你好世界！&quot;); printWriter.flush(); printWriter.close(); } 2)重定向其它地址浏览器会 1234567@Overrideprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //重定向到我们项目下的指定页面 resp.sendRedirect(\"success.html\"); //重定向到我们指定的地址 //resp.sendRedirect(\"http://www.baidu.com\");} 3)若禁用cookie，可采用编码重定向详细参考cookie禁用 使用response中的encodeRedirectURL()方法优化其请求路径。自动判断，如果禁用cookie则帮我们携带上session否则不会携带 &lt;a href=&quot;&lt;%=response.encodeRedirectURL(&quot;sessiontest.jsp&quot;)%&gt;&quot;&gt;去其他页面&lt;/a&gt; 4)获取响应流对象一般用作文件下载。详细参考文件下载 2、HttpServletRequest1)获取请求参数123456789101112131415&lt;form action=\"/one\" method=\"get\"&gt; 用户名&lt;input type=\"text\" name=\"username\"&gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt;&lt;h1&gt;POST请求&lt;/h1&gt;&lt;form action=\"/one\" method=\"post\"&gt; 用户名&lt;input type=\"text\" name=\"username\"&gt;&lt;br/&gt; 爱好: 篮球&lt;input type=\"checkbox\" name=\"interest\" value=\"lanqiu\"&gt; 足球&lt;input type=\"checkbox\" name=\"interest\" value=\"zuqiu\"&gt; 排球&lt;input type=\"checkbox\" name=\"interest\" value=\"paiqiu\"&gt; 性别： 男：&lt;input type=\"radio\" name=\"gender\" value=\"male\"&gt; 女：&lt;input type=\"radio\" name=\"gender\" value=\"female\"&gt; &lt;input type=\"submit\" value=\"提交\"&gt;&lt;/form&gt; 1234567891011121314151617 @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { req.setCharacterEncoding(\"utf-8\"); //1、获取单个值 文本框，单选框 String username = req.getParameter(\"username\"); String gender = req.getParameter(\"gender\"); System.out.println(username); System.out.println(gender); //2、获取某个参数的多个值，例如多选框 String[] interests = req.getParameterValues(\"interest\"); System.out.println(Arrays.toString(interests)); //3、获取请求头信息 System.out.println(req.getHeader(\"Host\")); System.out.println(req.getHeader(\"Content-Type\")); System.out.println(req.getHeader(\"Accept\")); }} 2)get和post请求处理乱码方式 GET请求 ①浏览器地址栏默认使用ISO-8859-1进行编码，所以我们需要用对应的编码格式解码 12345@Overrideprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //解决get请求乱码 System.out.println(new String(req.getParameter(\"username\").getBytes(\"ISO-8859-1\"),\"utf-8\"));} ②修改tomcat的解码规则 找到tomcat安装路径下的conf/server.xml文件： 在下列标签加入：URIEncoding=&quot;utf-8&quot; 即可 1&lt;Connector connectionTimeout=\"30000\" port=\"8080\" protocol=\"HTTP/1.1\" redirectPort=\"8443\" URIEncoding=\"utf-8\" /&gt; PSOT请求 123456789101112@Overrideprotected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //解决请求乱码 重新设置请求的编码格式，浏览器和我们服务器的编码和解码的格式不一致，所以我们需要在获取请求参数之前，同一设置编码格式 req.setCharacterEncoding(\"utf-8\"); //第一种方式：设置文本类型并设置编码格式 req.setContentType(\"text/html;charset=utf-8\"); //第二种方式：设置响应头 //req.addHeader(\"Content-Type\",\"text/html;charset=utf-8\"); //必须在获得PrintWriter流之前设置请求编码 PrintWriter printWriter = req.getWriter();} 在我们设置响应的编码格式时：只需要设置内容类型和编码格式就行。 3)请求转发123456789@Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //转发到指定路径或请求 RequestDispatcher requestDispatcher = req.getRequestDispatcher(\"success.html\"); //若转发到page/success.html页面，则： //req.getRequestDispatcher(\"page/success.html\"); //并转发请求和响应参数 requestDispatcher.forward(req, resp); } 3)获得项目路径12// /servlet_testString contextPath1 = req.getContextPath(); 4)获取请求地址request.getRequestURI(); 获取请求的URI 不包含项目路径 request.getRequestURL(); 获取请求的URL 包含项目路径(全路径) 5)获取请求流对象 若请求的enctytpe类型为 enctype=”application/x-www-form-urlencoded” 则流ServletInputStream流中存储的为 请求参数和值。 若请求的enctytpe类型为 enctype=”multipart/form-data” 则流ServletInputStream中存储为 一段段数据部分。 1ServletInputStream inputStream1 = request.getInputStream(); 3、转发和重定向的区别 转发(HttpServletRequest对象) 地址栏的路径不会更改 请求只会发生一次，即getRequestDispatcher(“success.html”)中的路径不会请求，只转发相应的请求和响应对象即可。 服务器内部完成 可以共享请求域数据(HttpServletRequest和HttpServletResponse) 必须是当前服务器的资源 可以访问WEB-IN下的资源 重定向(HttpServletResponse对象) 地址栏会变成getRequestDispatcher(“success.html”)中指定的转发路径 会发生两次请求 浏览器完成 不可以共享请求域数据(HttpServletRequest和HttpServletResponse) 可以是外部的资源 不可以访问WEB-IN下的资源 注意：我们只能一个请求对应一个响应，而且先处理请求操作再处理响应操作，不能有多个响应或者请求转发操作。 五、项目路径问题我们一般新建javaweb选择，选择打包的方式： 上面的Application context：/servlet_test 默认为项目名称。可以把其设置为 / 即可 我们的Servlet在进行地址解析的时候web.xml中的地址解析为： 12345&lt;servlet-mapping&gt; &lt;servlet-name&gt;TwoServlet&lt;/servlet-name&gt; &lt;!--其中的 / 代表的是当前项目的路径 即http://localhost:8081/servlet_test/ 这也是为什么我们无需在页面访问时加 / 的原因了--&gt; &lt;url-pattern&gt;/two&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 1、项目路径和服务器路径的区别：项目路径：http://localhost:8081/servlet_test/ 携带项目名称 服务器路径：http://localhost:8081/ 以我们tomcat服务器的路径，不携带项目名称 2、页面路径访问问题(在页面请求中访问servlet也如此) 若设置了路径项目名称 如果请求路径以 / 开头的，则代表为当前服务器路径即 http://localhost:8081/,。需要在后面加上项目名称 / servlet_test 即访问的规则 &lt;a href=&quot;/servlet_test/page/error.html&quot;&gt;错误页面&lt;/a&gt; 如果请求路径没有以 / 开头，那么可以不加项目名称 &lt;a href=&quot;page/error.html&quot;&gt;错误页面&lt;/a&gt; 若没有设置项目路径名称，则请求加不加 / 都无所谓 3、Servlet中的路径问题 重定向路径 因为重定向是请求路径交给浏览器去访问，所以在Servlet中使用重定向时加 / 也代表当前服务器路径即 http://localhost:8081/, 需要加项目名 。用法和在页面访问路径一致 response.sendRedirect(\"/servlet_test/success.html\"); &lt;!--￼13--&gt; - ```java //或者 req.getRequestDispatcher(\"success.html\").forward(req, resp); &lt;!--￼14--&gt; 使用HttpServletRequest中的getContextPath方法获取项目名称 // /servlet_test String contextPath1 = req.getContextPath(); &lt;!--￼15--&gt; 打印到页面：使用out对象 1234&lt;% //在页面打印 hello out.println(\"hello\");%&gt; 2、jsp表达式，在页面输出内容在jsp中声明的jsp表达式会被加载到service中的write()流方法中当做参数输出 123456&lt;!--会在头部导入指定包--&gt;&lt;%@ page import=\"java.util.Date\" %&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;!--会在页面输出日期--&gt;&lt;%=new Date()%&gt; 3、声明成员(少用)在jsp中以&lt;%! %&gt; 中声明的代码相当于声明在 Servlet的service方法外面。当做成员参数或成员方法。 1234&lt;%!private String name=\"张三\";%&gt;&lt;!--在页面输出 '张三'--&gt;&lt;%=name%&gt; 4、jsp注释&lt;%-- --%&gt; 1&lt;%-- 我是注释 --%&gt; 5、jsp指令&lt;%@ 指令名 属性名=属性值 %&gt; 1)page指令定义页面是如何解析 12&lt;%@ page import=\"java.util.Date\" %&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt; 2)include指令静态包含。要包含的文件不需要翻译和编译的。静态包含的内容一般不动 1&lt;%@include file=\"register.html\"%&gt; 3)taglib指令在页面引入标签库 &lt;%@ taglib 属性名=属性值 %&gt; 4)jsp指令&lt;jsp:指令名 属性名=属性值&gt; 12345678&lt;!--动态包含 需要翻译和编译，常用于经常变动的页面。--&gt; &lt;jsp:include page=\"register.jsp\"&gt;&lt;/jsp:include&gt;&lt;!--请求转发到指定页面--&gt;&lt;jsp:forward page=\"register.jsp\"&gt;&lt;/jsp:forward&gt;&lt;!--请求并指定参数--&gt;&lt;jsp:forward page=\"register.jsp\"&gt; &lt;jsp:param name=\"username\" value=\"张三\"/&gt;&lt;/jsp:forward&gt; 6、jsp九大隐含对象可以在jsp中直接使用 1)隐含对象 Throwable exception=null 代表捕获异常对象 ServletConfig config=null 代表Servlet配置信息 获得当前jsp对应servlet的详细信息 获取servlet名称 config.getServletName(); JspWriter out=null 代表在页面输出数据的out对象 out.print(&quot;你好&quot;); Object page=this; 代表当前jsp 主要使用this, page仅代表Object *HttpServletResponse *response 代表当前的响应对象 向页面输出内容 response.getWriter().write(&quot;hello&quot;); 2)四大域对象域对象用来在其他资源共享数据。都可以通过setAttribute(K,V)的形式设置数据。通过getAttribute(K)的形式拿到数据 PageContext pageContext=null 代表当前页面对象 获取所有的其他的隐含对象 ServletRequest request1 = pageContext.getRequest(); Object page1 = pageContext.getPage(); &lt;!--￼23--&gt; HttpSession session=null 代表会话对象 同一次会话共享数据， 浏览单打开–开始会话。 浏览器关闭–结束会话。使用不同web应用(Chrom,IE,Egde),就是不同的会话 HttpServletRequest request代表当前封装的请求对象 在同一个请求对象中共享数据，只要是同一次请求，就可以共享数据。转发也可以共享数据 ServletContent application =null 代表整个web应用 application 代表当前web应用。只要在同一个web应用都可以共享数据。web应用只要不卸载都可以访问 域对象 作用范围 起始时间 结束时间 pageContext 当前jsp页面 页面加载 离开页面 request 同一个请求 收到请求 响应 session 同一个会话 开始会话 结婚会话 application 当前web应用 web应用加载 web应用卸载 7、EL表达式EL表达式都是通过属性的get方法获取的。而不是属性。所以命名要以按照javabean的规范编写 EL表达式可以存在html标签中的属性中。或者任意hmtl标签内 1)获取页面显示域中的属性值${属性名} 2)要获取某个属性的值，直接${属性名.属性} 3)若el表达式中有多个属性名相同则会从四个域从小到大寻找，找到即停止 4)当有多个属性名相同时，则我们使用： 只能取出通过setAttribute()设置的值 pageContext域中的数据使用pageScope(封装了pageContext中的所有的属性并封装为map)获取属性 ${pageScope.属性} request域中的数据使用requestScope(封装了requestScope中的所有的属性并封装为map)获取属性 ${requestScope.属性} session域中的数据使用sessionScope(封装了sessionScope中的所有的属性并封装为map)获取属性 ${sessionScope.属性} application域中的数据使用applicationScope(封装了applicationScope中的所有的属性并封装为map)获取属性 ${applicationScope.属性} 5)el表达式可以取出指定的11隐含对象中的值，自己在&lt;% %&gt;定义的不能够取出。 12345678&lt;% String s = \"jj\";%&gt;&lt;!--不能够取出--&gt; el字符串s的值为: ${s} &lt;br/&gt;&lt;!--能够取出--&gt; 字符串s的值为: &lt;%=s%&gt; &lt;br/&gt; 6)当我们的属性名取出的名称出现歧义时我们可以使用['属性']的方式取出 可以通过${pageScope['属性名']['属性']} 或者${pageScope['属性名']} 7)使用el表达式中的的pageContext获取其他隐含对象，若要获取隐含对象中的其他属性，使用 .即可 1${pageContext.request.getAttribute(\"user\")} 8)el获取其他隐含对象的值 param 保存的请求参数是 key – value (value只有一个) ${param.username} paramsValues 保存的请求参数是 key –value (value有多个) ${paramValues..username} cookie 保存cookie信息 ${cookie.键.value} 获取指定cookie键的value 9)el表达式运算 empty 判断是否为空，为空则为true,否则会false ${empty &quot;你好&quot;} 也可以在el表达式中写其他表达式的元素，三门运算符等 10)获取请求的上下文路径 ${pageContext.request.contextPath} 123456789101112131415161718192021222324252627282930313233343536&lt;%@ page import=\"org.lc.entity.User\" %&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% User user = new User(1, \"admin\", \"123456\"); String s = \"jj\";%&gt;el字符串s的值为: ${s} &lt;br/&gt;字符串s的值为: &lt;%=s%&gt; &lt;br/&gt; pageContext:&lt;%pageContext.setAttribute(\"pageContextAttr\", \"pageContextValue\");%&gt;&lt;br/&gt; user:&lt;%pageContext.setAttribute(\"user\", user);%&gt;&lt;br/&gt; request:&lt;%request.setAttribute(\"user\", \"requestValue\");%&gt;&lt;br/&gt; session:&lt;%session.setAttribute(\"user\", \"sessionValue\");%&gt;&lt;br/&gt; application:&lt;%application.setAttribute(\"user\", \"applicationValue\");%&gt;&lt;br/&gt; &lt;hr/&gt;&lt;%-- 以前获取共享数据的方式--%&gt;&lt;%-- pageContext:&lt;%=pageContext.getAttribute(\"pageContextAttr\")%&gt;&lt;br/&gt;--%&gt;&lt;%-- 现在使用el表达式--%&gt;&lt;%--通过${属性值}--%&gt; pageContext:${pageContextAttr}&lt;br/&gt;&lt;%--直接获取属性对应的对象值--%&gt; user:${user}&lt;br/&gt;&lt;%--获取对象的属性--%&gt; user:${user.password}&lt;br/&gt; user:${pageScope.user.username}&lt;br/&gt; request:${requestScope.user}&lt;br/&gt; session:${sessionScope.user}&lt;br/&gt; application:${applicationScope.user}&lt;br/&gt;${pageContext.request.getAttribute(\"user\")}${pageContext.request.contextPath}&lt;/body&gt;&lt;/html&gt; 七、CookieHTTP是无状态协议 无状态：服务器无法分辨每次请求来自谁 所以使用cookie是让浏览器去保存一份数据，以后每次访问的时候带上相应的数据。Cookie是服务器发给浏览器保存的 1、创建cookiecookie由我们的服务器发送给浏览器创建并发送给浏览器设置保存，每次请求时都会携带此cookie。 在servlet中创建cookie 12345678910protected void create(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //可创建多个cookie //创建cookie 键 - 值 Cookie cookie=new Cookie(\"username\",\"louchen\"); //把cookie发送给浏览器 response.addCookie(cookie); response.getWriter().write(\"cookie发给你了...\");} 我们请求创建cookie后，发现在响应头中有Set-Cookie信息，则为Cookie信息 我们发现保存在浏览器的Cookie中，发现其过期时间Expire/Max-Age 为session，即cookie为一次会话的时间。 即 只要不关闭当前浏览器都是当前会话。若打开其他浏览器或关闭此浏览器则cookie失效。 当我们每次进行其他任何请求时，都会携带此cookie。如下请求头： 2、获取cookie servlet获取cookie 1234567891011 protected void get(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //cookie可能有多个 Cookie[] cookies = request.getCookies(); PrintWriter writer = response.getWriter(); for (Cookie cookie : cookies) { writer.write(\"cookie键:\"+cookie.getName()+\"-值:\"+cookie.getValue()+\"&lt;br/&gt;\"); } writer.close(); }} 3、删除cookie cookie默认的生命周期为session，即当前会话(浏览器一直不关则一直有效) 修改cookie的默认存活时间 cooke.setMaxAge(0) 参数为秒 为负数时，浏览器根本不会存储此cookie。 注意：不一定有效，根据不同浏览器的规则来实现 为0时，删除此cookie &gt; 0 时, 例如：setMaxAge(3600) ,则过期时间为3600秒后 servlet实现删除 12345678910111213141516protected void delete(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { Cookie[] cookies = request.getCookies(); PrintWriter writer = response.getWriter(); Cookie cookieR=null; for (Cookie cookie : cookies) { if (cookie.getName().equals(\"username\")) { //设置过期时间为0，则删除 cookie.setMaxAge(0); cookieR=cookie; } } //响应此修改后的cookie给浏览器 response.addCookie(cookieR); writer.write(\"已删除cookie...\"); writer.close();} 我们发现响应头中的Set-Cookie的Expires已经设置为我们最大生成时间0秒 并且发现浏览器中存储的Cookie也已经删除。 4、设置cookie有效时间 servlet实现 12345678910111213141516protected void livetime(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { Cookie[] cookies = request.getCookies(); PrintWriter writer = response.getWriter(); Cookie cookieR=null; for (Cookie cookie : cookies) { if (cookie.getName().equals(\"username\")) { //设置请求的最大生命时间为3600s cookie.setMaxAge(3600); cookieR=cookie; } } //响应此修改后的cookie给浏览器 response.addCookie(cookieR); writer.write(\"已持久化cookie 3600秒...\"); writer.close();} 我们发现在请求头中的Set-Cookie过期时间Expiress已经向后延期了3600秒 5、设置cookie请求路径 默认我们的每一次请求都会携带cookie。但是我们的请求往往不是每一次都需要携带cookie,所以我们可以设置cookie的请求路径 servlet设置cookie请求路径 12345678910protected void cookiePath(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //设置cookie Cookie cookie=new Cookie(\"cookieppp\",\"lc\"); //设置cookie访问的路径 即只有携带该路径 此cookie才会被存储 // /代表服务器根路径 http://localhost:8080/ //所以我们每次访问必须以 http://localhost:8080/hello/** 开始 cookie.setPath(\"/hello\"); response.addCookie(cookie); response.getWriter().write(\"cookie路径已被修改\");} 我们设置后浏览器发送给服务器一个cookie，但是我们此时并没有访问cookie路径，所以此时cooke并不会存储。 当我们请求以服务器的路径开始请求时 即 http://localhost:8080/hello 我们的浏览器才会存储此cookie,并且携带此cookie进行请求。 但我们的服务器请求其他非cookie路径时，请求不会携带cookie,浏览器也不会存储其cookie 5、修改cookie当我们要修改cookie的value值或者cookie的生存周期，我们可以通过遍历的方式通过cookie名称拿到此cookie，这样做可以，但是很麻烦。我们可以直接通过新建一个cookie来覆盖掉之前的cookie即可。 默认cookie的value值不能为中文，若为中文，则需要将中文编码。读取时将值进行解码 编码 String value = URLEncoder.encode(&quot;张三&quot;, &quot;utf-8&quot;); %E5%BC%A0%E4%B8%89 解码 String decode = URLDecoder.decode(&quot;%E5%BC%A0%E4%B8%89&quot;, &quot;utf-8&quot;); 张三 12345678protected void updateCookie(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //默认cookie的value值不能为中文，若为中文，则需要将中文编码。读取时将值进行解码 String value = URLEncoder.encode(\"张三\", \"utf-8\"); Cookie cookie = new Cookie(\"username\", value); cookie.setMaxAge(300); response.addCookie(cookie); response.getWriter().write(\"cookie值已被修改\");} 八、Session服务器保存的技术，域对象(在整个会话期间保存的数据在任意资源都可以取到) 作用：域对象共享数据。 session就是当前会话对象，它可以共享当前会话的数据。服务器会为每个会话(重新开启浏览器，或者打开不同的浏览器)创建独立的session。只会为每个会话创建一个session,第一次获取的session是新创建的，以后获取的都是之前创建的。 当我们的请求第一次使用session时，若session没有被创建，那么服务器会创建一个session，并生成一个sessionId发送个浏览器，浏览器在cookie中保存此sessionid。每次请求时并携带此sessionId. 当我们的服务器没有session时，第一次请求服务器会为我们的浏览器再响应头中传入一个JSESSIONID保存在浏览器的cookie中.发现session的默认生命周期即为一次会话 1、创建session对象并获取session id 在servlet中实现 1234567891011protected void get(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //从请求中获取session HttpSession session = request.getSession(); //判断该session是否为新创建的 boolean sessionNew = session.isNew(); //获取session id String id = session.getId(); response.getWriter().write(\"已经获取到session对象...是否为新创建的:\"+sessionNew); response.getWriter().write(\"&lt;br/&gt;session的id为:\"+id);} 2、设置sessiond的属性并获取session的属性值 servlet中设置 1234567protected void set(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { //获取session HttpSession session = req.getSession(); //给session设置属性 session.setAttribute(\"user\", \"louchen\"); resp.getWriter().write(\"已经向session设置属性user...\");} servlet 获取 123456protected void getValue(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { HttpSession session = request.getSession(); //获取sessions属性值 String user = (String) session.getAttribute(\"user\"); response.getWriter().write(\"session中属性user的值为：\"+user);} 3、获取session的有效时间 servlet中获取 123456protected void getTime(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { HttpSession session = request.getSession(); //以秒为单位 默认有效是时间为30分钟 int maxInactiveInterval = session.getMaxInactiveInterval(); response.getWriter().write(\"session的有效时间为：\"+maxInactiveInterval);} 为啥是30分钟，我们的浏览器再次关闭时，再打开时为啥还是失效？。 因为我们的sessionid是保存在cookie中，当我们关闭浏览器时，cookie即失效。再一次请求时cookie为空，所以session失效 我们可以在tomcat的配置中\\apache-tomcat-7.0.40\\conf\\web.xml查看session的有效时间 .单位为分钟 123&lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt;&lt;/session-config&gt; 4、设置session有效时间1)在tomcat中的web.xml中配置。 或者在项目下的web.xml中配置 单位为分钟 123&lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt;&lt;/session-config&gt; 2)延期失效 单位为秒 servlet设置 123456789protected void updateTime(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { HttpSession session = request.getSession(); int i=3; //单位秒 距离最后一次使用session开始计时 //为负数时：永不过期 //为正数时：过期时间单位为秒 session.setMaxInactiveInterval(i); response.getWriter().write(\"已设置session的有效期，时间为:\"+i);} 3）立即失效 servlet设置 123456protected void invalid(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { HttpSession session = request.getSession(); //session立即失效。不会延期 session.invalidate(); response.getWriter().write(\"session已失效...\");} 5、设置session持久化将sessionid存在cookie中并设置过期时间。即使关闭浏览器也不会失效。 12345678910protected void persistence(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { HttpSession session = request.getSession(); String id = session.getId(); //把session手动存在cookie中 Cookie cookie = new Cookie(\"JSESSIONID\", id); //设置过期时间 24小时 cookie.setMaxAge(60 * 60 * 24); response.addCookie(cookie); response.getWriter().write(\"session已持久化\");} 九、禁用cookie重写url​ 我们每次请求浏览器时，当服务器没有创建session，服务器会创建session对象并向我们的浏览器发送一份sessionid存储在cookie中，若我们禁用浏览器的cookie,那么浏览器并不会存储此sessionid，导致我们在请求服务器时服务器都会创建一份新的sessionid。,即从服务器无法获取session中设置的属性值 解决方法： 在请求指定session对象中的值时在地址栏中传入sessionid即可 bancookie.jsp 12345678910111213&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% //设置session属性 session.setAttribute(\"sessionAttr\", \"sessionValue\");%&gt;&lt;a href=\"sessiontest.jsp\"&gt;去其他页面&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; sessiontest.jsp 12345678910&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;!--获取session属性值--&gt;session中的值：${sessionAttr}&lt;/body&gt;&lt;/html&gt; 请求地址:·http://localhost:8080/sessiontest.jsp;jsessionid=9C592B93BFF112050536DDD98BFD6D7B jsessionid=9C592B93BFF112050536DDD98BFD6D7B 该sessionid为在页面bancookie.jsp 页面上获取的sessionid 使用response中的encodeRedirectURL()方法优化其请求路径。自动判断，如果禁用cookie则帮我们携带上session否则不会携带 &lt;a href=&quot;&lt;%=response.encodeRedirectURL(&quot;sessiontest.jsp&quot;)%&gt;&quot;&gt;去其他页面&lt;/a&gt; 十、session的钝化和活化现象：服务器关闭重新启动，只要浏览器没关，还是能获取到session的内容 钝化：服务器关闭后，会将session(序列化)保存到硬盘中，可以在项目中查看生成SESSION.ser的文件 活化：服务器再次启动时，把之前序列化好的文件加载进来。就会再次加载之前保存的SESSION.ser文件包含了session域中的内容 session域中的对象要能同session一起钝化到磁盘中必须实现serializable接口 十一、Filter 过滤器Filter是用来执行过滤任务的一个接口对象，作用于： 请求一个资源(动态资源Servlet,JSP,静态资源) 来自一个资源的响应 两个都可以。既可以过滤请求，也可以过滤响应 Filter过滤请求和响应： filter可以拦截请求(request),可以修改请求头，请求内容等 filter可以拦截来自服务端的响应(response),可以修改响应头和响应内容 放行请求 1、过滤器执行流程实现Filter接口： 只有请求地址为 http://localhost:8080/filtertest.jsp的 请求才能被该过滤器所过滤 请求参数携带 key 的才能被放行执行 123456789101112131415161718192021222324252627282930313233//实现Filter接口public class RoomFilter implements Filter {// 销毁的方法 @Override public void destroy() { }// 执行过滤的具体方法 @Override public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException { System.out.println(\"进入过滤器...\"); String key = req.getParameter(\"key\"); if (key == null || key.equals(\"\")) { //说明没拿到key 不放行 拦截所有页面内容。只会输出响应的值 resp.getWriter().write(\"stop in....\"); }else{ System.out.println(\"放行之前...\"); //放行该请求 chain.doFilter(req, resp); //继续执行后面代码 System.out.println(\"放行之后...\"); //我是经过过滤器的响应 响应对象做修改操作 resp.getWriter().write(\"我是给页面的响应...\"); } }// 初始化方法 @Override public void init(FilterConfig config) throws ServletException { }} 配置Filer请求路径 和servlet配置类似 &lt;url-pattern&gt;/*&lt;/url-pattern&gt; 过滤所有请求 1234567891011121314&lt;!-- 配置filter路径--&gt;&lt;filter&gt; &lt;!-- 配置filer名称--&gt; &lt;filter-name&gt;RoomFilter&lt;/filter-name&gt; &lt;!-- filer具体类路径--&gt; &lt;filter-class&gt;org.lc.controller.RoomFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;!-- 配置该filter过滤的路径--&gt;&lt;filter-mapping&gt; &lt;!-- 指定哪个filter--&gt; &lt;filter-name&gt;RoomFilter&lt;/filter-name&gt; &lt;!-- 过滤的路径 只要是以 '项目路径/filtertest.jsp' 的请求即被过滤 --&gt; &lt;url-pattern&gt;/filtertest.jsp&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 2、过滤器生命周期12345678910111213141516//实现Filter接口public class RoomFilter implements Filter {// 销毁的方法 @Override public void destroy() { }// 执行过滤的具体方法 @Override public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException {// 初始化方法 @Override public void init(FilterConfig config) throws ServletException { }} 1)初始化 服务器启动的时候即初始化。创建filter对象调用init()方法 。该过滤器为单例多线程，即只创建一个单例对象 2)每次拦截请求都执行 doFilter()方法 3)服务器停止执行destroy()方法销毁过滤器 3、过滤器拦截路径规则1)精确匹配 写要拦截的资源的详细资源路径 只拦截某一个具体的指定资源。 / 代表 项目路径(若配置项目名)：http://localhost:8080/项目名/ &lt;url-pattern&gt;/filtertest.jsp&lt;/url-pattern&gt; 只拦截 /filtertest.jsp 的请求路径 &lt;url-pattern&gt;/page/filtertest.jsp&lt;/url-pattern&gt; 只拦截 项目page文件夹下的 /page/filtertest.jsp 2)路径匹配 要拦截的请求路径，或者资源路径 &lt;url-pattern&gt;/page/*&lt;/url-pattern&gt; 拦截page开头的所有请求，或者拦截page下的所有资源 &lt;url-pattern&gt;/*&lt;/url-pattern&gt; 拦截所有请求和所有资源 3)后缀匹 *.后缀名 &lt;url-pattern&gt;*.jsp&lt;/url-pattern&gt; 拦截所有请求以 .jsp 结尾的资源 若要实现拦截 page文件下的所有以 *.jsp结尾的资源 &lt;filter-mapping&gt; &lt;filter-name&gt;PatternFilter&lt;/filter-name&gt; &lt;!--先拦截page下的所有请求--&gt; &lt;url-pattern&gt;/page/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; 123456789101112131415161718192021222324252627 通过请求拿到对应的请求路径，然后判断请求是否以指定规则结尾的，是则拦截，否则放行 `HttpServletRequest request= (HttpServletRequest) req;` 将`ServletRequest`请求强制转为`HttpServletRequest `请求 `request.getRequestURI();` 获取请求的URI 不包含项目路径 `request.getRequestURL();` 获取请求的URL 包含项目路径- ```java @Override public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException { System.out.println(&quot;执行doFilter...&quot;); HttpServletRequest request= (HttpServletRequest) req; // /page/index.jsp String requestURI = request.getRequestURI(); // http://localhost:8080/page/success.jsp StringBuffer requestURL = request.getRequestURL(); System.out.println(requestURI); System.out.println(requestURL); if (requestURL.toString().endsWith(&quot;.jsp&quot;)) { //拦截 以 .jsp结尾的 }else{ //放行其他的 chain.doFilter(req, resp); } } 错误写法: &lt;url-pattern&gt;/page/*.jsp&lt;/url-pattern&gt; ××× 4)一次过滤多个拦截规则1234567&lt;filter-mapping&gt; &lt;filter-name&gt;LoginFilter&lt;/filter-name&gt; &lt;!--拦截/shop2开头的所有请求--&gt; &lt;url-pattern&gt;/shop2/*&lt;/url-pattern&gt; &lt;!--拦截/page开头的所有请求--&gt; &lt;url-pattern&gt;/page/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 5)拦截指定servlet的所有请求12345&lt;filter-mapping&gt; &lt;filter-name&gt;PatternFilter&lt;/filter-name&gt; &lt;!--servlet的名称--&gt; &lt;servlet-name&gt;UserServlet&lt;/servlet-name&gt;&lt;/filter-mapping&gt; 4、filter响应中文乱码问题12345678910@Overridepublic void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException { //我们在执行放行方法之前若写入响应数据，则会造成乱码。因为resp中的响应头字符编码的头为空，所以需要手动设置字符编码 resp.setContentType(\"text/html;charest=utf-8\"); resp.getWriter().write(\"执行过滤器doFilter之前\"); chain.doFilter(req, resp); //而执行doFilter方法后，响应头的中的字符编码jsp已经为我们设置，所以后续执行不乱码 resp.getWriter().write(\"我是给页面的响应...\"); } 上述response封装完后，从上到下依次渲染数据，在doFilter之前的渲染数据若没有配置字符编码则会乱码，在doFilter之后的数据不会乱码，因为在doFilter中已经对字符完成编码 5、各种ServletConfig,ServletContext,FilterConfig初始化参数1)ServletConfig在该servlet创建的时候调用init()方法 一个servlet对应一个 ServletConfig 存放该servlet的配置信息 web.xml配置 1234567891011&lt;servlet&gt; &lt;servlet-name&gt;UserServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.lc.controller.UserServlet&lt;/servlet-class&gt; &lt;!--配置初始化参数--&gt; &lt;init-param&gt; &lt;!--参数名--&gt; &lt;param-name&gt;user&lt;/param-name&gt; &lt;!--参数值--&gt; &lt;param-value&gt;lc&lt;/param-value&gt; &lt;/init-param&gt;&lt;/servlet&gt; 1234567@Overridepublic void init(ServletConfig config) throws ServletException { //获取初始化参数 String user = config.getInitParameter(\"user\"); //lc System.out.println(user);} 2)ServletContext和FilterConfig服务器启动时即初始filter调用init()方法 ServletContext对应整个web应用 通过FilterConfig 或者ServletConfig 获得 ServletContext 一个filter对应一个FilterConfig ，存放该filer的配置信息 1234567891011121314151617&lt;!-- application初始化参数--&gt; &lt;context-param&gt; &lt;param-name&gt;user&lt;/param-name&gt; &lt;param-value&gt;applicationValue&lt;/param-value&gt; &lt;/context-param&gt; &lt;filter&gt; &lt;!-- 配置filer名称--&gt; &lt;filter-name&gt;RoomFilter&lt;/filter-name&gt; &lt;!-- filer具体类路径--&gt; &lt;filter-class&gt;org.lc.controller.RoomFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;!--filter初始化参数--&gt; &lt;param-name&gt;user&lt;/param-name&gt; &lt;param-value&gt;filterValue&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; 123456789101112131415161718// 初始化方法 @Override public void init(FilterConfig config) throws ServletException { //获取当前application参数 (代表整个web服务器) ServletContext servletContext = config.getServletContext(); //获取application初始化参数 String user = servletContext.getInitParameter(\"user\"); //applicationValue System.out.println(user); //获取过滤器初始化参数 String user1 = config.getInitParameter(\"user\"); //filterValue System.out.println(user1); String filterName = config.getFilterName(); //该filter的别名 System.out.println(filterName); } 6、过滤器链若多个过滤器过滤相同的请求，则会从web.xml中从上到下依次加载过滤器，优先执行先加载的过滤器 过滤器AFilter和BFilter依次过滤 a.jsp的页面请求 123456789101112131415 &lt;filter-name&gt;AFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.lc.controller.AFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;AFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/a.jsp&lt;/url-pattern&gt;&lt;/filter-mapping&gt;&lt;filter&gt; &lt;filter-name&gt;BFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.lc.controller.BFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;BFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/a.jsp&lt;/url-pattern&gt;&lt;/filter-mapping&gt; AFilter 1234567@Overridepublic void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException { System.out.println(\"顺序 1\"); //执行doFilter后，若还有相同请求的过滤器未执行则继续执行其他过滤器 chain.doFilter(req, resp); System.out.println(\"顺序 2\");} BFilter 123456@Overridepublic void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException { System.out.println(\"顺序 3\"); chain.doFilter(req, resp); System.out.println(\"顺序 4\");} a.jsp 123456789101112&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;% System.out.println(\"顺序 a.jsp\");%&gt; &lt;h1&gt;我是a.jsp页面&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 依次打印： 12345顺序 1顺序 3顺序 a.jsp顺序 4顺序 2 由上可以过滤器相当于在doFilter中执行递归调用。 7、dispatcher告诉服务器都拦截哪些方式到达的资源 FORWARD : 拦截转发过来的，转发到这个地址，会被拦截 INCLUDE：拦截包含的，包含这个地址的会被拦截，拦截动态包含 REQUEST(默认的)：直接请求的，直接请求这个地址会被拦截，post,get请求 ERROR：发送错误，去全局配置一个错误页面会被拦截。不是errorPage指向的页面。指的是全年局的配置 1234567&lt;filter-mapping&gt; &lt;filter-name&gt;BFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/a.jsp&lt;/url-pattern&gt; &lt;!--FORWARD,INCLUDE, REQUEST, ERROR--&gt; &lt;dispatcher&gt;REQUEST&lt;/dispatcher&gt; &lt;dispatcher&gt;FORWARD&lt;/dispatcher&gt;&lt;/filter-mapping&gt; 十二、JDBC使用步骤1、加载驱动 1Class.forName(\"com.mysql.jdbc.Driver\"); 2、获得连接 1Connection con=DriverManager.getConnection(\"jdbc:mysql://localhost:3306/test\",\"root\",\"123456\") 3、创建运行对象 4、运行sql 5、处理运行结果 6、释放资源 十三、AJAX1、简介AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。 AJAX 不是新的编程语言，而是一种使用现有标准的新方法。 AJAX 是与服务器交换数据并更新部分网页的艺术，在不重新加载整个页面的情况下。 2、js发送ajax请求 onreadystatechange 事件 获取响应过程状态信息 当请求被发送到服务器时，我们需要执行一些基于响应的任务。 每当 readyState 改变时，就会触发 onreadystatechange 事件。 readyState 属性存有 XMLHttpRequest 的状态信息。 下面是 XMLHttpRequest 对象的三个重要的属性： 属性 描述 onreadystatechange 存储函数（或函数名），每当 readyState 属性改变时，就会调用该函数。 readyState 存有 XMLHttpRequest 的状态。从 0 到 4 发生变化。0: 请求未初始化 1: 服务器连接已建立 2: 请求已接收 3: 请求处理中 4: 请求已完成，且响应已就绪 status 200: “OK”404: 未找到页面 123456789101112131415161718192021222324252627282930313233343536373839&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%--通过ajax请求--%&gt;&lt;script&gt; function btnAjax() { //1、创建xhr对象，用这个对象来向服务器发送请求 let xhr = new XMLHttpRequest(); //2、定义请求发送格式 //请求类型; 请求地址; 是否异步(默认true) //请求地址可以携带参数 xhr.open(\"GET\", \"ajax?username=zs&amp;pw=123456\", true); //3、发送请求 //若请求有请求体，则将请求体的数据发送(仅用于 POST 请求) // xhr.send(body); xhr.send(); //4、获取响应的数据 //xhr中的属性 //responseText获得字符串形式的响应数据。 //responseXML 获得XML形式的响应数据。 //当请求的处理状态为4 并且 status状态为200时 代表响应处理完成。 xhr.onreadystatechange = function () { if (!(xhr.readyState == 4 &amp;&amp; xhr.status == 200)) { let v = document.getElementById(\"text\"); v.innerText = xhr.responseText; } } }&lt;/script&gt;&lt;button onclick=\"btnAjax()\"&gt;发送请求&lt;/button&gt;&lt;div id=\"text\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 3、解决ajax请求缓存问题 (验证码)生成一个随机值携带参数一同发送给服务器 1$.get('ajax?username=lc&amp;pw=123'+Math.random(),function (data) { },\"text\"); 4、jquery发送$.post()/$.get()请求 $.get(URL,data,function(data,status,xhr),dataType) 发送get请求，在url中携带的参数和在data中传入的参数 都会被放到url地址栏中传输 $.post(URL,data,function(data,status,xhr),dataType) 发送post请求，在utl中携带的参数还是在url地址上，在data中的参数会被放在请求体中。 参数 描述 URL 必需。规定您需要请求的 URL。 data 可选。规定连同请求发送到服务器的数据。带key-value的参数 function(data,status,xhr) 可选。规定当请求成功时运行的函数。额外的参数：data - 包含来自请求的结果数据status(可选) - 包含请求的状态（”success”、”notmodified”、”error”、”timeout”、”parsererror”）xhr(可选) - 包含 XMLHttpRequest 对象 dataType 可选。规定预期的服务器响应的数据类型。“xml” - 一个 XML 文档html” - HTML 作为纯文本“text” - 纯文本字符串“script” - 以 JavaScript 运行响应，并以纯文本返回“json” - 以 JSON 运行响应，并以 JavaScript 对象返回“jsonp” - 使用 JSONP 加载一个 JSON 块，将添加一个 “?callback=?” 到 URL 来规定回调 1)发送get请求12345678910111213141516171819&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script src=\"/webjars/jquery/3.3.1-2/jquery.min.js\"&gt;&lt;/script&gt;&lt;script&gt; function jqueryAjax() { $.get('ajax?user=zs&amp;pw=123&amp;r='+Math.random(),{\"id\":1111,username:\"lc\",password:123456},function (data) { let parse = JSON.parse(data); $(\"#text\").text(parse.username+parse.id); },'text'); }&lt;/script&gt;&lt;button onclick=\"jqueryAjax()\"&gt;jquery发送get请求&lt;/button&gt;&lt;div id=\"text\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; servlet为例 1234567891011121314151617181920@Overrideprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { System.out.println(\"收到请求了\"); request.setCharacterEncoding(\"utf-8\"); String user1 = request.getParameter(\"user\"); String id = request.getParameter(\"id\"); String username = request.getParameter(\"username\"); String password = request.getParameter(\"password\"); System.out.println(\"url中的参数：\"+user1); System.out.println(\"data中的参数：\"+id); System.out.println(\"data中的参数：\"+username); System.out.println(\"data中的参数：\"+password); response.setContentType(\"text/html;charset=utf-8\"); User user = new User(1001, \"张三\", \"123456\"); Gson gson=new Gson(); //将javabean转为字符串 方便在请求中传输 String s = gson.toJson(user); response.getWriter().write(s);} 我们可以发现get请求在url中的参数和在data中的参数都被放在在url地址栏中，后台也能获取到全部数据 2)发送post请求12345678910111213141516171819&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script src=\"/webjars/jquery/3.3.1-2/jquery.min.js\"&gt;&lt;/script&gt;&lt;script&gt; function jqueryPost() { $.post('ajax?user=zs&amp;pw=123&amp;r='+Math.random(),{\"id\":1111,username:\"lc\",password:123456},function (data) { let parse = JSON.parse(data); $(\"#text\").text(parse.username+parse.id); },'text'); }&lt;/script&gt;&lt;button onclick=\"jqueryPost()\"&gt;jquery发送post请求&lt;/button&gt;&lt;div id=\"text\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 后端就是 上面的get请求的后端 我们可以发现发送post请求，地址栏中的参数还是在地址栏中，但是data中的数据会方法在请求体中，不会方在url中，这意味着我们的post请求可以发送大量数据。 5、$.ajax()更灵活的其他方式12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script src=\"/webjars/jquery/3.3.1-2/jquery.min.js\"&gt;&lt;/script&gt;&lt;script&gt; function jqueryOther() { $.ajax({ //1、请求地址 url:'ajax?user=zs&amp;pw=123&amp;r='+Math.random(), //2、请求类型 //请求类型(默认为get) post,get,delete,put //注意get没有请求体只能在url中传输参数，其他类型有请求体，参数可以在请求体中 type:'get', //3、请求参数。 //注意请求参数必须为js对象形式，不能为字符串 //例如：错误写法\"{\"id\":\"19321\",\"username\":\"louc\",\"password\":\"123456\"}\" 这样服务端会获取不到值 //允许的形式 data:'id=19321&amp;username=louc&amp;password=123456' 可以为参数形式 data:{\"id\":\"19321\",\"username\":\"louc\",\"password\":\"123456\"}, // data:'id=19321&amp;username=louc&amp;password=123456', //4、是否异步 默认为异步 async:true, //5、成功的回调 success: function (data) { //一般data类型为字符串 let p = JSON.parse(data); $(\"#text\").text(p.username+\"\"+p.id) }, //6、失败的回调 404 403等 error(data) { //打印错误信息 alert(\"错误\"+data) } }) }&lt;/script&gt;&lt;button onclick=\"jqueryOther()\"&gt;jquery发送其他格式请求&lt;/button&gt;&lt;div id=\"text\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 6、表单序列化12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;script src=\"/webjars/jquery/3.3.1-2/jquery.min.js\"&gt;&lt;/script&gt;&lt;script&gt; function subForm() { //传统获取表单属性值 // let id=$(\"input[name='id']\").val(); // let username=$(\"input[name='username']\").val(); // let password=$(\"input[name='password']\").val(); // alert(id+username+password) //序列化表单后，得到的字符串为 'id=19321&amp;username=louc&amp;password=123456' 形式 let formdata = $(\"#form1\").serialize(); alert(formdata)+ $.ajax({ url:\"ajax?user=zs&amp;pw=123&amp;r='+Math.random()\", data:formdata, async:true, type:'post', success: function (data) { //一般data类型为字符串 let p = JSON.parse(data); $(\"#text\").text(p.username+p.id) }, error(data) { alert(data) } }) }&lt;/script&gt;&lt;form action=\"#\" id=\"form1\"&gt; id &lt;input type=\"text\" name=\"id\"&gt;&lt;br&gt; 用户名 &lt;input type=\"text\" name=\"username\"&gt;&lt;br&gt; 密码&lt;input type=\"text\" name=\"password\"&gt;&lt;br&gt; &lt;button onclick=\"subForm()\"&gt;提交&lt;/button&gt;&lt;/form&gt;&lt;div id=\"text\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 十四、JSONJSON就是表示对象的方法，格式就是按照js声明对象的格式来. json的编写必须要符合js规范。 在js中：属性加和不加双引号都可以。值为必须为js符合的类型 在java中：json字符串必须符合json规范，所有属性必须加双引号。 转换为：JSON格式要求 key(属性) 必须有双引号 value ： 基本类型或者引用类型(对象) 123456789101112131415 //js对象写法 (也可以直接转为字符串，自动为属性加上引号 ) // let json={name:\"张三\", age: 22}; //json写法 属性必须加字符串 let json={\"name\":\"张三\", \"age\": 22}; //将json对象转为字符串 let str = JSON.stringify(json); //{\"name\":\"张三\", \"age\": 22} alert(str) //将字符串转为json对象/js对象 let jsonstr = JSON.parse(str);//获取js对象属性值 //张三 alert(jsonstr.name) 1、Gson的使用12345&lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;2.8.6&lt;/version&gt;&lt;/dependency&gt; 1)javabean和字符串的转换1234567891011 Gson gson=new Gson(); String str=\"{id:1002,username:'zs','password':123456}\"; //字符串转javabean User user = gson.fromJson(str, User.class);//User(id=1002, username=zs, password=123456) System.out.println(user); //javabean转字符串 String s = gson.toJson(user);//{\"id\":1002,\"username\":\"zs\",\"password\":\"123456\"} System.out.println(s); 2)List集合和字符串的转换12345678910111213141516Gson gson=new Gson();List&lt;User&gt; list=new ArrayList&lt;&gt;();list.add(new User(1001,\"zs\",\"123456\"));list.add(new User(1001,\"ls\",\"1234\"));list.add(new User(1001,\"ww\",\"12356\"));//集合转字符串String s = gson.toJson(list);//[{\"id\":1001,\"username\":\"zs\",\"password\":\"123456\"},{\"id\":1001,\"username\":\"ls\",\"password\":\"1234\"},{\"id\":1001,\"username\":\"ww\",\"password\":\"12356\"}]System.out.println(s);//字符串转集合List&lt;User&gt; list1 = gson.fromJson(s, new TypeToken&lt;List&lt;User&gt;&gt;() {}.getType());//[User(id=1001, username=zs, password=123456), User(id=1001, username=ls, password=1234), User(id=1001, username=ww, password=12356)]System.out.println(list1); 3)Map集合和字符串的转换1234567891011121314151617Gson gson=new Gson();HashMap&lt;String,User&gt; hashMap=new HashMap&lt;&gt;();User user1 = new User(1001, \"zs\", \"123456\");User user2 = new User(1001, \"zs\", \"123456\");hashMap.put(\"level1\", user1);hashMap.put(\"level2\", user2);//map集合转为字符串String s = gson.toJson(hashMap);//{\"level1\":{\"id\":1001,\"username\":\"zs\",\"password\":\"123456\"},\"level2\":{\"id\":1001,\"username\":\"zs\",\"password\":\"123456\"}}System.out.println(s);//字符串转为集合HashMap&lt;String,User&gt; o = gson.fromJson(s, new TypeToken&lt;HashMap&lt;String, User&gt;&gt;() {}.getType());//{level1=User(id=1001, username=zs, password=123456), level2=User(id=1001, username=zs, password=123456)}System.out.println(o); 十五、监听器​ 监听器，字面上的理解就是监听观察某个事件（程序）的发生情况，当被监听的事件真的发生了的时候，事件发生者（事件源） 就会给注册该事件的监听者（监听器）发送消息，告诉监听者某些信息，同时监听者也可以获得一份事件对象，根据这个对象可以获得相关属性和执行相关操作。 1、声明周期监听器。监听三个对象的生命周期(创建到消耗)1)监听请求 ServletRequestListener来一个请求就会执行一次初始化和销毁方法 1234567891011121314151617181920212223public class RequestLifeListener implements ServletRequestListener { /** * 请求来的时候 调用requestInitialized初始化方法 * @param sre */ @Override public void requestInitialized(ServletRequestEvent sre) { System.out.println(\"请求创建...\"); //获取application对象 代表整个web应用 ServletContext servletContext = sre.getServletContext(); //获取当前请求对象 ServletRequest servletRequest = sre.getServletRequest(); } /** * 请求结束，完成响应 调用requestDestroyed销毁方法 * @param sre */ @Override public void requestDestroyed(ServletRequestEvent sre) { System.out.println(\"请求销毁\"); }} web.xml配置该监听器： 123&lt;listener&gt; &lt;listener-class&gt;org.lc.listener.RequestLifeListener&lt;/listener-class&gt;&lt;/listener&gt; 2)监听整个web应用 ServletContextListener项目启动时调用一次初始化方法 。项目停止时调用销毁方法 123456789101112131415161718192021public class ApplicationLifeListener implements ServletContextListener { /** * 项目启动时调用此初始化方法 * @param servletContextEvent */ @Override public void contextInitialized(ServletContextEvent servletContextEvent) { System.out.println(\"ApplicationLifeListener 初始化\"); //获取当前web对象 ServletContext servletContext = servletContextEvent.getServletContext(); } /** * 项目停止时调用此销毁方法 * @param servletContextEvent */ @Override public void contextDestroyed(ServletContextEvent servletContextEvent) { System.out.println(\"ApplicationLifeListener销毁方法...\"); }} 123&lt;listener&gt; &lt;listener-class&gt;org.lc.listener.ApplicationLifeListener&lt;/listener-class&gt;&lt;/listener&gt; 3)监听会话 HttpSessionListener第一次使用session才会创建，session 失效(强制实现，超时)则调用相应的销毁方法 123456789101112131415161718192021public class SessionLifeListener implements HttpSessionListener { /** *第一次使用session的时候 初始化sessionCreated * @param httpSessionEvent */ @Override public void sessionCreated(HttpSessionEvent httpSessionEvent) { System.out.println(\"SessionLifeListener创建...\"); //获取当前session对象 HttpSession session = httpSessionEvent.getSession(); } /** * session失效的时候调用此 sessionDestroyed方法 * @param httpSessionEvent */ @Override public void sessionDestroyed(HttpSessionEvent httpSessionEvent) { System.out.println(\"SessionLifeListener销毁...\"); }} 2、属性监听器。监听三个对象中的属性1)监听请求属性 ServletRequestAttributeListener 当请求中的属性增加时调用attributeAdded方法 当请求中的属性修改时调用attributeReplaced方法 当请求中的属性移除时调用attributeRemoved方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public class RequestAttrListener implements ServletRequestAttributeListener { /** * 属性增加 * @param servletRequestAttributeEvent */ @Override public void attributeAdded(ServletRequestAttributeEvent servletRequestAttributeEvent) { System.out.println(\"添加属性...\"); //获取增加的属性key String name = servletRequestAttributeEvent.getName(); //获取增加的属性值 Object value = servletRequestAttributeEvent.getValue(); System.out.println(\"增加的属性 key:\"+name+\" value:\"+value); } /** * 属性移除 * @param servletRequestAttributeEvent */ @Override public void attributeRemoved(ServletRequestAttributeEvent servletRequestAttributeEvent) { System.out.println(\"删除属性...\"); //获取删除的属性key String name = servletRequestAttributeEvent.getName(); //获取删除的属性值 Object value = servletRequestAttributeEvent.getValue(); System.out.println(\"删除的属性 key:\"+name+\" value:\"+value); } /** * 属性修改 * @param servletRequestAttributeEvent */ @Override public void attributeReplaced(ServletRequestAttributeEvent servletRequestAttributeEvent) { System.out.println(\"修改属性...\"); //获取修改之前的属性key String name = servletRequestAttributeEvent.getName(); //获取修改之前的属性值 Object value = servletRequestAttributeEvent.getValue(); //获取请求对象 ServletRequest servletRequest = servletRequestAttributeEvent.getServletRequest(); //获取修改之后的属性值 Object parameter =servletRequest.getAttribute(name); System.out.println(\"修改之前的属性 key:\"+name+\" value:\"+value); System.out.println(\"修改之后的属性 key:\"+name+\" value:\"+parameter); }} 123&lt;listener&gt; &lt;listener-class&gt;org.lc.listener.RequestAttrListener&lt;/listener-class&gt;&lt;/listener&gt; 2)监听session属性 HttpSessionAttributeListener和监听请求的用法一致。 12345678910111213141516public class SessionAttrListener implements HttpSessionAttributeListener { @Override public void attributeAdded(HttpSessionBindingEvent httpSessionBindingEvent) { } @Override public void attributeRemoved(HttpSessionBindingEvent httpSessionBindingEvent) { } @Override public void attributeReplaced(HttpSessionBindingEvent httpSessionBindingEvent) { }} 3)监听web应用属性 ServletContextAttributeListener和监听请求的用法一致。 1234567891011121314151617public class ServletContextAttrListener implements ServletContextAttributeListener { @Override public void attributeAdded(ServletContextAttributeEvent servletContextAttributeEvent) { } @Override public void attributeRemoved(ServletContextAttributeEvent servletContextAttributeEvent) { } @Override public void attributeReplaced(ServletContextAttributeEvent servletContextAttributeEvent) { }} 3、sessions固有监听器1) 监听sessions活化钝化 HttpSessionActivationListener12345678910111213public class SessionActivationListener implements HttpSessionActivationListener { @Override public void sessionWillPassivate(HttpSessionEvent httpSessionEvent) { } @Override public void sessionDidActivate(HttpSessionEvent httpSessionEvent) { }} 2)监听一个对象是否绑定到session中(保存在session中) HttpSessionBindingListener123456789101112public class SessionBindingListener implements HttpSessionBindingListener { @Override public void valueBound(HttpSessionBindingEvent httpSessionBindingEvent) { } @Override public void valueUnbound(HttpSessionBindingEvent httpSessionBindingEvent) { }} 十六、文件上传与下载文件上传的必要条件： 指定input的类型type为file &lt;input type=&quot;file&quot; name=&quot;img&quot;&gt; 指定表单编码类型enctype为multipart/form-data多部分上传 默认为编码类型为application/x-www-form-urlencoded 表单提交请求类型必须为POST 12345&lt;form action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\"&gt; 用户名 &lt;input type=\"text\" name=\"username\"/&gt;&lt;br&gt; 头像：&lt;input type=\"file\" name=\"img\"&gt; &lt;input type=\"submit\" value=\"上传\"&gt;&lt;/form&gt; 我们发现请求类型为多部分表单数据类型。并且各部分之间的分隔符对应的为 boundary后的内容。每个input项代表一个部分，部分直接由浏览生成一个分隔符分割。 后端将请求流转换为字符串形式的数据。 我们可以发现请求中所有的数据被包含在流中，无法通过getParamter()获取参数 123456789------WebKitFormBoundaryveRHUB7FOGYYBQ3y //分隔符Content-Disposition: form-data; name=\"username\" //每个部分的类型和详细信息//空行后对应的为 每个部分的值admin ------WebKitFormBoundaryveRHUB7FOGYYBQ3yContent-Disposition: form-data; name=\"img\"; filename=\"1.jpg\"Content-Type: image/jpeg//文件流的数据??? \u0010JFIF \u0001\u0001 \u0001 \u0001 ?? C\u0005\u0006\u0007\u0006\u0007\u0006 \u0013 \u0018\u0011\u0012\u000e\u0013\u001c\u0018\u001d\u001d\u001b\u0018\u001b\u001a\u001f#,%\u001f!*!\u001a\u001b&amp;4'*./121\u001e%6:60:,010?? C 1、流和文件操作工具类commons-io 处理IOcommons-fileupload处理文件12345678910&lt;dependency&gt; &lt;groupId&gt;org.apache.commons&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;1.3.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.4&lt;/version&gt;&lt;/dependency&gt; 2、文件上传12345678910111213&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\"&gt; 用户名 &lt;input type=\"text\" name=\"username\"/&gt;&lt;br&gt; 头像：&lt;input type=\"file\" name=\"img\"&gt; &lt;input type=\"submit\" value=\"上传\"&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768@Overrideprotected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //不能通过 request.getParameter(\"username\")获取参数，因为请求已经被作为流传输分成一段一段的数据部分(表单的所有项,部件) //获取请求流对象 //ServletInputStream inputStream = request.getInputStream(); //1、创建工厂实例 DiskFileItemFactory factory = new DiskFileItemFactory(); //2、创建处理文件上传的servlet对象 ServletFileUpload fileUpload = new ServletFileUpload(factory); //3、解析文件上传请求 try { //4、使用该servlet将请求解析为 多个数据部件对象。即每一项代表一个数据项。 List&lt;FileItem&gt; fileItems = fileUpload.parseRequest(request); //遍历该数据部件 fileItems.forEach((fileItem)-&gt;{ //如果该项为 input标签中普通的 kye-value参数形式的部件 if (fileItem.isFormField()) { //获取表单项的name值 String username = fileItem.getFieldName(); try { //获取表单项的value值 并指定编码 String value = fileItem.getString(\"utf-8\"); } catch (UnsupportedEncodingException e) { e.printStackTrace(); } //获取表单项的文件名称 (为null) 普通input只有key-value String filename = fileItem.getName(); }else{ //否则为 文件对象 //获取input 标签name值 String fieldName = fileItem.getFieldName(); //获取文件名 String filename = fileItem.getName(); System.out.println(\"文件name值:\"+fieldName); System.out.println(\"文件名:\"+filename); try { //得到该文件的 数据流部分 InputStream inputStream = fileItem.getInputStream(); //生成随机文件名 String s = UUID.randomUUID().toString().replaceAll(\"-\", \"\"); String newfileName=s+\"_\"+filename; //获取相对路径 //设置存放指定文件夹的绝对路径： String realPath = request.getServletContext().getRealPath(\"/uploads\"); //F:\\桌面内容\\springboot2\\Spring+SpringMVC\\servlet01\\target\\servlet01\\uploads System.out.println(realPath); //创建输出流并指定文件路径 // / 代表tomcat安装的盘符 即 D: // . 代表tomcat安装目录下的 bin文件夹下 FileOutputStream fileOutputStream = new FileOutputStream(realPath+\"/\"+newfileName); //将输入流写到输出流中 IOUtils.copy(inputStream, fileOutputStream); //关流 fileOutputStream.close(); inputStream.close(); } catch (IOException e) { e.printStackTrace(); } } }); } catch (FileUploadException e) { e.printStackTrace(); } response.sendRedirect(\"/fileupload.jsp\");} 直接在服务器访问地址：http://localhost:8080/uploads/70f974b4c5544bae8ec3c55eea4c891a_1.jpg 3、获取指定文件或指定文件夹的绝对路径12String realPath = request.getServletContext().getRealPath(\"/uploads\");//F:\\桌面内容\\springboot2\\Spring+SpringMVC\\servlet01\\target\\servlet01\\uploads 4、文件下载123456789&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;a href=\"download\"&gt;下载图片&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839 @Override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //本质就是告诉浏览器我给你资源别直接打开 给我下载 //把要下载的资源传给浏览器 ServletContext servletContext = request.getServletContext(); //获取该图片的绝对路径 String realPath = servletContext.getRealPath(\"/uploads/哈哈.jpg\"); //动态获取文件类型 String mimeType = servletContext.getMimeType(realPath); //image/jpeg System.out.println(\"文件类型\"+mimeType); //设置响应头类型（这里我们是图片类型） response.setContentType(mimeType); // 若文件名为中文 则会无法识别 (万能解决方案) String s = new String(\"哈哈\".getBytes(\"gbk\"), \"iso8859-1\"); //设置浏览器处理的方式 即以附件形式打开 // Content-Disposition 处置方式 // attachment 附件 // filename=文件名 response.setHeader(\"Content-Disposition\",\"attachment;filename=\"+s); //设置文件大小(可选) 一般不设置// response.setContentLength(); //得到输入流 FileInputStream fileInputStream = new FileInputStream(realPath); ServletOutputStream outputStream = response.getOutputStream(); //将输入流拷贝到响应输出流 IOUtils.copy(fileInputStream, outputStream); //关流 outputStream.close(); fileInputStream.close(); } 点击下载，发现此时并没有打开，而是直接以附件形式打开 我们查看响应头 十七、javaweb项目部署tomcat1、一般我们通过maven打成war包部署 2、生成的war包在指定的项目的target目录下 3、将项目的war包 servlet01.war直接复制到tomcat安装目录下的webapp目录下 4、进入tomcat安装目录下的bin目录下执行startup.bat 批处理指令 5、执行后会把webapp下的servlet01.war的war包自动解压生成项目文件夹 6、控制台启动成功，输入浏览器访问 注意：这里访问必须携带项目文件夹名称，所有在项目中有路径访问时，必须要动态获取项目文件，否则会找不到。 http://localhost:8080/servlet01/downloadimg.jsp 十八、创建自定义服务我们每次手动执行启动startup.bat文件时不免麻烦。我们可以为此该批处理命令创建一个服务 1、以管理员身份打开cmd窗口 2、进入tomcat下的bin目录 3、使用service bat install 服务名 创建服务(Tomcat7.0) 4、启动服务 这里我们需要进入到任务管理器中才能查看到服务 5、删除服务 sc delete 服务名","link":"/2020/07/24/ssm/Servlet+JavaWeb/"},{"title":"深入理解Spring","text":"​ SpringFramewrok架构图 一、IOC和DIhttps://www.iteye.com/blog/jinnianshilongnian-1413846 1、IOC基本概念： IOC—Inversion of Control 即“控制反转”，不是什么技术，而是一种设计思想。 在传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IOC是有专门一个容器来创建这些对象，即由IOC容器来控制对象的创建而不再显式地使用new； 主动式(什么资源都自己创建)： 1234567public class UserService{ //我们在service想要使用dao中的对象，需要手动创建 UserDao userDao=new UserDao(); public User getUser(){ return userService.selectUser(); }} 即 UserService依赖于 UserDao 被动式(由我们容器创建)： 1234567public class UserService{ //我们只需要声明要使用的对象即可，IOC容器会帮我们创建和管理 UserDao userDao; public User getUser(){ return userService.selectUser(); }} 即 UserService依赖于 UserDao 谁控制谁，控制什么： 传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对象的创建；谁控制谁？当然是IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。 为何是反转，哪些方面反转了： 有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。 2、DI基本概念： DI—Dependency Injection，即“依赖注入”：即是IOC的实现方式。是组件之间依赖关系由容器在运行期决定，形象的说，即由容器动态的将某个依赖关系注入到组件之中。依赖注入的目的并非为软件系统带来更多功能，而是为了提升组件重用的频率，并为系统搭建一个灵活、可扩展的平台。通过依赖注入机制，我们只需要通过简单的配置，而无需任何代码就可指定目标需要的资源，完成自身的业务逻辑，而不需要关心具体的资源来自何处，由谁实现。理解DI的关键是：“谁依赖谁，为什么需要依赖，谁注入谁，注入了什么”， ●谁依赖于谁：当然是应用程序依赖于IoC容器； ●为什么需要依赖：应用程序需要IoC容器来提供对象需要的外部资源； ●谁注入谁：很明显是IoC容器注入应用程序某个对象，应用程序依赖的对象； ●注入了什么：就是注入某个对象所需要的外部资源（包括对象、资源、常量数据）。 ​ 容器指定那个组件(类)运行的时候，需要另外一个类(组件)；容器通过反射的方式，将容器中准备好的UserDao对象注入到UserService中声明的UserDao属性中。 3、简单IOC实例 123456789101112131415@Getter@Setter@ToString@NoArgsConstructor@AllArgsConstructorpublic class Person { private int id; private String name; private int age; private String gender; public Person() { System.out.println(\"person初始化...\"); }} 123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--注册一个Person对象。Spring会自动创建这个Person对象--&gt; &lt;!--一个bean可以注册一个组件(类)--&gt; &lt;!--id 唯一标识--&gt; &lt;!--class 类的全路径--&gt; &lt;bean id=\"person1\" class=\"org.lc.entity.Person\"&gt; &lt;!--property为属性赋值--&gt; &lt;!--name属性名 value属性值--&gt; &lt;property name=\"id\" value=\"1001\"/&gt; &lt;property name=\"name\" value=\"张三\"/&gt; &lt;property name=\"age\" value=\"12\"/&gt; &lt;property name=\"gender\" value=\"male\"/&gt; &lt;/bean&gt; &lt;bean id=\"person2\" class=\"org.lc.entity.Person\"&gt; &lt;property name=\"id\" value=\"1002\"/&gt; &lt;/bean&gt;&lt;/beans&gt; 1)读取Bean的xml获取Bean实例 1234567891011121314151617public class AppTest { //从容器中拿到这个组件 @Test public void Test1(){ //从绝对路径拿到配置文件 // ApplicationContext ico1 = new FileSystemXmlApplicationContext(\"\"); //从类路径(src)下拿到配置文件 classpath ApplicationContext ioc = new ClassPathXmlApplicationContext(\"ioc.xml\"); Person person1 = (Person) ioc.getBean(\"person1\"); Person person11 = (Person) ioc.getBean(\"person1\"); Person person2 = (Person) ioc.getBean(\"person2\"); //true System.out.println(person1==person11); }} 注意事项： ApplicationContext IOC接口 当创建ApplicationContext IOC容器创建完毕时即创建所有的对象. 无需等到getBean时再创建 ApplicationContext ioc = new ClassPathXmlApplicationContext(&quot;ioc.xml&quot;); 当配置一个bean，我们的IOC就位我们初始化创建一个实例对象 获取同一个bean多次时，获取的都是同一对象，即我们ICO创建bean对象是单实例的 找不到我们指定的bean时，会报错org.springframework.beans.factory.NoSuchBeanDefinitionException: 所有为对象属性的设置值都是通过set方法实现的 2)处理类型相同的多个Bean 当我们通过类对象获取bean时，当配置了多个相同的bean类型，那么会报错 1Person bean = ioc.getBean(\"person1\",Person.class); orgspringframework.beans.factory.NoUniqueBeanDefinitionException: No qualifying bean of type 'org.lc.entity.Person' available: expected single matching bean but found 2: person1,person2 指定要获取bean的id名称和类型 1Person bean = ioc.getBean(\"person1\",Person.class); 3)通过Bean中的有参构造器赋值12345678910 &lt;!--调用有参构造区进行赋值--&gt; &lt;!--person类中必须要有该下面完整的构造器--&gt;&lt;!-- public Person(int id, String name, int age, String gender) {}--&gt; &lt;!--通过有参构造器赋值，无需调用set方法--&gt; &lt;bean id=\"person3\" class=\"org.lc.entity.Person\"&gt; &lt;constructor-arg name=\"id\" value=\"10\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"name\" value=\"lc\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"age\" value=\"11\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg name=\"gender\" value=\"male\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt; 不写name属性的构造器赋值方法： 1234567&lt;!--当未指定name属性时，则必须按照构造器的属性顺序指定属性值，顺序不能颠倒--&gt;&lt;bean id=\"person4\" class=\"org.lc.entity.Person\"&gt; &lt;constructor-arg value=\"10\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=\"lc\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=\"11\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=\"male\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 如果赋值顺序颠倒，则可以指定index属性来指定顺序。索引从0开始 123456&lt;bean id=\"person4\" class=\"org.lc.entity.Person\"&gt; &lt;constructor-arg value=\"10\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=\"lc\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=\"male\" index=\"3\"&gt;&lt;/constructor-arg&gt; &lt;constructor-arg value=\"11\" index=\"2\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 还可以通过type来指定当前构造参数的类型 4)通过p标签赋值属性内部还是通过set方法赋值 xmlns:p=&quot;http://www.springframework.org/schema/p&quot; 1&lt;bean id=\"person4\" class=\"org.lc.entity.Person\" p:id=\"12\" p:gender=\"female\" p:name=\"张三\" p:age=\"12\"&gt;&lt;/bean&gt; 5)通过Bean赋值属性为null其实在xml中写的所有内容都是字符串，赋值给指定属性时类型会自动判断转换。 1234567&lt;!--若不为bean的属性赋值 则基本类型为默认值，引用类型默认为null--&gt;&lt;!--若要显示为某个属性赋值为null. 不能写成&lt;property name=\"id\" value=\"null\"&gt;否则还是赋值的为字符串null--&gt;&lt;bean id=\"person1\" class=\"org.lc.entity.Person\"&gt; &lt;property name=\"id\"&gt; &lt;null/&gt; &lt;/property&gt;&lt;/bean&gt; 6)通过ref引用其他外部Bean对象 123456789@Setter@Getter@ToStringpublic class Role { private int id; private String name; private String nameZh;} 1234567891011@Getter@Setter@ToString@AllArgsConstructor@NoArgsConstructorpublic class Car { private int id; private String nameCar; private double moneyCar;} 123456789101112131415@Getter@Setter@ToString@NoArgsConstructor@AllArgsConstructorpublic class Person { private int id; private String name; private int age; private String gender; private Car car; private List&lt;Role&gt; roleList; private Properties properties; private Map&lt;String,Object&gt; maps;} 12345678910&lt;bean id=\"car1\" class=\"org.lc.entity.Car\"&gt; &lt;property name=\"id\" value=\"111\"&gt;&lt;/property&gt; &lt;property name=\"nameCar\" value=\"宝马\"&gt;&lt;/property&gt; &lt;property name=\"moneyCar\" value=\"3600000\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"person1\" class=\"org.lc.entity.Person\"&gt; &lt;!--将该属性 引用ref外部的bean--&gt; &lt;property name=\"car\" ref=\"car1\"&gt;&lt;/property&gt;&lt;/bean&gt; 123456789Car car = (Car) ioc.getBean(\"car1\");Car car1 = ((Person) ioc.getBean(\"person1\")).getCar();//Car(id=111, nameCar=宝马, moneyCar=3600000.0)System.out.println(car1.toString());car.setNameCar(\"奔驰\");//Car(id=111, nameCar=奔驰, moneyCar=3600000.0)System.out.println(car1.toString());//trueSystem.out.println(car==car1); 通过bean声明的对象和ref引用的对象为同一对象。他们是同一个实例，修改一个对象的属性那么其他应引用该对象的属性也会改变。 7)创建使用内部Bean对象 创建内部的bean对象 与外部声明的bean不是同一对象 内部bean不能通过id获取到 123456789101112131415&lt;bean id=\"car1\" class=\"org.lc.entity.Car\"&gt; &lt;property name=\"id\" value=\"111\"&gt;&lt;/property&gt; &lt;property name=\"nameCar\" value=\"宝马\"&gt;&lt;/property&gt; &lt;property name=\"moneyCar\" value=\"3600000\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"person1\" class=\"org.lc.entity.Person\"&gt; &lt;property name=\"car\"&gt; &lt;!--创建内部的bean对象 与外部声明的bean不是同一对象--&gt; &lt;bean class=\"org.lc.entity.Car\"&gt; &lt;property name=\"id\" value=\"222\"&gt;&lt;/property&gt; &lt;property name=\"nameCar\" value=\"自行车\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; 123456Car car = (Car) ioc.getBean(\"car1\");Car car1 = ((Person) ioc.getBean(\"person1\")).getCar();//Car(id=111, nameCar=宝马, moneyCar=3600000.0)System.out.println(car.toString());//Car(id=222, nameCar=自行车, moneyCar=0.0)System.out.println(car1.toString()); 8)为List类型赋值1234567891011121314151617&lt;bean id=\"role1\" class=\"org.lc.entity.Role\"&gt; &lt;property name=\"id\" value=\"1\"&gt;&lt;/property&gt; &lt;property name=\"name\" value=\"admin\"&gt;&lt;/property&gt; &lt;property name=\"nameZh\" value=\"管理员\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"person2\" class=\"org.lc.entity.Person\"&gt; &lt;property name=\"roleList\"&gt; &lt;!--为list赋值 相当于 new ArrayList&lt;Role&gt;--&gt; &lt;array&gt; &lt;!--创建内部的bean并赋值--&gt; &lt;bean class=\"org.lc.entity.Role\" p:id=\"2\" p:name=\"test\" p:nameZh=\"测试人员\"&gt;&lt;/bean&gt; &lt;!--引用外部的bean--&gt; &lt;ref bean=\"role1\"&gt;&lt;/ref&gt; &lt;/array&gt; &lt;/property&gt; &lt;/bean&gt; 1234Person person2 = (Person) ioc.getBean(\"person2\"); List&lt;Role&gt; roleList = person2.getRoleList(); //[Role(id=2, name=test, nameZh=测试人员), Role(id=1, name=admin, nameZh=管理员)] System.out.println(roleList); 9)为map赋值123456789101112131415161718192021&lt;bean id=\"role1\" class=\"org.lc.entity.Role\"&gt; &lt;property name=\"id\" value=\"1\"&gt;&lt;/property&gt; &lt;property name=\"name\" value=\"admin\"&gt;&lt;/property&gt; &lt;property name=\"nameZh\" value=\"管理员\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"person3\" class=\"org.lc.entity.Person\"&gt; &lt;property name=\"maps\"&gt; &lt;!--为map赋值 相当于new LinkedHashMap&lt;String,Object&gt;--&gt; &lt;map&gt; &lt;!--一个entry代表一个健值对--&gt; &lt;entry key=\"key01\" value=\"张三\"&gt;&lt;/entry&gt; &lt;entry key=\"key02\" value=\"18\"&gt;&lt;/entry&gt; &lt;!--将value值引用外部bean--&gt; &lt;entry key=\"key03\" value-ref=\"role1\"&gt;&lt;/entry&gt; &lt;!--将value值创建内部bean--&gt; &lt;entry key=\"key04\"&gt; &lt;bean class=\"org.lc.entity.Role\" p:id=\"3333\" p:name=\"root\" p:nameZh=\"超级管理员\"&gt;&lt;/bean&gt; &lt;/entry&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; 1234Person person3 = (Person) ioc.getBean(\"person3\");Map&lt;String, Object&gt; maps = person3.getMaps();//{key01=张三, key02=18, key03=Role(id=1, name=admin, nameZh=管理员), key04=Role(id=3333, name=root, nameZh=超级管理员)}System.out.println(maps); 10)为Properties赋值12345678910&lt;bean id=\"person4\" class=\"org.lc.entity.Person\"&gt; &lt;property name=\"properties\"&gt; &lt;!--为properties属性赋值 相当于properties =new Properties() 所有的key value都是字符串类型 --&gt; &lt;props&gt; &lt;!--k=v都是字符串 值直接写在标签内--&gt; &lt;prop key=\"username\"&gt;root&lt;/prop&gt; &lt;prop key=\"password\"&gt;123456&lt;/prop&gt; &lt;/props&gt; &lt;/property&gt;&lt;/bean&gt; 123456Person person3 = (Person) ioc.getBean(\"person4\");Properties properties = person3.getProperties();// rootSystem.out.println(properties.getProperty(\"username\"));//123456System.out.println(properties.getProperty(\"password\")); 11)使用util创建一个可以引用的集合1xmlns:utils=&quot;http://www.springframework.org/schema/util&quot; 1234567891011121314151617181920&lt;!--相当于创建一个new LinkedHashMap 可以通过id 全局使用--&gt;&lt;utils:map id=\"maptutil\"&gt; &lt;!--一个entry代表一个健值对--&gt; &lt;entry key=\"key01\" value=\"张三\"&gt;&lt;/entry&gt; &lt;entry key=\"key02\" value=\"18\"&gt;&lt;/entry&gt; &lt;!--将value值引用外部bean--&gt; &lt;entry key=\"key03\" value-ref=\"role1\"&gt;&lt;/entry&gt; &lt;!--将value值创建内部bean--&gt; &lt;entry key=\"key04\"&gt; &lt;bean class=\"org.lc.entity.Role\" p:id=\"3333\" p:name=\"root\" p:nameZh=\"超级管理员\"&gt;&lt;/bean&gt; &lt;/entry&gt;&lt;/utils:map&gt;&lt;!--相当于创建一个list集合--&gt;&lt;utils:list id=\"utillist\"&gt; &lt;!--放入一个list--&gt; &lt;list&gt;&lt;/list&gt; &lt;!--放入一个普通的value值--&gt; &lt;value&gt;1&lt;/value&gt;&lt;/utils:list&gt; 12)级联属性赋值 当引用外部的bean并修改其中的属性时，对应外部的bean的属性也会改变。 123456789101112&lt;bean id=\"car1\" class=\"org.lc.entity.Car\"&gt; &lt;property name=\"id\" value=\"111\"&gt;&lt;/property&gt; &lt;property name=\"nameCar\" value=\"宝马\"&gt;&lt;/property&gt; &lt;property name=\"moneyCar\" value=\"3600000\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"person5\" class=\"org.lc.entity.Person\"&gt; &lt;!--引用外部bean--&gt; &lt;property name=\"car\" ref=\"car1\"&gt;&lt;/property&gt; &lt;!--引用外部bean后 并修改bean中的属性--&gt; &lt;property name=\"car.nameCar\" value=\"汗血宝马\"&gt;&lt;/property&gt;&lt;/bean&gt; 13)通过parent对指定Bean的继承1234567891011&lt;bean id=\"person6\" class=\"org.lc.entity.Person\"&gt; &lt;property name=\"id\" value=\"1002\"&gt;&lt;/property&gt; &lt;property name=\"name\" value=\"张三\"&gt;&lt;/property&gt; &lt;property name=\"age\" value=\"12\"&gt;&lt;/property&gt; &lt;property name=\"gender\" value=\"male\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;!--通过parent继承其他的bean--&gt;&lt;bean id=\"person7\" parent=\"person6\" class=\"org.lc.entity.Person\"&gt; &lt;!--将自己的属性重写 其他的属性继承--&gt; &lt;property name=\"name\" value=\"李四\"&gt;&lt;/property&gt;&lt;/bean&gt; 123Person person7 = (Person) ioc.getBean(\"person7\");//Person(id=1002, name=李四, age=12, gender=male, car=null, roleList=null, properties=null, maps=null)System.out.println(person7); 14)通过abstract将Bean声明为抽象的 该声明为abstract的bean只能被继承，不能通过id获取到该bean实例对象 123456&lt;bean id=\"person6\" class=\"org.lc.entity.Person\" abstract=\"true\"&gt; &lt;property name=\"id\" value=\"1002\"&gt;&lt;/property&gt; &lt;property name=\"name\" value=\"张三\"&gt;&lt;/property&gt; &lt;property name=\"age\" value=\"12\"&gt;&lt;/property&gt; &lt;property name=\"gender\" value=\"male\"&gt;&lt;/property&gt;&lt;/bean&gt; 15)Bean之间的依赖创建顺序 默认根据bean声明的先后顺序来创建bean 若指定depends-on 则先依次创建depends-on 中的bean role1,car1再创建person1 1234&lt;!--若根据bean声明的先后顺序来创建bean --&gt;&lt;bean id=\"person1\" class=\"org.lc.entity.Person\" depends-on=\"role1,car1\"&gt;&lt;/bean&gt;&lt;bean id=\"car1\" class=\"org.lc.entity.Car\"&gt;&lt;/bean&gt;&lt;bean id=\"role1\" class=\"org.lc.entity.Role\"&gt;&lt;/bean&gt; 4、Bean的作用域(默认为单例) prototype 多实例的 容器启动默认去创建多实例的bean 每次获取的时候才去创建这个bean 每次获取都会创建一个新的对象 singleton 单实例的 (默认) 在容器启动完成之前就已经创建好对象，保存在容器中了 任何获取到的该bean都是同一个对象 request 在web环境下，同一次请求创建一个Bean实例 session 在web环境下，同一次会话创建一个Bean实例 单例(默认)： 1&lt;bean id=\"person1\" class=\"org.lc.entity.Person\"&gt;&lt;/bean&gt; 1234 Person person1 = (Person) ioc.getBean(\"person1\"); Person person2= (Person) ioc.getBean(\"person1\");//true System.out.println(person1==person2); 多例： 1&lt;bean id=\"person1\" class=\"org.lc.entity.Person\" scope=\"prototype\"&gt;&lt;/bean&gt; 1234Person person1 = (Person) ioc.getBean(\"person1\");Person person2= (Person) ioc.getBean(\"person1\");//falseSystem.out.println(person1==person2); 5、静态工厂和实例工厂创建Bean工厂模式：工厂帮我们创建对象，有一个专门帮我们创建对象的类，这个类就是工厂 12345678@Getter@Setter@ToStringpublic class Drink { private int id; private String name; private int capacity;} 1)静态工厂工厂本身不需要创建对象；通过工厂中的静态方法调用创建对象 实例对象=工厂类.工厂静态方法() 12345678910//静态工厂public class DrinkStaticFactory { public static Drink getDrink(String name){ Drink drink=new Drink(); drink.setId(1); drink.setCapacity(1000); drink.setName(name); return drink; }} 123Drink d1 = DrinkStaticFactory.getDrink(\"可口可乐\");//Drink(id=1, name=可口可乐, capacity=1000)System.out.println(d1); 静态工厂获取bean123456789&lt;!--通过静态工厂创建需要的对象， 注意这里并不会创建工厂对象--&gt;&lt;!--class:工厂的类路径--&gt;&lt;!--factory-method: 指定方法名，是哪个工厂方法创建对象--&gt;&lt;bean id=\"drink1\" class=\"org.lc.factory.DrinkStaticFactory\" factory-method=\"getDrink\"&gt; &lt;!--指定该工厂方法传入的参数--&gt; &lt;!--name：为参数名--&gt; &lt;!--value 为参数值--&gt; &lt;constructor-arg name=\"name\" value=\"coco\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 123Drink drink1 = (Drink) ioc.getBean(\"drink1\");//Drink(id=1, name=coco, capacity=1000)System.out.println(drink1); 2)实例工厂工厂本身需要创建对象。 工厂类 工厂对象=new 工厂类(); 实例对象=工厂对象.工厂实例方法(); 123456789public class DrinkInstanceFactory { public Drink getDrink(String name) { Drink drink=new Drink(); drink.setId(1); drink.setCapacity(1000); drink.setName(name); return drink; }} 1234DrinkInstanceFactory drinkInstanceFactory=new DrinkInstanceFactory();Drink d1 = drinkInstanceFactory.getDrink(\"百世可乐\");//Drink(id=1, name=百世可乐, capacity=1000)System.out.println(d1); 静态工厂获取bean123456789101112&lt;!--创建工厂bean对象--&gt;&lt;bean id=\"drinkInstanceFactory\" class=\"org.lc.factory.DrinkInstanceFactory\"&gt;&lt;/bean&gt;&lt;!--在要创建的bean中指定实例工厂的bean--&gt;&lt;!--factory-bean：工厂bean的id --&gt;&lt;!--factory-method: 指定工厂的方法名，工厂实例方法的名称--&gt;&lt;bean id=\"drink2\" class=\"org.lc.entity.Drink\" factory-bean=\"drinkInstanceFactory\" factory-method=\"getDrink\"&gt; &lt;!--为该工厂方法传入需要的参数--&gt; &lt;!--name 参数名--&gt; &lt;!--value 参数值--&gt; &lt;constructor-arg name=\"name\" value=\"星巴克\"&gt;&lt;/constructor-arg&gt;&lt;/bean&gt; 123Drink drink =(Drink)ioc.getBean(\"drink2\");//Drink(id=1, name=星巴克, capacity=1000)System.out.println(drink); 6、实现FactoryBean工厂获取所需的Bean public interface FactoryBean为spring的一个接口，只要是实现了这个接口的，都认为是一个工厂 创建该工厂对象，通过getBean方法获取实现FactoryBean&lt;T&gt;中声明的所需要的类型对象 IOC容器启动的时候会创建我们实现FactoryBean的工厂对象，但是并不会创建该需要的Role创建该实例对象(无论是单例还是多例)。只有获取的时候才会创建实例对象 1234567891011121314151617181920212223242526public class MyFactoryImp implements FactoryBean&lt;Role&gt; { //返回该对象 @Override public Role getObject() throws Exception { Role role =new Role(); role.setId(1); role.setName(\"superuser\"); role.setNameZh(\"超级用户\"); return role; } //返回该实例Clss @Override public Class&lt;?&gt; getObjectType() { return Role.class; } //指定返回的对象是否为单例 //true 指定为单例 //false 指定为多例 @Override public boolean isSingleton() { return true; }} 123&lt;!--public interface FactoryBean&lt;T&gt;为spring的一个接口，只要是实现了这个接口的，都认为是一个工厂--&gt;&lt;!--IOC容器启动的时候并不会 创建该实例对象。只有获取的时候才会创建实例对象--&gt;&lt;bean id=\"myFactoryImpl\" class=\"org.lc.factory.MyFactoryImp\"&gt;&lt;/bean&gt; 123456 Role role =(Role)ioc.getBean(\"myFactoryImpl\"); Role role1 =(Role)ioc.getBean(\"myFactoryImpl\");//true System.out.println(role==role1);//Role(id=1, name=superuser, nameZh=超级用户) System.out.println(role); 7、Bean的生命周期1234567891011121314151617181920@Setter@Getter@ToStringpublic class Role { private int id; private String name; private String nameZh; //构造器 public Role() { System.out.println(\"创建...role\"); } //初始化方法 public void initRole() { System.out.println(\"初始化role...\"); } //销毁方法 public void destoryRole() { System.out.println(\"销毁role...\"); }} 1)单例(默认singleton)： 单例的对象bean的执行顺序： (容器启动)构造器—&gt; (容器启动)初始化方法(init-method指定的方法)—&gt; (容器关闭)销毁方法 (destroy-method指定的方法) 容器启动时调用 构造器 和 初始化方法, 关闭容器调用close()后调用销毁方法 1234&lt;!--指定beans的初始化和销毁方法--&gt;&lt;!--init-method：指定该bean中的初始化方法，在对象创建时调用--&gt;&lt;!--destroy-method： 指定该bean的销毁方法。在容器销毁时调用--&gt;&lt;bean id=\"role1\" class=\"org.lc.entity.Role\" init-method=\"initRole\" destroy-method=\"destoryRole\"&gt;&lt;/bean&gt; 1234ConfigurableApplicationContext ioc = new ClassPathXmlApplicationContext(\"ioc3.xml\");System.out.println(\"容器要关闭了...\");//ioc的关闭容器的方法ioc.close(); 1234创建...role初始化role...容器要关闭了...销毁role... 2)多例(prototype): 多例的对象在获取该对象时才会创建该Bean，即获取对象时调用 (获取bean时)构造方法—&gt; (获取bean时)初始化方法 。销毁方法使用完该bean后自动销毁，容器无需干预。 对象的销毁不会在容器close()时销毁，该对象使用完自动销毁 1234&lt;!--指定beans的初始化和销毁方法--&gt;&lt;!--init-method：指定该bean中的初始化方法，在对象创建时调用--&gt;&lt;!--destroy-method： 多例时，该实例不会销毁，自动销毁。--&gt;&lt;bean id=\"role1\" class=\"org.lc.entity.Role\" init-method=\"initRole\" destroy-method=\"destoryRole\" scope=\"prototype\"&gt;&lt;/bean&gt; 12345ConfigurableApplicationContext ioc = new ClassPathXmlApplicationContext(\"ioc3.xml\"); Role role1 = (Role) ioc.getBean(\"role1\"); System.out.println(\"容器要关闭了...\"); //ioc的关闭容器的方法 ioc.close(); 123创建...role初始化role...容器要关闭了... 3)bean的前置后置处理器在bean创建的时候，对实例对象进行的操作。 单例在容器的启动的时候创建bean 多例在获取该bean的时候创建 自定义类实现BeanPostProcessor接口。并将该自定义MyProcesserBean处理器注册在bean.xml文件中 所有的bean实例都会在创建时使用该前置和后置处理器。 调用bean构造器方法–&gt; 调用bean的前置处理器(postProcessBeforeInitialization) –&gt;调用bean指定的初始化方法–&gt;调用的bean的后置处理器(postProcessAfterInitialization) 若bean没有指定初始化方法则也可以正常使用该处理器 1234567891011121314151617181920@Setter@Getter@ToStringpublic class Role { private int id; private String name; private String nameZh; //构造器 public Role() { System.out.println(\"创建...role\"); } //初始化方法 public void initRole() { System.out.println(\"初始化role...\"); } //销毁方法 public void destoryRole() { System.out.println(\"销毁role...\"); }} 123456789101112131415161718192021222324252627282930public class MyProcesserBean implements BeanPostProcessor { /** * bean调用初始化方法之前的处理器 * @param bean bean的构造方法创建的对象 * @param beanName bean在xml中的id * @return 返回该对象 * @throws BeansException */ @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException { System.out.println(\"bean初始化之前的处理器:beanname\" + beanName); System.out.println(\"----\"+bean); return bean; } /** * bean调用初始化方法完成后的处理器 * @param bean bean的构造方法创建的对象 * @param beanName bean在xml中的id * @return 返回该对象 * @throws BeansException */ @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException { System.out.println(\"bean初始化之前的处理器:beanname\" + beanName); System.out.println(\"----\"+bean); return bean; }} 12345&lt;!--为该bean指定 初始化执行的方法 和 销毁时执行的方法--&gt;&lt;bean id=\"role1\" class=\"org.lc.entity.Role\" init-method=\"initRole\" destroy-method=\"destoryRole\" &gt;&lt;/bean&gt;&lt;!--配置bean的初始化处理器--&gt;&lt;bean id=\"myProcessBean\" class=\"org.lc.factory.MyProcesserBean\"&gt;&lt;/bean&gt; 12Role role1 = (Role) ioc.getBean(\"role1\");System.out.println(\"获取bean====\"+role1); 12345678910111213141516//调用bean的构造器时创建...role //调用bean的前置处理器 (在bean的指定的初始化方法之前调用)bean初始化之前的处理器:beannamerole1----Role(id=0, name=null, nameZh=null)//调用bean的初始化方法初始化role...//调用bean的后置处理器 (在bean的指定的初始化方法之后调用)bean初始化之前的处理器:beannamerole1----Role(id=0, name=null, nameZh=null)//获取该bean实例获取bean====Role(id=0, name=null, nameZh=null) 8、Spring管理连接池依赖 1234567891011&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.18&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.46&lt;/version&gt;&lt;/dependency&gt; 1、通过xml配置连接池123456&lt;bean id=\"druidDataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"123456\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/test?serverTimezone=Asia/Shanghai&amp;amp;useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;useSSL=false\"&gt;&lt;/property&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.jdbc.Driver\"&gt;&lt;/property&gt;&lt;/bean&gt; 2、引用外部文件抽取连接配置classpath: 固定写法，加载类路径下的配置文件 &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot; /&gt; 注意 在配置&lt;property name=&quot;username&quot; value=&quot;${jdbc.username}&quot;&gt;&lt;/property&gt;的value时，不能写成value=”${username}” 因为username为spring中的一个内部属性(当前用户)。在前面加前缀即可 jdbc.properties 1234jdbc.username=rootjdbc.password=123456jdbc.url=jdbc:mysql://localhost:3306/test?serverTimezone=Asia/Shanghai&amp;useUnicode=true&amp;characterEncoding=UTF-8&amp;useSSL=falsejdbc.dirverClass=com.mysql.jdbc.Driver 12345678910&lt;!--加载外部的properties配置文件--&gt; &lt;!--classpath: 固定写法，加载类路径下的配置文件--&gt; &lt;context:property-placeholder location=\"classpath:jdbc.properties\" /&gt; &lt;bean id=\"druidDataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"&gt; &lt;property name=\"username\" value=\"${jdbc.username}\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"${jdbc.password}\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"${jdbc.url}\"&gt;&lt;/property&gt; &lt;property name=\"driverClassName\" value=\"${jdbc.dirverClass}\"&gt;&lt;/property&gt; &lt;/bean&gt; 测试： 123456789101112ApplicationContext ioc = new ClassPathXmlApplicationContext(\"application.xml\");@Testpublic void Test1() throws SQLException { //通过名称bean的id获取 // DruidDataSource druidDataSource = (DruidDataSource) ioc.getBean(\"druidDataSource\"); //通过bean的类型获取(若存在多个类型相同的bena则会报错) DruidDataSource druidDataSource = ioc.getBean(DruidDataSource.class); DruidPooledConnection connection = druidDataSource.getConnection(); //com.mysql.jdbc.JDBC4Connection@6b67034 System.out.println(connection);} 9、基于xml的自动装配 1234567891011@Getter@Setter@ToString@AllArgsConstructor@NoArgsConstructorpublic class Car { private int id; private String nameCar; private double moneyCar;} 12345678@Setter@Getter@ToStringpublic class Role { private int id; private String name; private String nameZh;} 1234567891011121314151617@Getter@Setter@ToString@AllArgsConstructor@NoArgsConstructorpublic class Person { private int id; private String name; private int age; private String gender; private Car car; private List&lt;Role&gt; roleList; public Person(Car car) { this.car = car; }} 1)手动装配123456789&lt;bean id=\"car1\" class=\"org.lc.entity.Car\"&gt; &lt;property name=\"nameCar\" value=\"奥迪双钻\"/&gt;&lt;/bean&gt;&lt;!--手动赋值--&gt;&lt;bean id=\"person1\" class=\"org.lc.entity.Person\"&gt; &lt;!--通过property的ref引用bean为属性赋值--&gt; &lt;property name=\"car\" ref=\"car1\"&gt;&lt;/property&gt;&lt;/bean&gt; 2)自动装配 autowire=”no/default” 不自动装配 不自动为属性赋值 autowire=”byName” 通过属性名作为id去容器中找这个组件，找到则赋值，找不到赋值为nullprivate Car car; 通过car名称作为id去找 相当于 getBean(&quot;car&quot;); autowire=”byType” 通过类型去容器中寻找这个组件，找到一个则为其赋值，找到多个则报错。找不到则赋值为nullpricate Car car; 通过Car类型寻找 相当于getBean(Car.class); autowire=”constructor” 通过Person中的构造器进行寻找public Person(Car car) {} 先按照构造器参数的上的Car类型进行寻找，找到则装配，找不到则返回null 如果按照类型找到了多个，则按照构造器car参数名称进行寻找，找到则装配，找不到赋值为null 不会报错 1234567891011121314151617181920212223&lt;bean id=\"car\" class=\"org.lc.entity.Car\"&gt; &lt;property name=\"nameCar\" value=\"奥迪双钻\"/&gt;&lt;/bean&gt;&lt;bean id=\"car2\" class=\"org.lc.entity.Car\"&gt; &lt;property name=\"nameCar\" value=\"宝马\"/&gt;&lt;/bean&gt;&lt;!--为Person中的自定义属性自动装配--&gt;&lt;!--通过autowire属性为对象中的所有属性(这里的属性必须为自定义的属性)自动装配--&gt;&lt;!--autowire: autowire=\"no/default\" 不自动装配 不自动为属性赋值 autowire=\"byName\" 通过属性名作为id去容器中找这个组件，找到则赋值，找不到赋值为null private Car car; 通过car名称作为id去找 相当于 getBean(\"car\"); autowire=\"byType\" 通过类型去容器中寻找这个组件，找到一个则为其赋值，找到多个则报错。找不到则赋值为null pricate Car car; 通过Car类型寻找 相当于getBean(Car.class); autowire=\"constructor\" 通过Person中的构造器进行寻找 public Person(Car car) {} 先按照构造器参数的上的Car类型进行寻找，找到则装配，找不到则返回null 如果按照类型找到了多个，则按照构造器car参数名称进行寻找，找到则装配，找不到赋值为null 不会报错--&gt;&lt;bean id=\"person1\" class=\"org.lc.entity.Person\" autowire=\"byName\"&gt;&lt;/bean&gt; 装配list集合12345678910111213&lt;bean id=\"person1\" class=\"org.lc.entity.Person\" autowire=\"byType\"&gt;&lt;/bean&gt;&lt;!--下面的三个Role对象都会装配到 List&lt;Role&gt; roleList; 集合中--&gt;&lt;bean id=\"role1\" class=\"org.lc.entity.Role\"&gt; &lt;property name=\"nameZh\" value=\"测试1\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"role2\" class=\"org.lc.entity.Role\"&gt; &lt;property name=\"nameZh\" value=\"测试2\"&gt;&lt;/property&gt;&lt;/bean&gt;&lt;bean id=\"role3\" class=\"org.lc.entity.Role\"&gt; &lt;property name=\"nameZh\" value=\"测试3\"&gt;&lt;/property&gt;&lt;/bean&gt; 10、SPEL表达式(#表达式)Spring Expression Language (spring表达式语言) 1234567891011121314151617181920&lt;bean id=\"car1\" class=\"org.lc.entity.Car\"&gt; &lt;property name=\"id\" value=\"111\"/&gt; &lt;property name=\"nameCar\" value=\"丰田\"/&gt; &lt;property name=\"moneyCar\" value=\"100000\"/&gt;&lt;/bean&gt;&lt;bean id=\"person2\" class=\"org.lc.entity.Person\"&gt; &lt;!--计算值--&gt; &lt;property name=\"id\" value=\"#{2*10*10}\"&gt;&lt;/property&gt; &lt;!--引用其他bean的属性值--&gt; &lt;property name=\"name\" value=\"#{car1.nameCar}\"&gt;&lt;/property&gt; &lt;!--引用其他bean 和ref属性值一样--&gt; &lt;property name=\"car\" value=\"#{car1}\"&gt;&lt;/property&gt; &lt;!--调用静态方法和非静态方法--&gt; &lt;!--语法规则: #{T(静态类全类名).静态方法名(参数)} --&gt; &lt;property name=\"gender\" value=\"#{T(java.util.UUID).randomUUID().toString().substring(0,5)}\"&gt;&lt;/property&gt; &lt;!--调用非静态方法--&gt; &lt;property name=\"age\" value=\"#{car1.getId()}\"&gt;&lt;/property&gt;&lt;/bean&gt; 123 Person person1 = (Person) ioc.getBean(\"person2\");//Person(id=200, name=丰田, age=111, gender=e57b0, car=Car(id=111, nameCar=丰田, moneyCar=100000.0), roleList=null) System.out.println(person1); 11、通过注解创建Dao,Service,Controller @Controller 一般加到控制器类上 @Service 一般加到服务层上service @Repository 一般应用到持久层Dao @Component 不属于以上三层时加该注解 上面所有的注解效果都是一样的，只是方便标识和查看 默认被以上组件标记的bean声明都是单例类型 bean的id名默认为类名首字母小写。 即UserController的id名 userController 123@Controllerpublic class UserController {} 123@Repositorypublic class UserDao {} 123@Servicepublic class UserService {} 1)扫描指定所有带注解的包 123&lt;!--扫描所有声明带注解到容器中的包--&gt;&lt;!--base-package 指定扫描基础包路径--&gt;&lt;context:component-scan base-package=\"org.lc\"&gt;&lt;/context:component-scan&gt; 1234 UserController userController1 = (UserController) ioc.getBean(\"userController\"); UserController userController2 = (UserController) ioc.getBean(\"userController\");//true System.out.println(userController1==userController2); 2)为指定组件指定id名称若注解中只有一个value属性则可省略 123@Controller(value = \"controller1\")public class UserController {} 1UserController userController1 = (UserController) ioc.getBean(\"controller1\"); 3)指定bean的作用域(单例，多例)1234@Controller(value = \"controller1\")@Scope(value = \"prototype\")public class UserController {} 1234 UserController userController1 = (UserController) ioc.getBean(\"controller1\"); UserController userController2 = (UserController) ioc.getBean(\"controller1\");//false System.out.println(userController1==userController2); 4)排除扫描不包含的组件context:exclude-filter12345678910111213&lt;!--扫描声明为到容器中的包--&gt;&lt;!--base-package 指定扫描基础包路径--&gt;&lt;!--默认全部扫描--&gt;&lt;context:component-scan base-package=\"org.lc\"&gt; &lt;!--扫描时排除一些不要的组件--&gt; &lt;!--type=\"assignable\" 指定排除规则，排除某个具体的类，按照类排除 expression=\"\" 该类所在的全类名 type=\"annotation\" 指定排除规则，按照注解排除指定类 expression=\"\" 该注解的全类名 --&gt; &lt;context:exclude-filter type=\"assignable\" expression=\"org.lc.dao.UserDao\"/&gt; &lt;context:exclude-filter type=\"annotation\" expression=\"org.springframework.stereotype.Service\"/&gt;&lt;/context:component-scan&gt; 5)扫描包含指定的组件context:include-filter12345678&lt;!--扫描声明为到容器中的包--&gt;&lt;!--base-package 指定扫描基础包路径--&gt;&lt;!--默认全部扫描--&gt;&lt;!--注意：这里默认扫描全部，我们要禁用use-default-filters默认的扫描规则，否则还是全部扫描进来了--&gt;&lt;context:component-scan base-package=\"org.lc\" use-default-filters=\"false\"&gt; &lt;!-- 值包含标有@Controller注解的类--&gt; &lt;context:include-filter type=\"annotation\" expression=\"org.springframework.stereotype.Controller\"/&gt;&lt;/context:component-scan&gt; 12、@Autowired自动装配原理 首先按照注入的类型(UserService)去IOC容器中查找对应的组件，若找到则装配，找不到抛异常 ioc.getBean(UserService.class); 123456- 若找到多个，则按照注入的属性名称(userService)作为bean的id去容器中查找，找到则装配，找不到，抛异常 - ```java @Autowired private UserService userService; 1234567@Service//默认bean的id userServicepublic class UserService { public void getUser() { System.out.println(\"执行查找用户..UserService\"); }} 12345678@Service////默认bean的id userServiceExcpublic class UserServiceExc extends UserService{ @Override public void getUser() { System.out.println(\"执行查找用户..UserServiceExc\"); }} 1234567891011@Controllerpublic class UserController { //注入类型 //默认按照类型到IOC容器中查找，若找到多个，则以属性名userService作为id去容器中查找指定id的bean。若没找到则抛出异常 @Autowired private UserService userService; public void getUser() { userService.getUser(); }} 123 UserController userController = (UserController) ioc.getBean(\"userController\");//执行查找用户..UserService userController.getUser(); 1)配合@Qualifier使用若使用@Autowired找到多个类型，注入时不想通过默认属性名作为id寻找，那么直接可以使用@Qualifier按照其指定的名称去容器中找知道的bean 12345678910111213@Controllerpublic class UserController { @Qualifier(\"userServiceExc\") @Autowired //若找到多个类型，不想用属性名称作为id查找，则可以直接使用@Qualifier注解中指定的名称查找 private UserService userService; public void getUser() { userService.getUser(); }} 123//执行查找用户..UserServiceExc UserController userController = (UserController) ioc.getBean(UserController.class);userController.getUser(); 2)指定@Autowired(required = false)若指定@Qualifier还找不到，则将该属性装配为null。 123456789101112@Controllerpublic class UserController { @Qualifier(\"userServiceExc111\") @Autowired(required = false) private UserService userService; public void getUser() { //UserService:null System.out.println(\"UserService:\"+userService); }} 3)在方法参数上使用@Autowired和@Qualifier1234567891011121314@Controllerpublic class UserController { //容器启动时 会运行此方法 //自动为为 UserDao和UserService进行装配 //用法和在属性上一致 @Autowired public void getUser(UserDao userDao,@Qualifier(\"userServiceExc\")UserService userService) { //userDao:org.lc.dao.UserDao@56a6d5a6 System.out.println(\"userDao:\"+userDao); //UserService:org.lc.service.UserServiceExc@18ce0030 System.out.println(\"UserService:\"+userService); }} 13、@Resource自动装配与@Autowired的区别1)@Autowired用来装配bean, 可作用于字段上, 也可以作用于setter方法上. 是Spring的注解. 即只能在spring框架中使用 默认情况下要求对象必须存在, 它要求依赖对象必须存在. 若允许null值, 可以设置它的required为false. 默认按照类型byType进行装配注入. 如果想按照名称进行装配的话, 需要与Qualifer注解搭配使用 2)@Resource是J2EE的注解. 扩展性更强，可以用在其他框架上。 所有不能应用@Autowired中的required属性和@Primary注解 默认按照名称来装配注入,若找到多个相同的名称则抛异常，若找不到则按照bean的类型来找，若找到多个bean类型也抛异常 它有两个属性是比较重要的: name: Spring将name的属性值解析为bean的名称, 使用byName的自动注入策略 type: Spring将type的属性值解析为bean的类型, 使用byType的自动注入策略，如果既不指定name属性又不指定type属性, Spring这时通过反射机制默认使用byName自动注入策略 1234567891011//默认按照属性名称redisTemplate做为bean的id去容器中找，找到多个抛异常@Resourceprivate RedisTemplate redisTemplate; //通过type属性注入，则先按照类型找，若找到多个则按照属性名称找@Resource(type = RedisTemplate.class)private RedisTemplate redisTemplate; //通过name，type属性注入 同时按照类型和名称找 找不到抛异常@Resource(name = \"RedisTemplate\",type = RedisTemplate.class)private RedisTemplate redisTemplate; 14、Spring的单元测试1234567891011 &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.2.5.RELEASE&lt;/version&gt; &lt;/dependency&gt; 123456789101112//classpath: 使用指定的xml文件@ContextConfiguration(locations = \"classpath:application.xml\")//使用junit4测试@RunWith(SpringJUnit4ClassRunner.class)public class SpringTest { @Autowired private UserController userController; @Test public void Test(){ System.out.println(userController); }} 15、泛型依赖注入Dao: 1234@Repositorypublic abstract class BaseDao&lt;T&gt; { public abstract void save();} 1234567@Repositorypublic class BookDao extends BaseDao&lt;Book&gt;{ @Override public void save() { System.out.println(\"BookDao...保存图书\"); }} 1234567@Repositorypublic class UserDao extends BaseDao&lt;User&gt;{ @Override public void save() { System.out.println(\"UserDao...保存用户\"); }} Service: 123456789101112131415//这里并不用注册为bean对象 因为我们的继承该BaseService的对象已经注册为bean// 虽然不能够使用private BaseDao&lt;T&gt; baseDao;属性和public void save() {}方法，但是能够继承此方法和属性。public class BaseService&lt;T&gt; { //泛型依赖注入，注入一个组件的时候，他的泛型也是参考标准 //即指定的T为User时 会在容器中寻找 BaseDao&lt;User&gt;类型的对象 //即指定的T为Book时 会在容器中寻找 BaseDao&lt;Book&gt;类型的对象 @Autowired private BaseDao&lt;T&gt; baseDao; public void save() { System.out.println(\"自动注入的dao:\"+baseDao); baseDao.save(); }} 12@Servicepublic class BookService extends BaseService&lt;Book&gt;{} 12@Servicepublic class UserService extends BaseService&lt;User&gt; {} 测试： 1234567891011@Autowiredprivate UserService userService;@Autowiredprivate BookService bookService;@Testpublic void Test(){ userService.save(); bookService.save();} 1234自动注入的dao:org.lc.dao.UserDao@3c19aaa5UserDao...保存用户自动注入的dao:org.lc.dao.BookDao@3349e9bbBookDao...保存图书 16、BeanFactory和ApplicationContext的区别(面试) ApplicationContext是BeanFactory的子接口 BeanFactory：bean工厂接口；负责创建bean实例；容器里面保存的所有单实例bean起始是一个map(concurrentHashMap)；也是spring最底层的接口 ApplicationContext：是容器接口；更多的负责容器功能的实现；可以基于BeanFactory创建好的对象之上完成强大的容器，容器可以从map中获取这个bean并进行AOP,DI BeanFactory是最底层的接口，ApplicationContext留给程序员使用的IOC容器接口； Spring中最大的模式就是工厂模式 通过在xml里面配置bean来让BeanFactory帮用户创建bean 1&lt;bean class=\"\" id=\"\"&gt;&lt;/bean&gt; 17、Bean的生命周期(初始化流程)面试简单流程 https://www.jb51.net/article/154487.htm Bean 容器找到配置文件中 Spring Bean 的定义。 Bean 容器利用 Java Reflection API 创建一个Bean的实例。 如果涉及到一些属性值 利用 set()方法设置一些属性值。 如果 Bean 实现了 BeanNameAware 接口，调用 setBeanName()方法，传入Bean的名字。 如果 Bean 实现了 BeanClassLoaderAware 接口，调用 setBeanClassLoader()方法，传入 ClassLoader对象的实例。 与上面的类似，如果实现了其他 *.Aware接口，就调用相应的方法。 如果有和加载这个 Bean 的 Spring 容器相关的 BeanPostProcessor 对象，执行postProcessBeforeInitialization() 方法 如果Bean实现了InitializingBean接口，执行afterPropertiesSet()方法。 如果 Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。 如果有和加载这个 Bean的 Spring 容器相关的 BeanPostProcessor 对象，执行postProcessAfterInitialization() 方法 当要销毁 Bean 的时候，如果 Bean 实现了 DisposableBean 接口，执行 destroy() 方法。 当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。 二、AOP1、基本概念 AOP（Aspect Oriented Programming）称为面向切面编程，在程序开发中主要用来解决一些系统层面上的问题，比如日志，事务，权限等待 在不改变原有的逻辑的基础上，增加一些额外的功能。代理也是这个功能，读写分离也能用aop来做。 将某段代码动态的切入到指定方法的指定位置进行运行的这种编程方式，称为面向切面编程 AOP与OOP区别？AOP可以说是OOP（Object Oriented Programming，面向对象编程）的补充和完善。 OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能。日志代码往往横向地散布在所有对象层次中，而与它对应的对象的核心功能毫无关系对于其他类型的代码，如安全性、异常处理和透明的持续性也都是如此，这种散布在各处的无关的代码被称为横切（cross cutting），在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。 AOP技术恰恰相反，它利用一种称为”横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect”，即切面。所谓”切面”，简单说就是那些与业务无关，却为业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。 2、使用场景例如日志记录，在不改变源代码的情况下动态的加入到指定方法的指定位置 1)基于接口的jdk动态代理实现目标对象需要实现一个接口对象，我们的代理对象无需实现接口对象，但是在底层仍然是通过反射来实现代理对象实现相应的接口 接口对象 123456public interface Caculate { int add(int a, int b); int substract(int a, int b); int multiply(int a, int b); int divide(int a, int b);} 目标对象 12345678910111213141516171819public class CaculateImpl implements Caculate { @Override public int add(int a, int b) { //int c=1/0; return a+b; } @Override public int substract(int a, int b) { return a-b; } @Override public int multiply(int a, int b) { return a-b; } @Override public int divide(int a, int b) { return a/b; }} 获取代理对象 12345678910111213141516171819202122232425public class ProxyInstance { private Object object; public ProxyInstance(Object object) { this.object = object; } //获取代理对象 public Object getProxyInstance() { return Proxy.newProxyInstance(object.getClass().getClassLoader(), object.getClass().getInterfaces(), (proxy, method, args) -&gt; { Object invoke=null; try { System.out.println(\"执行:【\" + method.getName() + \"】方法之前的记录\"); invoke = method.invoke(object, args); System.out.println(\"执行:【\" + method.getName() + \"】方法之后的记录,方法的参数为:【\" + Arrays.toString(args) + \"】,方法的结果为【\" + invoke + \"】\"); } catch (Exception e) { System.out.println(\"方法抛出的异常为:【\"+e.getCause()+\"】\"); }finally { System.out.println(\"总要执行的记录....\"); } System.out.println(\"方法返回结果之前的记录...\"); return invoke; }); }} 12345678910public class Test { public static void main(String[] args) { ProxyInstance proxyInstance = new ProxyInstance(new CaculateImpl()); //获取代理对象时，实际还是在底层为我们的目标对象创建了一个代理对象实现相同的接口。 //所以这里我们需要使用接口对象带接收返回值 Caculate instance = ((Caculate) proxyInstance.getProxyInstance()); int add = instance.add(1, 2); System.out.println(add); }} 12345执行:【add】方法之前的记录执行:【add】方法之后的记录,方法的参数为:【[1, 2]】,方法的结果为【3】总要执行的记录....方法返回结果之前的记录...3 3、专业术语解释 (1)横切关注点：对哪些方法进行拦截，拦截后怎么处理，这些关注点称之为横切关注点 (2)Aspect(切面):通常是一个类，里面可以定义切入点和通知 (3)JointPoint(连接点):程序执行过程中明确的点，一般是方法的调用。被拦截到的点，因为Spring只支持方法类型的连接点，所以在 Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器 (4)Advice(通知):AOP在特定的切入点上执行的增强处理，有before(前置),after(后置),afterReturning(最终),afterThrowing(异常),around(环绕) (5)Pointcut(切入点):就是带有通知的连接点，在程序中主要体现为书写切入点表达式 (6)weave(织入)：将切面应用到目标对象并导致代理对象创建的过程 (7)introduction(引入)：在不修改代码的前提下，引入可以在运行期为类动态地添加一些方法或字段 (8)AOP代理(AOP Proxy)：AOP框架创建的对象，代理就是目标对象的加强。Spring中的AOP代理可以使JDK动态代理，也可以是CGLIB代理，前者基于接口，后者基于子类 (9)目标对象（Target Object）: 包含连接点的对象。也被称作被通知或被代理对象。POJO 4、AOP简单配置流程配置流程： 1)将目标类和切面类(封装了通知方法，切入点方法(切点表达式))加入到IOC容器中 2)指定切面类加上@Aspect注解 3)告诉Spring切面中的通知(执行方法)在什么时候运行 @Before 在目标方法执行之前运行 @After 在目标方法结束(无论目标方法是否成功完成)之后运行 @AfterReturning 在目标方法正常完成后之后运行 @AfterThrowing 在目标方法抛出异常之后运行 @Around 环绕通知 相当于： Object invoke=null; try { //@Before invoke = method.invoke(object, args); //@AfterReturning } catch (Exception e) { //@AfterThrowing }finally { //@After } return invoke; &lt;!--￼110--&gt; // 在org.lc.aop.CaculateImpl类下的所有方法为pulibc修饰符,返回类型为int,参数为两个int类型的所有方法加上前置通知 @Before(\"execution(public int org.lc.aop.CaculateImpl.*(int,int))\") &lt;!--￼111--&gt; 测试：1)目标对象实现了接口(jdk动态代理)123456public interface Caculate { int add(int a, int b); int substract(int a, int b); int multiply(int a, int b); int divide(int a, int b);} 12345678910111213141516171819@Servicepublic class CaculateImpl implements Caculate { @Override public int add(int a, int b) { return a+b; } @Override public int substract(int a, int b) { return a-b; } @Override public int multiply(int a, int b) { return a-b; } @Override public int divide(int a, int b) { return a/b; }} 12345678910111213141516171819202122232425//切面类@Component@Aspectpublic class LogUtils { @Before(\"execution(public int org.lc.aop.CaculateImpl.*(int,int))\") public static void startLog() { System.out.println(\"执行:【\" + \"method.getName()\" + \"】方法之前的记录\"); } @AfterReturning(\"execution(public int org.lc.aop.CaculateImpl.*(int,int))\") public static void returnLog() { System.out.println(\"执行:【\" + \"method.getName()\" + \"】方法之后的记录,方法的参数为:【\" +\" Arrays.toString(args)\" + \"】,方法的结果为【\" + \"invoke \"+ \"】\"); } @AfterThrowing(\"execution(public int org.lc.aop.CaculateImpl.*(int,int))\") public static void exceptionLog() { System.out.println(\"方法抛出的异常为:【\"+\"e.getCause()\"+\"】\"); } @After(\"execution(public int org.lc.aop.CaculateImpl.*(int,int))\") public static void finallyLog() { System.out.println(\"总要执行的记录....\"); }} 1234 &lt;!--扫描org.lc所有包--&gt;&lt;context:component-scan base-package=\"org.lc\"/&gt;&lt;!--开启基于注解的AOP注解--&gt; &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt; 12345678910 //注入接口@Autowired private Caculate caculate; @Test public void Test(){ caculate.add(1, 2); //class com.sun.proxy.$Proxy25 System.out.println(caculate.getClass()); } 123执行:【method.getName()】方法之前的记录总要执行的记录....执行:【method.getName()】方法之后的记录,方法的参数为:【 Arrays.toString(args)】,方法的结果为【invoke 】 若目标对象实现了接口，则使用的是jdk动态代理来实现AOP 通过注入接口对象来使用，通过caculate.getClass() 方法我们可以发现，AOP底层还是为我们创建了一个代理对象来实现相同的接口的。 2)目标对象没有实现接口(cglib代理) 若我们的目标对象没有实现接口，则使用的是cglib代理，默认为我们的目标类创建了一个内部类作为子类来实现代理- 通过注入本类使用。 只对CaculateImpl类做修改： 123456789101112131415@Servicepublic class CaculateImpl{ public int add(int a, int b) { return a+b; } public int substract(int a, int b) { return a-b; } public int multiply(int a, int b) { return a-b; } public int divide(int a, int b) { return a/b; }} 123456789@Autowiredprivate CaculateImpl caculate;@Testpublic void Test(){ caculate.add(1, 2); //class org.lc.aop.CaculateImpl$$EnhancerBySpringCGLIB$$92c177be System.out.println(caculate.getClass());} 5、切点表达式详解@Before(&quot;execution(访问修饰符 返回类型 类的全路径名.方法名(参数类型1,参数类型2...))&quot;) 1)匹配一个或多个字符 1@Before(\"execution(public int org.lc.aop.CaculateIm*.*(int,int))\") 2)匹配任意一个参数，第一个是int类型，第二个任意参数类型（匹配两个参数） 1@Before(\"execution(public int org.lc.aop.CaculateIm*.*(int,*))\") 3)匹配任意多个参数，任意参数类型 1@Before(\"execution(public int org.lc.aop.CaculateIm*.*(..))\") 4)匹配一层路径 即 aop和CaculateIm之间最多有一层路径 1@Before(\"execution(public int org.lc.aop.*.CaculateIm*.*(int,*))\") 5)匹配多层路径 即 aop和CaculateIm之间可以有任意层路径 1@Before(\"execution(public int org.lc.aop..CaculateIm*.*(int,*))\") 6)访问修饰符的位置不能写 * ，权限位置不写就行。 public关键字可选 7)最模糊的匹配(最好不要这样写) 任意包下的任意方法的任意参数的任意返回值 1@Before(\"execution(* *.*(..))\") 8)满足多个表达式&amp;&amp; 1execution(public int org.lc.aop.CaculateIm*.*(..))&amp;&amp;execution(public int org.lc.aop.CaculateIm*.*(int,int)) 8)满足一个表达式 || 1execution(public int org.lc.aop.CaculateIm*.*(int,double))||execution(public int org.lc.aop.CaculateIm*.*(int,int)) 9)不满足表达式 1!execution(public int org.lc.aop.CaculateIm*.*(..)) 6、AOP中的JoinPoint/返回值/异常对象JoinPoint必须放在参数列表的第一位 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354//切面类@Component@Aspectpublic class LogUtils { /** * 前置通知 * @param joinPoint 连接点，封装了目标方法的信息 */ @Before(\"execution(public int org.lc.aop.CaculateImpl.*(int,int))\") public static void startLog(JoinPoint joinPoint) { //获取方法的参数列表 Object[] args = joinPoint.getArgs(); //获取方法对象 Signature signature = joinPoint.getSignature(); //获取方法的名称 signature.getName(); //获取方法的访问修饰符 signature.getModifiers(); System.out.println(\"执行:【\" + signature.getName() + \"】方法之前的记录,方法的参数列表为【\"+Arrays.toString(args)+\"】\"); } /** * 返回通知(方法正常返回) * @param joinPoint 连接点，封装了目标方法的信息 * @param object 指定返回值 需要在注解中使用 returning = \"参数名称\"，告诉spring要使用什么参数作为返回值 * 注意：如果指定返回类型为 double，方法只能返回double的类型才会执行此 返回通知 * 所以我们在声明返回类型时，一般声明为较大范围的类型 */ @AfterReturning(value = \"execution(public int org.lc.aop.CaculateImpl.*(int,int))\",returning = \"object\") public static void returnLog(JoinPoint joinPoint,Object object) { System.out.println(\"执行:【\" + joinPoint.getSignature().getName() + \"】方法之后的记录,方法的结果为【\" + object + \"】\"); } /** * 异常通知 方法抛出异常执行 * @param joinPoint * @param e 方法抛出的异常类型 需要在注解中使用 throwing = \"参数名称\" ,告诉spring要使用什么参数作为返回值 * 注意：如果指定异常为 NullPointerException的异常，方法只能抛出的异常为NullPointerException的异常才会执行此 异常通知 * 所以我们在声明异常时，一般声明为较大范围的类型 */ @AfterThrowing(value = \"execution(public int org.lc.aop.CaculateImpl.*(int,int))\",throwing = \"e\") public static void exceptionLog(JoinPoint joinPoint,Exception e) { System.out.println(\"【\"+joinPoint.getSignature().getName()+\"】方法抛出的异常为:【\"+e+\"】\"); } /** * 后置通知 无论方法是否正常返回都执行 * @param joinPoint */ @After(\"execution(public int org.lc.aop.CaculateImpl.*(int,int))\") public static void finallyLog(JoinPoint joinPoint) { System.out.println(\"方法【\"+joinPoint.getSignature().getName()+\"】总要执行的记录....\"); }} 7、提取切点表达式实现重用 给定一个空的无参无返的方法 在方法上加入@Pointcut注解并加上重用的切点表达式 123456789101112131415161718//切面类@Component@Aspectpublic class LogUtils { /** * 1、给定一个空的无参无返的方法 * 2、在方法上加入@Pointcut注解并加上重用的切点表达式 */ @Pointcut(\"execution(public int org.lc.aop.CaculateImpl.*(int,int))\") public void myCutPointExpress(){ } @Before(\"myCutPointExpress()\") public static void startLog(JoinPoint joinPoint) { }} 8、@Around环绕通知的使用环绕通知集成了 前置通知，后置通知，返回通知，异常通知 为一体的通知 @Around内部就是一个 代理方法 相当于invoke.method(obj,args) 所以我们环绕通知的实现原理就是帮我们的切面类创建了一个代理对象，代理对象调用invoke.method(obj,args)来决定目标方法的执行时间和前后要处理的通知。而多层的切面，就相当于代理类调用的嵌套 12345678910111213141516171819202122232425262728293031323334353637383940414243//切面类@Component@Aspectpublic class LogUtils { /** * 1、给定一个空的无参无返的方法 * 2、在方法上加入@Pointcut注解并加上重用的切点表达式 */ @Pointcut(\"execution(public int org.lc.aop.CaculateImpl.*(int,int))\") public void myCutPointExpress(){ } /** * 环绕通知 * interface ProceedingJoinPoint extends JoinPoint 可以使用JoinPoint中的方法 * @return */ @Around(\"myCutPointExpress()\") public Object aroundAdvice(ProceedingJoinPoint pjp){ //获取当前执行方法的参数 Object[] args = pjp.getArgs(); //获取当前执行的方法 Signature signature = pjp.getSignature(); Object proceed=null; try { //@Before System.out.println(\"【前置通知】+【\"+signature.getName()+\"】方法执行之前的通知,方法的参数为【\"+Arrays.toString(args)+\"】\"); //相当于利用反射调用目标方法，相当于 invoke.method(obj,args) //帮我们执行目标方法 proceed = pjp.proceed(args); //@AfterReturing System.out.println(\"【返回通知】+【\"+signature.getName()+\"】方法返回之后的通知,方法结果为【\"+proceed+\"】\"); }catch (Throwable throwable) { //@AfterThrowing System.out.println(\"【异常通知】+【\"+signature.getName()+\"】方法执行异常的通知,异常原因为【\"+throwable.getCause()+\"】\"); }finally { //@After System.out.println(\"【后置通知】+【\"+signature.getName()+\"】方法最终执行的通知\"); } //将方法执行的结果返回出去 供外部接收使用 return proceed; }} 9、普通通知和环绕通知共存的执行顺序环绕通知总是优先于普通通知执行的，因为环绕通知控制了目标方法的执行时机，只有环绕通知内部执行了pjp.proceed(args);目标回调方法，普通通知才能运行 普通通知的执行顺序 【普通前置】 –&gt; 目标方法执行 –&gt;【普通后置】–&gt;【普通返回通知】/【异常通知】 环绕通知的执行顺序 【环绕前置】 –&gt; 目标方法执行 –&gt;【环绕返回/异常】–&gt;【环绕后置】 环绕通知和普通通知执行属性 【环绕前置】--&gt; 【普通前置】 --&gt;目标方法执行 --&gt; 【环绕正常返回/异常】--&gt; 【环绕后置】---&gt;【普通后置】--&gt; 【普通返回/异常】 &lt;!--￼132--&gt; 10、多切面AOP1)默认按照切面文件的开头字母顺序决定谁先切入方法，先切入的后返回 2)通过@Order注解指定文件的加载顺序，值越小越优先加载 3)切面类中的环绕通知并不会影响其他切面类 若切面L优先于切面A先执行，并且只有切面A中有环绕通知：则执行顺序如下 123456789【环绕L前置通知】+【add】方法执行之前的通知,方法的参数为【[1, 2]】【前置通知L】执行:【add】方法之前的记录,方法的参数列表为【[1, 2]】【前置通知A】执行:【add】方法之前的记录,方法的参数列表为【[1, 2]】【后置通知A】方法【add】总要执行的记录....【返回通知A】执行:【add】方法之后的记录,方法的结果为【3】【环绕L返回通知】+【add】方法返回之后的通知,方法结果为【3】【环绕L后置通知】+【add】方法最终执行的通知【后置通知L】方法【add】总要执行的记录....【返回通知L】执行:【add】方法之后的记录,方法的结果为【3】 11、AOP应用场景Authentication 权限 Caching 缓存 Context passing 内容传递 Error handling 错误处理 Lazy loading 懒加载 Debugging 调试 logging, tracing, profiling and monitoring 记录跟踪 优化 校准 Performance optimization 性能优化 Persistence 持久化 Resource pooling 资源池 Synchronization 同步 Transactions 事务 12、基于XML配置AOP 目标对象 1234567891011121314public class CaculateImpl{ public int add(int a, int b) { return a+b; } public int substract(int a, int b) { return a-b; } public int multiply(int a, int b) { return a-b; } public int divide(int a, int b) { return a/b; }} 切面类 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class BLogUtils { public static void startLog(JoinPoint joinPoint) { //获取方法的参数列表 Object[] args = joinPoint.getArgs(); //获取方法对象 Signature signature = joinPoint.getSignature(); System.out.println(\"【前置通知】执行:【\" + signature.getName() + \"】方法之前的记录,方法的参数列表为【\" + Arrays.toString(args) + \"】\"); } public static void returnLog(JoinPoint joinPoint, Object object) { System.out.println(\"【返回通知】执行:【\" + joinPoint.getSignature().getName() + \"】方法之后的记录,方法的结果为【\" + object + \"】\"); } public static void exceptionLog(JoinPoint joinPoint, Exception e) { System.out.println(\"【异常通知】【\" + joinPoint.getSignature().getName() + \"】方法抛出的异常为:【\" + e + \"】\"); } public static void finallyLog(JoinPoint joinPoint) { System.out.println(\"【后置通知】方法【\" + joinPoint.getSignature().getName() + \"】总要执行的记录....\"); } public Object aroundAdvice(ProceedingJoinPoint pjp) { //获取当前执行方法的参数 Object[] args = pjp.getArgs(); //获取当前执行的方法 Signature signature = pjp.getSignature(); Object proceed = null; try { System.out.println(\"【环绕前置通知】+【\" + signature.getName() + \"】方法执行之前的通知,方法的参数为【\" + Arrays.toString(args) + \"】\"); //相当于利用反射调用目标方法，相当于 invoke.method(obj,args) proceed = pjp.proceed(args); System.out.println(\"【环绕返回通知】+【\" + signature.getName() + \"】方法返回之后的通知,方法结果为【\" + proceed + \"】\"); } catch (Exception e) { System.out.println(\"【环绕异常通知】+【\" + signature.getName() + \"】方法执行异常的通知,异常原因为【\" + e + \"】\"); throw new RuntimeException(e); } catch (Throwable throwable) { throwable.printStackTrace(); } finally { System.out.println(\"【环绕后置通知】+【\" + signature.getName() + \"】方法最终执行的通知\"); } return proceed; }} xml配置 123456789101112131415161718192021222324252627282930313233343536373839&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!--注入目标对象--&gt; &lt;bean id=\"caculate\" class=\"org.lc.aop.CaculateImpl\"&gt;&lt;/bean&gt; &lt;!--注入切面类--&gt; &lt;bean id=\"bLogUtils\" class=\"org.lc.utils.BLogUtils\"&gt;&lt;/bean&gt; &lt;!--AOP配置--&gt; &lt;aop:config&gt; &lt;!--配置切点表达式，声明在切面外部，供整个AOP中的其他切面中使用，为全局切点表达式--&gt; &lt;aop:pointcut id=\"mypoint2\" expression=\"execution(* org.lc.aop.CaculateImpl.*(int,int))\"/&gt; &lt;!--指定切面类，引用外部注入的切面类--&gt; &lt;aop:aspect ref=\"bLogUtils\"&gt; &lt;!--配置切点表达式，相当于在bLogUtils切面类中声明的切点表达式，只能在本切面类使用--&gt; &lt;aop:pointcut id=\"mypoint1\" expression=\"execution(* org.lc.aop.CaculateImpl.*(int,int))\"/&gt; &lt;!--配置环绕通知，并引用切点表达式。 注意：若环绕通知配置在其他通知后，则环绕前置和普通前置顺序颠倒--&gt; &lt;aop:around method=\"aroundAdvice\" pointcut-ref=\"mypoint1\"&gt;&lt;/aop:around&gt; &lt;!--配置前置通知, 并自定义切点表达式--&gt; &lt;aop:before method=\"startLog\" pointcut=\"execution(* org.lc.aop.CaculateImpl.*(int,int))\"&gt;&lt;/aop:before&gt; &lt;!--配置返回通知,并引用切点表达式，并指定作为返回值的参数--&gt; &lt;aop:after-returning method=\"returnLog\" returning=\"object\" pointcut-ref=\"mypoint1\"&gt;&lt;/aop:after-returning&gt; &lt;!--配置异常通知，并引用切点表达式，并指定作为异常对象的参数--&gt; &lt;aop:after-throwing method=\"exceptionLog\" pointcut-ref=\"mypoint1\" throwing=\"e\"&gt;&lt;/aop:after-throwing&gt; &lt;!--配置后置通知，并指定切点表达式--&gt; &lt;aop:after method=\"finallyLog\" pointcut-ref=\"mypoint1\"&gt;&lt;/aop:after&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 123456789101112//classpath: 使用指定的xml文件@ContextConfiguration(locations = \"classpath:applicationContext.xml\")//使用junit4测试@RunWith(SpringJUnit4ClassRunner.class)public class SpringTest { @Autowired private CaculateImpl caculate; @Test public void Test(){ caculate.add(1, 2); }} 123456【环绕前置通知】+【add】方法执行之前的通知,方法的参数为【[1, 2]】【前置通知】执行:【add】方法之前的记录,方法的参数列表为【[1, 2]】【环绕返回通知】+【add】方法返回之后的通知,方法结果为【3】【环绕后置通知】+【add】方法最终执行的通知【返回通知】执行:【add】方法之后的记录,方法的结果为【3】【后置通知】方法【add】总要执行的记录.... 13、XML配置多切面12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsdhttp://www.springframework.org/schema/contexthttp://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!--注入目标对象--&gt; &lt;bean id=\"caculate\" class=\"org.lc.aop.CaculateImpl\"&gt;&lt;/bean&gt; &lt;!--注入切面类BLogUtils--&gt; &lt;bean id=\"bLogUtils\" class=\"org.lc.utils.BLogUtils\"&gt;&lt;/bean&gt; &lt;!--注入切面类LogUtils--&gt; &lt;bean id=\"logUtils\" class=\"org.lc.utils.LogUtils\"&gt;&lt;/bean&gt; &lt;!--AOP配置--&gt; &lt;aop:config&gt; &lt;!--配置切点表达式，声明在切面外部，供整个AOP中的其他切面中使用，为全局切点表达式--&gt; &lt;aop:pointcut id=\"globalPoincut\" expression=\"execution(* org.lc.aop.CaculateImpl.*(int,int))\"/&gt; &lt;!--指定切面类BLogUtils，引用外部注入的切面类bLogUtils--&gt; &lt;!--使用order绝对执行的先后顺序，小的先执行--&gt; &lt;aop:aspect ref=\"bLogUtils\" order=\"2\"&gt; &lt;!--配置切点表达式，相当于在bLogUtils切面类中声明的切点表达式，只能在本切面类使用--&gt; &lt;aop:pointcut id=\"mypoint1\" expression=\"execution(* org.lc.aop.CaculateImpl.*(int,int))\"/&gt; &lt;!--配置环绕通知，并引用切点表达式。 注意：若环绕通知配置在其他通知后，则环绕前置通知顺序会乱--&gt; &lt;aop:around method=\"aroundAdvice\" pointcut-ref=\"mypoint1\"&gt;&lt;/aop:around&gt; &lt;!--配置前置通知, 并自定义切点表达式--&gt; &lt;aop:before method=\"startLog\" pointcut=\"execution(* org.lc.aop.CaculateImpl.*(int,int))\"&gt;&lt;/aop:before&gt; &lt;!--配置返回通知,并引用切点表达式，并指定作为返回值的参数--&gt; &lt;aop:after-returning method=\"returnLog\" returning=\"object\" pointcut-ref=\"mypoint1\"&gt;&lt;/aop:after-returning&gt; &lt;!--配置异常通知，并引用切点表达式，并指定作为异常对象的参数--&gt; &lt;aop:after-throwing method=\"exceptionLog\" pointcut-ref=\"mypoint1\" throwing=\"e\"&gt;&lt;/aop:after-throwing&gt; &lt;!--配置后置通知，并指定切点表达式--&gt; &lt;aop:after method=\"finallyLog\" pointcut-ref=\"mypoint1\"&gt;&lt;/aop:after&gt; &lt;/aop:aspect&gt; &lt;!--指定切面类LogUtils，引用外部注入的切面类logUtils--&gt; &lt;!--使用order绝对执行的先后顺序，小的先执行--&gt; &lt;aop:aspect ref=\"logUtils\" order=\"1\"&gt; &lt;!--配置环绕通知，并引用切点表达式。注意：若环绕通知配置在其他通知后，则环绕前置通知顺序会乱--&gt; &lt;aop:around method=\"aroundAdvice\" pointcut-ref=\"globalPoincut\"&gt;&lt;/aop:around&gt; &lt;!--配置前置通知, 并自定义切点表达式--&gt; &lt;aop:before method=\"startLog\" pointcut=\"execution(* org.lc.aop.CaculateImpl.*(int,int))\"&gt;&lt;/aop:before&gt; &lt;!--配置返回通知,并引用切点表达式，并指定作为返回值的参数--&gt; &lt;aop:after-returning method=\"returnLog\" returning=\"object\" pointcut-ref=\"globalPoincut\"&gt;&lt;/aop:after-returning&gt; &lt;!--配置异常通知，并引用切点表达式，并指定作为异常对象的参数--&gt; &lt;aop:after-throwing method=\"exceptionLog\" pointcut-ref=\"mypoint1\" throwing=\"e\"&gt;&lt;/aop:after-throwing&gt; &lt;!--配置后置通知，并指定切点表达式--&gt; &lt;aop:after method=\"finallyLog\" pointcut-ref=\"globalPoincut\"&gt;&lt;/aop:after&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 三、事务1、数据库事务及四大特性(ACID)​ 数据库事务（Transaction）是由若干个SQL语句构成的一个操作序列，有点类似于Java的synchronized同步。数据库系统保证在一个事务中的所有SQL要么全部执行成功，要么全部不执行，即数据库事务具有ACID特性： 原子性(Atomicity):事务中的所有操作作为一个整体像原子一样不可分割，要么全部成功,要么全部失败。 一致性 (Consistency):事务执行后，数据库状态与其他业务规则保持一致。如转账业务，无论事务执行成功否，参与转账的两个账号余额之和应该是不变的。 隔离性(Isolation):并发执行的事务不会相互影响,其对数据库的影响和它们串行执行时一样。比如多个用户同时往一个账户转账,最后账户的结果应该和他们按先后次序转账的结果一样。 持久性(Durability):事务一旦提交,其对数据库的更新就是持久的。任何事务或系统故障都不会导致数据丢失。 2、MySQL中的事务在默认情况下，MySQL**每执行一条SQL语句，都是一个单独的事务**。如果需要在一个事务中包含多条SQL语句，那么需要开启事务和结束事务。 开启事务：start transaction 业务SQL操作…….. 结束事务：commit或rollback ​ 在执行SQL语句之前，先执行start transaction，这就开启了一个事务（事务的起点），然后可以去执行多条SQL语句，最后要结束事务，commit表示提交，即事务中的多条SQL语句所作出的影响会持久到数据库中，或者rollback，表示回滚到事务的起点，之前做的所有操作都被撤销了。 1)修改MySQL隔离级别(默认为可重复读)SET [SESSION] | GLOBAL] TRANSACTION ISOLATION LEVEL {READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE} SESSION 当前会话； GLOBAL全局的； READ UNCOMMITTED 读未提交；READ COMMITTED 读已提交；REPEATABLE READ 可重复读；SERIALIZABLE 串行化 例如： SET SESSION TRANSACTION IOSLATION LEVEL READ UNCOMMITTED 设置当前会话事务的隔离级别为 读未提交 事务隔离级别 脏读 不可重复读 幻读 读未提交（read-uncommitted） √ √ √ 不可重复读（read-committed） × √ √ 可重复读（repeatable-read） × × √ 串行化（serializable） × × × 2)查询MySQL的隔离级别123SELECT @@global.tx_isolation ##查询全局隔离级别SELECT @@session.tx_isolation ##查询当前会话隔离级别 (若我们用cmd进入mysql服务，则一个窗口代表一个会话)SELECT @@tx_isolation ##同上 3)MySQL事务操作开启事务：start transaction 提交事务：commit 回滚事务：rollback 2、JDBC中的事务处理在JDBC中处理事务，都是通过Connection完成的。 同一事务中所有的操作，都在使用同一个Connection对象。 ①JDBC中的事务 Connection的三个方法与事务有关： setAutoCommit（boolean）:设置是否为自动提交事务，如果true（默认值为true）表示自动提交，也就是每条执行的SQL语句都是一个单独的事务，如果设置为false，那么相当于开启了事务了；con.setAutoCommit(false) 表示开启事务。 commit（）：提交结束事务。 rollback（）：回滚结束事务。 12345678910111213 Connection con = 拿到连接，通过连接完成事务操作try{ //开启事务 并关闭自动提交事务 con.setAutoCommit(false); /** * *业务逻辑处理 * **/ con.commit();//try的最后提交事务 } catch(Exception e) { con.rollback();//回滚事务} 3、配置声明式(注解)事务声明式事务就好像我们使用AOP中的环绕通知一样来实现JDBC中的事务操作。 我们只需要在需要回滚的方法上加上一个类似于环绕通知的注解(@Transaction)来实现方法的回滚 我们的Spring已经为我们提供了一个切面类 PlatformTransactionManager 的抽象接口 我们只需要配置其实现该接口的不同数据库操作方法的事务管理器即可 JPA 使用的：JtaTransactionManager 事务管理器 Hibernate使用的：HibernateTransactionManager 事务管理器 JDBCTemplate使用的 : DataSourceTransactionManager 事务管理器 配置流程： 1)配置数据源 2)配置事务管理器(相当于切面类),并指定数据源 3)开启基于注解的事务控制,并指定事务管理器 表 123456789101112131415161718CREATE TABLE `account` ( `username` varchar(50) NOT NULL, `balance` int(11) NOT NULL, PRIMARY KEY (`username`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;CREATE TABLE `book` ( `isbn` varchar(50) NOT NULL, `book_name` varchar(100) DEFAULT NULL, `price` int(11) DEFAULT NULL, PRIMARY KEY (`isbn`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;CREATE TABLE `book_stock` ( `isbn` varchar(50) NOT NULL, `stock` int(11) DEFAULT NULL, PRIMARY KEY (`isbn`)) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4; dao层 12345678910111213141516171819202122232425262728293031323334353637@Repositorypublic class BookDao { @Autowired private JdbcTemplate jdbcTemplate; /** * 减去某个用户的余额 * @param username * @param money */ public void updataBalance(String username, int money) { String sql = \"update account set balance=balance-? where username=?\"; jdbcTemplate.update(sql, money, username); } /** * 按照ISBN号码获取图书的价格 * @param isbn * @return */ public int getPrice(String isbn) { String sql = \"SELECT price from book where isbn=?\"; return jdbcTemplate.queryForObject(sql,Integer.class, isbn); } /** * 按照ISBN号码减去库存 * 这里我们设置每次减1 * @param isbn */ public void updateStock(String isbn) { String sql = \"update book_stock set stock=stock-1 where isbn=?\"; jdbcTemplate.update(sql, isbn); }} service层 在需要回滚的业务方法上加@Transactional注解 1234567891011121314151617181920212223@Servicepublic class BookService { @Autowired private BookDao bookDao; /** * 结账 * @param username * @param isbn */ //在需要回滚的业务方法上加@Transactional注解 @Transactional public void checkout(String username, String isbn) { //减库存 bookDao.updateStock(isbn); //查询图书价格 int price = bookDao.getPrice(isbn); //减余额 bookDao.updataBalance(username, price); }} 核心xml配置文件 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:property-placeholder location=\"classpath:jdbc.properties\"/&gt; &lt;context:component-scan base-package=\"org.lc\"&gt;&lt;/context:component-scan&gt; &lt;!--注入数据源--&gt; &lt;bean id=\"druidDataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"&gt; &lt;property name=\"username\" value=\"${jdbc.username}\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"${jdbc.password}\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"${jdbc.url}\"&gt;&lt;/property&gt; &lt;property name=\"driverClassName\" value=\"${jdbc.dirverClass}\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--配置jdbctemplate--&gt; &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt; &lt;property name=\"dataSource\" ref=\"druidDataSource\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--事务控制--&gt; &lt;!--配置事务管理器(相当于切面类)进行事务控制--&gt; &lt;bean id=\"dataSourceTransactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;!--我们控制事务管理器，就是要控制数据源，因为都是通过连接对象来进行事务的提交和回滚--&gt; &lt;!--控制数据源--&gt; &lt;property name=\"dataSource\" ref=\"druidDataSource\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--开启基于注解的事务控制,并指定事务管理器--&gt; &lt;!--在方法上加@Transaction注解--&gt; &lt;tx:annotation-driven transaction-manager=\"dataSourceTransactionManager\"&gt;&lt;/tx:annotation-driven&gt;&lt;/beans&gt; 测试: 1234567891011121314@ContextConfiguration(locations = \"classpath:tx.xml\")@RunWith(SpringJUnit4ClassRunner.class)public class TranscationTest { @Autowired private BookService bookService; @Test public void Test(){ //在此方法操作中，只要有一步出错，则全部回滚 bookService.checkout(\"Tom\",\"ISBN-001\"); System.out.println(\"结账成功！\"); }} 4、@Transaction注解属性详解 @Transaction 12345678910111213141516171819202122232425262728@Target({ElementType.TYPE, ElementType.METHOD})@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface Transactional { @AliasFor(\"transactionManager\") String value() default \"\"; @AliasFor(\"value\") String transactionManager() default \"\"; Propagation propagation() default Propagation.REQUIRED; Isolation isolation() default Isolation.DEFAULT; //设置超时回滚 int timeout() default -1; boolean readOnly() default false; Class&lt;? extends Throwable&gt;[] rollbackFor() default {}; String[] rollbackForClassName() default {}; Class&lt;? extends Throwable&gt;[] noRollbackFor() default {}; String[] noRollbackForClassName() default {};} 0)transactionManager 配置多事务管理器若配置多数据源则需要配置多事务管理器 在使用的使用指定@Transacation(transactionManager =&quot;&quot;)的事务管理器 1)timeout(单位秒)事务超出指定执行时长后自动终止并回滚 设置的timeout为3秒，若执行业务操作的时间超过3秒则会业务回滚，并抛出以下异常 org.springframework.transaction.TransactionTimedOutException: 1234567891011121314@Transactional(timeout = 3)public void checkout(String username, String isbn) { //减库存 bookDao.updateStock(isbn); try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } //查询图书价格 int price = bookDao.getPrice(isbn); //减余额 bookDao.updataBalance(username, price);} 2)readOnly设置事务为只读事务，可以进行事务优化，加快查询速度。忽略并发安全和一些繁琐的操作 设置为只读事务的方法中只能有查询操作，不能有修改操作，否则会报错： org.springframework.dao.TransientDataAccessResourceException: PreparedStatementCallback; 12//默认为false@Transactional(readOnly = true) 3)事务回滚异常分类默认发生运行时异常都回滚，发生编译时异常不会回滚 运行时异常(非检查异常)：可以不用处理，默认都回滚。 例如 空指针异常，数组索引越界异常等 编译时异常(检查异常)：通过try-catch，或在方法上声明throws的异常默认不回滚。 例如 文件读写流等 注意： 所有被try-catch（包括运行时异常和非运行异常）的异常都不会回滚 运行时异常 只有通过throw或throws抛出异常才会回滚 非运行时异常默认不会回滚(因为运行之前就已经被try-catch了)，通过throw和throws抛出异常也不会回滚。只有设置rollbackFor指定其非运行时异常，通过thows抛出的异常才能回滚。 4)指定不回滚异常设置哪些异常不会回滚；可以设置让回滚的异常不回滚。 ②noRollbackForClassName(不常用) 指定不会滚异常的全路径类名 @Transactional(noRollbackForClassName = {&quot;java.lang.ArithmeticException&quot;}) ①noRollbackFor 指定不回滚异常的Class类 @Transactional(noRollbackFor = {ArithmeticException.class,NullPointerException.class}) 设置 算数异常 和 空指针异常不会滚。(默认是运行时异常都要回滚) 12345678910111213 @Transactional(noRollbackFor = {ArithmeticException.class,NullPointerException.class}) public void checkout(String username, String isbn) { //减库存 bookDao.updateStock(isbn); //查询图书价格 int price = bookDao.getPrice(isbn); //减余额 bookDao.updataBalance(username, price); //遇到此异常不会回滚 (默认回滚) int i=1/0; }} 5)指定回滚异常设置哪些异常会回滚；可以让不会滚的异常发生回滚 ①rollbackForClassName(不常用) 指定会滚异常的全路径类名 @Transactional(rollbackForClassName = {&quot;java.io.FileNotFoundException&quot;}) ②rollbackFor 指定回滚异常的Class类 @Transactional(rollbackFor = {FileNotFoundException.class}) 设置 文件找不到异常 会回滚。(默认是编译时异常不回滚) 注意： 只有通过throws抛出异常才会回滚，如果try-catch则无效 12345678910111213 @Transactional(rollbackFor = {FileNotFoundException.class}) public void checkout(String username, String isbn) throws FileNotFoundException { //减库存 bookDao.updateStock(isbn); //查询图书价格 int price = bookDao.getPrice(isbn); //减余额 bookDao.updataBalance(username, price); //找不到文件回滚。 (默认不回滚) new FileInputStream(\"f://ddd\"); }} 6)事务的隔离级别@Transactional(isolation = Isolation.REPEATABLE_READ ) 默认隔离级别DEFAULT， 使用数据库设置的隔离级别 ( 默认 ) ，由 DBA 默认的设置来决定隔离级别 。 1234567891011121314public enum Isolation { DEFAULT(-1), READ_UNCOMMITTED(1), READ_COMMITTED(2), REPEATABLE_READ(4), SERIALIZABLE(8); private final int value; private Isolation(int value) { this.value = value; } public int value() { return this.value; }} 多个事务并发操作产生的问题，假设现在有两个事务T1和T2 ①读未提交(READ UNCOMMITTED)–产生脏读和不可重复读和幻读允许T1读取T2未提交后的修改数据，产生脏读。 ②读已提交(READ COMMITTED)–避免脏读，产生不可重复读和幻读事务T1不能够读取到T2未提交修改的数据。读已提交能够避免脏读。但是不能保证可重复读。 ③可重复读(READ COMMITTED)–避免脏读和不可重复读，产生幻读可重复读为MySQL默认的隔离级别，可重复读也叫快照读，即事物T1第一次读数据的时候，留下一个快照，T2事物对其数据进行任意操作(更新，删除)，事物T1都是从快照中读取，数据保持一致，即便数据从数据库中删除，只要T1还未结束当前事务，读取到的数据依然和开始的不变。 1)什么是幻读？ InnoDB实现的RR通过mvcc机制避免了这种幻读现象。 事务B执行插入操作后，在事务A中查询没有查到B添加的数据行，这就是可重复读。 但是，在事务A执行了对事务B中插入的数据进行update后，再查询时就查到了事务B中添加的数据，这就是幻读。 这种结果告诉我们其实在MySQL可重复读的隔离级别中并不是完全解决了幻读的问题，而是解决了读数据情况下的幻读问题。而对于修改的操作依旧存在幻读问题，就是说MVCC对于幻读的解决是不彻底的。 ④串行化(SERIALIZABLE)–避免一切确保事务T1可以多次从一个表中读取到相同的行，在T1事务执行期间，禁止其他事务对这个表添加，更新，删除操作，可以避免任何并发问题，但是其性能十分低下。 7)事务的传播行为@Transactional(propagation = Propagation.REQUIRED) 默认的传播行为REQUIRED 12345678910111213141516public enum Propagation { REQUIRED(0), SUPPORTS(1), MANDATORY(2), REQUIRES_NEW(3), NOT_SUPPORTED(4), NEVER(5), NESTED(6); private final int value; private Propagation(int value) { this.value = value; } public int value() { return this.value; }} 事务传播行为类型 说明 支持当前事务情况：↓ PROPAGATION_REQUIRED 如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。Spring中的默认的传播行为，常用。 PROPAGATION_SUPPORTS 如果当前存在事务,则加入该事务;如果当前没有事务,则以非事务的方式继续运行。 PROPAGATION_MANDATORY 如果当前存在事务,则加入该事务;如果当前没有事务,则抛出异常。(mandatory:强制性) 不支持当前事务：↓ PROPAGATION_REQUIRES_NEW 创建一个新的事务,如果当前存在事务,则把当前事务挂起。常用。 PROPAGATION_NOT_SUPPORTED 以非事务方式运行,如果当前存在事务,则把当前事务挂起。 PROPAGATION_NEVER 以非事务方式运行,如果当前存在事务,则抛出异常。 其他情况：↓ PROPAGATION_NESTED 如果当前存在事务,则创建一个事务作为当前事务的嵌套事务来运行;如果当前没有事务,则该取值等价于PROPAGATION_REQUIRED。 REQUIRES_NEW和REQUIRED传播行为详解 DAO层 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647@Repositorypublic class BookDao { @Autowired private JdbcTemplate jdbcTemplate; /** * 减去某个用户的余额 * @param username * @param money */ public void updataBalance(String username, int money) { String sql = \"update account set balance=balance-? where username=?\"; jdbcTemplate.update(sql, money, username); } /** * 按照ISBN号码获取图书的价格 * @param isbn * @return */ public int getPrice(String isbn) { String sql = \"SELECT price from book where isbn=?\"; return jdbcTemplate.queryForObject(sql,Integer.class, isbn); } /** * 按照ISBN号码减去库存 * 这里我们设置每次减1 * @param isbn */ public void updateStock(String isbn) { String sql = \"update book_stock set stock=stock-1 where isbn=?\"; jdbcTemplate.update(sql, isbn); } /** * 根据 isbn修改书的价格 * @param isbn * @param price */ public void updatePrice(String isbn, int price) { String sql=\"update book set price=? where isbn=?\"; jdbcTemplate.update(sql, price, isbn); }} service层 (内层事务) 1234567891011121314151617181920212223242526272829@Servicepublic class BookService { @Autowired private BookDao bookDao; /** * 结账 * @param username * @param isbn */ @Transactional(propagation = Propagation.REQUIRES_NEW) public void checkout(String username, String isbn){ //减库存 bookDao.updateStock(isbn); //查询图书价格 int price = bookDao.getPrice(isbn); //减余额 bookDao.updataBalance(username, price); // int i=1/0; } @Transactional(propagation =Propagation.REQUIRED) public void updatePrice(String isbn, int price) { bookDao.updatePrice(isbn, price); int i=1/0; }} service (外层事务） 12345678910111213141516171819@Servicepublic class MultipleTransactionService { @Autowired private BookService bookService; //外层事务 @Transactional public void multipleTran() { //内层事务1 bookService.checkout(\"Tom\", \"ISBN-001\"); //内层事务2 bookService.updatePrice(\"ISBN-003\",500); // int i=1/0; }} 测试代码 12345678910@ContextConfiguration(locations = \"classpath:tx.xml\")@RunWith(SpringJUnit4ClassRunner.class)public class TranscationTest { @Autowired private MultipleTransactionService multipleTransactionService; @Test public void Test1(){ multipleTransactionService.multipleTran(); }} 外层事务默认为 REQUIRES 注意：下面的异常必须为抛出异常 ，try-catch异常不会回滚。 当内部事务1和内部事务2的传播行为是REQUIRES_NEW , 无论外层事务是否发生异常，内部事务都回新建一个自己的事务，不会回滚 当内部事务1和内部事务2的传播行为是REQUIRES , 内部事务会依赖外部事务，外层事务发生异常，内部事务全部回滚 当内部事务1为REQUIRES ，事务2位REQUIRES_NEW, 当内部事务1发生异常，则会向上抛出，若事务1在事务2前面执行，那么事务2并不会执行，事务1提前回滚。 当内部事务1为REQUIRES_NEW ，事务2位REQUIRES, 当内部事务2发生异常，则会向上抛出，事务1新建事务运行并不会回滚，事务2回滚。 若内部事务依赖于外部事务，那么在内部事务设置的其他属性如：timeout并不会生效，需要在外部事务上设置。 不能在同一Service类中实现事务嵌套，否则无效，例如： @Service class MultipleService{ @Autowired private BookDao bookDao; @Transaction void mA(){} @Transaction void mB(){} @Transaction void mC(){ //失效，相当于三个事务为同一个事务 mA(); mB(); } } &lt;!--￼158--&gt; xml配置 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;context:property-placeholder location=\"classpath:jdbc.properties\"/&gt; &lt;context:component-scan base-package=\"org.lc\"&gt;&lt;/context:component-scan&gt; &lt;!--注入数据源--&gt; &lt;bean id=\"druidDataSource\" class=\"com.alibaba.druid.pool.DruidDataSource\"&gt; &lt;property name=\"username\" value=\"${jdbc.username}\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"${jdbc.password}\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"${jdbc.url}\"&gt;&lt;/property&gt; &lt;property name=\"driverClassName\" value=\"${jdbc.dirverClass}\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--配置jdbctemplate--&gt; &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt; &lt;property name=\"dataSource\" ref=\"druidDataSource\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--事务控制--&gt; &lt;!--配置事务管理器(相当于切面类)进行事务控制--&gt; &lt;bean id=\"dataSourceTransactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;!--我们控制事务管理器，就是要控制数据源，因为都是通过连接对象来进行事务的提交和回滚--&gt; &lt;!--控制数据源--&gt; &lt;property name=\"dataSource\" ref=\"druidDataSource\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;aop:config&gt; &lt;!--定义切点表达式 指定哪些方法需要增强--&gt; &lt;!--指定ser开头的包及其下面的任意包和任意方法作为切点--&gt; &lt;aop:pointcut id=\"txPoint\" expression=\"execution(* org.lc.ser*.*.*(..))\"/&gt; &lt;!--事务增强 advice-ref:配置哪些方法需要进行事务的配置 pointcut-ref：指定哪些方法需要进行增强 --&gt; &lt;aop:advisor advice-ref=\"myAdvice\" pointcut-ref=\"txPoint\"&gt;&lt;/aop:advisor&gt; &lt;/aop:config&gt; &lt;!--配置事务增强 transaction-manager：指定事务管理器--&gt; &lt;tx:advice id=\"myAdvice\" transaction-manager=\"dataSourceTransactionManager\"&gt; &lt;!--配置事务属性--&gt; &lt;!--指定增强的方法的事务属性配置--&gt; &lt;tx:attributes&gt; &lt;!--为所有方法配置 事务--&gt; &lt;tx:method name=\"*\"/&gt; &lt;!--为checkout 配送事务传播行为 REQUIRED，隔离级别REPEATABLE_READ，超时值 -1(永远不会超时)--&gt; &lt;tx:method name=\"checkout\" propagation=\"REQUIRED\" timeout=\"-1\" isolation=\"REPEATABLE_READ\" /&gt; &lt;!--为所有get开头的方法 设为只读--&gt; &lt;tx:method name=\"get*\" read-only=\"true\"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt;&lt;/beans&gt; 6、事务失效的几种情况","link":"/2020/07/24/ssm/Spring/"},{"title":"深入理解JVM虚拟机","text":"Ⅰ、jvm简介一、什么是JVMjava虚拟机(java virtual machine) java程序的运行环境(java二进制字节码的运行环境) 好处： 一次编写，导出运行 自动内存管理，垃圾回收功能 多态 数组下标越界检查 … 二、jre、jdk、jvm的区别？ ### 三、JVM组成部分 四、常见的jvm Ⅱ、JVM内存结构一、程序计数器(Program Counter Register) 1.1定义Program Counter Register 程序计数器（寄存器） java程序执行流程：首先java源代码编译成 –&gt; 二进制字节码(包含一系列jvm指令)–&gt; 通过解释器解释成机器码–&gt;机器码交给cpu识别运行 程序计数器实现：在物理实现上是寄存器实现的 作用：是记住下一条jvm指令的执行地址 (例如执行地址0 的代码getstatic,那么jvm就会存储3所对应的地址astore_1) 特点： 线程私有 不会存在内存溢出 二、虚拟机栈(Java Virtual Machine Stacks ) 2.1定义Java Virtual Machine Stacks （Java 虚拟机栈） 栈中存的是基本数据类型和堆中对象的引用 每个线程运行时所分配的内存为虚拟机栈，jvm为每个线程分配一个虚拟机栈 每个栈有多个栈帧(Frame)组成,对应着每个方法调用时的所占用的内存(每个运行的方法对应一个栈帧) 每个线程只能有一个活动栈帧(正在执行的那个方法)、对应着当前正在执行的那个方法 2.2栈演示：12345678910111213public class T1 { public static void main(String[] args) { method1(); } static void method1() { method2(2,3); } private static int method2(int a, int b) { return a+b; }} 方法执行过程通过压栈的方式，为每一个方法分配一个栈帧，方法执行完后，采用先进后出的方式依次出栈。 2.3问题辨析①垃圾回收是否涉及栈内存？不涉及，栈帧对应着一个一个的方法，方法执行完后，将出栈，自动释放内存。垃圾回收只是对堆内存回收 ②栈内存越大越好吗？可通过-Xss分配栈的内存，默认根据机器的内存自动分配。若本机内存500M,栈内存设置为1M,那么可以创建500个线程来使用分配栈的内存 ③方法内的局部变量是否线程安全？不会，每个线程对应一个虚拟机栈，方法的执行对应每一个栈帧，内存相互独立，不会干扰。 如果方法内的局部变量没有逃离方法的作用范围，则线程安全 若引用类型的变量通过方法传参，返回值返回则非线程安全 2.4栈内存溢出(StackOverflowError)①栈帧过多导致内存溢出(方法的递归调用)②栈帧过大导致栈内存溢出(-Xss)12345678910111213141516public class T2 { static int count; public static void main(String[] args) { try { method1(); } catch (Throwable e) { e.printStackTrace(); System.out.println(count); } } static void method1() { count++; method1(); }} 1234java.lang.StackOverflowError at org.lc.jvm_stack.T2.method1(T2.java:23) //....18340 上述递归方法执行了18340后出现栈的溢出，我们可以通过修改栈的内存大小为512K来让栈更快溢出 1234java.lang.StackOverflowError at org.lc.jvm_stack.T2.method1(T2.java:23) //....6617 这次只递归调用了6617此即溢出 ③线程运行诊断(jstack)1)cpu过高(线程高负荷运行没有终止)例如：线程中没有终止的条件对while(true)循环 用top定位哪个进程对cpu的占用过高 ps H -eo pid,tid,%cpu | grep 进程id（用ps命令进一步定位是哪个线程引起的cpu占用过高） H: 展示所有进程中的所有线程信息 eo: 输出指定内容 pid:进程id tid:线程id %cpu: cpu占用信息 | grep 进程id : 利用管道操作符查找匹配进程id 找到占用高的cpu的线程后，记住进程id，使用 jstack 进程id jstack 进程id 列出该进程下的所有线程信息 可以根据线程id 找到有问题的线程，进一步定位到问题代码的源码行号。因为使用jstack展示的线程信息的id为16进制,所以我们需要将占用cpu高的线程tid，32665转换为16进制为7F99，找到7F99对应的线程thread1，找到出问题的代码行数 2)程序运行很长时间没有结果 (死锁)三、本地方法栈(Native Method Stacks) 为本地的方法提供一块内存空间；例如Object中的wait,clone,sleep方法，方法用native修饰 四、堆(Heap) 4.1定义Heap 堆 通过 new 关键字，创建对象都会使用堆内存。jdk&gt;=1.7类的静态变量也存在堆中。jdk&lt;=1.6类的静态变量存在方法区 特点: 它是线程共享的，堆中对象都需要考虑线程安全的问题 有垃圾回收机制 4.2堆内存溢出(OutofMemoryError)(-Xmx)123456789101112131415public class T1 { public static void main(String[] args) { int i=0; try { String a = \"hello\"; while (true) { a=a+a; //会不断创建字符串进行拼接，该对象一直不被释放 i++; } } catch (Throwable throwable) { throwable.printStackTrace(); System.out.println(i); } }} 123456java.lang.OutOfMemoryError: Java heap space at java.util.Arrays.copyOfRange(Arrays.java:3664) at java.lang.String.&lt;init&gt;(String.java:207) at java.lang.StringBuilder.toString(StringBuilder.java:407) at org.lc.jvm_heap.T1.main(T1.java:16)26 通过参数-Xmx修改堆内存大小为8M缩短堆内存的溢出时间 1234567java.lang.OutOfMemoryError: Java heap space at java.util.Arrays.copyOf(Arrays.java:3332) at java.lang.AbstractStringBuilder.ensureCapacityInternal(AbstractStringBuilder.java:124) at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:448) at java.lang.StringBuilder.append(StringBuilder.java:136) at org.lc.jvm_heap.T1.main(T1.java:16)17 4.3堆内存诊断①jps 工具 模拟高内存占用代码 12345678910111213public class T2 { public static void main(String[] args) throws InterruptedException { System.out.println(\"1.....\"); Thread.sleep(30000); byte[] array=new byte[1024*1024*10]; System.out.println(\"2....\"); Thread.sleep(30000); array=null; System.gc();//垃圾回收 System.out.println(\"3....\"); Thread.sleep(100000000L); }} 查看当前系统中S哪些 java 进程 ②jmap 工具 查看堆内存占用情况 jmap - heap 进程id ③jconsole工具 图形界面的，多功能的监测工具，可以连续监测 直接输入jconsole命令即可 ④jvisualvm工具(高内存占用)程序运行很长时间没有结果 模拟代码 123456789101112public class T3 { public static void main(String[] args) throws InterruptedException { List&lt;Student&gt; list=new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 200; i++) { list.add(new Student()); } Thread.sleep(100000000L); }}class Student { private byte[] big = new byte[1024 * 1024];} 我们首先使用jconsole工具来查看，并执行GC 我们发现虽然执行GC回收了一些内存，但是但是占用很高的内存。这时我们使用jvisualvm命令 执行堆Dump，对内存进行快照 点击查找 点击进入占用内存大的类 我们查看elementData存储的为元素Size有200个,每个元素占用1M作用。查看代码找出问题 五、方法区(Method Area) 5.1定义官方：https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4 ​ Java虚拟机有一个区域的方法,是所有Java虚拟机线程之间共享。方法区域类似于编译代码的存储区域传统语言或类似于“文本”段在一个操作系统的过程。它存储每个类结构如运行时常量池、字段和方法的数据和方法和构造函数的代码,包括特殊方法(§2.9)中使用的类和实例初始化和接口初始化(类的构造器)。方法区在jvm启动时创建，逻辑上(概念)是堆的组成部分。所以我们的方法区只是一种规范，方法区的实现由不同厂商决定，不强制它的实现位置。 5.2组成在我们使用的Oracle的jdk实现版本中，方法区的实现如下： jdk1.6 method Area只是一种概念。具体的实现是永久代(PermGen) StringTable为串池 jdk1.8 方法区的实现由永久代废弃，变为元空间(Metaspace)的实现，占用的内存为本地内存，即操作系统的内存 5.3方法区内存溢出(-XX:MaxMetaspaceSize) 测试代码 123456789101112131415161718192021//ClassLoader: 用来加载类的二进制字节码public class T4 extends ClassLoader{ public static void main(String[] args) { int j=0; try { T4 test=new T4(); for (int i = 0; i &lt; 10000; i++,j++) { //ClassWriter 作用是生成类的二进制字节码 ClassWriter cw=new ClassWriter(0);// 版本号 ; publc; 类名；包名； 父类； 接口 cw.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, \"Class\"+i,null, \"java/lang/Object\", null);// 返回byte[] byte[] code=cw.toByteArray();// 执行了类的加载 test.defineClass(\"Class\"+i,code, 0, code.length); //Class对象 } }finally { System.out.println(j); } }} 110000 默认不会出现内存溢出，因为此时jdk1.8的元空间实现的方法区使用的为操作系统的内存。本机操作系统内存足够大。 设置元空间(方法区)的大小为8M参数：-XX:MaxMetaspaceSize=10m 123456789//加载3331个类文件内存溢出3331Exception in thread \"main\" java.lang.OutOfMemoryError: Compressed class space at java.lang.ClassLoader.defineClass1(Native Method) at java.lang.ClassLoader.defineClass(ClassLoader.java:763) at java.lang.ClassLoader.defineClass(ClassLoader.java:642) at org.lc.jvm_heap.T4.main(T4.java:27)Process finished with exit code 1 1.8 以前会导致永久代内存溢出 设置永久代内存大小 -XX:MaxPermSize=10m java.lang.OutOfMemoryError: permGen space 1.8 之后会导致元空间内存溢出(默认不会溢出) 设置元空间内存大小 -XX:MaxMetaspaceSize=10m java.lang.OutOfMemoryError: Compressed class space 5.4常量池&amp;运行时常量池 测试代码 12345public class T1 { public static void main(String[] args) { System.out.println(\"hello world\"); }} 反编译文件：javap -v T1.class 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475Last modified 2020-6-7; size 547 bytes MD5 checksum 8f4a2ef03e7776481657f0feef4a573a Compiled from \"T1.java\"public class org.lc.method_area.T1 minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPER //常量池.......main方法中的指令根据`#序号`会在此处寻找对应的类型和输出的值Constant pool: #1 = Methodref #6.#20 // java/lang/Object.\"&lt;init&gt;\":()V #2 = Fieldref #21.#22 // java/lang/System.out:Ljava/io/PrintStream; #3 = String #23 // hello world #4 = Methodref #24.#25 // java/io/PrintStream.println:(Ljava/lang/String;)V #5 = Class #26 // org/lc/method_area/T1 #6 = Class #27 // java/lang/Object #7 = Utf8 &lt;init&gt; #8 = Utf8 ()V #9 = Utf8 Code #10 = Utf8 LineNumberTable #11 = Utf8 LocalVariableTable #12 = Utf8 this #13 = Utf8 Lorg/lc/method_area/T1; #14 = Utf8 main #15 = Utf8 ([Ljava/lang/String;)V #16 = Utf8 args #17 = Utf8 [Ljava/lang/String; #18 = Utf8 SourceFile #19 = Utf8 T1.java #20 = NameAndType #7:#8 // \"&lt;init&gt;\":()V #21 = Class #28 // java/lang/System #22 = NameAndType #29:#30 // out:Ljava/io/PrintStream; #23 = Utf8 hello world #24 = Class #31 // java/io/PrintStream #25 = NameAndType #32:#33 // println:(Ljava/lang/String;)V #26 = Utf8 org/lc/method_area/T1 #27 = Utf8 java/lang/Object #28 = Utf8 java/lang/System #29 = Utf8 out #30 = Utf8 Ljava/io/PrintStream; #31 = Utf8 java/io/PrintStream #32 = Utf8 println #33 = Utf8 (Ljava/lang/String;)V{ public org.lc.method_area.T1(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.\"&lt;init&gt;\":()V 4: return LineNumberTable: line 10: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lorg/lc/method_area/T1; public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=1, args_size=1 //通过`#序号`的方式在常量池Constant pool中寻找对应的类型。 0: getstatic #2 //在常量池中寻找#2序号 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #3 // String hello world 5: invokevirtual #4 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return LineNumberTable: line 12: 0 line 13: 8 LocalVariableTable: Start Length Slot Name Signature 0 9 0 args [Ljava/lang/String;}SourceFile: \"T1.java\" 常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量 等信息 运行时常量池，常量池是 *.class 文件中的，当该类被加载，它的常量池信息就会放入运行时常量 池，并把里面的#符号地址变为真实地址，此时的常量池就叫运行时常量池 5.5StringTable(串池)12345678910111213141516171819202122232425262728public class T1 { public static void main(String[] args) {// 1、串池 StringTable[\"a\",\"b,\"ab\"] hashtable结构，不能扩容// 2、串池中的字符串都不是重复的，若发现首次在串池中找不到所需的字符串，则会在创建的时候保存在串池中一份// 3、字符串都是懒惰加载的,即允许到该代码行时才会在串池中创建存储// 4、通过String s1=new String(\"ab\")创建的字符传,若常量池中没有则，则会先将常量\"ab\"放在常量池中保存一份。再通过new一个String对象来从常量池中加载该\"ab\"常量,但是引用的变量s1为堆中的地址。只有调用s1.intern()方法，此s1才会执行常量池中的地址 //// 将\"a\" 保存在串池 String s1 = \"a\";// 将\"b\" 保存在串池 String s2 = \"b\";// 将\"ab\" 保存在串池 String s3 = \"ab\";// 反编译发现 new StringBuilder().append(s1).append(s2).toString()。 即new String(\"ab\")// 重新在堆中创建一个字符串对象 String s4 = s1 + s2;// 因为\"a\",\"b\"在编译期已确定不会再更改，所以jvm在编译期间就帮我们优化为\"ab\" String s5 = \"a\" + \"b\";// 反编译发现 new StringBuilder().append(s1).append(\"b\").toString()。 即new String(\"ab\") String s6 = s1 + \"b\";// true，都是指向串池中的地址 System.out.println(s3==s5);// s3位串池中的地址。s6为堆中的地址，即false System.out.println(s3==s6); }} javap -v T1.class 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586 Last modified 2020-6-7; size 993 bytes MD5 checksum 72da179befc5b24f8006197550ecf10c Compiled from \"T1.java\"public class org.lc.method_area.T1 minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #12.#37 // java/lang/Object.\"&lt;init&gt;\":()V #2 = String #38 // a #3 = String #39 // b #4 = String #40 // ab //.... stack=3, locals=7, args_size=1 //从串池中加载(即在常量池#2位置加载字符串a) a 0: ldc #2 // String a //存储给变量Slot=1的变量，即变量s1 2: astore_1 //从串池中加载 b 3: ldc #3 // String b //存储给变量Slot=2的变量，即变量s2 5: astore_2 //从串池中加载 ab 6: ldc #4 // String ab //存储给变量Slot=3的变量，即变量s3 8: astore_3 //创建StringBuilder对象 9: new #5 // class java/lang/StringBuilder 12: dup //创建一个无参的构造函数 13: invokespecial #6 // Method java/lang/StringBuilder.\"&lt;init&gt;\":()V //从Slot=1的变量位置读取字符串String s1=\"a\" 16: aload_1 //使用append方法 17: invokevirtual #7 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; //从Slot=2的变量位置读取字符串String s2=\"b\" 20: aload_2 //再次使用append方法 21: invokevirtual #7 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; //回调虚方法 toString() 24: invokevirtual #8 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; //储存到slot=4的位置 即储存给变量s4 27: astore 4 //直接从常量池中的#4位置加载字符串\"ab\" 29: ldc #4 // String ab //储存给Slot=5的位置，即变量s5 31: astore 5 //下面同理 33: new #5 // class java/lang/StringBuilder 36: dup 37: invokespecial #6 // Method java/lang/StringBuilder.\"&lt;init&gt;\":()V 40: aload_1 41: invokevirtual #7 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 44: ldc #3 // String b 46: invokevirtual #7 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 49: invokevirtual #8 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; 52: astore 6 54: getstatic #9 // Field java/lang/System.out:Ljava/io/PrintStream; 57: aload_3 58: aload 6 60: if_acmpne 67 63: iconst_1 64: goto 68 67: iconst_0 68: invokevirtual #10 // Method java/io/PrintStream.println:(Z)V 71: return LineNumberTable: line 16: 0 line 18: 3 line 20: 6 line 23: 9 line 25: 29 line 26: 33 line 28: 54 line 29: 71 //从此处加载和赋值变量 LocalVariableTable: Start Length Slot Name Signature 0 72 0 args [Ljava/lang/String; 3 69 1 s1 Ljava/lang/String; 6 66 2 s2 Ljava/lang/String; 9 63 3 s3 Ljava/lang/String; 29 43 4 s4 Ljava/lang/String; 33 39 5 s5 Ljava/lang/String; 54 18 6 s6 Ljava/lang/String; //..... 5.6StringTable特性 常量池中的字符串仅是符号，第一次用到时才变为对象 利用串池的机制，来避免重复创建字符串对象 字符串变量拼接的原理是 StringBuilder （1.8） 字符串常量拼接的原理是编译期优化 可以使用 intern 方法，主动将串池中还没有的字符串对象放入串池 1.8 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池， 会把串 池中的对象返回 1.6 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有会把此对象复制一份， 放入串池， 会把串池中的对象返回 123456789101112public class T2 { public static void main(String[] args) {// 首先在串池中放入 \"a\",\"b\" String s1 = new String(\"a\") + new String(\"b\");// 再将s1拼接成的\"ab\"手动放入串池，串池中没有，放入成功，则s1指向串池的内容。 String s2=s1.intern(); //将s1放入串池的地址赋值给s2// 所以 s1也为串池的内容 true //注意若这里的jdk版本为1.6那么为fasle，因为这里会将对象s1拷贝一份到常量池,使用s1的时候还是堆中的对象，而不是常量池中的对象 System.out.println(s1 == \"ab\");// 所以 s2也为串池的内容 true System.out.println(s2 == \"ab\"); }} 123456789101112131415public class T2 { public static void main(String[] args) {// 首先在串池中放入 \"ab\" String s0=\"ab\";// 再在串池放入 \"a\" \"b\" String s1 = new String(\"a\") + new String(\"b\");// 再将s1拼接成的\"ab\"手动放入串池。// 注意此时的串池中有\"ab\",则放入失败。返回串池中的\"ab\"给s2 String s2=s1.intern();// 所以 s1是堆中的那个对象new String(\"ab\") false System.out.println(s1 == s0);// 所以 s2也为串池的内容 true System.out.println(s2 == s0); }} 5.7StringTale位置 jdk1.6的时候，串池在方法区，即永久代。 jdk1.8的时候，串池在堆空间。方法区为元空间, 即本地内存。 12345678910111213141516public class T3 { public static void main(String[] args) { List&lt;String&gt; list=new ArrayList&lt;&gt;(); int j=0; try { for (int i = 0; i &lt; 260000; i++) { list.add(String.valueOf(i).intern()); j++; } } catch (Throwable throwable) { throwable.printStackTrace(); }finally { System.out.println(j); } }} 12345java.lang.OutOfMemoryError: GC overhead limit exceeded //超过了GC回收的限制 GC花费了大量的时间进行垃圾回收，但是还是只回收了一部分内存。 at java.lang.Integer.toString(Integer.java:401) at java.lang.String.valueOf(String.java:3099) at org.lc.method_area.T3.main(T3.java:19)145683 关掉GC回收，-Xmx10m -XX:-UseGCOverheadLimit -XX:-UseGCOverheadLimit -代表关闭 +代表开启 12345java.lang.OutOfMemoryError: Java heap space //堆空间内存溢出 at java.lang.Integer.toString(Integer.java:401) at java.lang.String.valueOf(String.java:3099) at org.lc.method_area.T3.main(T3.java:19)146834 5.8StringTable 垃圾回收当串池中的数据快占用满堆内存的时候，会触发一次GC垃圾回收操作，将没有地址引用的对象进行垃圾进行回收 5.8StringTable调优①调整XX:StringTableSizeStringTable是由hash表加链表组成(和hashmap类似) 例如：如果要把上万级的单词数量代码加载到串池中。若串池的StringTable的桶的个数过少，则索引时间会变慢，hash冲突会变高。 若读取到的40万个单词存到串池中，若设置StringTable个数为1000,那么每个桶的放的个数为400个单词。寻找字符串的时间会非常慢。所以当我们存储的字符串非常多需要放到串池中，那么我们可以考虑设置StringTable桶的个数： -XX:StringTableSize=桶个数，来减少hash碰撞的概率。 ②决定是否将字符串入池(使用intern()）当我们使用的字符串有大量的重复串时，我们可以使用String的intern()方法入池,下次遇到重复的串存储时，直接从串池中拿即可。减少内存占用。 在jdk1.8的时候，intern()方法首先对字符串入池，若池中存在则返回池中的字符串，否则将该字符串入池 六、直接内存(Direct Memory)6.1NIO/IO 同步阻塞IO模型读取文件： java本身不具备磁盘读写的能力，必须调用操作系统的函数才能方法读取内存中的数据 当CPU运行到内核态时，磁盘文件先加载到系统缓存区，java会在内存中划分一块缓冲区，再将系统缓冲区的代码读到java堆内存的缓冲区，完成一次缓冲拷贝，周而复始完成读取操作。 同步非阻塞NIO模型读取文件： 操作系统划分一块direct memory区，操作系统和java代码都可以直接访问此缓冲区的数据，所以NIO少了一部分数据的复制操作。 6.2定义 常见于 NIO 操作时，用于数据缓冲区 分配回收成本较高，但读写性能高 不受 JVM 内存回收管理（System.gc()只能回收jvm的垃圾，不能回收直接内存） 6.3直接内存溢出 使用NIO划分内存区域，模拟内存溢出 12345678910111213141516171819public class T4 { //100mb static int _100Mb = 1024 * 1024 * 100; public static void main(String[] args) { List&lt;ByteBuffer&gt; list=new ArrayList&lt;&gt;(); int i=0; try { while (true) { //一次划分直接内存100MB ByteBuffer byteBuffer=ByteBuffer.allocateDirect(_100Mb); list.add(byteBuffer); i++; } }finally { System.out.println(i); } }} 123456Exception in thread \"main\" java.lang.OutOfMemoryError: Direct buffer memory at java.nio.Bits.reserveMemory(Bits.java:694) at java.nio.DirectByteBuffer.&lt;init&gt;(DirectByteBuffer.java:123) at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:311) at org.lc.method_area.T4.main(T4.java:27)36 6.4直接内存分配和回收原理12345678910111213public class T1 {// 1GB static int _1GB=1024*1024*1024; public static void main(String[] args) throws IOException {// 划分一块1GB大小的直接内存 ByteBuffer byteBuffer=ByteBuffer.allocateDirect(_1GB); System.out.println(\"分配完毕...\"); System.in.read(); System.out.println(\"开始释放...\"); System.gc(); }} 我们查看任务资源管理器，查看该程序的内存占用情况为1GB： 运行完该代码后，发现内存已释放，我们能否得出结论是System.gc()释放的吗？不是。 通过底层发现是使用了 Unsafe 对象完成直接内存的分配回收，并且回收需要主动调用 freeMemory 方法 ByteBuﬀer 的实现类内部，使用了 Cleaner （虚引用）来监测 ByteBuﬀer 对象，一旦 ByteBuﬀer 对象被垃圾回收，那么就会由 ReferenceHandler 线程通过 Cleaner 的 clean 方法调 用 freeMemory 来释放直接内存 ①禁用显示的垃圾回收(System.gc())即让System.gc()失效，避免程序员在代码中无意使用该Full GC方式回收垃圾，会回收新生代和老年代，会造成程序暂停时间较长。 -XX:+DisableExplicitGC 禁用GC回收 -XX:-DisableExplicitGC 开启GC回收 禁用垃圾回收以后，我们可以使用Unsafe的freeMemory来实现垃圾回收。或者等到内存占用到一定比例由jvm自动回收 Ⅲ、垃圾回收一、如何判断对象可以回收1.1引用计数法(废弃)对象被引用，计数+1 对象直接相互引用，但是两个对象都没用到，对象无法回收 1.2可达性分析算法 Java 虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象 扫描堆中的对象，看是否能够沿着 GC Root对象 为起点的引用链找到该对象，找不到，表示可以 回收 哪些对象可以作为 GC Root ? 系统类，Object,HashMap,String… 本地方法 正在加锁的对象 活动线程中的对象 1.3四种引用 注：实线代表强引用 ①强引用 只有所有 GC Roots 对象都不通过【强引用】引用该对象，该对象才能被垃圾回 强引用类型是我们平时写代码的时候最常用的引用 12345678910111213public class Main { public static void main(String[] args) { //创建一个对象，new出来的对象都是分配在java堆中的 Sample sample = new Sample(); //sample这个引用就是强引用 sample = null; //将这个引用指向空指针, //那么上面那个刚new来的对象就没用任何其它有效的引用指向它了 //也就说该对象对于垃圾收集器是符合条件的 //因此在接下来某个时间点 GC进行收集动作的时候, 该对象将会被销毁，内存被释放 }}class Sample {} 由以上图可知，GCRoot根对象C和B同时引用对象A1,那么此时A1对象不能被回收。 只有C和B同时断开和A1对象的引用时，A1对象才能被回收 ②软引用 仅有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次出发垃圾回收，回收软引用 对象 可以配合引用队列来释放软引用自身 当A2对象有强对象B引用它时，A2对象不能被回收 当A2没有被强对象引用时，只是被C对象间接引用(软引用)，那么当jvm进行垃圾回收时，若回收后还是发现内存不足，那么A2对象也有可能会被回收 ③弱引用 仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象 可以配合引用队列来释放弱引用自身 当A3对象有强对象B引用它时，A3对象不能被回收 当A2没有被强对象B引用时，只是被C对象间接引用(弱引用)，那么当jvm进行垃圾回收操作时，无论内存是否充足，该对象都会被回收 1)软弱引用配合引用队列软引用和弱引用可以配合引用队列使用，也可以不配合引用队列使用 当软引用和弱引用的对象被释放后，引用自身也是一个对象，如果在创建的时候给软弱引用分配了一个引用队列，软弱引用所引用的对象被回收时，该软弱引用会进入这个引用队列。因为软弱引用也占用一定内存，也有可能被强引用所引用，所以需要当对软弱引用进行释放的时候，需要在引用队列中找到该软弱引用把它释放掉 ④虚引用 必须配合引用队列使用，主要配合 ByteBuﬀer 使用，被引用对象回收时，会将虚引用入队， 由 Reference Handler 线程调用虚引用相关方法释放直接内存 例如:当我们使用ByteBuffer声明一块直接内存的时候，如果ByteBuffer没有被B对象引用时，ByteBuffer可能被回收，但是此时所分配的直接内存不能被jvm所直接回收，所以此时ByteBuffer被释放后，虚引用会进入引用队列，使用Unsafe中的freeMemory方法找到该直接内存地址把该直接内存释放掉 *⑤终结器引用 无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队（被引用对象 暂时没有被回收），再由 Finalizer 线程通过终结器引用找到被引用对象并调用它的 ﬁnalize 方法，第二次 GC 时才能回收被引用对象 当A4对象没有被强B对象引用时，A4对象可能会被回收，当jvm对A4对象回收时，会为A4对象创建一个终结器引用，并把该引用放入引用队列，这是A4对象还没有被回收，jvm在合适的时机再用一个优先级很低的finallizehandler线程，去队列中寻找有没有一个新加入的终结器引用，根据终结器引用找到该A4对象，并调用finallize()方法，释放该对象内存。所以该方法效率非常低，在第二次的时候才能被回收，优先级较低的线程使该finallize()可能不会被执行。 1)虚引用和终结器引用必须配合引用队列使用1.4四种引用的应用①软引用 未使用引用，将堆内存设置为20M 12345678910public class T1 { private static final int _4MB=4*1024*1024; public static void main(String[] args) throws IOException { List&lt;byte[]&gt; list=new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 5; i++) { list.add(new byte[_4MB]); } System.in.read(); }} 123//发生堆内存溢出Exception in thread \"main\" java.lang.OutOfMemoryError: Java heap space at org.lc.jvm_reference.T1.main(T1.java:19) 使用软引用 -XX:+PrintGCDetails -verbose:gc 查看GC的详细信息 1234567891011121314 public static void soft() { //创建软引用对象，此时引用 List--&gt; SoftReference --&gt; byte[] List&lt;SoftReference&lt;byte[]&gt;&gt; list=new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 5; i++) { SoftReference&lt;byte[]&gt; softReference = new SoftReference&lt;&gt;(new byte[_4MB]); list.add(softReference); System.out.println(list.size()); } System.out.println(\"循环结束...\"+list.size()); for (SoftReference&lt;byte[]&gt; ref : list) { System.out.println(ref.get()); } }} 12345678910111213141516171819202122232425262728293031123//加入第四个字节对象时，发现内存不足，进行一次垃圾回收[GC (Allocation Failure) [PSYoungGen: 1994K-&gt;488K(6144K)] 14282K-&gt;13005K(19968K), 0.0027620 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 4//但是，回收后发现内存还是不足，即进行软引用的垃圾回收，将前面四个软引用回收掉[GC (Allocation Failure) --[PSYoungGen: 4696K-&gt;4696K(6144K)] 17214K-&gt;17222K(19968K), 0.0009000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (Ergonomics) [PSYoungGen: 4696K-&gt;4520K(6144K)] [ParOldGen: 12525K-&gt;12491K(13824K)] 17222K-&gt;17012K(19968K), [Metaspace: 3214K-&gt;3214K(1056768K)], 0.0042977 secs] [Times: user=0.06 sys=0.02, real=0.00 secs] [GC (Allocation Failure) --[PSYoungGen: 4520K-&gt;4520K(6144K)] 17012K-&gt;17052K(19968K), 0.0005820 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]//触发full gc,把新生代和老年代内存都释放掉，即回收前四个软引用[Full GC (Allocation Failure) [PSYoungGen: 4520K-&gt;0K(6144K)] [ParOldGen: 12531K-&gt;610K(8704K)] 17052K-&gt;610K(14848K), [Metaspace: 3214K-&gt;3214K(1056768K)], 0.0055406 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 5循环结束...5nullnullnullnull //只获得了最后一次加入对象[B@135fbaa4Heap //新生代占的内存最大，即为最后一次加入的字节数组大小 PSYoungGen total 6144K, used 4376K [0x00000000ff980000, 0x0000000100000000, 0x0000000100000000) eden space 5632K, 77% used [0x00000000ff980000,0x00000000ffdc6220,0x00000000fff00000) from space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000) to space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000) //老年代的被回收 ParOldGen total 8704K, used 610K [0x00000000fec00000, 0x00000000ff480000, 0x00000000ff980000) object space 8704K, 7% used [0x00000000fec00000,0x00000000fec98888,0x00000000ff480000) Metaspace used 3220K, capacity 4500K, committed 4864K, reserved 1056768K class space used 349K, capacity 388K, committed 512K, reserved 1048576K 1)使用引用队列1234567891011121314151617181920212223242526272829303132public class T1 { private static final int _4MB=4*1024*1024; public static void main(String[] args) throws IOException { //创建软引用对象，此时引用 List--&gt; SoftReference --&gt; byte[] List&lt;SoftReference&lt;byte[]&gt;&gt; list=new ArrayList&lt;&gt;();// 引用队列 ReferenceQueue&lt;byte[]&gt; queue=new ReferenceQueue&lt;&gt;(); for (int i = 0; i &lt; 5; i++) { //软引用关联引用队列 SoftReference&lt;byte[]&gt; softReference = new SoftReference&lt;&gt;(new byte[_4MB],queue); list.add(softReference); System.out.println(list.size()); }// 从队列中获取无用的 软引用对象，并移除 Reference&lt;? extends byte[]&gt; poll = queue.poll(); while (poll != null) { //从集合重移除无用的软引用对象 list.remove(poll);// 从队列中移除 poll=queue.poll(); } System.out.println(\"循环结束...\"+list.size()); for (SoftReference&lt;byte[]&gt; ref : list) { System.out.println(ref.get()); } }} 123456712345循环结束...1[B@135fbaa4 ②弱引用1)使用引用队列123456789101112131415public class T2 { private static final int _4MB=4*1024*1024; public static void main(String[] args) { List&lt;WeakReference&lt;byte[]&gt;&gt; list=new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 5; i++) { WeakReference&lt;byte[]&gt; weakReference = new WeakReference&lt;&gt;(new byte[_4MB]); list.add(weakReference); for (WeakReference&lt;byte[]&gt; w:list){ System.out.print(w.get()+\"\"); } System.out.println(); } System.out.println(\"循环结束\"); }} 1234567891011121314151617181920[B@135fbaa4[B@135fbaa4[B@45ee12a7[B@135fbaa4[B@45ee12a7[B@330bedb4//存入第四个对象的时候发生一次垃圾回收 触发minorGC回收年轻代 [GC (Allocation Failure) [PSYoungGen: 1993K-&gt;488K(6144K)] 14281K-&gt;12985K(19968K), 0.0019001 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] //第四个对象勉强存放成功[B@135fbaa4[B@45ee12a7[B@330bedb4[B@2503dbd3 //第五次存入对象的之前 再触发minorGC回收年轻代 回收掉第四次的若引用对象 [GC (Allocation Failure) [PSYoungGen: 4696K-&gt;488K(6144K)] 17194K-&gt;13065K(19968K), 0.0006471 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [B@135fbaa4[B@45ee12a7[B@330bedb4 null [B@4b67cf4d循环结束Heap PSYoungGen total 6144K, used 4752K [0x00000000ff980000, 0x0000000100000000, 0x0000000100000000) eden space 5632K, 75% used [0x00000000ff980000,0x00000000ffdaa000,0x00000000fff00000) from space 512K, 95% used [0x00000000fff80000,0x00000000ffffa020,0x0000000100000000) to space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000) ParOldGen total 13824K, used 12577K [0x00000000fec00000, 0x00000000ff980000, 0x00000000ff980000) object space 13824K, 90% used [0x00000000fec00000,0x00000000ff848700,0x00000000ff980000) Metaspace used 3218K, capacity 4500K, committed 4864K, reserved 1056768K class space used 349K, capacity 388K, committed 512K, reserved 1048576K 二、垃圾回收算法2.1标记清除(Mark Sweep) 速度快 会造成内存碎片 先记录未被使用的对象(垃圾)的起始地址，再清除该起始地址的数据，并不会整理合并地址块，新加入的对象地址直接塞到对应空的地址块即可 2.2标记整理(Mark Compact) 速度慢 没有内存碎片 对比垃圾清除算法，多了一步再垃圾进行清除后，会对内存碎片进行整理，使存储空间得到充分利用，缺点时耗费性能。 清除一块垃圾的时候，将存活的对象向前移动。 2.3复制(Copy) 不会有内存碎片 复制占用双倍的内存空间 占用双倍的存储空间，首先将被GCRoot引用的对象移动至另一块内存区域，并进行整理，留下的垃圾区域直接清除，然后再交换两块内存区域的位置 三、分代垃圾回收 ​ 首先，先创建的对象放入伊甸园区，伊甸园被区被占满后，触发第一次Minor GC，采用可达性分析算法，根据GC Root引用链去找可以回收的垃圾，将垃圾进行标记，标记成功，采用复制算法，将回收后幸存的垃圾复制到幸存区To中，并让幸存对象的寿命加1，然后可以回收掉伊甸园中其他的垃圾，将幸存区To的位置和幸存区From的位置进行交换(它们内存空间大小不会改变,此时存活的对象在幸存区From中)。即伊甸园中的空间已释放，又可以创建新的对象放入伊甸园中。当伊甸园中的内存又满了的时候，再触发第二次Minor GC，再根据引用链找到伊甸园和幸存区From中的对象，将存活的对象放入幸存区To中，将伊甸园中来的对象寿命加1，将幸存区From中还存或的对象加1(即变成2)，剩下在伊甸园和幸存区From中的垃圾清除释放，然后又把在幸存To中的对象位置和幸存区From进行交换(此时存活对象在幸存区From中)。 ​ 当幸存区中的对象年龄的阈值超过默认值15时，我们的虚拟机认为这是价值较高的对象，不会被轻易回收，会将该对象晋升到老年代中，老年代不会轻易被回收。或者当年轻代中的内存被占满的时候，这是还要放比较大的对象时，新生代中已存在的对象会忽略阈值的限制直接晋升到老年代，腾出空间给新加入的对象使用。 ​ 当老年代内存也快满的时候，会触发一次Full GC来触发一次老年代的垃圾回收,Full GC会回收新生代和老年代的垃圾回收。当老年代空间不足时会先尝试触发minor gc（JDK 6 update 24 之后规定，只要老年代的连续空间大于新时代的对象总大小或者平均晋升大小就会进行minor GC），如果之后空间不足(又有对象从新生代区域升级到老年代)，那么触发Full gc, 那么stop the world会更长，应避免这种操作，如果full gc后老年代空间还不足则 out of memory 要点： full gc 又叫 major gc (major garbage collection ) 新生代区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使新生代区能尽快空闲出来。 对象首先分配在伊甸园区 新生代空间不足时，触发Minor GC，伊甸园和from存货的对象使用copy赋值到to中，是存活对象的年龄加1，并且交换form,to中的值，并释放的垃圾对象 minor gc 会引发 stop the world 暂停其他用户的线程，等待垃圾回收结束，用户线程才恢复运行。 对象寿命超过阈值时，会晋升至老年代，最大寿命是15(4bit 1111 转为十进制为15) 当老年代空间不足时会先尝试触发minor gc（JDK 6 update 24 之后规定，只要老年代的连续空间大于新时代的对象总大小或者平均晋升大小就会进行minor GC），如果之后空间不足(又有对象从新生代区域升级到老年代)，那么触发Full gc, 那么stop the world会更长，应避免这种操作，如果full gc后老年代空间还不足则 out of memory 3.1为什么要进行分代垃圾回收分代的垃圾回收策略，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。 在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：String对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。 试想，在不进行对象存活时间区分的情况下，每次垃圾回收都是对整个堆空间进行回收，花费时间相对会长，同时，因为每次回收都需要遍历所有存活对象，但实际上，对于生命周期长的对象而言，这种遍历是没有效果的，因为可能进行了很多次遍历，但是他们依旧存在。因此，分代垃圾回收采用分治的思想，进行代的划分，把不同生命周期的对象放在不同代上，不同代上采用最适合它的垃圾回收方式进行回收。 3.2相关JVM参数 堆初始大小 -Xms 堆最大大小 -Xmx 或 -XX:MaxHeapSize=size 新生代大小 -Xmn 或 (-XX:NewSize=size + -XX:MaxNewSize=size ) 幸存区比例（动态） -XX:InitialSurvivorRatio=ratio 和 -XX:+UseAdaptiveSizePolicy 幸存区比例 -XX:SurvivorRatio=ratio 晋升阈值 -XX:MaxTenuringThreshold=threshold 晋升详情 -XX:+PrintTenuringDistribution GC详情 -XX:+PrintGCDetails -verbose:gc FullGC 前 MinorGC -XX:+ScavengeBeforeFullGC (fullgc前是否进行minor gc 默认开启) 3.3GC分析①基本信息123456789101112131415public class T1 {// 模拟512KB对象存储 private static final int _512KB=512*1024;// 模拟1MB private static final int _1MB=1024*1024;// 模拟6MB private static final int _6MB=6*1024*1024;// 模拟7MB private static final int _7MB=7*1024*1024;// 模拟8MB private static final int _8MB=8*1024*1024; //设置虚拟机参数 -Xms20M( 堆初始大小20M) -Xmx20M(堆最大大小20M) -Xmn10M(新生代大小10M) -XX:+UseSerialGC(使用UseSerialGC垃圾回收器保证幸存区大小不会动态调整) -XX:+PrintGCDetails -verbose:gc(打印gc日志) public static void main(String[] args) { }} 123456789101112131415Heap //新生代 总大小为9M，还有1M分配给幸存区To空闲的一块位置 def new generation total 9216K, used 1997K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000) //伊甸园区 已经使用24%(系统启动类) eden space 8192K, 24% used [0x00000000fec00000, 0x00000000fedf37f8, 0x00000000ff400000) //幸存区From from space 1024K, 0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000) //幸存区To to space 1024K, 0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000) //老年代 tenured generation total 10240K, used 0K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000) the space 10240K, 0% used [0x00000000ff600000, 0x00000000ff600000, 0x00000000ff600200, 0x0000000100000000) //元空间 Metaspace used 3093K, capacity 4496K, committed 4864K, reserved 1056768K class space used 335K, capacity 388K, committed 512K, reserved 1048576K ②minor gc 触发第一次GC: 12345public static void main(String[] args) { List&lt;byte[]&gt; list=new ArrayList&lt;&gt;(); list.add(new byte[_7MB]); list.add(new byte[_512KB]); } 12345678910111213141516//首先存入7MB对象时伊甸园区存不下，触发一次minor gc垃圾回收后，512K的对象恰好放到伊甸园区。// 新生代(总大小为9216k)回收前占2001k,回收后占628k 堆(总大小为19456K)回收前占2001k,回收后占628k [GC (Allocation Failure) [DefNew: 2001K-&gt;628K(9216K), 0.0012164 secs] 2001K-&gt;628K(19456K), 0.0012517 secs] //花费时间 0.00[Times: user=0.00 sys=0.00, real=0.00 secs] Heap //此时新生代内存已经非常紧张 def new generation total 9216K, used 8718K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000) //伊甸园区栈已使用98% eden space 8192K, 98% used [0x00000000fec00000, 0x00000000ff3e6840, 0x00000000ff400000) //幸存区From已占用61% from space 1024K, 61% used [0x00000000ff500000, 0x00000000ff59d1b8, 0x00000000ff600000) to space 1024K, 0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000) tenured generation total 10240K, used 0K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000) the space 10240K, 0% used [0x00000000ff600000, 0x00000000ff600000, 0x00000000ff600200, 0x0000000100000000) Metaspace used 3202K, capacity 4496K, committed 4864K, reserved 1056768K class space used 347K, capacity 388K, committed 512K, reserved 1048576K 触发第二次GC: 123456public static void main(String[] args) { List&lt;byte[]&gt; list=new ArrayList&lt;&gt;(); list.add(new byte[_7MB]); list.add(new byte[_512KB]); list.add(new byte[_512KB]); } 123456789101112131415//当存入_7MB触发该次GC,进行垃圾回收，512k恰好放入伊甸园区[GC (Allocation Failure) [DefNew: 2001K-&gt;620K(9216K), 0.0014167 secs] 2001K-&gt;620K(19456K), 0.0014490 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] //当存入第二个512k对象时，触发第二次minor gc[GC (Allocation Failure) [DefNew: 8628K-&gt;517K(9216K), 0.0045477 secs] 8628K-&gt;8284K(19456K), 0.0045761 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] Heap //此时的新生代 只占用1193k def new generation total 9216K, used 1193K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000) eden space 8192K, 8% used [0x00000000fec00000, 0x00000000feca91d8, 0x00000000ff400000) from space 1024K, 50% used [0x00000000ff400000, 0x00000000ff481580, 0x00000000ff500000) to space 1024K, 0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000) //新生代的中的7MB对象晋升到老年代中，当内存非常紧张时，会忽略阈值的限制，直接进入老年代 tenured generation total 10240K, used 7766K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000) the space 10240K, 75% used [0x00000000ff600000, 0x00000000ffd95af8, 0x00000000ffd95c00, 0x0000000100000000) Metaspace used 3216K, capacity 4496K, committed 4864K, reserved 1056768K class space used 349K, capacity 388K, committed 512K, reserved 1048576K ③大对象直接晋升老年代1234public static void main(String[] args) { List&lt;byte[]&gt; list=new ArrayList&lt;&gt;(); list.add(new byte[_8MB]); } 123456789//当我们的对象超过新生代存放的最大大小时，会直接进入老年代。就是你新生代gc再干净，也存不下 def new generation total 9216K, used 2165K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000) eden space 8192K, 26% used [0x00000000fec00000, 0x00000000fee1d620, 0x00000000ff400000) from space 1024K, 0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000) to space 1024K, 0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000) tenured generation total 10240K, used 8192K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000) the space 10240K, 80% used [0x00000000ff600000, 0x00000000ffe00010, 0x00000000ffe00200, 0x0000000100000000) Metaspace used 3215K, capacity 4496K, committed 4864K, reserved 1056768K class space used 349K, capacity 388K, committed 512K, reserved 1048576K ④Full gc12345public static void main(String[] args) { List&lt;byte[]&gt; list=new ArrayList&lt;&gt;(); list.add(new byte[_8MB]); list.add(new byte[_8MB]);} 123456789101112131415//内存溢出前，full gc触发新生代的minor gc垃圾回收[GC (Allocation Failure) [DefNew: 2001K-&gt;649K(9216K), 0.0012435 secs][Tenured: 8192K-&gt;8840K(10240K), 0.0023755 secs] 10193K-&gt;8840K(19456K), [Metaspace: 3209K-&gt;3209K(1056768K)], 0.0036723 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] //触发full gc[Full GC (Allocation Failure) [Tenured: 8840K-&gt;8822K(10240K), 0.0015547 secs] 8840K-&gt;8822K(19456K), [Metaspace: 3209K-&gt;3209K(1056768K)], 0.0015824 secs] [Times: user=0.02 sys=0.00, real=0.00 secs] Heap def new generation total 9216K, used 246K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000) eden space 8192K, 3% used [0x00000000fec00000, 0x00000000fec3d890, 0x00000000ff400000) from space 1024K, 0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000) to space 1024K, 0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000) tenured generation total 10240K, used 8822K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000) the space 10240K, 86% used [0x00000000ff600000, 0x00000000ffe9d948, 0x00000000ffe9da00, 0x0000000100000000) Metaspace used 3241K, capacity 4496K, committed 4864K, reserved 1056768K class space used 352K, capacity 388K, committed 512K, reserved 1048576KException in thread \"main\" java.lang.OutOfMemoryError: Java heap space at org.lc.jvm_gc.T1.main(T1.java:30) ⑤一个线程中的OOM，不会导致我们主程序结束四、垃圾回收器1、垃圾回收器比较①串行 单线程 堆内存较小，适应个人电脑 ②吞吐量优先 多线程 堆内存较大，多核cpu 让单位时间内，stw的时间最端。 即某一段时间内发生的gc次数少。但是每次耗费的时间多 ③响应时间优先 多线程 堆内存较大 多核cpu 尽可能让单次stw的时间最短 。即某一段时间发生的gc虽然多，但是每次耗费的时间短 2、串行(Serial)①-XX:+UseSerialGC = Serial + SerialOld (包括新生代和老年代的垃圾回收器) 采用新生代：复制算法，老年代：标记整理算法进行垃圾回收。当一个线程进行垃圾的回收，其他的用户线程会阻塞，保证正在进行数据内存整理不受其他线程的干扰 3、吞吐量垃圾回收(Parallel并行)并行收集器。 采用新生代：复制算法，老年代：标记整理算法进行垃圾回收 垃圾回收线程的个数取决于CPU核心数，充分利用CPU的性能。 ①-XX:+UseParallelGC :新生代的垃圾回收器。 -XX:+UseParallelOldGC 老年代的垃圾回收器。 jdk8默认开启的，只要开启一个，另一个自动开启。 ②-XX:+UseAdaptiveSizePolicy :动态调整堆中新生代中区域大小 ③-XX:GCTimeRatio=ratio gc时间比率，一般为 1+(1+ratio) ratio一般为19，即100分钟执行gc时间为2分钟 ④-XX:MaxGCPauseMillis=ms 默认200ms gc最大暂停时间 ⑤-XX:ParallelGCThreads=n 垃圾回收线程的个数 4、响应时间优先(CMS:并发标记清除) 并行（Parallel） ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。 并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。 CMS （Concurrent Mark Sweep）：收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。 CMS（Concurrent Mark Sweep）：收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。 CMS存在的问题：因为采用标记清除的方式清除垃圾，当新生代和老年代内存碎片非常多时，此时会并发gc失败，会退化使用串行的gc方式，使gc执行的时间变得很长 ①-XX:+UseConcMarkSweepGC：老年代的垃圾回收器 ,当该垃圾回收器执行失败时，会退化到执行使用Serial Old串行的收集器 -XX:+UseParNewGC 新生代的垃圾回收器。 ②-XX:ParallelGCThreads=n ： 并行的线程数 -XX:ConcGCThreads=threads：并发的线程数 一般如果cpu总核数为4，那么并行数为3(执行其他用户线程)，并发数为1(执行垃圾回收) ③-XX:CMSInitiatingOccupancyFraction=percent 若percent为80，则代表当老年代内存为80的时候，就出发一次垃圾回收。目的时留下多余的空间给浮动垃圾(并行清理的过程中，其他用户线程留下的垃圾)。percent值越小，触发gc的时间就越早 ④-XX:+CMSScavengeBeforeRemark 在重新标记之前，对新生代做一次垃圾回收 从名字中的Mark Sweep这两个词可以看出，CMS 收集器是一种 “标记-清除”算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤： 初始标记(会stw)： 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ； 并发标记(不会stw)： 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。 重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短 并发清除： 开启用户线程，同时 GC 线程开始对未标记的区域做清扫 1)并发和并行的区别？ 如果某个系统支持两个或者多个动作（Action）同时存在，那么这个系统就是一个并发系统。如果某个系统支持两个或者多个动作同时执行，那么这个系统就是一个并行系统。并发系统与并行系统这两个定义之间的关键差异在于“存在”这个词。 在并发程序中可以同时拥有两个或者多个线程。这意味着，如果程序在单核处理器上运行，那么这两个线程将交替地换入或者换出内存。这些线程是同时“存在”的——每个线程都处于执行过程中的某个状态。如果程序能够并行执行，那么就一定是运行在多核处理器上。此时，程序中的每个线程都将分配到一个独立的处理器核上，因此可以同时运行。 “并行”概念是“并发”概念的一个子集。也就是说，你可以编写一个拥有多个线程或者进程的并发程序，但如果没有多核处理器来执行这个程序，那么就不能以并行方式来运行代码。因此，凡是在求解单个问题时涉及多个执行流程的编程模式或者执行行为，都属于并发编程的范畴。 5、G1 (Garbage-First)收集器 2004 论文发布 2009 JDK 6u14 体验 2012 JDK 7u4 官方支持 2017 JDK 9 默认 适用场景： 同时注重吞吐量（Throughput）和低延迟（Low latency），默认的暂停目标是 200 ms 超大堆内存，会将堆划分为多个大小相等的 Region 整体上是 标记+整理 算法，两个区域之间是 复制 算法 相关 JVM 参数 -XX:+UseG1GC -XX:G1HeapRegionSize=size -XX:MaxGCPauseMillis=time ①G1垃圾回收阶段 1)Young Collection(新生代垃圾回收)会 STW。新创建的对象会放入伊甸园区 进行新生代的垃圾回收后通过复制算法将伊甸园(E)中存活的对象放入幸存区(S) 当幸存区中的对象满了的时候或者幸存区中的对象年龄超过阈值的年龄时，幸存区中对象将会晋升到老年代中(S) 2) Young Collection + CM (新生代垃圾回收+并发标记) 基本步骤 初始标记：在 Young GC 时会进行 GC Root 的初始标记(找到根对象) 并发标记: ** 老年代占用堆空间比例达到阈值时，进行并发标记**（不会 STW） 3)Mixed Collection(混合收集)会对 E(伊甸园区)、S(幸存区)、O(老年代) 进行全面垃圾回收 最终标记（Remark）会 STW 。解决在并发标记中用户线程改变的一些需要回收垃圾对象的引用。 拷贝存活（Evacuation）会 STW。 注意，这里的老年代也会采用复制算法进行清除垃圾，但是不会全部进行复制清除，而是会根据最大暂停时间MaxGCPauseMillis来动态清除需要回收的垃圾。若设定的最大暂停时间够，则执行老年代的全部垃圾清除，否则将根据jvm来自动判断哪些垃圾优先清除获得收益最大。 6、Full GC SerialGC 新生代内存不足发生的垃圾收集 - minor gc 老年代内存不足发生的垃圾收集 - full gc ParallelGC 新生代内存不足发生的垃圾收集 - minor gc 老年代内存不足发生的垃圾收集 - full gc G1,CMS 新生代内存不足发生的垃圾收集 - minor gc 老年代内存不足 当老年代内存占比45%(默认)以上，会触发并发标记和混合收集阶段。如果回收速度 &gt; 用户线程产生垃圾 (还是属于并发标记阶段)。 当回收速度&lt; 用户线程产生垃圾 (退化为串行的收集器，触发full fc) Ⅳ、类加载和字节码技术1.类文件结构 2. 字节码指令 3. 编译期处理 4. 类加载阶段 5. 类加载器 6. 运行期优化 一、类文件结构 根据 Java 虚拟机规范，类文件由单个 ClassFile 结构组成： 123456789101112131415161718ClassFile { u4 magic; //Class 文件的标志 u2 minor_version;//Class 的小版本号 u2 major_version;//Class 的大版本号 u2 constant_pool_count;//常量池的数量 cp_info constant_pool[constant_pool_count-1];//常量池 u2 access_flags;//Class 的访问标记 u2 this_class;//当前类 u2 super_class;//父类 u2 interfaces_count;//接口 u2 interfaces[interfaces_count];//一个类可以实现多个接口 u2 fields_count;//Class 文件的字段属性 field_info fields[fields_count];//一个类会可以有个字段 u2 methods_count;//Class 文件的方法数量 method_info methods[methods_count];//一个类可以有个多个方法 u2 attributes_count;//此类的属性表中的属性数 attribute_info attributes[attributes_count];//属性表集合} 1、魔数2、版本3、常量池常量池中每一项常量都是一个表，这14种表有一个共同的特点：开始的第一位是一个 u1 类型的标志位 -tag 来标识常量的类型，代表当前这个常量属于哪种常量类型． 类型 标志（tag） 描述 CONSTANT_utf8_info 1 UTF-8编码的字符串 CONSTANT_Integer_info 3 整形字面量 CONSTANT_Float_info 4 浮点型字面量 CONSTANT_Long_info ５ 长整型字面量 CONSTANT_Double_info ６ 双精度浮点型字面量 CONSTANT_Class_info ７ 类或接口的符号引用 CONSTANT_String_info ８ 字符串类型字面量 CONSTANT_Fieldref_info ９ 字段的符号引用 CONSTANT_Methodref_info 10 类中方法的符号引用 CONSTANT_InterfaceMethodref_info 11 接口中方法的符号引用 CONSTANT_NameAndType_info 12 字段或方法的符号引用 CONSTANT_MothodType_info 16 标志方法类型 CONSTANT_MethodHandle_info 15 表示方法句柄 CONSTANT_InvokeDynamic_info 18 表示一个动态方法调用点 4、访问标识与继承信息5、Filed信息 6、method信息7、附加信息二、字节码指令1、javap工具自己分析类文件结构太麻烦了，Oracle 提供了 javap 工具来反编译 class 文件 反编译：javap -v 编译后的class文件名称.class java源文件 12345public class T1 { public static void main(String[] args) { System.out.println(\"hello wrold\"); }} class反编译文件 javap -v T1.class 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798Classfile /F:/jvm/jvm_demo/target/classes/org/lc/jvm_class/T1.class //最后修改时间 字节大小 Last modified 2020-6-13; size 543 bytes //md5签名 MD5 checksum 8f97f15345eca913d4885be87c3c3632 //编译哪个原文件 Compiled from \"T1.java\"public class org.lc.jvm_class.T1 minor version: 0 //魔数 代表jdk8 major version: 52 //访问修饰符 flags: ACC_PUBLIC, ACC_SUPER //常量池Constant pool:// 方法引用 引用的位置#6和位置#20 引用的详细信息 #1 = Methodref #6.#20 // java/lang/Object.\"&lt;init&gt;\":()V //字段引用 引用的位置#6和位置#22 引用的详细信息 #2 = Fieldref #21.#22 // java/lang/System.out:Ljava/io/PrintStream; #3 = String #23 // hello wrold #4 = Methodref #24.#25 // java/io/PrintStream.println:(Ljava/lang/String;)V #5 = Class #26 // org/lc/jvm_class/T1 #6 = Class #27 // java/lang/Object #7 = Utf8 &lt;init&gt; #8 = Utf8 ()V #9 = Utf8 Code #10 = Utf8 LineNumberTable #11 = Utf8 LocalVariableTable #12 = Utf8 this #13 = Utf8 Lorg/lc/jvm_class/T1; #14 = Utf8 main #15 = Utf8 ([Ljava/lang/String;)V #16 = Utf8 args #17 = Utf8 [Ljava/lang/String; #18 = Utf8 SourceFile #19 = Utf8 T1.java #20 = NameAndType #7:#8 // \"&lt;init&gt;\":()V #21 = Class #28 // java/lang/System #22 = NameAndType #29:#30 // out:Ljava/io/PrintStream; #23 = Utf8 hello wrold #24 = Class #31 // java/io/PrintStream #25 = NameAndType #32:#33 // println:(Ljava/lang/String;)V #26 = Utf8 org/lc/jvm_class/T1 #27 = Utf8 java/lang/Object #28 = Utf8 java/lang/System #29 = Utf8 out #30 = Utf8 Ljava/io/PrintStream; #31 = Utf8 java/io/PrintStream #32 = Utf8 println #33 = Utf8 (Ljava/lang/String;)V{ //构造方法 public org.lc.jvm_class.T1(); //构造方法的参数信息 descriptor: ()V //访问修饰符 flags: ACC_PUBLIC Code: //最大操作栈的深度 局部变量表的长度 参数的长度 stack=1, locals=1, args_size=1 //把局部变量表的第0项加到操作数栈 0: aload_0 //调用常量池#1 中的方法 1: invokespecial #1 // Method java/lang/Object.\"&lt;init&gt;\":()V //返回 4: return //上面的0 1 4代表字节码中的行号 LineNumberTable: //10代表源java文件中的行号 0代表字节码中的行号 line 10: 0 // //本地变量表 LocalVariableTable: //从字节码的文件start行开始到length的作用范围为5行 变量名为this Start Length Slot Name Signature 0 5 0 this Lorg/lc/jvm_class/T1; //main方法 public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=1, args_size=1 //到常量池中的#2取静态变量System.out 0: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; //加载常量池中的hello world常量 3: ldc #3 // String hello wrold //回调方法PrintStream.println 5: invokevirtual #4 // Method java/io/PrintStream.println:(Ljava/lang/String;)V //返回 8: return LineNumberTable: //源文件中的12行对象 字节码中的第0行 line 12: 0 line 13: 8 LocalVariableTable: Start Length Slot Name Signature 0 9 0 args [Ljava/lang/String;}SourceFile: \"T1.java\" 2、图解方法执行流程1)原始java代码12345678910public class Demo3_1 { public static void main(String[] args) { int a = 10; //当存储的整数小于short的最大范围内，和方法的字节码指令存在一起 //当存储的整数大于short的最大值时，它会存在常量池中 int b = Short.MAX_VALUE + 1; int c = a + b; System.out.println(c); } } 2)编译后的字节码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192 Last modified 2020-6-13; size 602 bytes MD5 checksum 6db3390c8e1a174924ec1bb427f963ed Compiled from \"T2.java\"public class org.lc.jvm_class.T2 minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #7.#25 // java/lang/Object.\"&lt;init&gt;\":()V #2 = Class #26 // java/lang/Short #3 = Integer 32768 #4 = Fieldref #27.#28 // java/lang/System.out:Ljava/io/PrintStream; #5 = Methodref #29.#30 // java/io/PrintStream.println:(I)V #6 = Class #31 // org/lc/jvm_class/T2 #7 = Class #32 // java/lang/Object #8 = Utf8 &lt;init&gt; #9 = Utf8 ()V #10 = Utf8 Code #11 = Utf8 LineNumberTable #12 = Utf8 LocalVariableTable #13 = Utf8 this #14 = Utf8 Lorg/lc/jvm_class/T2; #15 = Utf8 main #16 = Utf8 ([Ljava/lang/String;)V #17 = Utf8 args #18 = Utf8 [Ljava/lang/String; #19 = Utf8 a #20 = Utf8 I #21 = Utf8 b #22 = Utf8 c #23 = Utf8 SourceFile #24 = Utf8 T2.java #25 = NameAndType #8:#9 // \"&lt;init&gt;\":()V #26 = Utf8 java/lang/Short #27 = Class #33 // java/lang/System #28 = NameAndType #34:#35 // out:Ljava/io/PrintStream; #29 = Class #36 // java/io/PrintStream #30 = NameAndType #37:#38 // println:(I)V #31 = Utf8 org/lc/jvm_class/T2 #32 = Utf8 java/lang/Object #33 = Utf8 java/lang/System #34 = Utf8 out #35 = Utf8 Ljava/io/PrintStream; #36 = Utf8 java/io/PrintStream #37 = Utf8 println #38 = Utf8 (I)V{ public org.lc.jvm_class.T2(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.\"&lt;init&gt;\":()V 4: return LineNumberTable: line 10: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lorg/lc/jvm_class/T2; public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=4, args_size=1 0: bipush 10 2: istore_1 3: ldc #3 // int 32768 5: istore_2 6: iload_1 7: iload_2 8: iadd 9: istore_3 10: getstatic #4 // Field java/lang/System.out:Ljava/io/PrintStream; 13: iload_3 14: invokevirtual #5 // Method java/io/PrintStream.println:(I)V 17: return LineNumberTable: line 12: 0 line 15: 3 line 16: 6 line 17: 10 line 18: 17 LocalVariableTable: Start Length Slot Name Signature 0 18 0 args [Ljava/lang/String; 3 15 1 a I 6 12 2 b I 10 8 3 c I}SourceFile: \"T2.java\" 3)常量载入运行时常量池将字节码中的常量池内容载入到运行时常量池中(也是属于方法区) 4)方法字节码载入方法区将字节码中的方法载入方法区 5)main线程开始运行，分配栈帧内存stack=2 操作栈的深度2 locals=4 局部变量表的长度4 6)执行引擎开始执行字节码(1) bipush 10 将一个 byte 压入操作数栈（其长度会补齐 4 个字节），类似的指令还有 sipush 将一个 short 压入操作数栈（其长度会补齐 4 个字节） ldc 将一个 int 压入操作数栈 ldc2_w 将一个 long 压入操作数栈（分两次压入，因为 long 是 8 个字节） 这里小的数字都是和字节码指令存在一起，超过 short 范围的数字存入了常量池 (2) istore_1将操作数栈顶数据弹出，存入局部变量表的 slot 1 这一步相当于 *int a=10; *的操作 (3) ldc #3 从常量池加载 #3 数据到操作数栈 注意 Short.MAX_VALUE 是 32767，所以 32768 = Short.MAX_VALUE + 1 实际是在编译期间计算 好的 (4) istore_2 (5)iload_1 (6)iload_2 (7)iadd (8)istore_3 (9)getstatic #4 (10)iload_3 (11)invokevirtual #5 找到常量池 #5 项 定位到方法区 java/io/PrintStream.println:(I)V 方法 生成新的栈帧（分配 locals、stack等） 传递参数，执行新栈帧中的字节码 执行完毕，弹出栈帧 清除 main 操作数栈内容 (12)return 完成 main 方法调用，弹出 main 栈帧 程序结束 7) i++/++i问题12345678public class T3 { public static void main(String[] args) { int a=10; int b=a++ + ++a + a--; System.out.println(a); System.out.println(b); }} 反编译文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293 Last modified 2020-6-13; size 577 bytes MD5 checksum 27586d3e5e18016da857182af5251ba9 Compiled from \"T3.java\"public class org.lc.jvm_class.T3 minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #5.#22 // java/lang/Object.\"&lt;init&gt;\":()V #2 = Fieldref #23.#24 // java/lang/System.out:Ljava/io/PrintStream; #3 = Methodref #25.#26 // java/io/PrintStream.println:(I)V #4 = Class #27 // org/lc/jvm_class/T3 #5 = Class #28 // java/lang/Object #6 = Utf8 &lt;init&gt; #7 = Utf8 ()V #8 = Utf8 Code #9 = Utf8 LineNumberTable #10 = Utf8 LocalVariableTable #11 = Utf8 this #12 = Utf8 Lorg/lc/jvm_class/T3; #13 = Utf8 main #14 = Utf8 ([Ljava/lang/String;)V #15 = Utf8 args #16 = Utf8 [Ljava/lang/String; #17 = Utf8 a #18 = Utf8 I #19 = Utf8 b #20 = Utf8 SourceFile #21 = Utf8 T3.java #22 = NameAndType #6:#7 // \"&lt;init&gt;\":()V #23 = Class #29 // java/lang/System #24 = NameAndType #30:#31 // out:Ljava/io/PrintStream; #25 = Class #32 // java/io/PrintStream #26 = NameAndType #33:#34 // println:(I)V #27 = Utf8 org/lc/jvm_class/T3 #28 = Utf8 java/lang/Object #29 = Utf8 java/lang/System #30 = Utf8 out #31 = Utf8 Ljava/io/PrintStream; #32 = Utf8 java/io/PrintStream #33 = Utf8 println #34 = Utf8 (I)V{ public org.lc.jvm_class.T3(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.\"&lt;init&gt;\":()V 4: return LineNumberTable: line 10: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lorg/lc/jvm_class/T3; public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=3, args_size=1 0: bipush 10 2: istore_1 3: iload_1 4: iinc 1, 1 7: iinc 1, 1 10: iload_1 11: iadd 12: iload_1 13: iinc 1, -1 16: iadd 17: istore_2 18: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 21: iload_1 22: invokevirtual #3 // Method java/io/PrintStream.println:(I)V 25: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 28: iload_2 29: invokevirtual #3 // Method java/io/PrintStream.println:(I)V 32: return LineNumberTable: line 12: 0 line 13: 3 line 14: 18 line 15: 25 line 16: 32 LocalVariableTable: Start Length Slot Name Signature 0 33 0 args [Ljava/lang/String; 3 30 1 a I 18 15 2 b I}SourceFile: \"T3.java\" 注意: iinc 指令(自增指令)是直接在局部变量 slot 上进行运算 a++ 和 ++a 的区别是先执行 iload (从本地变量表加载)还是 先执行 iinc 【1】首先将10入栈 【2】将10出栈存入局部变量表中的变量a 【3】读取a变量的值加载到栈中 【4】执行a++操作，即在slot槽中完成自增1操作，但是不会影响栈中已经加载的数据。此时的a为11 【5】执行++a的iinc操作，即再次在slot槽中完成自增1操作但是不会影响栈中已经加载的数据。此时的a为12 【6】iload加载局部变量表中a的值并入栈 【7】在栈中完成add加操作 【8】执行a - - 的iload操作完成入栈,此时a为12 【9】执行a– 的iinc的操作完成自减1的操作 ，此时a为11 【10】在栈中完成add累加操作 【11】将34出栈，存入本地变量表中的变量b 8)静态块/静态变量执行流程(类的初始化&lt;cinit&gt;()V )123456789101112131415161718192021public class T4 { static { //静态成员变量的再次声明修改必须在静态块中或者方法中才能修改 i=20; } //先把i放入常量池中，赋值操作还未执行，从上到下依次执行静态块中的赋值操作 static int i=10; static { //静态成员变量的再次声明修改必须在静态块中或者方法中才能修改 i=30; j=10; } //先把j放入常量池中，赋值操作还未执行，从上到下依次执行静态块中的赋值操作 static int j=20; public static void main(String[] args) { //30 System.out.println(i); //20 System.out.println(j); }} 编译器会按从上至下的顺序，收集所有 static 静态代码块和静态成员赋值的代码，合并为一个特殊的方法 &lt;cinit&gt;()V ： 123456789101112131415161718192021222324static {}; descriptor: ()V flags: ACC_STATIC Code: stack=1, locals=0, args_size=0 //20压栈 0: bipush 20 //赋值常量池中的变量i 2: putstatic #3 // Field i:I //10压栈 5: bipush 10 //赋值常量池中变量i 7: putstatic #3 // Field i:I 10: bipush 30 12: putstatic #3 // Field i:I 15: bipush 10 17: putstatic #5 // Field j:I 20: return LineNumberTable: line 12: 0 line 14: 5 line 16: 10 line 17: 15 line 18: 20 &lt;cinit&gt;()V 方法会在类加载的初始化阶段被调用 9)游离块/构造函数执行流程(对象的初始化)123456789101112131415161718192021222324public class T5 { //构造函数中的所有操作，总是在所有成员变量和游离块中的内容依次加载完毕才会执行 public T5(String a, int b) { //最后执行 this.a = a; this.b = b; } //成员变量a的声明先放入常量池中，但赋值操作还未进行,从上到下依次加载成员变量和赋值操作 private String a=\"s1\"; { b=20; } //成员变量a的声明先放入常量池中，但赋值操作还未进行，从上到下依次加载成员变量和赋值操作 private int b=10; { a = \"s2\"; } public static void main(String[] args) { T5 t5 = new T5(\"S3\", 30); System.out.println(t5.a); System.out.println(t5.b); }} 编译器会按从上至下的顺序，收集所有 {} 代码块和成员变量赋值的代码，形成新的构造方法，但原始构 造方法内的代码总是在后 12345678910111213141516171819202122232425262728293031323334353637383940public org.lc.jvm_class.T5(java.lang.String, int); descriptor: (Ljava/lang/String;I)V flags: ACC_PUBLIC Code: stack=2, locals=3, args_size=3 0: aload_0 1: invokespecial #1 // Method java/lang/Object.\"&lt;init&gt;\":()V 4: aload_0 5: ldc #2 // String s1 7: putfield #3 // Field a:Ljava/lang/String; 10: aload_0 11: bipush 20 13: putfield #4 // Field b:I 16: aload_0 17: bipush 10 19: putfield #4 // Field b:I 22: aload_0 23: ldc #5 // String s2 25: putfield #3 // Field a:Ljava/lang/String; 28: aload_0 29: aload_1 30: putfield #3 // Field a:Ljava/lang/String; 33: aload_0 34: iload_2 35: putfield #4 // Field b:I 38: return LineNumberTable: line 20: 0 line 11: 4 line 13: 10 line 15: 16 line 17: 22 line 21: 28 line 22: 33 line 23: 38 LocalVariableTable: Start Length Slot Name Signature 0 39 0 this Lorg/lc/jvm_class/T5; 0 39 1 a Ljava/lang/String; 0 39 2 b I 10)不同方法的调用123456789101112131415public class T6 { public T6() { } private void test1() { } private final void test2() { } public void test3(){} public static void test4(){} public static void main(String[] args) { T6 t6=new T6(); t6.test1(); t6.test2(); t6.test3();// 类名直接调用 T6.test4(); }} 1234567891011121314151617181920212223242526272829303132333435public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=2, args_size=1 //new一个对象在堆中。 在操作数栈中分配一块引用 0: new #2 // class org/lc/jvm_class/T6 //将栈中的对象的引用赋值一份调用此构造方法，然后出栈释放 3: dup //构造方法唯一确定 4: invokespecial #3 // Method \"&lt;init&gt;\":()V 7: astore_1 8: aload_1 //private私有方法唯一确定，不能被继承，即直接能够直接从类中找到该方法 9: invokespecial #4 // Method test1:()V 12: aload_1 //final方法唯一确定，即不能被覆盖，即直接能够直接从类中找到该方法 13: invokespecial #5 // Method test2:()V 16: aload_1 //public公共方法不能确定，可能被其他类重写，在编译期间不能确定。 17: invokevirtual #6 // Method test3:()V //static静态方法，直接通过类名调用。 20: invokestatic #7 // Method test4:()V 23: return LineNumberTable: line 17: 0 line 18: 8 line 19: 12 line 20: 16 line 22: 20 line 23: 23 LocalVariableTable: Start Length Slot Name Signature 0 24 0 args [Ljava/lang/String; 8 16 1 t6 Lorg/lc/jvm_class/T6; invokespecial，invokestatic属于静态绑定，即在编译期间就能确定其唯一性。 invokevirtual 属于动态绑定，需要在运行时才能确定其唯一性。 11)synchronized字节码分析12345678public class T8 { public static void main(String[] args) { Object lock=new Object(); synchronized (lock) { System.out.println(\"ok\"); } }} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667{ public org.lc.jvm_class.T8(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.\"&lt;init&gt;\":()V 4: return LineNumberTable: line 10: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lorg/lc/jvm_class/T8; public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=4, args_size=1 //new一份对象放入堆中，将地址引用放入操作数栈中 0: new #2 // class java/lang/Object //赋值一份该对象的在栈中的引用，这个引用将调用构造方法 3: dup 4: invokespecial #1 // Method java/lang/Object.\"&lt;init&gt;\":()V //将对象赋给lock变量 Object lock=new Object(); 7: astore_1 //将对象引用加载到操作数栈 8: aload_1 //赋值一份锁对象，分别对应一份加锁一份解锁用 9: dup 10: astore_2 //这里赋值的对象加到一个本地变量表中的匿名参数中astrore_2上 11: monitorenter 12: getstatic #3 // Field java/lang/System.out:Ljava/io/PrintStream; 15: ldc #4 // String ok 17: invokevirtual #5 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 20: aload_2 21: monitorexit 22: goto 30 25: astore_3 26: aload_2 27: monitorexit 28: aload_3 29: athrow 30: return Exception table: from to target type 12 22 25 any 25 28 25 any LineNumberTable: line 12: 0 line 13: 8 line 14: 12 line 15: 20 line 16: 30 LocalVariableTable: Start Length Slot Name Signature 0 31 0 args [Ljava/lang/String; 8 23 1 lock Ljava/lang/Object; StackMapTable: number_of_entries = 2 frame_type = 255 /* full_frame */ offset_delta = 25 locals = [ class \"[Ljava/lang/String;\", class java/lang/Object, class java/lang/Object ] stack = [ class java/lang/Throwable ] frame_type = 250 /* chop */ offset_delta = 4} 三、编译器处理所谓的 *语法糖 *其实就是指 java 编译器把 *.java 源码编译为 *.class 字节码的过程中，自动生成 和转换的一些代码，主要是为了减轻程序员的负担，算是 java 编译器给我们的一个额外福利（给糖吃 嘛）注意，以下代码的分析，借助了 javap 工具，idea 的反编译功能，idea 插件 jclasslib 等工具。另外， 编译器转换的结果直接就是 class 字节码，只是为了便于阅读，给出了 几乎等价 的 java 源码方式，并 不是编译器还会转换出中间的 java 源码，切记 1、默认构造函数12public class T1 {} 伪字节码： 123456789package org.lc.jvm_compiler;public class T1 { // 这个无参构造是编译器帮助我们加上的 public T1() { // 即调用父类 Object 的无参构造方法，即调用 java/lang/Object.\" &lt;init&gt;\":()V super(); }} 2、自动拆装箱包装类.valueOf(值); //装箱 包装类实例对象.intValue(); //拆箱 这个特性是 JDK 5 开始加入的， 代码片段1 ： 123456public class T1 { public static void main(String[] args) { Integer x=1; int y=x; }} 这段代码在 JDK 5 之前是无法编译通过的，必须改写为 代码片段2 : 123456public class T1 { public static void main(String[] args) { Integer x=Integer.valueOf(1); int y=x.intValue(); }} 3、泛型集合取值泛型也是在 JDK 5 开始加入的特性，但 java 在编译泛型代码后会执行 泛型擦除 的动作，即泛型信息 在编译为字节码之后就丢失了，实际的类型都当做了 Object 类型来处理： 1234567public class T1 { public static void main(String[] args) { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(10); // 实际调用的是 List.add(Object e) Integer x = list.get(0); // 实际调用的是 Object obj = List.get(int index); }} 所以在取值时，编译器真正生成的字节码中，还要额外做一个类型转换的操作： 12// 需要将 Object 转为 Integer Integer x = (Integer)list.get(0); 如果前面的 x 变量类型修改为 int 基本类型那么终生成的字节码是： 12// 需要将 Object 转为 Integer, 并执行拆箱操作 int x = ((Integer)list.get(0)).intValue(); 4、可变参数可变参数也是 JDK 5 开始加入的新特性： 例如： 1234567891011public class T2 { public static void main(String[] args) { foo(\"hello\",\"world\"); } public static void foo(String... args) {// 直接赋值 String[] array=args; System.out.println(array); }} 可变参数 String… args 其实是一个 String[] args ，从代码中的赋值语句中就可以看出来。 同 样 java 编译器会在编译期间将上述代码变换为： 1234567891011public class T2 { public static void main(String[] args) { foo(new String[]{\"hello\",\"world\"}); } public static void foo(String[] args) {// 直接赋值 String[] array=args; System.out.println(array); }} 注意 : 如果调用了 foo() 则等价代码为 foo(new String[]{}) ，创建了一个空的数组，而不会 传递 null 进去 5、foreach循环 数组的循环 仍是 JDK 5 开始引入的语法糖，数组的循环： 123456789public class T3 { public static void main(String[] args) {// 数组的初始化赋值操作 int[] array = {1, 2, 3, 4, 5, 6}; for (int arr : array) { System.out.println(arr); } }} 12345678public class T3 { public static void main(String[] args) { int[] array = new int[]{1, 2, 3, 4, 5, 6}; for (int i = 0; i &lt; array.length; i++) { System.out.println(array[i]); } }} 集合的循环 12345678public class T3 { public static void main(String[] args) { List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6); for (Integer i : list) { System.out.println(i); } }} 实际被编译器转换为对迭代器的调用： 123456789public static void main(String[] args) { List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6); Iterator var2 = list.iterator(); while(var2.hasNext()) { Integer i = (Integer)var2.next(); System.out.println(i); } } 注意: foreach 循环写法，能够配合数组，以及所有实现了 Iterable 接口的集合类一起使用，其 中 Iterable 用来获取集合的迭代器（ Iterator) 6、switch字符串枚举允许的类型： 基本数据类型：byte, short, char, int 包装数据类型：Byte, Short, Character, Integer 枚举类型：Enum Jdk 7+（JDK1.7之后） 开始支持 字符串类型：String（Jdk 7+（JDK1.7之后） 开始支持 不支持boolean和double，float，long型 12345678910public static void choose(String str) { switch (str) { case \"hello\": System.out.println(\"h\"); break; case \"world\": System.out.println(\"w\"); break; } } 注意 switch 配合 String 和枚举使用时，变量不能为null，原因分析完语法糖转换后的代码应当自 然清楚 字节码： 12345678910111213141516171819202122232425public static void choose(String str) { byte var2 = -1; //其实是将字符串转换为hashcode 即为字符串和枚举时不能为空 switch(str.hashCode()) { //case的变量在编译的时候已经确定 case 99162322: if (str.equals(\"hello\")) { var2 = 0; } break; case 113318802: if (str.equals(\"world\")) { var2 = 1; } } switch(var2) { case 0: System.out.println(\"h\"); break; case 1: System.out.println(\"w\"); } } 可以看到，执行了两遍 switch，第一遍是根据字符串的 hashCode 和 equals 将字符串的转换为相应 byte 类型，第二遍才是利用 byte 执行进行比较。 为什么第一遍时必须既比较 hashCode，又利用 equals 比较呢？hashCode 是为了提高效率，减少可 能的比较；而 equals 是为了防止 hashCode 冲突，例如 BM 和 C. 这两个字符串的hashCode值都是 2123 ，如果有如下代码： 12345678910public static void choose(String str) { switch (str) { case \"BM\": System.out.println(\"h\"); break; case \"C.\": System.out.println(\"w\"); break; } } 字节码 12345678910111213141516171819202122public static void choose(String str) { byte var2 = -1; switch(str.hashCode()) { //hash碰撞 case 2123: //hash碰撞后再采用equals进行值的比较，提高效率。这样做和hashmap类似 if (str.equals(\"C.\")) { var2 = 1; } else if (str.equals(\"BM\")) { var2 = 0; } default: switch(var2) { case 0: System.out.println(\"h\"); break; case 1: System.out.println(\"w\"); } } } 7、switch枚举12345678910111213141516171819public class T4 { public static void main(String[] args) { } public static void choose(Sex sex) { switch (sex) { case MALE: System.out.println(\"男\"); break; case FEMALE: System.out.println(\"女\"); break; } }}enum Sex{ MALE, FEMALE} 8、枚举类JDK 7 新增了枚举类，以前面的性别枚举为例： 1234enum Sex { MALE, FEMALE } 转换后代码： 9、try-with-resourcesJDK 7 开始新增了对需要关闭的资源处理的特殊语法 try-with-resources： 12345try(资源变量 = 创建资源对象){ } catch( ) { } 其中资源对象需要实现 AutoCloseable 接口，例如 InputStream 、 OutputStream 、 Connection 、 Statement 、 ResultSet 等接口都实现了 AutoCloseable ，使用 try-withresources 可以不用写 finally 语句块，编译器会帮助生成关闭资源代码，例如： 1234567public static void main(String[] args) { try (InputStream is = new FileInputStream(\"d:/1.txt\")) { System.out.println(is); } catch (IOException e) { e.printStackTrace(); } } 编译后的代码： 12345678910111213141516171819202122232425262728293031323334public static void main(String[] args) { try { InputStream is = new FileInputStream(\"d:/1.txt\"); Throwable var2 = null; try { System.out.println(is); } catch (Throwable var12) { //var2是我们代码出现的异常 var2 = var12; throw var12; } finally { //判断资源不为空 if (is != null) { //如果我们代码有异常 if (var2 != null) { try { is.close(); } catch (Throwable var11) { // 如果 close 出现异常，作为被压制异常添加 var2.addSuppressed(var11); } } else { // 如果我们代码没有异常，close 出现的异常就是后 catch 块中的 e is.close(); } } } } catch (IOException var14) { var14.printStackTrace(); } } 为什么要设计一个 addSuppressed(Throwable e) （添加被压制异常）的方法呢？是为了防止异常信 息的丢失（想想 try-with-resources 生成的 ﬁanlly 中如果抛出了异常）： 1234567891011121314151617public class T5 { public static void main(String[] args) { try (MyResouce myResouce=new MyResouce()){ int i=1/0; } catch (Exception e) { //执行的代码异常 e.printStackTrace(); } }}class MyResouce implements AutoCloseable{ @Override public void close() throws Exception { //关闭时的异常 throw new Exception(\"close异常\"); }} 执行的代码和关闭时的异常都能捕获到。 12345java.lang.ArithmeticException: / by zero at org.lc.jvm_compiler.T5.main(T5.java:20) Suppressed: java.lang.Exception: close异常 at org.lc.jvm_compiler.MyResouce.close(T5.java:30) at org.lc.jvm_compiler.T5.main(T5.java:21) 10、方法重写时的桥接我们都知道，方法重写时对返回值分两种情况： 父子类的返回值完全一致 子类返回值可以是父类返回值的子类（比较绕口，见下面的例子） 对于子类，java 编译器会做如下处理： 其中桥接方法比较特殊，仅对 java 虚拟机可见，并且与原来的 public Integer m() 没有命名冲突，可以 用下面反射代码来验证 123for (Method m : B.class.getDeclaredMethods()) { System.out.println(m); } 会输出： 12public java.lang.Integer test.candy.B.m()public java.lang.Number test.candy.B.m() 11、匿名内部类12345678910public class T7 { public static void main(String[] args) { Runnable runnable=new Runnable() { @Override public void run() { System.out.println(\"ok\"); } }; }} 转换之后的代码： 1234567// 额外生成的类 final class Candy11$1 implements Runnable { Candy11$1() { } public void run() { System.out.println(\"ok\"); } } 12345public class T7 { public static void main(String[] args) { Runnable runnable=new Candy11$1(); }} 引用局部变量的匿名内部类 转换后代码： 12345public class T7 { public static void test(final int x) { Runnable runnable=new Candy11$1(x); }} 为了保证一致性，即局部变量中的值在匿名内部类中使用始终不变，即在局部变量上加final 四、类加载阶段1、加载 将类的字节码载入方法区中，内部采用 C++ 的 instanceKlass 描述 java 类，它的重要 ﬁeld 有： _java_mirror 即 java 的类镜像，例如对 String 来说，就是 String.class，作用是把 klass 暴 露给 java 使用 _super 即父类 _ﬁelds 即成员变量 _methods 即方法 _constants 即常量池 _class_loader 即类加载器 _vtable 虚方法表 _itable 接口方法表 如果这个类还有父类没有加载，先加载父类 加载和链接可能是交替运行的 注意: instanceKlass 这样的【元数据】是存储在方法区（1.8 后的元空间内），但 _java_mirror 是存储在堆中 可以通过前面介绍的 HSDB 工具查看 2、链接①验证验证类是否符合 JVM规范，安全性检查 用 UE 等支持二进制的编辑器修改 HelloWorld.class 的魔数，在控制台运行 ②准备为 static 变量分配空间，设置默认值 static 变量在 JDK 7 之前存储于 instanceKlass 末尾(方法区元空间)，从 JDK 7 开始，存储于 _java_mirror 末尾(堆) static 变量分配空间和赋值是两个步骤，分配空间在准备阶段完成，赋值在初始化阶段完成 如果 static 变量是 ﬁnal 的基本类型，以及字符串常量，那么编译阶段值就确定了，赋值在准备阶 段完成 如果 static 变量是 ﬁnal 的，但属于引用类型，那么赋值也会在初始化阶段完成 12345678910111213public class T8 { //静态成员是在准备阶段做分配空间的操作(和赋初始值)，并未赋值 static int a; //静态成员是在准备阶段做分配空间的操作，在类的构造(&lt;cinit()V&gt;)时候即初始化阶段赋值 static int b=10; //静态final成员，若为基本类型(包括String)。在准备阶段即完成赋值操作， static final int c=20; //静态final成员在准备阶段即完成赋值操作 static final String d = \"hello\"; //静态final成员，若为引用类型(String除外)，赋值阶段是在类的构造(&lt;cinit()V&gt;)进行的即初始化阶段 static final Object e=new Object();} 字节码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556{ static int a; descriptor: I flags: ACC_STATIC static int b; descriptor: I flags: ACC_STATIC static final int c; descriptor: I flags: ACC_STATIC, ACC_FINAL ConstantValue: int 20 static final java.lang.String d; descriptor: Ljava/lang/String; flags: ACC_STATIC, ACC_FINAL ConstantValue: String hello static final java.lang.Object e; descriptor: Ljava/lang/Object; flags: ACC_STATIC, ACC_FINAL //构造方法 public org.lc.jvm_compiler.T8(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.\"&lt;init&gt;\":()V 4: return LineNumberTable: line 10: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lorg/lc/jvm_compiler/T8; //类的构造 static {}; descriptor: ()V flags: ACC_STATIC Code: stack=2, locals=0, args_size=0 0: bipush 10 2: putstatic #2 // Field b:I 5: new #3 // class java/lang/Object 8: dup 9: invokespecial #1 // Method java/lang/Object.\"&lt;init&gt;\":()V 12: putstatic #4 // Field e:Ljava/lang/Object; 15: return LineNumberTable: line 14: 0 line 19: 5}SourceFile: \"T8.java\" ③解析将常量池中的符号引用解析为直接引用。我们将字节码的方法字段等信息加载到方法区，未解析之前这些只是一些未知的符号，当经过解析之后，将把符号和内存中的位置(地址)相关联。 3、初始化&lt;cinit&gt;()v方法 初始化即调用&lt;cinit&gt;()v,虚拟机会保证这个类的『构造方法』的线程安全 发生的时机： 会发生初始化 概括得说，类初始化是【懒惰的】 main 方法所在的类，总会被首先初始化 首次访问这个类的静态变量或静态方法时 子类初始化，如果父类还没初始化，会引发 父类的初始化 子类访问父类的静态变量，只会触发父类的初始化 Class.forName 默认会造成类的初始化 new 会导致初始化 调用静态方法会触发类的初始化，若父类未初始化，则会优先触发父类的初始化。若子类调用父类的静态方法则，只会触发父类的初始化 不会发生初始化 访问类的 static ﬁnal 静态常量（基本类型和字符串）不会触发初始化。在链接的准备阶段即完成赋值操作。 类对象.class 不会触发初始化 。 在类加载的时候就会加载此Class (_java_mirror 即 java 的类镜像) 创建该类的数组不会触发初始化 调用类加载器的loadClass方法 Class.forName的第二个参数为false。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class A{ static int a=0; static { System.out.println(\"a init\"); }}class B extends A{ final static double b=5.0; static boolean c=false; static { System.out.println(\"b init\"); }}public class T1 { // 若类初始化 则会执行static中的内容 static { System.out.println(\"main init\"); } //有main方法所在的类会初始化 public static void main(String[] args) throws ClassNotFoundException {// ***************************不会初始化的情况***********************************// 1、静态常量(基本类型和字符串)不会触发初始化// System.out.println(B.b);// 2、类.class不会触发初始化(加载阶段已经创建好class)// System.out.println(B.class);// 3、创建该类的数组不会触发初始化// System.out.println(new B[0]);// 4、不会初始化A,B 但是会加载A,B// ClassLoader c1= Thread.currentThread().getContextClassLoader();// c1.loadClass(\"org.lc.jvm_classloader.B\");// 5、不会初始化A,B 但是会加载A,B// ClassLoader c2=Thread.currentThread().getContextClassLoader();// 不初始化:参数设为false// Class.forName(\"org.lc.jvm_classloader.B\", false, c2); // ***************************会初始化的情况***********************************// 1、首次访问这个类的静态变量或静态方法时。初始化A// System.out.println(A.a);// 2、子类初始化，如果父类还没有初始化，会引发父类的初始化。初始化A,B。父类优先初始化// System.out.println(B.c);// 3、子类访问父类的静态变量，只触发父类的初始化，初始化A// System.out.println(B.a);// 4、会初始A,B. 优先初始化父类A// Class.forName(\"org.lc.jvm_classloader.B\");// 从源码 默认初始化参数为true// return forName0(className, true, ClassLoader.getClassLoader(caller), caller); }} *4、练习12345678910111213141516171819public class T2 { public static void main(String[] args) {// 不会初始化 System.out.println(E.a);// 不会初始化 System.out.println(E.b); //会初始化 System.out.println(E.c); }}class E { static { System.out.println(\"E init\"); } public static final int a = 10; public static final String b = \"hello\"; //会初始化 因为jvm在编译期间自动帮我们对20进行装箱的操作 public static final Integer c = 20; //Integer.valueOf(20);} 安全的单例模式： 1234567891011121314public class Singleton { private Singleton(){ } //静态内部类可以访问外部类的成员 private static class LazyHolder{ static final Singleton INSTANCE=new Singleton(); }// 第一次调用 getInstance 方法，才会导致内部类加载和初始化其静态成员 public static Singleton getInstance() { return LazyHolder.INSTANCE; }} *5、静态成员存储位置​ 在JDK8之前，静态成员（静态变量和静态方法）都是存储在方法区（永久代）中的静态区中（这里指类被加载后，静态成员的存储位置）。但在JDK8之后，永久代被移除了，取而代之的是元空间（metaspace）。但元空间中存储的主要是.class文件的元数据信息，静态成员的存储位置由方法区转到了堆内存（heap）中。​ 不过，不管是JDK8，还是更早的版本中，静态方法的执行（不仅仅是静态方法，还有普通的成员方法）都是在栈内存（stack）中进行的。每个线程都会在栈内存中开辟一个栈，在调用方法时，对应的方法都会在执行这个方法的线程的栈中创建一个“栈帧”，栈帧中保存了局部变量表（基本数据类型和对象引用）、操作数栈、动态连接和返回地址等信息。等到方法执行完毕，栈帧被销毁，对应的内存也将被释放 五、类加载器1、类加载器分类以jdk8为例： 名称 加载哪的类 说明 Bootstrap ClassLoader(启动类加载器) JAVA_HOME/jre/lib 无法直接访问 Extension ClassLoader(扩展类加载器) JAVA_HOME/jre/lib/ext 上级为 Bootstrap，显示为 null Application ClassLoader(应用程序加载器) classpath(我们应用程序启动的路径) 上级为 Extension 自定义类加载器 自定义 上级为 Application Bootstrap ClassLoader启动类加载器由c++实现。其余的加载器均由java实现且全部继承自java.lang.ClassLoader 123456789101112131415161718public class T3 { public static void main(String[] args) throws ClassNotFoundException { //1、使用 Class类获取该类的ClassLoader对象。 获取该类的类加载器 //null 说明为启动类加载器 System.out.println(String.class.getClassLoader()); //2、使用 ClassLoader类加载器对象的getParent()获取该类的上一级加载器 //sun.misc.Launcher$ExtClassLoader@135fbaa4 说明为本级为应用程序类加载器。上一级为扩展类加载器 System.out.println(T1.class.getClassLoader().getParent()); //3、上述方式1,2不会触发类的初始化 //通过Class.forName会触发类的初始化 Class&lt;?&gt; aClass = Class.forName(\"org.lc.jvm_classloader.T1\"); //sun.misc.Launcher$AppClassLoader@18b4aac2 说明为应用程序类加载器 System.out.println(aClass.getClassLoader()); }} 2、双亲委派模式所谓的双亲委派，就是指调用类加载器的 loadClass 方法时，查找类的规则 默认通过ClassLoader加载指定类走的是双亲委派机制 123456public class T3 { public static void main(String[] args) throws ClassNotFoundException { ClassLoader classLoader = T3.class.getClassLoader(); System.out.println(classLoader.loadClass(\"org.lc.jvm_classloader.T1\").getClassLoader()); }} 源码分析 1234567891011121314151617181920212223242526272829303132333435363738394041424344protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException { synchronized (getClassLoadingLock(name)) { // First, check if the class has already been loaded //1、首先检查本类的类加载器是否已经加载该类，首次肯定没有。 Class&lt;?&gt; c = findLoadedClass(name); if (c == null) { long t0 = System.nanoTime(); try { //2、如果本类的上级类加载器不为空 if (parent != null) { //3、使用上级的类加载器查找该类是否加载。采用递归的方式继续向上级查找 c = parent.loadClass(name, false); } else { //4、直到上级为空即为BootstrapClassloader时，然后调用 c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { //类没找到抛出异常 // ClassNotFoundException thrown if class not found // from the non-null parent class loader } if (c == null) { // If still not found, then invoke findClass in order // to find the class. //当递归到BootstrapClassloader加载器时，会分别使用各自的加载器向下递归加载类，若找到则返回，否则抛出的异常ClassNotFoundException被下一级类加载器捕获 long t1 = System.nanoTime(); //使用各自的类加载器加载该类 c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); } } if (resolve) { resolveClass(c); } return c; } } 就上述例子执行流程 1、首先使用本类的加载器(应用程序类加载器)查看要加载的类T1是否被加载，首次应该没用被加载。 2、然后会使用本类的上一级加载器(扩展类加载器)查看T1类是否被加载(parent.loadClass(name, false))，此时开始递归调用，直到递归到parent为null即到启动类加载器的时候，查看T1类是否被加载，若没有则开始使用启动类加载器加载此类，若找不到此类，则抛出异常，该异常有下一级类加载器捕获。从上到下依次使用各自的类加载器加载此类。直达加载到此类返回，或者抛出异常ClassNotFoundException。 3、从本级的类加载器开始向上级类加载器寻找要加载的类是否已经被加载，直到递归到顶级类加载器(BootStrapClassloader)时，若还未发现要加载的类没有被加载，则开始使用各自的类加载器加载要加载的类(findClass(name))，从上级往下级依次使用类加载器加载。知道找到类或抛出异常 双亲委派的作用： 防止重复加载同一个.class。通过委托去向上面问一问，加载过了，就不用再加载一遍。保证数据安全。 保证核心.class不能被篡改。通过委托方式，不会去篡改核心.class，即使篡改也不会去加载，即使加载也不会是同一个.class对象了。不同的加载器加载同一个.class也不是同一个Class对象。这样保证了Class执行安全。 3、线程上下文类加载器我们在使用 JDBC 时，都需要加载 Driver 驱动，不知道你注意到没有，不写 1Class.forName(\"com.mysql.jdbc.Driver\") 也是可以让 com.mysql.jdbc.Driver 正确加载的，你知道是怎么做的吗？ 让我们追踪一下源码: 123456789public class DriverManager { // 注册驱动的集合 private final static CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers= new CopyOnWriteArrayList&lt;&gt;(); // 初始化驱动 static { loadInitialDrivers(); println(\"JDBC DriverManager initialized\"); }} 先不看别的，看看 DriverManager 的类加载器： 1System.out.println(DriverManager.class.getClassLoader()); 打印 null，表示它的类加载器是 Bootstrap ClassLoader，会到 JAVA_HOME/jre/lib 下搜索类，但 JAVA_HOME/jre/lib 下显然没有 mysql-connector-java-5.1.47.jar 包，这样问题来了，在 DriverManager 的静态代码块中，怎么能正确加载 com.mysql.jdbc.Driver 呢？ 这里其实是打破双亲委派模式的规则，因为我们发现DriverManager 的类加载器为启动类加载器，但是启动类加载器中并没有类文件，所以无法找到 1)使用ServiceLoader机制加载启动 即SPI Thread.currentThread().getContextClassLoader(); 获取的还是启动类加载器 12345public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service) { //默认把应用程序类加载器赋值给当前线程。当前线程获取的时候拿到的即为应用程序类加载器 ClassLoader cl = Thread.currentThread().getContextClassLoader(); return ServiceLoader.load(service, cl); } 12345678910ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class); Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator(); try{ while(driversIterator.hasNext()) { driversIterator.next(); } } catch(Throwable t) { // Do nothing } return null; 2)使用 jdbc.drivers 定义的驱动名加载驱动 我们从源码发现，其实内部还是调用的一个 ClassLoader.getSystemClassLoader() 获得的是应用程序类加载器加载Dirver驱动 123456789101112131415if (drivers == null || drivers.equals(\"\")) { return; } String[] driversList = drivers.split(\":\"); println(\"number of Drivers:\" + driversList.length); for (String aDriver : driversList) { try { println(\"DriverManager.Initialize: loading \" + aDriver); //使用ClassLoader.getSystemClassLoader()获得应用程序类加载器加载驱动 Class.forName(aDriver, true, ClassLoader.getSystemClassLoader()); } catch (Exception ex) { println(\"DriverManager.Initialize: load failed: \" + ex); } } 4、自定义类加载器 什么时候需要自定义类加载器 1）想加载非 classpath 随意路径中的类文件 2）都是通过接口来使用实现，希望解耦时，常用在框架设计 3）这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于 tomcat 容器 步骤： 继承 ClassLoader 父类 要遵从双亲委派机制，重写 ﬁndClass 方法 注意不是重写 loadClass 方法，否则不会走双亲委派机制 读取类文件的字节码 调用父类的 deﬁneClass 方法来加载类 使用者调用该类加载器的 loadClass 方法 注意：认定是同一个类的条件是：类加载器相同，名称相同，命名空间相同。 使用不同的类加载器加载的类不同","link":"/2020/07/24/jvm/JVM/"},{"title":"深入理解Java并发编程","text":"-Ⅰ、进程和线程 一、进程和线程的区别？简单的比喻：进程=火车，线程=车厢 线程在进程下行进（单纯的车厢无法运行） 一个进程可以包含多个线程（一辆火车可以有多个车厢） 不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘） 同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易） 进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源） 进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢） 进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上） 进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－“互斥锁” 进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量” 进一步总结： 进程是一个资源的容器，为进程里的所有线程提供共享资源，是对程序的一种静态描述 线程是计算机最小的调度和运行单位，是对程序的一种动态描述 例如： 开个QQ，开了一个进程；开了迅雷，开了一个进程。在QQ的这个进程里，传输文字开一个线程、传输语音开了一个线程、弹出对话框又开了一个线程。 所以运行某个软件，相当于开了一个进程。在这个软件运行的过程里（在这个进程里），多个工作支撑的完成QQ的运行，那么这“多个工作”分别有一个线程。 所以一个进程管着多个线程。 1、进程 程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在 指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的 当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。 进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器 等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等） 2、线程 一个进程之内可以分为一到多个线程。 一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行 Java 中，线程作为小调度单位，进程作为资源分配的小单位。 在 windows 中进程是不活动的，只是作 为线程的容器 3、进程和线程的区别 进程是资源分配的最小单位，线程是CPU调度的最小单位 进程基本上相互独立的，而线程存在于进程内，是进程的一个子集 进程拥有共享的资源，如内存空间等，供其内部的线程共享 进程间通信较为复杂 同一台计算机的进程通信称为 IPC（Inter-process communication） 不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP 线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量 线程更轻量，线程上下文切换成本一般上要比进程上下文切换低 Ⅱ、Java线程一、创建线程的方式1、继承Thread只有调用start()方法才算开启一个线程。否则只是代表创建一个Thread实例。 123456789public class MyThread extends Thread{ @Override public void run() { for (int i = 0; i &lt; 10; i++) {// Thread.currentThread().getName()获取当前线程名称 System.out.println(Thread.currentThread().getName()+\":\"+i); } }} 1234567891011121314151617181920public class T1 { public static void main(String[] args) {// ①继承Thread类 重写run方法 MyThread myThread=new MyThread();// 设置线程的名称 myThread.setName(\"myThread\"); myThread.start();// ②使用匿名内部类继承Thread Thread thread1=new Thread(\"thread1\"){ @Override public void run() { for (int i = 0; i &lt; 10; i++) { System.out.println(Thread.currentThread().getName()+\":\"+i); } } }; thread1.start(); }} 2、实现Runnable接口12345678public class MyRunnable implements Runnable { @Override public void run() { for (int i = 0; i &lt; 10; i++) { System.out.println(Thread.currentThread().getName()+\":\"+i); } }} 123456789101112131415161718public class T1 { public static void main(String[] args) {// ①传入Runnable接口的实现类 Thread thread=new Thread(new MyRunnable(), \"myRunnable\"); thread.start();// ②使用匿名内部类实现Runnable接口 Thread thread1=new Thread(new Runnable(){ @Override public void run() { for (int i = 0; i &lt; 10; i++) { System.out.println(Thread.currentThread().getName()+\":\"+i); } } },\"myRunnable2\"); thread1.start(); }} 3、实现Callable接口Callable和Runnable的区别是，Callable接口可以拿到线程处理后的返回值给其他线程使用 12345678910111213141516171819202122232425262728293031323334353637383940public class MyCallable implements Callable&lt;Integer&gt; { @Override public Integer call() throws Exception { Thread.sleep(2000); System.out.println(Thread.currentThread().getName()); return 100; } public static void main(String[] args) {// 新建任务// ①通过实现Callable接口 FutureTask&lt;Integer&gt; task=new FutureTask&lt;&gt;(new MyCallable());// ②使用匿名内部类实现Callable实现接口 FutureTask&lt;String&gt; task1=new FutureTask&lt;&gt;(()-&gt;{ System.out.println(Thread.currentThread().getName()); return \"hello java\"; });// FutureTask也是实现Runnable接口的 Thread thread=new Thread(task, \"MyCallable\"); Thread thread1=new Thread(task1,\"MyCallable2\");// 开启此线程 thread.start(); thread1.start();// 主线程获取返回值 try {// 注意：主线程会一直阻塞在这里，直到get拿到此返回值 Integer t1 = task.get(); String t2 = task1.get(); System.out.println(t1); System.out.println(t2); } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } }} 4、Thread和Runnable的关系Thread 是把线程和任务合并在了一起 Runnable是把线程和任务分开了 用 Runnable 更容易与线程池等高级 API 配合 用 Runnable 让任务类脱离了 Thread 继承体系，更灵活 三、原理之线程运行1、栈与栈帧栈先进后出 Java Virtual Machine Stacks （Java 虚拟机栈） 我们都知道 JVM 中由堆、栈、方法区所组成，其中栈内存是给谁用的呢？其实就是线程，每个线程启动后，虚拟 机就会为其分配一块栈内存。 每个线程都有自己的一个独立的栈帧，栈帧之间互不影响。 每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存 每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法 idea中每个方法执行的栈帧，我们可以看到main方法首先入栈，然后method1和method2相继压栈，最后mehtod2和mehtod1执行完后，从上到下出栈 图解分析：方法执行在jvm中内存区域分析： 方法相继出栈： 2、线程上下文切换因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码 线程的 cpu 时间片用完 垃圾回收 有更高优先级的线程需要运行 线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法 当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念 就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的 状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等 Context Switch 频繁发生会影响性能 四、Thread常用方法 方法名 static 功能说明 注意 start() 启动一个新线 程，在新的线程 运行 run 方法 中的代码 start 方法只是让线程进入就绪，里面代码不一定立刻 运行（CPU 的时间片还没分给它）。每个线程对象的 start方法只能调用一次，如果调用了多次会出现 IllegalThreadStateException run() 新线程启动后会 调用的方法 如果在构造 Thread 对象时传递了 Runnable 参数，则 线程启动后会调用 Runnable 中的 run 方法，否则默 认不执行任何操作。但可以创建 Thread 的子类对象， 来覆盖默认行为 join() 等待线程运行结 束 join(long n) 等待线程运行结 束,多等待 n 毫秒 getId() 获取线程长整型 的 id id 唯一 getName() 获取线程名 setName(String name) 修改线程名 getPriority() 获取线程优先级 setPriority(int) 修改线程优先级 java中规定线程优先级是1~10 的整数，较大的优先级 能提高该线程被 CPU 调度的机率 getState() 获取线程状态 Java 中线程状态是用 6 个 enum 表示，分别为： NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED isInterrupted() 判断是否被打 断 不会清除 打断标记 isAlive() 线程是否存活 （还没有运行完 毕） interrupt() 打断线程 如果被打断线程正在 sleep，wait，join 会导致被打断 的线程抛出 InterruptedException，并清除 打断标记；如果打断的正在运行的线程，则会设置 打断标记；park 的线程被打断，也会设置 打断标记 interrupted() static 判断当前线程是 否被打断 会清除 打断标记 currentThread() static 获取当前正在执 行的线程 sleep(long n) static 让当前执行的线 程休眠n毫秒， 休眠时让出 cpu 的时间片给其它 线程 yield() static 提示线程调度器 让出当前线程对 CPU的使用 主要是为了测试和调试 五、sleep与yield1、sleep①调用 sleep 会让当前线程从 Running 进入 Timed Waiting 状态（阻塞） 1234567891011121314151617181920212223242526272829@Slf4jpublic class T1 { public static void main(String[] args) { Thread t1=new Thread(()-&gt;{ try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } });// 新建的线程t1处于new状态// NEW log.info(\"{}\",t1.getState()); t1.start();// 调用start方法后线程t1处于可运行状态// RUNNABLE log.info(\"{}\",t1.getState()); try {// 主线程休眠1秒 Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); }// 此时主线程执行到这的时候，t1线程处于休眠状态// 即此时t1处于超时等待// TIMED_WAITING log.info(\"{}\",t1.getState()); }} ②其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException 123456789101112131415161718@Slf4jpublic class T2 { public static void main(String[] args) throws InterruptedException { Thread t1=new Thread(()-&gt;{ try { log.info(\"start sleep....\"); Thread.sleep(3000); } catch (InterruptedException e) { log.info(\"i wake up\"); e.printStackTrace(); } }); t1.start(); Thread.sleep(1000);// 打断正在休眠的进程 抛出InterruptedException异常 t1.interrupt(); }} 12345617:02:56.329 [Thread-0] INFO org.lc.sleep_yield.T2 - start sleep....17:02:57.325 [Thread-0] INFO org.lc.sleep_yield.T2 - i wake upjava.lang.InterruptedException: sleep interrupted at java.lang.Thread.sleep(Native Method) at org.lc.sleep_yield.T2.lambda$main$0(T2.java:18) at java.lang.Thread.run(Thread.java:748) ③睡眠结束后的线程未必会立刻得到执行 睡眠过后，还是要等cpu来分配时间片给该线程来执行 ④建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性 TimeUnit.DAYS TimeUnit.HOURS TimeUnit.MINUTES TimeUnit.SECONDS 1234567891011121314@Slf4jpublic class T3 { public static void main(String[] args) { log.info(\"start sleep\"); try {// 格式化睡眠时间 1 秒 TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } log.info(\"end sleep\"); }} 2、yieldThread.yield(); ①调用 yield 会让当前线程从 Running 进入 Runnable 就绪状态，然后调度执行其它线程 ②具体的实现依赖于操作系统的任务调度器 1234567891011121314151617181920public class T4 { public static void main(String[] args) { Thread t1=new Thread(()-&gt;{ int count = 0; for (; ; ) {// 设置yield() 让出cpu Thread.yield(); System.out.println(\"t1----:\"+count++); } },\"t1\"); Thread t2=new Thread(()-&gt;{ int count = 0; for (; ; ) { System.out.println(\"t2----:\"+count++); } },\"t2\"); t1.start(); t2.start(); }} 12345678......t1----:6577t1----:6578t1----:6579t2----:23524t2----:23525t2----:23526.... 我们明显可以发现，yield是有一定作用来让出cpu时间片给其他线程来执行的 3、sleep与yield的区别当运行中的线程调用yield方法时，会直接进入从运行状态进入就绪状态，然后等待cpu时间片的调用。 当运行中的线程调用sleep方法时，线程会进入一个timed waiting阻塞状态，只有该sleep时间片过了，才有机会让cpu调用此线程 4、线程优先级 线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它 如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用 setPriority(int newPriority) 范围：1-10 123456789101112 /** * 线程最小的优先级. */ public final static int MIN_PRIORITY = 1;/** * 线程默认的优先级. */ public final static int NORM_PRIORITY = 5; /** * 线程最大的优先级 */ public final static int MAX_PRIORITY = 10; 12345678910111213141516171819202122public class T4 { public static void main(String[] args) { Thread t1=new Thread(()-&gt;{ int count = 0; for (; ; ) { System.out.println(\"t1----:\"+count++); } },\"t1\"); Thread t2=new Thread(()-&gt;{ int count = 0; for (; ; ) { System.out.println(\"t2----:\"+count++); } },\"t2\");// 设置t1线程最大的优先级 t1.setPriority(Thread.MAX_PRIORITY);// 设置t2线程最小的优先级 t2.setPriority(Thread.MIN_PRIORITY); t1.start(); t2.start(); }} 123456...t1----:34178t1----:34179t2----:28259t2----:28260... 我们可以发现优先级高的线程比优先级高的有明显 5、设置线程优先级和yield的区别都是可以尽量让出cpu时间片给其他线程执行，但是还是取决于cpu的执行能力和cpu是否闲忙的程度 6、sleep应用：使用sleep限制对cpu的占用​ 在没有利用 cpu 来计算时，不要让 while(true) 空转浪费 cpu，这时可以使用 yield 或 sleep 来让出 cpu 的使用权 给其他程序 可以用 wait 或 条件变量达到类似的效果 不同的是，后两种都需要加锁，并且需要相应的唤醒操作，一般适用于要进行同步的场景 sleep 适用于无需锁同步的场景 在单核cpu情况下，如果我们运行一下代码： 123456789public class T5 { public static void main(String[] args) { new Thread(()-&gt;{ while (true) { System.out.println(\"hello world! \"); } }).start(); }} 我们会发现cpu会出现占满的情况。 修改以上代码： 1234567891011121314public class T5 { public static void main(String[] args) { new Thread(()-&gt;{ while (true) { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"hello world! \"); } }).start(); }} 我们可以发现加上sleep后cpu占用率明显下降。 六、join的使用join会阻塞当前正在运行的代码。直到该join对应的线程执行完毕。 join底层其实就是wait 1、基本应用1234567891011121314151617181920212223@Slf4jpublic class T6 { static int a=0; public static void main(String[] args) throws InterruptedException { log.info(\"开始\"); Thread t1 = new Thread(() -&gt; { try { log.info(\"开始\"); Thread.sleep(1000); log.info(\"结束\"); } catch (InterruptedException e) { e.printStackTrace(); } a=10; }, \"t1\"); t1.start();// 主线程等待该线程结束 然后才能执行后面的代码 会阻塞当前主线程 t1.join(); log.info(\"结果为:{}\",a); log.info(\"结束\"); }} 1234510:14:00.197 [main] INFO org.lc.sleep_yield.T6 - 开始10:14:00.240 [t1] INFO org.lc.sleep_yield.T6 - 开始10:14:01.240 [t1] INFO org.lc.sleep_yield.T6 - 结束10:14:01.240 [main] INFO org.lc.sleep_yield.T6 - 结果为:1010:14:01.241 [main] INFO org.lc.sleep_yield.T6 - 结束 2、同步应用-等待多个线程结果以调用方角度来讲，如果 需要等待结果返回，才能继续运行就是同步 不需要等待结果返回，就能继续运行就是异步 1234567891011121314151617181920212223242526272829303132333435@Slf4jpublic class T7 { static int a=0; static int b=0; public static void main(String[] args) throws InterruptedException { test(); } private static void test() throws InterruptedException { Thread t1=new Thread(()-&gt;{ try { Thread.sleep(1000); a=10; } catch (InterruptedException e) { e.printStackTrace(); } },\"t1\"); Thread t2=new Thread(()-&gt;{ try { Thread.sleep(2000); b=20; } catch (InterruptedException e) { e.printStackTrace(); } },\"t2\"); long start = System.currentTimeMillis(); t1.start(); t2.start(); t1.join(); t2.join(); long end = System.currentTimeMillis(); log.info(\"a:{} b:{} 花费时间:{}\",a,b,end-start); }} 110:25:45.948 [main] INFO org.lc.sleep_yield.T7 - a:10 b:20 花费时间:2000 我们可以发现，为啥不是3秒呢？ 因为t1线程在跑的同时，t2线程也在跑。当等待t1线程跑完时，经过了1秒，到t2线程时，t2已经跑了1秒，所以现在只用等待1s即可，所以总共为2s 3、限时同步join(long n) 等待线程执行毫秒 1234567891011121314151617181920@Slf4jpublic class T7 { static int a=0; public static void main(String[] args) throws InterruptedException { test1(); } private static void test1() throws InterruptedException { Thread t1=new Thread(()-&gt;{ try { Thread.sleep(3000); a=10; } catch (InterruptedException e) { e.printStackTrace(); } },\"t1\"); t1.start(); t1.join(1500); log.info(\"{}\",a); }} 110:41:59.091 [main] INFO org.lc.sleep_yield.T7 - 0 我们发现当join设置的小于t1线程的执行时间时，t1线程还没有执行完，主线程即不再等待，将执行join后面的代码 12345678910111213141516171819202122@Slf4jpublic class T7 { static int a=0; public static void main(String[] args) throws InterruptedException { test1(); } private static void test1() throws InterruptedException { Thread t1=new Thread(()-&gt;{ try { Thread.sleep(2000); a=10; } catch (InterruptedException e) { e.printStackTrace(); } },\"t1\"); long s=System.currentTimeMillis(); t1.start(); t1.join(4000); long e=System.currentTimeMillis(); log.info(\"{}, 时间：{}\",a,e-s); }} 110:46:03.790 [main] INFO org.lc.sleep_yield.T7 - 10, 时间：2000 我们发现当设置的join时间大于t1线程的执行时间，则t1线程会提前终止join。 七、interrupt使用注意： interrupt() 使线程中断 。实例方法。 isInterrupted() 判断线程是否被打断，不会清除标记 。该方法为实例方法 interrupted() 判断线程是否被打断，会清除标记。该方法为静态方法 1、打断 sleep，wait，join 的阻塞线程打断sleep，wait，join时的阻塞线程，会清除interrupt标记，即isInterrupted()为false 这几个方法都会让线程进入阻塞状态打断 sleep 的线程, 会清空打断状态，以 sleep 为例(打断正在睡眠的线程)： 123456789101112131415161718@Slf4jpublic class T1 { public static void main(String[] args) throws InterruptedException { Thread t1=new Thread(()-&gt;{ try { log.info(\"开始睡眠\"); Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } }); t1.start(); Thread.sleep(1000); log.info(\"interrupt\"); t1.interrupt(); log.info(\"打断状态:{}\",t1.isInterrupted()); }} 123456711:38:13.518 [Thread-0] INFO org.lc.interrupt.T1 - 开始睡眠11:38:14.518 [main] INFO org.lc.interrupt.T1 - interruptjava.lang.InterruptedException: sleep interrupted at java.lang.Thread.sleep(Native Method) at org.lc.interrupt.T1.lambda$main$0(T1.java:18) at java.lang.Thread.run(Thread.java:748)11:38:14.518 [main] INFO org.lc.interrupt.T1 - 打断状态:false 2、打断正常运行的线程12345678910111213141516@Slf4jpublic class T2 { public static void main(String[] args) throws InterruptedException { Thread t1=new Thread(()-&gt;{ while (true) { } },\"t1\"); t1.start();// 保证t1线程能够在main线程执行打断方法时运行 Thread.sleep(1000); log.info(\"interrupt\"); t1.interrupt(); log.info(\"打断状态:{}\",t1.isInterrupted()); }} 1211:48:32.775 [main] INFO org.lc.interrupt.T2 - interrupt11:48:32.778 [main] INFO org.lc.interrupt.T2 - 打断状态:true 上述程序未终止 对于正常运行的线程，如果此时t1线程被告知需要打断，则需要在线程内部手动终止程序。否则会一直运行。 1234567891011121314151617181920@Slf4jpublic class T2 { public static void main(String[] args) throws InterruptedException { Thread t1=new Thread(()-&gt;{ while (true) {// 如果当前线程被告知要打断，即设置了interrupte标记为true if(Thread.currentThread().isInterrupted()){ log.info(\"退出循环！\"); break; } } },\"t1\"); t1.start();// 保证t1线程能够在main线程执行打断方法时运行 Thread.sleep(1000); log.info(\"interrupt\"); t1.interrupt(); log.info(\"打断状态:{}\",t1.isInterrupted()); }} 12311:51:59.831 [main] INFO org.lc.interrupt.T2 - interrupt11:51:59.834 [t1] INFO org.lc.interrupt.T2 - 退出循环！11:51:59.834 [main] INFO org.lc.interrupt.T2 - 打断状态:true 3、优雅的利用interrupt打断线程①错误思路 使用线程对象的 stop() 方法停止线程 stop 方法会真正杀死线程，如果这时线程锁住了共享资源，那么当它被杀死后就再也没有机会释放锁， 其它线程将永远无法获取锁 使用 System.exit(int) 方法停止线程 目的仅是停止一个线程，但这种做法会让整个程序都停止 ②终止模式之两阶段终止模式(Two Phase Termination )模拟应用监控，若出现应用出现异常则停止监控。手动点击停止，也停止监控 ③利用 isInterrupted()interrupt 可以打断正在执行的线程，无论这个线程是在 sleep，wait，还是正常运行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Slf4jpublic class TwoPhaseTermination {// 监视器线程 private static Thread monitor; /** * 启动线程监控 */ public static void start() { monitor =new Thread(()-&gt;{ while (true) {// 如果当前线程是被提示需要打断 if(Thread.currentThread().isInterrupted()){ log.info(\"日志监控停止...\"); break; } try { Thread.sleep(2000); log.info(\"日志监控中...\"); } catch (InterruptedException e) {// 当主程序第一次打算该线程时，如果在sleep时被打断，则interrupt为false// 当主程序第一次打算该线程时，如果在sleep之外时被打断，则interrupt为true,这时进入while时，interrupt为true// 所以这里我们需要手动设置，该线程要被打断 monitor.interrupt(); e.printStackTrace(); } } },\"monitor\"); monitor.start(); } /** * 终止线程 */ public static void stop() { monitor.interrupt(); } public static void main(String[] args) throws InterruptedException {// 启动监控 start();// 保证已经进入监控线程 Thread.sleep(8000);// 停止监控 log.info(\"stop\"); stop(); }} 12345678913:23:05.423 [monitor] INFO org.lc.interrupt.TwoPhaseTermination - 日志监控中...13:23:07.427 [monitor] INFO org.lc.interrupt.TwoPhaseTermination - 日志监控中...13:23:09.427 [monitor] INFO org.lc.interrupt.TwoPhaseTermination - 日志监控中...13:23:11.423 [main] INFO org.lc.interrupt.TwoPhaseTermination - stopjava.lang.InterruptedException: sleep interrupted at java.lang.Thread.sleep(Native Method) at org.lc.interrupt.TwoPhaseTermination.lambda$start$0(TwoPhaseTermination.java:31) at java.lang.Thread.run(Thread.java:748)13:23:11.423 [monitor] INFO org.lc.interrupt.TwoPhaseTermination - 日志监控停止... 4、打断park线程①打断 park 线程, 不会清空打断状态 ②如果打断标记已经是 true, 则 park 会失效 1234567891011121314151617181920@Slf4jpublic class ParkTest { public static void main(String[] args) throws InterruptedException { Thread t1=new Thread(()-&gt;{ log.info(\"park...\");// 执行到该代码时，该线程会阻塞 LockSupport.park(); log.info(\"unpark...\"); log.info(\"打断状态:{}\",Thread.currentThread().isInterrupted());// 再次使用park,不会阻塞该线程。 当线程打断的标记为true时，park不会阻塞线程 LockSupport.park(); log.info(\"unpark\"); },\"t1\"); t1.start(); Thread.sleep(2000);// 打断park线程 t1.interrupt(); }} 123415:31:21.611 [t1] INFO org.lc.interrupt.ParkTest - park...15:31:23.610 [t1] INFO org.lc.interrupt.ParkTest - unpark...15:31:23.610 [t1] INFO org.lc.interrupt.ParkTest - 打断状态:true15:31:23.611 [t1] INFO org.lc.interrupt.ParkTest - unpark 我们可以发现，打断后的park，线程标记为true,再次使用park时，park不会阻塞。即只有当线程标记为falses时park才有效。 结论：可以使用 Thread.interrupted() 清除打断状态 注意： Thread.currentThread().isInterrupted()和Thread.interrupted()最好不要同时使用。 Thread.interrupted()要在Thread.currentThread().isInterrupted()之前使用 5、 不推荐的方法还有一些不推荐使用的方法，这些方法已过时，容易破坏同步代码块，造成线程死锁 方法名 是否static 功能说明 stop() 停止线程运行 suspend() 挂起（暂停）线程运行 resume() 恢复线程运行 八、主线程和守护线程默认情况下线程为非守护线程，Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其它非守 护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。 设置守护线程的方法：setDaemon(true); 该方法为实例方法 123456789101112131415161718@Slf4jpublic class DaemonTest { public static void main(String[] args) throws InterruptedException { Thread t1=new Thread(()-&gt;{ try { log.info(\"开始运行\"); Thread.sleep(3000); log.info(\"线程t1终止...\"); } catch (InterruptedException e) { e.printStackTrace(); } },\"t1\"); t1.setDaemon(true); t1.start(); Thread.sleep(1000); log.info(\"主线程终止...\"); }} 1216:20:42.775 [t1] INFO org.lc.interrupt.DaemonTest - 开始运行16:20:43.774 [main] INFO org.lc.interrupt.DaemonTest - 主线程终止... 非守护线程执行完后，所有守护线程无论是否执行完毕，直接退出。无需执行守护线程后面代码 注意 垃圾回收器线程就是一种守护线程 Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等 待它们处理完当前请求 九、线程的状态1、五种状态(操作系统层面) 【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联 【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行 【运行状态】指获取了 CPU 时间片运行中的状态 当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换 【阻塞状态】 如果调用了阻塞 API，如 BIO(同步阻塞I/O) 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入 【阻塞状态】 等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】 与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑 调度它们 【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态 2、六种状态(Java层面)这是从 Java API 层面来描述的 根据 Thread.State 枚举，分为六种状态 NEW 线程刚被创建，但是还没有调用 start() 方法 RUNNABLE 当调用了 start() 方法之后，注意，Java API 层面的 RUNNABLE 状态涵盖了 操作系统 层面的 【可运行状态】、【运行状态】和【阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为 是可运行） BLOCKED ， WAITING， TIMED_WAITING 都是 Java API 层面对【阻塞状态】的细分，后面会在状态转换一节 详述 TERMINATED 当线程代码运行结束 3、代码示例六种状态12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576@Slf4jpublic class PeriodTest { public static void main(String[] args) {// 模拟新建状态NEW Thread t1 = new Thread(() -&gt; { log.info(\"running...\"); }, \"t1\");// 模拟可运行状态Runnable Thread t2 = new Thread(() -&gt; { while (true) {// 即任务的重复执行,执行完后从运行状态又回到可运行状态 } }, \"t2\"); t2.start();// 模拟终止TERMINATED状态 Thread t3 = new Thread(() -&gt; { log.info(\"running...\"); }, \"t3\"); t3.start();// 模拟有时限的等待状态TIMED WAITING Thread t4 = new Thread(() -&gt; {// 获得当前对象锁 synchronized (PeriodTest.class) { try {// 足够的睡眠时间 Thread.sleep(1000000); } catch (InterruptedException e) { e.printStackTrace(); } } }, \"t4\"); t4.start();// 模拟WAITING Thread t5 = new Thread(() -&gt; { try {// 阻塞状态 都不会得到任务调度器的调度 t2.join(); } catch (InterruptedException e) { e.printStackTrace(); } }, \"t5\"); t5.start();// 模拟BLOCK Thread t6 = new Thread(() -&gt; {// 此时的锁已经被t4线程拿到。所以这里拿不到锁 synchronized (PeriodTest.class) { try { Thread.sleep(1000000); } catch (InterruptedException e) { e.printStackTrace(); } } }, \"t6\"); t6.start(); try {// 等待t3线程执行完 Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } log.info(\"t1的线程状态为:{}\", t1.getState()); log.info(\"t2的线程状态为:{}\", t2.getState()); log.info(\"t3的线程状态为:{}\", t3.getState()); log.info(\"t4的线程状态为:{}\", t4.getState()); log.info(\"t5的线程状态为:{}\", t5.getState()); log.info(\"t6的线程状态为:{}\", t6.getState()); }} 123456717:30:16.284 [t3] INFO org.lc.interrupt.PeriodTest - running...17:30:17.284 [main] INFO org.lc.interrupt.PeriodTest - t1的线程状态为:NEW17:30:17.285 [main] INFO org.lc.interrupt.PeriodTest - t2的线程状态为:RUNNABLE17:30:17.285 [main] INFO org.lc.interrupt.PeriodTest - t3的线程状态为:TERMINATED17:30:17.285 [main] INFO org.lc.interrupt.PeriodTest - t4的线程状态为:TIMED_WAITING17:30:17.285 [main] INFO org.lc.interrupt.PeriodTest - t5的线程状态为:WAITING17:30:17.285 [main] INFO org.lc.interrupt.PeriodTest - t6的线程状态为:BLOCKED 十、习题1、烧水泡茶(sleep)阅读华罗庚《统筹方法》，给出烧水泡茶的多线程解决方案 123456789101112131415161718192021222324252627282930313233343536@Slf4jpublic class T8 { public static void main(String[] args) { Thread t1=new Thread(()-&gt;{ try { log.info(\"洗水壶...\"); Thread.sleep(1000); log.info(\"烧水...\"); Thread.sleep(10000); } catch (InterruptedException e) { e.printStackTrace(); } },\"张三\"); Thread t2 = new Thread(() -&gt; { try { log.info(\"洗茶壶...\"); Thread.sleep(1000); log.info(\"洗茶杯...\"); Thread.sleep(1000); log.info(\"拿茶叶...\"); Thread.sleep(1000);// 等待t1烧水的线程执行完。// WAITING t1.join(); log.info(\"泡茶叶...\"); } catch (InterruptedException e) { e.printStackTrace(); } }, \"小三\"); t1.start(); t2.start(); }} 12345618:01:49.779 [小三] INFO org.lc.sleep_yield.T8 - 洗茶壶...18:01:49.780 [张三] INFO org.lc.sleep_yield.T8 - 洗水壶...18:01:50.782 [张三] INFO org.lc.sleep_yield.T8 - 烧水...18:01:50.782 [小三] INFO org.lc.sleep_yield.T8 - 洗茶杯...18:01:51.783 [小三] INFO org.lc.sleep_yield.T8 - 拿茶叶...18:02:00.783 [小三] INFO org.lc.sleep_yield.T8 - 泡茶叶... 2、多线程下载图片12345678910111213141516171819202122232425262728293031323334public class DownloadImage extends Thread{ private String url; private String name; public DownloadImage(String url, String name) { this.url=url; this.name=name; } protected void downloadImageHandler() { try { FileUtils.copyURLToFile(new URL(this.url),new File(this.name)); System.out.println(\"下载文件:\"+this.name); } catch (IOException e) { e.printStackTrace(); } } @Override public void run() { this.downloadImageHandler(); } public static void main(String[] args) { DownloadImage d1=new DownloadImage(\"http://img.louchen.top/2020/05/rdb01.png\", \"1.png\"); DownloadImage d2=new DownloadImage(\"http://img.louchen.top/2020/05/rdb02.png\", \"2.png\"); DownloadImage d3=new DownloadImage(\"http://img.louchen.top/2020/05/aof01.png\", \"3.png\"); DownloadImage d4=new DownloadImage(\"http://img.louchen.top/2020/05/aof02.png\", \"4.png\"); d1.start(); d2.start(); d3.start(); d4.start(); }} 3、龟兔赛跑12345678910111213141516171819202122232425262728293031public class Race implements Runnable { private static String winner; protected boolean isOver(int step){ if(winner!=null){ return true; } if (step == 100) { winner=Thread.currentThread().getName(); System.out.println(\"胜利者是:\"+winner); return true; } return false; } @Override public void run() { for (int i = 0; i &lt;=100; i++) { boolean over = this.isOver(i); if(over){ break; } System.out.println(Thread.currentThread().getName()+\":跑了\"+i+\"步;\"); } } public static void main(String[] args) { Thread t1 = new Thread(new Race(), \"乌龟\"); Thread t2 = new Thread(new Race(), \"兔子\"); t1.start(); t2.start(); }} Ⅲ、共享线程之管程(悲观锁)1、共享带来的问题①、java的体现两个线程对初始值为 0 的静态变量一个做自增，一个做自减，各做 5000 次，结果是 0 吗？ 1234567891011121314151617181920212223@Slf4jpublic class T1 { static int count=0; public static void main(String[] args) throws InterruptedException { Thread t1=new Thread(()-&gt;{ for (int i = 0; i &lt; 5000; i++) { count++; } },\"t1\"); Thread t2=new Thread(()-&gt;{ for (int i = 0; i &lt; 5000; i++) { count--; } },\"t2\"); t1.start(); t2.start(); t1.join(); t2.join(); log.info(\"count:{}\",count); }} 121:47:14.620 [main] INFO org.lc.synchronized_t.T1 - count:486 答案显然不为0 ②、问题分析以上的结果可能是正数、负数、零。为什么呢？因为 Java 中对静态变量的自增，自减并不是原子操作，要彻底理 解，必须从字节码来进行分析 例如对于 i++而言（i 为静态变量），实际会产生如下的 JVM 字节码指令： 1234getstatic i // 获取静态变量i的值iconst_1 // 准备常量1iadd // 自增 putstatic i // 将修改后的值存入静态变量i 而对应 i-- 也是类似： 1234getstatic i // 获取静态变量i的值 iconst_1 // 准备常量1 isub // 自减 putstatic i // 将修改后的值存入静态变量i 而 Java 的内存模型如下，完成静态变量的自增，自减需要在主存和工作内存中进行数据交换： 如果是单线程以上 8 行代码是顺序执行（不会交错）没有问题： 但多线程下这 8 行代码可能交错运行：出现负数的情况： 出现正数的情况: ③、临界区 Critical Section 一个程序运行多个线程本身是没有问题的 问题出在多个线程访问共享资源 多个线程读共享资源其实也没有问题 在多个线程对共享资源读写操作时发生指令交错，就会出现问题 一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为临界区 例如，下面代码中的临界区： 1234567891011static int counter = 0; static void increment() // 临界区 { counter++; } static void decrement() // 临界区 { counter--;} ④、竞态条件(Race Condition )：多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件 4、synchronized(也叫互斥锁)解决方案为了避免临界区的竞态条件发生，有多种手段可以达到目的。 阻塞式的解决方案：synchronized，Lock 非阻塞式的解决方案：原子变量 阻塞式的【对象锁】：它采用互斥的方式让同一 时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住。这样就能保证拥有锁 的线程可以安全的执行临界区内的代码，不用担心线程上下文切换 注意: 虽然 java 中互斥和同步都可以采用 synchronized 关键字来完成，但它们还是有区别的： 互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码 同步是由于线程执行的先后、顺序不同、需要一个线程等待其它线程运行到某个点 ①语法线程1拿到对象锁之后，线程2来访问该临界区会发生blocked阻塞 注意：锁不能为基本数据类型。只能为实例类型或包装类,包括String,且不能为null。 1234synchronized(对象) // 线程1， 线程2(blocked) { 临界区 } ②解决上述1中出现的问题12345678910111213141516171819202122232425262728293031@Slf4jpublic class T1 { static int count=0;// o对象作为锁对象 static Object o=new Object(); public static void main(String[] args) throws InterruptedException { Thread t1=new Thread(()-&gt;{ for (int i = 0; i &lt; 5000; i++) { //临界区为count++ synchronized (o) { count++; } } },\"t1\"); Thread t2=new Thread(()-&gt;{ for (int i = 0; i &lt; 5000; i++) { ////临界区为count-- synchronized (o) { count--; } } },\"t2\"); t1.start(); t2.start(); t1.join(); t2.join(); log.info(\"count:{}\",count); }} 111:15:17.879 [main] INFO org.lc.synchronized_t.T1 - count:0 这时我们发现是始终为0 交替执行count++和count–。 假如t1线程中先拿到锁，执行完count++代码块之后，该线程释放锁，然后，t1和t2线程再次同时竞争该锁，谁拿到锁谁先执行，没拿到的等待。直到所有的代码程序执行完毕。 ③时序提来解释上述过程 ④通俗的方式解释 你可以做这样的类比： synchronized(对象) 中的对象，可以想象为一个房间（room），有唯一入口（门）房间只能一次进入一人 进行计算，线程 t1，t2 想象成两个人 当线程 t1 执行到 synchronized(room) 时就好比 t1 进入了这个房间，并锁住了门拿走了钥匙，在门内执行 count++ 代码 这时候如果 t2 也运行到了 synchronized(room) 时，它发现门被锁住了，只能在门外等待，发生了上下文切 换，阻塞住了 这中间即使 t1 的 cpu 时间片不幸用完，被踢出了门外（不要错误理解为锁住了对象就能一直执行下去哦）， 这时门还是锁住的，t1 仍拿着钥匙，t2 线程还在阻塞状态进不来，只有下次轮到 t1 自己再次获得时间片时才 能开门进入 当 t1 执行完 synchronized{} 块内的代码，这时候才会从 obj 房间出来并解开门上的锁，唤醒 t2 线程把钥 匙给他。t2 线程这时才可以进入 obj 房间，锁住了门拿上钥匙，执行它的 count– 代码 ⑤思考 如果把 synchronized(obj) 放在 for 循环的外面，如何理解？ 1234567891011121314151617181920212223242526272829303132@Slf4jpublic class T1 { static int count=0;// o对象作为锁对象 static Object o=new Object(); public static void main(String[] args) throws InterruptedException { Thread t1=new Thread(()-&gt;{ synchronized (o) { //相当于两条的自增指令，保持原子性执行了200次，该期间不会被其他线程所干扰 for (int i = 0; i &lt; 100; i++) { System.out.println(\"t1\"); count++; } } },\"t1\"); Thread t2=new Thread(()-&gt;{ synchronized (o) { for (int i = 0; i &lt; 100; i++) { System.out.println(\"t2\"); count++; } } },\"t2\"); t1.start(); t2.start(); t1.join(); t2.join(); log.info(\"count:{}\",count); }} 每次需要把synchronized(锁){}中的代码块执行完后才会释放锁，即谁先拿到锁，谁先执行完所有for循环的count++或count–操作。 如果 t1 synchronized(obj1) 而 t2 synchronized(obj2) 会怎样运作？ 锁住的对象不同，没有产生竞争关系。 无效 如果 t1 synchronized(obj) 而 t2 没有加会怎么样？如何理解？ 对象没有产生竞争。无效 ⑥面向对象改进把需要保护的共享变量放入一个类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859@Slf4jpublic class T1 { public static void main(String[] args) throws InterruptedException { Room room=new Room(); Thread t1=new Thread(()-&gt;{ for (int i = 0; i &lt; 1000; i++) { System.out.println(\"t1\"); room.increment(); } },\"t1\"); Thread t2=new Thread(()-&gt;{ for (int i = 0; i &lt; 1000; i++) { System.out.println(\"t2\"); room.decrement(); } },\"t2\"); t1.start(); t2.start();// 让t1线程跑完 t1.join();// 让t2线程跑完 t2.join(); log.info(\"count:{}\",room.getCount()); }}class Room{ private int count=0; /** * 加 */ public void increment(){// 锁住当前创建的对象 synchronized (this){ count++; } } /** * 减 */ public void decrement(){ synchronized (this) { count--; } } /** * 获得值 * @return */ public int getCount() { synchronized (this) { return count; } }} 12//交替执行t1 t212:56:13.825 [main] INFO org.lc.synchronized_t.T1 - count:0 5、方法上的synchronized 非静态方法锁的是对象， 静态方法因为共享性质，锁的是类对象(类对象只能有一份，即无论new多少个对象，其中的类对象只有一份) 类中的非静态成员储存在堆。静态方法储存在方法区，被该类中的对象所共享 ①加在普通方法注意：这里不叫锁方法，而是叫锁当前this对象 12345678910111213class Test{ public synchronized void test(){ }}//等价于==&gt;class Test{ public void test(){ synchronized(this){ } }} ②加在静态方法上注意：这里叫锁类对象，因为在静态方法中无法调用this对象。 12345678910111213class Test{ public synchronized static void test(){ }}//等价于==&gt;class Test{ public static void test(){ synchronized(Test.class){ } }} ③线程八锁其实就是考察 synchronized 锁住的是哪个对象(实例对象，还是类对象) *情况1： * 结果为1 2 或 2 1 12345678910111213141516171819@Slf4jpublic class T2 { public static void main(String[] args) { Number number=new Number();// 使用的同一对象，即锁同一对象，产生互斥 new Thread(()-&gt;{number.a();},\"t1\").start(); new Thread(()-&gt;{number.b();},\"t2\").start(); }}@Slf4jclass Number{ public synchronized void a() { log.debug(\"1\"); } public synchronized void b() { log.debug(\"2\"); }} 情况2: 结果为 2 （1秒后） 1 或 (1秒后) 1 2 123456789101112131415161718192021222324252627@Slf4jpublic class T2 { public static void main(String[] args) { Number number=new Number();// 使用的同一对象，即锁同一对象，产生互斥 Thread t1=new Thread(()-&gt;{number.a();},\"t1\"); Thread t2=new Thread(()-&gt;{number.b();},\"t2\"); t1.start(); t2.start(); }}@Slf4jclass Number{ public synchronized void a() { try { //如果线程首先运行此代码，则后序线程使用该对象(是对象，不是方法)时，会阻塞。 Thread.sleep(1000); log.debug(\"1\"); } catch (InterruptedException e) { e.printStackTrace(); } } public synchronized void b() { log.debug(\"2\"); }} 情况3： 结果为： 3 (1秒后) 1 2 或 3 2 (1秒后) 1 或 2 3 (1秒后) 1 123456789101112131415161718192021222324252627282930313233@Slf4jpublic class T2 { public static void main(String[] args) { Number number=new Number();// t1,t2使用的同一对象，即锁同一对象，产生互斥 Thread t1=new Thread(()-&gt;{number.a();},\"t1\"); Thread t2=new Thread(()-&gt;{number.b();},\"t2\");// t3与(t1,t2)并行，t1与t2产生竞争关系 Thread t3=new Thread(()-&gt;{number.c();},\"t3\"); t1.start(); t2.start(); t3.start(); }}@Slf4jclass Number{ public synchronized void a() { try { Thread.sleep(1000); log.debug(\"1\"); } catch (InterruptedException e) { e.printStackTrace(); } } public synchronized void b() { log.debug(\"2\"); } public void c() { log.debug(\"3\"); }} 情况4：结果为 2 （1秒后） 1 123456789101112131415161718192021222324252627@Slf4jpublic class T2 { public static void main(String[] args) { Number number1=new Number(); Number number2=new Number();// t1,t2使用的不同对象，即不互斥 并行关系 Thread t1=new Thread(()-&gt;{number1.a();},\"t1\"); Thread t2=new Thread(()-&gt;{number2.b();},\"t2\"); t1.start(); t2.start(); }}@Slf4jclass Number{ public synchronized void a() { try { Thread.sleep(2000); log.debug(\"1\"); } catch (InterruptedException e) { e.printStackTrace(); } } public synchronized void b() { log.debug(\"2\"); }} 情况5： 结果为 2 （1秒后） 1 12345678910111213141516171819202122232425262728@Slf4jpublic class T2 { public static void main(String[] args) { Number number1=new Number();// t1执行的为类对象 t2为this实例对象。即为并行关系 Thread t1=new Thread(()-&gt;{number1.a();},\"t1\"); Thread t2=new Thread(()-&gt;{number1.b();},\"t2\"); t1.start(); t2.start(); }}@Slf4jclass Number{// 锁的为类对象 public static synchronized void a() { try { Thread.sleep(1000); log.debug(\"1\"); } catch (InterruptedException e) { e.printStackTrace(); } }// 锁的为this对象实例 public synchronized void b() { log.debug(\"2\"); }} 情况6： 结果为 2 （1秒后） 1 或 (1秒后) 1 2 12345678910111213141516171819202122232425262728@Slf4jpublic class T2 { public static void main(String[] args) { Number number1=new Number();// t1与t2执行的都是同一类对象。即为互斥关系 Thread t1=new Thread(()-&gt;{number1.a();},\"t1\"); Thread t2=new Thread(()-&gt;{number1.b();},\"t2\"); t1.start(); t2.start(); }}@Slf4jclass Number{// 锁的为类对象 public static synchronized void a() { try { Thread.sleep(2000); log.debug(\"1\"); } catch (InterruptedException e) { e.printStackTrace(); } }// 锁的为类对象 public static synchronized void b() { log.debug(\"2\"); }} 情况7： 2 （1秒后) 1 12345678910111213141516171819202122232425262728293031@Slf4jpublic class T2 { public static void main(String[] args) { Number number1=new Number(); Number number2=new Number();// t1锁的为类对象Number，无论new多少个对象，类对象只有一个。// t2锁的为this对象实例// t1与t2并行关系 Thread t1=new Thread(()-&gt;{number1.a();},\"t1\"); Thread t2=new Thread(()-&gt;{number2.b();},\"t2\"); t1.start(); t2.start(); }}@Slf4jclass Number{// 锁的为类对象 public static synchronized void a() { try { Thread.sleep(2000); log.debug(\"1\"); } catch (InterruptedException e) { e.printStackTrace(); } }// 锁的为this实例对象 public synchronized void b() { log.debug(\"2\"); }} 情况8： 结果为 2 （1秒后） 1 或 (1秒后) 1 2 12345678910111213141516171819202122232425262728293031@Slf4jpublic class T2 { public static void main(String[] args) { Number number1=new Number(); Number number2=new Number();// t1锁的为类对象Number，无论new多少个对象，类对象只有一个Number.class。// t1锁的为类对象Number，无论new多少个对象，类对象只有一个Number.class。// t1与t2互斥关系 Thread t1=new Thread(()-&gt;{number1.a();},\"t1\"); Thread t2=new Thread(()-&gt;{number2.b();},\"t2\"); t1.start(); t2.start(); }}@Slf4jclass Number{// 锁的为类对象 public static synchronized void a() { try { Thread.sleep(2000); log.debug(\"1\"); } catch (InterruptedException e) { e.printStackTrace(); } }// 锁的为类对象 public static synchronized void b() { log.debug(\"2\"); }} 结论： 锁类对象：首先判断是否为同一类对象，若为同一类对象，无论new多少次，类对象只有一份。即产生互斥 static synchronized void test(){} &lt;!--￼63--&gt; 锁this类对象： 若使用的同一实例对象(需要在临界区加synchronized)，则产生互斥。 synchronized void test(){} &lt;!--￼64--&gt; 6、变量的线程安全分析①成员变量和静态变量是否线程安全 如果它们没有共享，则线程安全 如果它们被共享了，根据它们的状态是否能够改变，又分两种情况 如果只有读操作，则线程安全 如果有读写操作，则这段代码是临界区，需要考虑线程安全 ②局部变量是否线程安全？ 局部变量是线程安全的 但局部变量引用的对象则未必 如果该对象没有逃离方法的作用访问，它是线程安全的 如果该对象逃离方法的作用范围(即该对象为方法外的变量)，需要考虑线程安全 局部变量线程安全分析1234public static void test1() { int i = 10; i++;} 每个线程调用 test1() 方法时局部变量 i，会在每个线程的栈帧内存中被创建多份，因此不存在共享。即每个线程在栈中的独立栈帧都会创建一个新的i变量内存 ③引用的变量在方法外(产生线程安全问题)123456789101112131415161718192021222324252627282930313233public class T3 {// 线程个数 static final int THRUED_NUMBER=2;// 循环次数 static final int LOOP_NUMBER=200; public static void main(String[] args) { ThreadUnSafe test=new ThreadUnSafe(); for (int i = 0; i &lt; THRUED_NUMBER; i++) {// 这里两个线程共用同一个对象中的list成员变量。所以会发生remove异常(未添加元素就移除) new Thread(()-&gt;{ test.method1(LOOP_NUMBER); },\"Thread:\"+i).start(); } }}class ThreadUnSafe{// 成员变量 ArrayList&lt;String&gt; list=new ArrayList&lt;&gt;(); public void method1(int loopNumber) { for (int i = 0; i &lt; loopNumber; i++) { //临界区 产生竞争条件 this.method2(); this.method3(); } } private void method2() { list.add(\"1\"); } private void method3() { list.remove(0); }} 1234567Exception in thread \"Thread:0\" java.lang.IndexOutOfBoundsException: Index: 0, Size: 0 at java.util.ArrayList.rangeCheck(ArrayList.java:657) at java.util.ArrayList.remove(ArrayList.java:496) at org.lc.synchronized_t.ThreadUnSafe.method3(T3.java:45) at org.lc.synchronized_t.ThreadUnSafe.method1(T3.java:36) at org.lc.synchronized_t.T3.lambda$main$0(T3.java:21) at java.lang.Thread.run(Thread.java:748) 分析：即某一个线程先执行add,我们发现add源码中有一个size++，该size是成员变量，多个线程共享size操作，即会出现线程不安全的问题。即不同的线程操作add时，可能size可能出现竞争导致size写回的时候不会添加或者添加被覆盖的情况。即会出现索引越界的异常 ④引用的变量在方法内(线程安全)将 list 修改为局部变量 12345678910111213141516171819202122232425262728293031public class T3 {// 线程个数 static final int THRUED_NUMBER=2;// 循环次数 static final int LOOP_NUMBER=200; public static void main(String[] args) { ThreadUnSafe test=new ThreadUnSafe(); for (int i = 0; i &lt; THRUED_NUMBER; i++) { new Thread(()-&gt;{ test.method1(LOOP_NUMBER); },\"Thread:\"+i).start(); } }}class ThreadUnSafe{ public void method1(int loopNumber) { // 局部变量 ArrayList&lt;String&gt; list=new ArrayList&lt;&gt;(); for (int i = 0; i &lt; loopNumber; i++) { this.method2(list); this.method3(list); } } private void method2(ArrayList&lt;String&gt; list) { list.add(\"1\"); } private void method3(ArrayList&lt;String&gt; list) { list.remove(0); }} 分析： list 是局部变量，每个线程调用时会创建其不同实例，没有共享 不同线程为list变量创建不同的栈帧内存。即不共享 而 method2 的参数是从 method1 中传递过来的，与 method1 中引用同一个对象 方法访问修饰符带来的思考，如果把 method2 和 method3 的方法修改为 public 会不会代理线程安全问题？ 情况1：有其它线程调用 method2 和 method3 情况2：在 情况1 的基础上，为 ThreadSafe 类添加子类，子类覆盖 method2 或 method3 方法，即 123456789101112131415161718192021222324class ThreadUnSafe{ public void method1(int loopNumber) { ArrayList&lt;String&gt; list=new ArrayList&lt;&gt;(); for (int i = 0; i &lt; loopNumber; i++) { method2(list); method3(list); } } public void method2(ArrayList&lt;String&gt; list) { list.add(\"1\"); } public void method3(ArrayList&lt;String&gt; list) { list.remove(0); }}class ThreadSafeSubClass extends ThreadUnSafe{ @Override public void method3(ArrayList&lt;String&gt; list) { new Thread(()-&gt;{ list.remove(0); }).start(); }} 结论：从这个例子可以看出 private 或 ﬁnal 提供【安全】的意义所在，请体会开闭原则中的【闭】 7、常见线程安全类 String Integer StringBuﬀer Random Vector Hashtable java.util.concurrent 包下的类 这里说它们是线程安全的是指，多个线程调用它们同一个实例的某个方法时，是线程安全的。也可以理解为： HashTable给每个方法加上synchronized给对象上锁。即多个线程操作同一个对象会产生互斥，只要是操作了对象中的任意synchronized方法 1234567Hashtable hashtable=new Hashtable();new Thread(()-&gt;{ hashtable.put(\"k1\", \"v1\");},\"t1\").start();new Thread(()-&gt;{ hashtable.put(\"k2\", \"v2\");},\"t2\").start(); 它们的每个方法是原子的 ①线程安全类方法的组合(非线程安全)这种组合方式，并不能保证原子性。 12345Hashtable hashtable=new Hashtable();//多个线程操作 t1,t2if(hashtable.get(\"k1\")==null){ hashtable.put(\"k1\", \"v1\");} 注意：假设线程1先拿到锁，先执行get操作，执行完后会释放锁。此时t2线程开始执行get操作，执行完后释放锁，恰巧t2线程又拿到了锁执行put操作，执行完后释放锁。然后t1线程拿到锁执行put操作，此时t2线程的put操作已被t1线程覆盖 ②不可变类线程安全性String、Integer 等都是不可变类，因为其内部的状态不可以改变，因此它们的方法都是线程安全的 String 有 replace，substring 等方法【可以】改变值啊，那么这些方法又是如何保证线程安 全的呢？ 因为我们从源码可以发现，replace和substring 都是对其原来的字符串进行修改拷贝后重新new了一个新的字符串 12345678910public String substring(int beginIndex) { if (beginIndex &lt; 0) { throw new StringIndexOutOfBoundsException(beginIndex); } int subLen = value.length - beginIndex; if (subLen &lt; 0) { throw new StringIndexOutOfBoundsException(subLen); } return (beginIndex == 0) ? this : new String(value, beginIndex, subLen); } 8、习题①买票1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980@Slf4jpublic class T4 {// random线程安全 static Random random=new Random(); /** * 随机获取买票数量 1-5 * @return */ public static int randomAmount() { return random.nextInt(5)+1; } public static void main(String[] args) { TicketWindow ticketWindow = new TicketWindow(2000);// 储存线程 List&lt;Thread&gt; threadList=new ArrayList&lt;&gt;();// 存储每个线程卖的票数// 这里需要使用Vector来保证线程安全，因为多个线程多同一个集合进行操作 List&lt;Integer&gt; sellCount=new Vector&lt;&gt;(); for (int i = 0; i &lt; 1000; i++) { Thread thread=new Thread(()-&gt;{ try {// 模拟线程创建延迟 Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); }// 多个线程对同一ticketWindow对象操作，产生线程安全问题 int sell = ticketWindow.sell(randomAmount());// 多个线程对同一集合操作，产生线程安全问题 sellCount.add(sell); });// 这里的集合线程安全，因为只是对thread变量的引用进行添加操作，线程没有对threadList集合操作 threadList.add(thread);// 启动线程 thread.start(); }// 遍历所有线程 threadList.forEach(t-&gt; { try {// 保证所有线程执行完毕 t.join(); } catch (InterruptedException e) { e.printStackTrace(); } });// 遍历集合进行买票求和操作 int sum = sellCount.stream().mapToInt(t -&gt; t).sum(); log.info(\"卖的总票数为:{}\",sum); log.info(\"剩余总票数为:{}\",ticketWindow.getCount()); }}//模拟售票窗口class TicketWindow{ //余票 private int count; public TicketWindow(int count) { this.count = count; } //获取余票 public int getCount() { return count; } /** *售票方法 * @param amount 售票数量 * @return 成功售票,返回售票数量。售票失败。返回0 */ public int sell(int amount){ if (this.count &gt;= amount) { this.count -= amount; return amount; } return 0; }} 结果 售票数量和初始余票数量(2000)不一致。线程不安全。 1212:57:03.578 [main] INFO org.lc.synchronized_t.T4 - 卖的总票数为:204812:57:03.582 [main] INFO org.lc.synchronized_t.T4 - 剩余总票数为:0 解决方法： 给售票方法(临界区)加synchornized 123456789101112/** *售票方法 * @param amount 售票数量 * @return 成功售票,返回售票数量。售票失败。返回0 */ public synchronized int sell(int amount){ if (this.count &gt;= amount) { this.count -= amount; return amount; } return 0; } ②转账12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364@Slf4jpublic class T5 { static Random random = new Random(); //随机转账1到100 public static int randomInt() { return random.nextInt(100) + 1; } public static void main(String[] args) throws InterruptedException {// 账户a 1000 Account a = new Account(1000);// 账户b 1000 Account b = new Account(1000);// 线程t1实现a对b的多次随机转账 Thread t1 = new Thread(() -&gt; { for (int i = 0; i &lt; 1000; i++) {// 线程不安全 a.transfer(b, randomInt()); } });// 线程2实现b对a的多次随机转账 Thread t2=new Thread(()-&gt;{ for (int i = 0; i &lt; 1000; i++) {// 线程不安全 b.transfer(a, randomInt()); } }); t1.start(); t2.start(); t1.join(); t2.join(); log.info(\"账户a:{}\",a.getMoney()); log.info(\"账户b:{}\",b.getMoney()); }}//账户类class Account { // 账户余额 private int money; public Account(int money) { this.money = money; } public int getMoney() { return money; } public void setMoney(int money) { this.money = money; } /** * 转账操作 * * @param target 目标转账用户 * @param amount 转账金额 */ public void transfer(Account target, int amount) { if (this.money &gt;= amount) { this.setMoney(this.getMoney() - amount); target.setMoney(target.getMoney() + amount); } }} 结果为：账户完全紊乱。 1215:42:02.613 [main] INFO org.lc.synchronized_t.T5 - 账户a:160715:42:02.617 [main] INFO org.lc.synchronized_t.T5 - 账户b:0 首先我们可以想到给方法加锁: 123456public synchronized void transfer(Account target, int amount) { if (this.money &gt;= amount) { this.setMoney(this.getMoney() - amount); target.setMoney(target.getMoney() + amount); } } 注意：上述方法是给当前对象加锁，即当前调用transfer方法的对象加锁，但是传过来的Account对象还是两个线程在共享使用，即会出现问题。 最终解决：我们给当前类对象加锁，尽管你创建多个账户对象，但是对个线程进行转账的时候，只有一个线程能执行该方法。即类对象只有一个，给类对象加锁，被多个线程使用时互斥。但是这会出现一个缺点，同一个时间只有一个线程能做此事，导致效率非常低。 12345678public void transfer(Account target, int amount) { synchronized (Account.class) { if (this.money &gt;= amount) { this.setMoney(this.getMoney() - amount); target.setMoney(target.getMoney() + amount); } } } 1215:46:10.728 [main] INFO org.lc.synchronized_t.T5 - 账户a:199915:46:10.733 [main] INFO org.lc.synchronized_t.T5 - 账户b:1 9、Monitor概念①java对象头 例如： Integer对象大小=8字节(Object Header)+储存值的4字节 int 大小=4字节 以 32 位虚拟机为例 普通对象： Klass Word 存储的是对象的类型，即类对象的指针 Mark Word 包含的为对象的详细信息，即对象的成员 Mark Word结构： 10、wait、notify①为什么需要wait ②wait原理 Owner 线程发现条件(即该线程已经获得了锁)不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态 BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片 BLOCKED 线程会在 Owner 线程释放锁时唤醒 ③API介绍调用wait方法，会取消偏量锁撤销，升级为重量锁 WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入 EntryList 重新竞争 obj.wait() 让进入 object 监视器的线程到 waitSet 等待 obj.notify() 在 object 上正在 waitSet 等待的线程中挑一个唤醒 obj.notifyAll() 让 object 上正在 waitSet 等待的线程全部唤醒 它们都是线程之间进行协作的手段，都属于 Object 对象的方法。必须获得此对象的锁，才能调用这几个方法 即必须为锁的这个对象才能调用wait/notify。即synchronized(lock)中的 lock对象调用wait/notify 注意：没有获得锁的线程执行wait/notify方法会报错 12345678910public class T1 { static final Object object=new Object(); public static void main(String[] args) { try { object.wait(); } catch (InterruptedException e) { e.printStackTrace(); } }} 1234Exception in thread \"main\" java.lang.IllegalMonitorStateException at java.lang.Object.wait(Native Method) at java.lang.Object.wait(Object.java:502) at org.lc.wait_notify.T1.main(T1.java:14) 正确的姿势： 123456789101112131415public class T1 { static final Object object=new Object(); public static void main(String[] args) { try { synchronized (object) { object.wait(); } } catch (InterruptedException e) { e.printStackTrace(); } }} wait(),notify(),notifyAll()实例： 123456789101112131415161718192021222324252627282930313233343536373839404142@Slf4jpublic class T1 { static final Object object=new Object(); public static void main(String[] args) throws InterruptedException { new Thread(()-&gt;{ synchronized (object) { log.info(\"开始执行...\"); try { //线程进入waiting阻塞 object.wait(); } catch (InterruptedException e) { e.printStackTrace(); } log.info(\"其他代码...\"); } },\"t1\").start(); new Thread(()-&gt;{ synchronized (object) { log.info(\"开始执行...\"); try { //线程进入waiting阻塞 object.wait(); } catch (InterruptedException e) { e.printStackTrace(); } log.info(\"其他代码...\"); } },\"t2\").start(); // 先让其他线程执行 Thread.sleep(2000); synchronized (object) {// 唤醒一个线程(唤醒的线程竞争)// object.notify();// 唤醒所有waiting线程 object.notifyAll(); } }} 123411:28:06.797 [t1] INFO org.lc.wait_notify.T1 - 开始执行...11:28:06.799 [t2] INFO org.lc.wait_notify.T1 - 开始执行...11:28:08.795 [t2] INFO org.lc.wait_notify.T1 - 其他代码...11:28:08.795 [t1] INFO org.lc.wait_notify.T1 - 其他代码... wait(long n)有时限的等待, 到 n 毫秒后结束等待，重新争抢锁。或是被 notify/notifyAll 123456789101112131415161718@Slf4jpublic class T2 { static final Object object=new Object(); public static void main(String[] args) throws InterruptedException { new Thread(() -&gt; { synchronized (object) { log.info(\"开始执行...\"); try { //线程进入waiting阻塞 object.wait(3000); } catch (InterruptedException e) { e.printStackTrace(); } log.info(\"其他代码...\"); } }, \"t1\").start(); }} 1211:32:31.444 [t1] INFO org.lc.wait_notify.T2 - 开始执行...11:32:34.447 [t1] INFO org.lc.wait_notify.T2 - 其他代码... 3秒后自动被唤醒 ④wait(long n)和sleep(long n)的区别1) sleep 是 Thread 方法，而 wait 是 Object 的方法 2) sleep 不需要强制和 synchronized 配合使用，但 wait 需要 和 synchronized 一起用 3) sleep 在睡眠的同时，不会释放对象锁的，但 wait 在等待的时候会释放对象锁 4) 它们 状态都是 TIMED_WAITING ⑤唤醒占用同一锁的其他指定线程-实例注意：这里不能用sleep，因为sleep不会释放锁，而要用wiat,wait会释放锁 用 notifyAll 仅解决某个线程的唤醒问题，但使用 if + wait 判断仅有一次机会，一旦条件不成立，就没有重新 判断的机会了 解决方法，用 while + wait，当条件不成立，再次 wait 虚假唤醒：notify 只能随机唤醒一个 WaitSet 中的线程，这时如果有其它线程也在等待，那么就可能唤醒不了正确的线 程，称之为【虚假唤醒】 解决方法，改为 notifyAll 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364@Slf4jpublic class T3 { // 锁 final static Object room = new Object(); // 是否有烟 static boolean hasSomke = false; // 是否有外卖 static boolean hasLunch = false; public static void main(String[] args) throws InterruptedException { new Thread(()-&gt;{ synchronized (room) { log.info(\"有烟没？{}\",hasSomke); while (!hasSomke) { log.info(\"先休息一下...\"); try {// 若错误被唤醒，那么会重新判断条件 room.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } log.info(\"有烟没?{}\",hasSomke); if (hasSomke) { log.info(\"开始干活...\"); } } },\"烟枪王\").start(); new Thread(()-&gt;{ synchronized (room) { log.info(\"午饭到没？{}\",hasLunch); if (!hasLunch) { log.info(\"做等饭来...\"); try { room.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } log.info(\"午饭到没？{}\", hasLunch); if (hasLunch) { log.info(\"开吃...\"); } } },\"大胃王\").start();// 先执行其他线程 Thread.sleep(2000); synchronized (room) {// 预先送饭 hasLunch=true; log.info(\"送饭了...\");// 当我们使用notity()时，这是可能会唤醒送烟线程，导致虚假唤醒// notify 只能随机唤醒一个 WaitSet 中的线程// room.notify(); room.notifyAll(); } }} 1234567812:36:46.600 [烟枪王] INFO org.lc.wait_notify.T3 - 有烟没？false12:36:46.605 [烟枪王] INFO org.lc.wait_notify.T3 - 先休息一下...12:36:46.605 [大胃王] INFO org.lc.wait_notify.T3 - 午饭到没？false12:36:46.605 [大胃王] INFO org.lc.wait_notify.T3 - 做等饭来...12:36:48.600 [main] INFO org.lc.wait_notify.T3 - 送饭了...12:36:48.600 [大胃王] INFO org.lc.wait_notify.T3 - 午饭到没？true12:36:48.600 [大胃王] INFO org.lc.wait_notify.T3 - 开吃...12:36:48.600 [烟枪王] INFO org.lc.wait_notify.T3 - 先休息一下... 11、同步模式之保护性暂停①.定义即 Guarded Suspension，用在一个线程等待另一个线程的执行结果要点 有一个结果需要从一个线程传递到另一个线程，让他们关联同一个 GuardedObject 如果有结果不断从一个线程到另一个线程那么可以使用消息队列（见生产者/消费者） JDK 中，join 的实现、Future 的实现，采用的就是此模式 因为要等待另一方的结果，因此归类到同步模式 ②应用- 超时效果1234567891011121314//下载返回读取的网页public class Downloader { public static List&lt;String&gt; download() throws IOException { HttpsURLConnection connection= (HttpsURLConnection) new URL(\"https://www.baidu.com/\").openConnection(); List&lt;String&gt; list=new ArrayList&lt;&gt;(); try(BufferedReader reader=new BufferedReader(new InputStreamReader(connection.getInputStream(), StandardCharsets.UTF_8))) { String line; while ((line = reader.readLine()) != null) { list.add(line); } } return list; }} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374@Slf4jpublic class T4 { public static void main(String[] args) {// 线程1等待线程2的下载结果 GuardedObject guardedObject=new GuardedObject(); new Thread(()-&gt;{// 等待结果 log.info(\"等待结果...\");// 设置超时时间 List&lt;String&gt; o = (List&lt;String&gt;) guardedObject.get(2000); log.info(\"下载的内容:{}\", o==null?\"已超时...\":o.toString()); },\"t1\").start(); new Thread(()-&gt;{ log.info(\"执行下载\"); try {// 下载 List&lt;String&gt; download = Downloader.download();// 传入下载的结果// 这时会唤醒阻塞的线程 guardedObject.complete(download); } catch (IOException e) { e.printStackTrace(); } },\"t2\").start(); }}class GuardedObject{// 结果 private Object response; /** * 获取值 * @param timeout 超时的时间 * @return 返回的结果 */ public Object get(long timeout) { synchronized (this){// 开始时间 long start=System.currentTimeMillis();// 经历的时间 long passedTime=0;// 是否得到结果 while (response==null) {// 这一轮循环应该等待的时间 long waitTime=timeout-passedTime;// 如果经历时间超过 预设的超时时间 if (waitTime&lt;=0) {// 直接退出 break; } try {// 防止虚假唤醒 this.wait(waitTime); } catch (InterruptedException e) { e.printStackTrace(); }// 求得经历的时间 passedTime=System.currentTimeMillis()-start; }// 不为空 返回此结果 return response; } }// 产生结果 public void complete(Object response) { synchronized (this) { this.response=response;// 唤醒等待结果的线程 this.notifyAll(); } }} 设置超时时间：2000(2s) guardedObject.get(2000); 12315:48:00.528 [t1] INFO org.lc.wait_notify.T4 - 等待结果...15:48:00.528 [t2] INFO org.lc.wait_notify.T4 - 执行下载15:48:02.081 [t1] INFO org.lc.wait_notify.T4 - 下载的内容:[&lt;!DOCTYPE html&gt;, &lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt;&lt;meta http-equiv=content-type content=text/html;charset=utf-8&gt;&lt;meta http-.. 设置超时时间：1000(1s) guardedObject.get(1000); 12315:53:50.537 [t2] INFO org.lc.wait_notify.T4 - 执行下载15:53:50.537 [t1] INFO org.lc.wait_notify.T4 - 等待结果...15:53:51.541 [t1] INFO org.lc.wait_notify.T4 - 下载的内容:已超时... ③应用 - join原理12Thread t1=new Thread(()-&gt;{});t1.join(2000); 源码如下： 12345678910111213141516171819202122232425262728public final synchronized void join(long millis) throws InterruptedException { long base = System.currentTimeMillis(); long now = 0; if (millis &lt; 0) { throw new IllegalArgumentException(\"timeout value is negative\"); } //如果没有传入过期时间 if (millis == 0) { //轮询 查询该t1线程是否消亡 while (isAlive()) { //主线程一直阻塞 wait(0); } } else { //调用者线程进入t1的waitSet等待，直到t1运行结束 while (isAlive()) { long delay = millis - now; if (delay &lt;= 0) { break; } //休眠指定的实现 wait(delay); now = System.currentTimeMillis() - base; } } } ​ join方法的本质调用的是Object中的wait方法实现线程的阻塞，但是我们需要知道的是，调用wait方法必须要获取锁，所以join方法是被synchronized修饰的，synchronized修饰在方法层面相当于synchronized(this),this就是t1本身的实例。​ 实际上主线程会持有t1这个对象的锁（即把当前线程对象当锁），然后调用wait方法去阻塞，而这个方法的调用者是在主线程中的。所以造成主线程阻塞。 ④应用- 多任务版 GuardedObject12、异步模式之生产者/消费者①定义要点 与前面的保护性暂停中的 GuardObject 不同，不需要产生结果和消费结果的线程一一对应 消费队列可以用来平衡生产和消费的线程资源 生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据 消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据 JDK 中各种阻塞队列，采用的就是这种模式 ②实例 定义消息 12345678910111213141516171819202122//定义消息final class Message{ private int id; private Object value; public Message(int id, Object value) { this.id = id; this.value = value; } public int getId() { return id; } public Object getValue() { return value; } @Override public String toString() { return \"Message{\" + \"id=\" + id + \", value=\" + value + '}'; }} 消息队列 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@Slf4jclass MessageQueue{// 消息的队列集合 //双向队列 private LinkedList&lt;Message&gt; list=new LinkedList&lt;&gt;(); //队列容量 private int capcity; public MessageQueue(int capcity) { this.capcity = capcity; } //获取消息 public Message take(){ synchronized (list) {// 判断队列是否为空 while (list.isEmpty()) { try { log.info(\"队列为空,消费者线程等待...\");// 为空一直等待 list.wait(); } catch (InterruptedException e) { e.printStackTrace(); } }// 从队列的头部取 Message message = list.removeFirst(); log.info(\"已消费消息{}\",message);// 唤醒存入消息的线程 list.notifyAll(); return message; } } //存入消息 public void put(Message message) { synchronized (list) {// 检查队列是否已满 while (list.size() == capcity) { try { log.info(\"队列已满,生产者等待...\"); list.wait(); } catch (InterruptedException e) { e.printStackTrace(); } }// 从队列的尾部加 list.addLast(message); log.info(\"已生产消息{}\",message);// 唤醒取出消息的线程 list.notifyAll(); } }} 测试 1234567891011121314151617181920212223public class T6 { public static void main(String[] args) throws InterruptedException { MessageQueue queue=new MessageQueue(2); for (int i = 0; i &lt; 3; i++) { int id=i+1; new Thread(()-&gt;{ queue.put(new Message(id,\"值:\"+id )); },\"生产者:\"+id).start(); } Thread.sleep(1000); new Thread(()-&gt;{ while (true) { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } queue.take(); } },\"消费者\").start(); }} 1234567820:52:02.285 [生产者:1] INFO org.lc.wait_notify.MessageQueue - 已生产消息Message{id=1, value=值:1}20:52:02.290 [生产者:3] INFO org.lc.wait_notify.MessageQueue - 已生产消息Message{id=3, value=值:3}20:52:02.290 [生产者:2] INFO org.lc.wait_notify.MessageQueue - 队列已满,生产者等待...20:52:04.285 [消费者] INFO org.lc.wait_notify.MessageQueue - 已消费消息Message{id=1, value=值:1}20:52:04.285 [生产者:2] INFO org.lc.wait_notify.MessageQueue - 已生产消息Message{id=2, value=值:2}20:52:05.286 [消费者] INFO org.lc.wait_notify.MessageQueue - 已消费消息Message{id=3, value=值:3}20:52:06.287 [消费者] INFO org.lc.wait_notify.MessageQueue - 已消费消息Message{id=2, value=值:2}20:52:07.287 [消费者] INFO org.lc.wait_notify.MessageQueue - 队列为空,消费者线程等待... 13、park和unpark①基本使用它们是 LockSupport 类中的方法 12345// 暂停当前线程 LockSupport.park();// 恢复某个线程的运行 LockSupport.unpark(暂停线程对象) 先 park 后 unpark 123456789101112131415161718192021@Slf4jpublic class T1 { public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(() -&gt; { log.info(\"start...\"); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } log.info(\"park...\"); LockSupport.park(); log.info(\"resume...\"); }, \"t1\"); t1.start(); Thread.sleep(2000); log.info(\"unpark\"); LockSupport.unpark(t1); }} 123421:09:20.417 [t1] INFO org.lc.park_unpark.T1 - start...21:09:21.421 [t1] INFO org.lc.park_unpark.T1 - park...21:09:22.415 [main] INFO org.lc.park_unpark.T1 - unpark21:09:22.415 [t1] INFO org.lc.park_unpark.T1 - resume... 先 unpark 后 park 。也能唤醒park进程 123456789101112131415161718192021@Slf4jpublic class T1 { public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(() -&gt; { log.info(\"start...\"); try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } log.info(\"park...\"); LockSupport.park(); log.info(\"resume...\"); }, \"t1\"); t1.start(); Thread.sleep(1000); log.info(\"unpark\"); LockSupport.unpark(t1); }} 123421:11:05.473 [t1] INFO org.lc.park_unpark.T1 - start...21:11:06.473 [main] INFO org.lc.park_unpark.T1 - unpark21:11:07.476 [t1] INFO org.lc.park_unpark.T1 - park...21:11:07.476 [t1] INFO org.lc.park_unpark.T1 - resume... ②基本原理每个线程都有自己的一个 Parker 对象，由三部分组成_counter ， _cond和 _mutex打个比喻 线程就像一个旅人，Parker 就像他随身携带的背包，条件变量就好比背包中的帐篷。_counter 就好比背包中 的备用干粮（0 为耗尽，1 为充足） 调用 park 就是要看需不需要停下来歇息 如果备用干粮耗尽，那么钻进帐篷歇息 如果备用干粮充足，那么不需停留，继续前进 调用 unpark，就好比令干粮充足 如果这时线程还在帐篷，就唤醒让他继续前进 如果这时线程还在运行，那么下次他调用 park 时，仅是消耗掉备用干粮，不需停留继续前进 因为背包空间有限，多次调用 unpark 仅会补充一份备用干粮 ③与Object的wait&amp;notify相比 wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必 park &amp; unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程，就不那么【精确】 park &amp; unpark 可以先 unpark，而 wait &amp; notify 不能先 notify 14、活跃性①多把不相干的锁将锁的粒度细分 好处，是可以增强并发度 坏处，如果一个线程需要同时获得多把锁，就容易发生死锁 共用一把锁this： 12345678910111213141516171819202122232425262728293031323334public class T1 { public static void main(String[] args) { Room room=new Room(); new Thread(()-&gt;{ try { room.sleep(); } catch (InterruptedException e) { e.printStackTrace(); } },\"t1\").start(); new Thread(()-&gt;{ try { room.study(); } catch (InterruptedException e) { e.printStackTrace(); } },\"t2\").start(); }}@Slf4jclass Room{ public void sleep() throws InterruptedException { synchronized (this) { log.info(\"sleep...\"); Thread.sleep(2000); } } public void study() throws InterruptedException { synchronized (this) { log.info(\"study...\"); Thread.sleep(2000); } }} 1220:03:29.176 [t2] INFO org.lc.deathLock.Room - study...20:03:31.176 [t1] INFO org.lc.deathLock.Room - sleep... 我们发现始终是顺序执行的，即是互斥的。但是两个线程业务并不相干。所有我们可以使用不同的锁。 多个锁： 修改Room类 12345678910111213141516171819@Slf4jclass Room{ public final static Object sleepRoom=new Object(); public final static Object studyRoom=new Object(); public void sleep() throws InterruptedException { synchronized (sleepRoom) { log.info(\"sleep...\"); Thread.sleep(2000); } } public void study() throws InterruptedException { synchronized (studyRoom) { log.info(\"study...\"); Thread.sleep(2000); } }} 1220:03:29.176 [t2] INFO org.lc.deathLock.Room - study...20:03:29.176 [t1] INFO org.lc.deathLock.Room - sleep... ②死锁一个线程需要同时获取多把锁，这时就容易发生死锁 t1 线程 获得 o1对象 锁，接下来想获取 o2对象 的锁 t2 线程 获得 o2对象 锁,接下来想获取 o1对象 的锁 123456789101112131415161718192021222324252627282930313233@Slf4jpublic class T2 { static Object o1=new Object(); static Object o2=new Object(); public static void main(String[] args) { new Thread(()-&gt;{ synchronized (o1){ log.info(\"get lock o1\"); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (o2){ log.info(\"get lock o2\"); } } },\"t1\").start(); new Thread(()-&gt;{ synchronized (o2){ log.info(\"get lock o2\"); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (o1){ log.info(\"get lock o1\"); } } },\"t2\").start(); }} 12320:08:51.708 [t2] INFO org.lc.deathLock.T2 - get lock o220:08:51.708 [t1] INFO org.lc.deathLock.T2 - get lock o1//程序未终止.. ③活锁活锁出现在两个线程互相改变对方的结束条件，后谁也无法结束 123456789101112131415161718192021222324252627282930@Slf4jpublic class T3 { static int count=10; public static void main(String[] args) { new Thread(()-&gt;{ //期望到0就退出 while (count&gt;0) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } log.info(\"count:{}\", count); count--; } },\"t1\").start(); new Thread(()-&gt;{ //期望到20就退出循环 while (count&lt;20){ try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } log.info(\"count:{}\",count); count++; } },\"t2\").start(); }} 123420:17:59.724 [t1] INFO org.lc.deathLock.T3 - count:1120:17:59.811 [t2] INFO org.lc.deathLock.T3 - count:1020:17:59.825 [t1] INFO org.lc.deathLock.T3 - count:11//一值循环的增减 ④饥饿很多教程中把饥饿定义为，一个线程由于优先级太低，始终得不到 CPU 调度执行，也不能够结束，饥饿的情况不 易演示，讲读写锁时会涉及饥饿问题 看使用顺序加锁的方式解决之前的死锁问题 顺序加锁的解决方案 15、ReentrantLock(可重入锁)相对于 synchronized 它具备如下特点 可中断 在阻塞中没有获得锁的线程可中断阻塞。 可以设置超时时间 没有获得锁的线程，最多等待的时间则会放弃获得锁 可以设置为公平锁 支持多个条件变量 与 synchronized 一样，都支持可重入 (轻量级锁) 基本语法： 123456789 ReentrantLock reentrantLock=new ReentrantLock();// 获得锁 reentrantLock.lock(); try { //临界区... }finally { //释放锁 reentrantLock.unlock(); } ①可重入可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁 如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住 123456789101112131415161718192021222324252627282930313233@Slf4jpublic class T1 { static ReentrantLock lock=new ReentrantLock(); public static void main(String[] args) { m1(); } static void m1() { lock.lock(); try { log.info(\"m1...\"); m2(); }finally { lock.unlock(); } } static void m2() { lock.lock(); try { log.info(\"m2...\"); m3(); }finally { lock.unlock(); } } static void m3() { lock.lock(); try { log.info(\"m3...\"); }finally { lock.unlock(); } }} 12312:00:10.170 [main] INFO org.lc.Reentrant_Lock.T2 - m1...12:00:10.173 [main] INFO org.lc.Reentrant_Lock.T2 - m2...12:00:10.173 [main] INFO org.lc.Reentrant_Lock.T2 - m3... ②可打断让没有获得锁的线程中在阻塞的线程被打断 lock.lockInterruptibly() 可打断获得锁的模式 可中断模式： 123456789101112131415161718192021222324252627282930313233@Slf4jpublic class T3 { private static ReentrantLock lock=new ReentrantLock(); public static void main(String[] args) throws InterruptedException { Thread t1=new Thread(()-&gt;{ try { //如果没有竞争那么此方法就会获取lock锁 //如果有竞争就进入阻塞队列，可以被其他线程用interrupt打断 log.info(\"尝试获取锁...\"); lock.lockInterruptibly(); } catch (InterruptedException e) { e.printStackTrace(); log.info(\"没有获得到锁...返回\"); //这里我们被打断，后面的代码也就无需执行了 return; } try { log.info(\"获取到锁...\"); }finally { lock.unlock(); } },\"t1\"); //主线程先获取到锁 lock.lock(); t1.start(); Thread.sleep(1000); //打断t1线程 t1.interrupt(); }} 123412:23:27.170 [t1] INFO org.lc.Reentrant_Lock.T3 - 尝试获取锁...java.lang.InterruptedException at ....12:23:28.168 [t1] INFO org.lc.Reentrant_Lock.T3 - 没有获得到锁...返回 不可中断模式，那么即使使用了 interrupt 也不会让等待中断 12345678910111213141516171819202122@Slf4jpublic class T3 { private static ReentrantLock lock=new ReentrantLock(); public static void main(String[] args) throws InterruptedException { Thread t1=new Thread(()-&gt;{ try { //如果没有竞争那么此方法就会获取lock锁 //如果有竞争就进入阻塞队列，可以被其他线程用interrupt打断 log.info(\"尝试获取锁...\"); lock.lock(); } finally { lock.unlock(); } },\"t1\"); //主线程先获取到锁 lock.lock(); t1.start(); Thread.sleep(1000); log.info(\"打断...\"); t1.interrupt(); }} 12312:34:20.364 [t1] INFO org.lc.Reentrant_Lock.T3 - 尝试获取锁...12:34:21.361 [main] INFO org.lc.Reentrant_Lock.T3 - 打断...//阻塞的线程并没有被打断。 ③锁超时 如果没有获得到锁，立刻失败返回 tryLock() 获取到锁返回true,否则返回false 1234567891011121314151617181920212223242526@Slf4jpublic class T4 { private static ReentrantLock lock=new ReentrantLock(); public static void main(String[] args) throws InterruptedException { Thread t1=new Thread(()-&gt;{ log.info(\"尝试获取锁...\"); if(!lock.tryLock()){ //没有获得锁 返回false log.info(\"没有获得到锁...\"); return; } try { log.info(\"获得了锁...\"); } finally { lock.unlock(); } },\"t1\"); //主线程先获取到锁 lock.lock(); t1.start(); }} 1212:43:47.121 [t1] INFO org.lc.Reentrant_Lock.T4 - 尝试获取锁...12:43:47.123 [t1] INFO org.lc.Reentrant_Lock.T4 - 没有获得到锁... 在指定的时间内等待锁，等待的时候可被打断。 tryLock(long timeout, TimeUnit unit) 1234567891011121314151617181920212223242526272829303132333435363738@Slf4jpublic class T4 { private static ReentrantLock lock=new ReentrantLock(); public static void main(String[] args) throws InterruptedException { Thread t1=new Thread(()-&gt;{ try { log.info(\"尝试获取锁...\"); //最多等待3秒，没有获得到锁返回false if (!lock.tryLock(3, TimeUnit.SECONDS)) { //没有获得锁 返回false log.info(\"没有获得到锁...\"); //直接退出 return; } } catch (InterruptedException e) { e.printStackTrace(); log.info(\"被打断...没有获得到锁\");// 打断后也应该返回 return; } try { log.info(\"获得了锁...\"); } finally { lock.unlock(); } },\"t1\"); //主线程先获取到锁 lock.lock(); t1.start(); Thread.sleep(1000); //主线程获得锁1s后打断在阻塞等待的t1线程 t1.interrupt(); }} 123412:53:08.668 [t1] INFO org.lc.Reentrant_Lock.T4 - 尝试获取锁...java.lang.InterruptedException at ....12:53:09.666 [t1] INFO org.lc.Reentrant_Lock.T4 - 被打断...没有获得到锁 ④公平锁即在WaitSet中阻塞的线程争抢锁的时候是非公平的，即随机争抢。 而公平锁，阻塞线程在争抢锁的时候是按照阻塞队列的顺序来的。 ReentrantLock默认是不公平的 12//设置公平锁ReentrantLock lock = new ReentrantLock(true); 公平锁一般没有必要，会降低并发度。 ⑤条件变量​ synchronized 中也有条件变量，就是我们讲原理时那个 waitSet 休息室，当条件不满足时进入 waitSet 等待 ReentrantLock 的条件变量比 synchronized 强大之处在于，它是支持多个条件变量的，这就好比 synchronized 是那些不满足条件的线程都在一间休息室等消息 而 ReentrantLock 支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤 醒，即阻塞队列的存放位置可以分组， 使用要点(和synchronized类似，只是阻塞队列做了区分，然后需要手动释放锁) await 前需要获得锁 await 执行后，会释放锁，进入 conditionObject 等待 await 的线程被唤醒(signal)（或打断、或超时）取重新竞争 lock 锁 竞争 lock 锁成功后，从 await 后继续执行 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788@Slf4jpublic class T6 {// 是否有烟 static boolean hasSmoke=false;// 是否有饭 static boolean hasLunch=false;// 可重入锁 static ReentrantLock lock=new ReentrantLock();// 抽烟的队列 static Condition somekRoom=lock.newCondition();// 吃饭的队列 static Condition lunchRoom=lock.newCondition(); public static void main(String[] args) throws InterruptedException { new Thread(()-&gt;{// 尝试获得锁 lock.lock(); try { log.info(\"有烟没？{}\",hasSmoke); while (!hasSmoke) { try { log.info(\"烟没到，休息下...\"); //没烟。等烟 somekRoom.await(); } catch (InterruptedException e) { //可打断 e.printStackTrace(); } } //有烟 log.info(\"有烟，开始干活！\"); }finally {// 释放锁 lock.unlock(); } },\"烟杆子\").start(); new Thread(()-&gt;{// 尝试获得锁 lock.lock(); try { log.info(\"有饭没？{}\",hasLunch); while (!hasLunch) { try { log.info(\"没饭，睡一会...\"); lunchRoom.await(); } catch (InterruptedException e) {// 可被打断 e.printStackTrace(); } } log.info(\"饭来了，恰饭!\"); }finally {// 释放锁 lock.unlock(); } },\"饭桶\").start(); new Thread(()-&gt;{// 获取锁 lock.lock(); try {// 送烟 hasSmoke=true;// 唤醒阻塞的烟杆子// 这里signal()只会唤醒somkeRoom中的一个 somekRoom.signal(); }finally { lock.unlock(); } },\"工具人1\").start(); Thread.sleep(2000); new Thread(()-&gt;{// 获得锁 lock.lock(); try {// 送饭 hasLunch=true;// 关系lunchRoom中等待的队列 lunchRoom.signal(); }finally { lock.unlock(); } },\"工具人2\").start(); }} 12345616:27:44.550 [烟杆子] INFO org.lc.Reentrant_Lock.T6 - 有烟没？false16:27:44.554 [烟杆子] INFO org.lc.Reentrant_Lock.T6 - 烟没到，休息下...16:27:44.554 [饭桶] INFO org.lc.Reentrant_Lock.T6 - 有饭没？false16:27:44.554 [饭桶] INFO org.lc.Reentrant_Lock.T6 - 没饭，睡一会...16:27:44.554 [烟杆子] INFO org.lc.Reentrant_Lock.T6 - 有烟，开始干活！16:27:46.548 [饭桶] INFO org.lc.Reentrant_Lock.T6 - 饭来了，恰饭! 16、设计模式-同步模式之顺序控制①固定运行顺序题目：必须先打印2后打印11、使用wait/notify1234567891011121314151617181920212223242526272829303132@Slf4jpublic class T1 { static Object lock=new Object(); static boolean isRun=false; public static void main(String[] args) { Thread t1 = new Thread(() -&gt; { synchronized (lock) { while (!isRun) { try { lock.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } log.info(\"RunWith 1...\"); } }, \"t1\"); Thread t2=new Thread(()-&gt;{ synchronized (lock) { log.info(\"RunWith 2...\"); if(!isRun){ isRun=true; lock.notify(); } } },\"t2\"); t1.start(); t2.start(); }} 1216:48:20.774 [t2] INFO org.lc.desiger_.T1 - RunWith 2...16:48:20.776 [t1] INFO org.lc.desiger_.T1 - RunWith 1... 2、使用ReentrantLock123456789101112131415161718192021222324252627282930313233343536@Slf4jpublic class T2 { static ReentrantLock lock=new ReentrantLock(); static Condition waitSet=lock.newCondition(); static boolean isRun=false; public static void main(String[] args) { new Thread(()-&gt;{ lock.lock(); try { while (!isRun){ try { waitSet.await(); } catch (InterruptedException e) { e.printStackTrace(); } } log.info(\"runwith 1\"); }finally { lock.unlock(); } },\"t1\").start(); new Thread(()-&gt;{ lock.lock(); try { if (!isRun) { isRun=true; log.info(\"runwith 2\"); waitSet.signal(); } }finally { lock.unlock(); } },\"t1\").start(); }} 1216:59:17.669 [t1] INFO org.lc.desiger_.T2 - runwith 216:59:17.671 [t1] INFO org.lc.desiger_.T2 - runwith 1 3、使用park和unpark123456789101112131415@Slf4jpublic class T3 { public static void main(String[] args) { Thread t1= new Thread(() -&gt; { LockSupport.park(); log.info(\"runwith 1\"); }, \"t1\"); t1.start(); new Thread(()-&gt;{ log.info(\"runwith 2\"); LockSupport.unpark(t1); },\"t2\").start(); }} ②交替输出题目：线程 1 输出 a 5 次，线程 2 输出 b 5 次，线程 3 输出 c 5 次。现在要求输出 abcabcabcabcabc 怎么实现 1、使用wait/notify1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class T4 { public static void main(String[] args) {// 下一定义标记为1 即先打印a PrintABC printABC = new PrintABC(1, 5); new Thread(()-&gt;{ printABC.print(\"a\", 1, 2); },\"t1\").start(); new Thread(()-&gt;{ printABC.print(\"b\", 2, 3); },\"t2\").start(); new Thread(()-&gt;{ printABC.print(\"c\", 3, 1); },\"t3\").start(); }}/**依次打印abc五次 * 当前打印标记 下一打印标记 * a 1 2 * b 2 3 * c 3 1 */class PrintABC{// 当前打印标记 int flag;// 下一打印标记 int nextFlag;// 循环次数 int loopNumber; public PrintABC(int nextFlag, int loopNumber) { this.nextFlag = nextFlag; this.loopNumber = loopNumber; } public void print(String word, int flag, int nextFlag){ for (int i = 0; i &lt; loopNumber; i++) { synchronized (this) {// 如果当前传过来的标记和下一打印标记不一致 while (this.nextFlag!=flag) { try {// 等待 this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.print(word); this.nextFlag=nextFlag;// 唤醒所有进程 this.notifyAll(); } } }} 1abcabcabcabcabc 2、使用ReentrantLock12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class T5 { public static void main(String[] args) throws InterruptedException { ReentrantPrint reentrantPrint = new ReentrantPrint(5); Condition a = reentrantPrint.newCondition(); Condition b = reentrantPrint.newCondition(); Condition c = reentrantPrint.newCondition(); new Thread(()-&gt;{ reentrantPrint.print(\"a\", a, b); },\"t1\").start(); new Thread(()-&gt;{ reentrantPrint.print(\"b\", b, c); },\"t2\").start(); new Thread(()-&gt;{ reentrantPrint.print(\"c\", c, a); },\"t3\").start(); //先让上述线程都进入各自的阻塞队列 Thread.sleep(2000);// 主线程启动 先唤醒t1打印a reentrantPrint.lock(); try {// 唤醒a队列 a.signal(); System.out.println(\"start...\"); }finally { //释放锁 reentrantPrint.unlock(); } }}class ReentrantPrint extends ReentrantLock {// 循环次数 int loopNumber; public ReentrantPrint(int loopNumber) { this.loopNumber = loopNumber; } /** * 打印的方法 * @param word 打印的内容 * @param cond 当前线程睡眠的队列 * @param nextCond 下一个唤醒的队列 */ public void print(String word,Condition cond,Condition nextCond) { for (int i = 0; i &lt; loopNumber; i++) {// 尝试获得锁 lock(); try { try { //a等待的队列 cond.await();// 打印单词 System.out.print(word);// 下一个唤醒的队列 nextCond.signal(); } catch (InterruptedException e) { e.printStackTrace(); } }finally { unlock(); } } }} 12start...abcabcabcabcabc 3、park和unpark1234567891011121314151617181920212223242526272829303132333435363738394041public class T6 { static Thread t1; static Thread t2; static Thread t3; public static void main(String[] args) throws InterruptedException { ParkPrint parkPrint = new ParkPrint(5); t1 = new Thread(() -&gt; { parkPrint.print(\"a\", t2); }, \"t1\"); t2 = new Thread(() -&gt; { parkPrint.print(\"b\", t3); }, \"t2\"); t3 = new Thread(() -&gt; { parkPrint.print(\"c\", t1); }, \"t3\"); t1.start(); t2.start(); t3.start();// 保证上述线程启动完毕 Thread.sleep(2000);// 先唤醒t1线程 打印a LockSupport.unpark(t1); }}class ParkPrint{ int loopNumber; public ParkPrint(int loopNumber) { this.loopNumber = loopNumber; } public void print(String word,Thread nextThread){ for (int i = 0; i &lt; loopNumber; i++) {// 先阻塞 LockSupport.park(); System.out.print(word); LockSupport.unpark(nextThread); } }} 1abcabcabcabcabc 17、本章小结 Ⅳ、共享模型之内存1、java内存模型JMM: java memory model 它定义了主存(线程共享的数据、静态成员变量，成员变量)、工作内存(局部变量)抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、 CPU 指令优化等。 JMM 体现在以下几个方面 原子性 - 保证指令不会受到线程上下文切换的影响 可见性 - 保证指令不会受 cpu 缓存的影响 有序性 - 保证指令不会受 cpu 指令并行优化的影响 2、可见性①退不出的循环先来看一个现象，按道理来说，主线程经过1秒后修改flag变量，线程t1终止，但是main 线程对 flag变量的修改对于 t1 线程不可见，导致了 t 1线程无法停止： 12345678910111213public class T1 { static boolean flag = true; public static void main(String[] args) throws InterruptedException { new Thread(()-&gt;{ while (flag) { } },\"t1\").start(); Thread.sleep(1000); flag=false; }} 原因： 初始状态t1线程开始从主存flag的值到工作内存中 因为t1线程要频繁的从主存中读取flag的值，JIT(just-in-time compilation)即时编译器会将flag的值缓存到自己的工作内存中的高速缓存中，减少对主存中flag的访问，以提高效率 1 秒之后，main 线程修改了 flag的值，并同步至主存，而 t1线程 是从自己工作内存中的高速缓存中读取这个变量 的值，结果永远是旧值 解决方法： 使用volatile关键字 加上volatile(易变的)关键字，只能修饰成员变量，不能修饰局部变量 1volatile static boolean flag = true; 使用加synchronized锁的方式 1234567891011121314151617181920@Slf4jpublic class T1 { static boolean flag = true; static Object lock=new Object(); public static void main(String[] args) throws InterruptedException { new Thread(()-&gt;{ while (true) { synchronized (lock) { if (!flag) { break; } } } },\"t1\").start(); Thread.sleep(1000); log.info(\"退出...\"); flag=false; }} 3、原子性和可见性前面例子体现的实际就是可见性，它保证的是在多个线程之间，一个线程对 volatile 变量的修改对另一个线程可 见， 不能保证原子性，仅用在一个写线程，多个读线程的情况： 上例从字节码理解是这样的： 123456getstatic run // 线程 t 获取 run true getstatic run // 线程 t 获取 run true getstatic run // 线程 t 获取 run true getstatic run // 线程 t 获取 run true putstatic run // 线程 main 修改 run 为 false， 仅此一次 getstatic run // 线程 t 获取 run false 比较一下之前我们将线程安全时举的例子：两个线程一个 i++ 一个 i– ，只能保证看到新值，不能解决指令交错 1234567891011// 假设i的初始值为0 getstatic i // 线程2-获取静态变量i的值 线程内i=0 getstatic i // 线程1-获取静态变量i的值 线程内i=0 iconst_1 // 线程1-准备常量1 iadd // 线程1-自增 线程内i=1 putstatic i // 线程1-将修改后的值存入静态变量i 静态变量i=1 iconst_1 // 线程2-准备常量1 isub // 线程2-自减 线程内i=-1 putstatic i // 线程2-将修改后的值存入静态变量i 静态变量i=-1 ①synchronized和volatile区别： synchronized语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性，也可以保证有序性(但是需要将修改的变量全部交由synchronized管理)。但缺点是synchronize属于重量级的操作，性能相对较低。 volatile并不能保证原子性，但是能够保证其有序性和可见性。他适用于一个线程读，另一个线程写的情况 4、终止模式之两阶段终止模式(volatile)我们之前使用isInterrupted来实现，现在我们使用volatile实现监视器功能 12345678910111213141516171819202122232425262728293031323334353637public class T2 { public static void main(String[] args) throws InterruptedException { LogMonitor logMonitor=new LogMonitor(); logMonitor.start(); //5秒后停止监控 Thread.sleep(5000); logMonitor.stop(); }}@Slf4jclass LogMonitor{ private Thread thread; private volatile boolean flag=false; public void start(){ thread=new Thread(()-&gt;{ while (true) { if(flag){ log.info(\"停止监控...\"); break; } try { Thread.sleep(1000); log.info(\"监控记录中...\"); } catch (InterruptedException e) { } } },\"监视器\"); thread.start(); } public void stop() { flag=true; //打断线程 避免在睡眠后又一次记录 thread.interrupt(); }} 1234519:50:16.992 [监视器] INFO org.lc.volatile_.LogMonitor - 监控记录中...19:50:17.996 [监视器] INFO org.lc.volatile_.LogMonitor - 监控记录中...19:50:18.997 [监视器] INFO org.lc.volatile_.LogMonitor - 监控记录中...19:50:19.998 [监视器] INFO org.lc.volatile_.LogMonitor - 监控记录中...19:50:20.991 [监视器] INFO org.lc.volatile_.LogMonitor - 停止监控... 5、同步模式之Balking(犹豫模式)①定义：Balking （犹豫）模式用在一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需再做 了，直接结束返回 ②监控日志-案例防止创建多个启动实例 synchronized+volatile synchronzed保证原子性，volatile保证可见性 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class T2 { public static void main(String[] args) throws InterruptedException { LogMonitor logMonitor=new LogMonitor();// 这里启动多个实例 还是按照每秒执行一次来监控 logMonitor.start(); logMonitor.start(); logMonitor.start(); //5秒后停止监控// Thread.sleep(5000);// logMonitor.stop(); }}@Slf4jclass LogMonitor{ private Thread thread; private volatile boolean flag=false;// 判断是否已经启动了该监视器 private boolean isStaring=false; public void start(){ //多个线程来访问修改isStrating,会产生线程安全问题 需要使用synchronize来保证原子性 synchronized (this) { if (isStaring) {// 已经启动了 直接返回 return; } } isStaring=true; thread=new Thread(()-&gt;{ while (true) { if(flag){ log.info(\"停止监控...\"); break; } try { Thread.sleep(1000); log.info(\"监控记录中...\"); } catch (InterruptedException e) { } } },\"监视器\"); thread.start(); } public void stop() { flag=true; //打断线程 避免在睡眠后又一次记录 thread.interrupt(); }} 123420:09:15.560 [监视器] INFO org.lc.volatile_.LogMonitor - 监控记录中...20:09:16.566 [监视器] INFO org.lc.volatile_.LogMonitor - 监控记录中...20:09:17.566 [监视器] INFO org.lc.volatile_.LogMonitor - 监控记录中...... ③线程安全的单例模式效率太低，详细请看7下的第④个。 12345678910111213public class SafeSingleton { private static SafeSingleton safeSingleton=null; private SafeSingleton() { } public static synchronized SafeSingleton getInstance() { if (safeSingleton != null) { return safeSingleton; } return safeSingleton=new SafeSingleton(); }} 6、有序性JVM 会在不影响正确性的前提下，可以调整语句的执行顺序，思考下面一段代码 1234static int i; static int j; // 在某个线程内执行如下赋值操作 i = ...; j = ...; 可以看到，至于是先执行 i 还是 先执行 j ，对终的结果不会产生影响。所以，上面代码真正执行时，既可以是 12i = ...; j = ...; 也可以是 12j = ...; i = ...; 这种特性称之为『指令重排』，多线程下『指令重排』会影响正确性。 使用：volatile 修饰的变量，可以防止指令重排 即被volatile修饰的变量在修改之前的代码都是有序的(只是在本线程有效)，不可被jvm进行优化，重新排列运行 7、volatile原理①读屏障和写屏障的可见性和有序性 可见性 写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中 而读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中新数据 有序性 写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后 读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前 volatile 的底层实现原理是内存屏障，Memory Barrier（Memory Fence） 对 volatile 变量的写指令后会加入写屏障 对 volatile 变量的写指令后会加入写屏障 ②如何保证可见性 写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中 private volatile boolena ready=false; public void actor2(I_Result r) { num = 2; //写到主存中 ready = true; // ready 是 volatile 赋值带写屏障 // 写屏障 } &lt;!--￼151--&gt; &lt;img src=\"http://img.louchen.top/2020/05/20200528102536.png\" style=\"zoom: 67%;\" /&gt; ③如何保证有序性 写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后 public void actor2(I_Result r) { num = 2; ready = true; // ready 是 volatile 赋值带写屏障 // 写屏障 } &lt;!--￼152--&gt; &lt;img src=\"C:\\Users\\42119\\AppData\\Roaming\\Typora\\typora-user-images\\1590632954308.png\" alt=\"1590632954308\" style=\"zoom:67%;\" /&gt; 总结： 被volatile修饰的成员变量，只能在本线程保证有序性和可见性，不能解决指令交错。 写屏障：保证被volatile的修饰的成员变量在改变之前的代码都是写到主存中。保证在修改该变量之前的代码不会排在该变量之后。 读屏障：保证被volatile的修饰的成员变量在读取之后的代码都是从主存中读。保证在读该变量之后的代码不会排在该变量之前。 ④单例模式的 double-checked locking (双重检查)之前创建的单例的方式： 这种方式效率非常低。 12345678910111213public class SafeSingleton { private static SafeSingleton safeSingleton=null; private SafeSingleton() { } public static SafeSingleton getInstance() { synchronized (SafeSingleton.class) { if (safeSingleton == null) { return safeSingleton==new SafeSingleton();; } } return safeSingleton }} 改进： 1234567891011121314151617public class SafeSingleton { private static SafeSingleton safeSingleton=null; private SafeSingleton() { } public static SafeSingleton getInstance() { //多个线程访问 如果实例不为空则直接返回，后面的线程无需再竞争锁 if(safeSingleton==null) {// 第一个进来的线程 获得到锁创建 synchronized (SafeSingleton.class) { if (safeSingleton == null) { return safeSingleton=new SafeSingleton(); } } } return safeSingleton; }} 以上的实现特点是： 懒惰实例化 首次使用 getInstance() 才使用 synchronized 加锁，后续使用时无需加锁 有隐含的，但很关键的一点：第一个 if 使用了 INSTANCE 变量，是在同步块之外 但在多线程环境下，上面的代码是有问题的，getInstance 方法对应的字节码为： 其中 17 表示创建对象，将对象引用入栈 // new Singleton 20 表示复制一份对象引用 // 引用地址 21 表示利用一个对象引用，调用构造方法 24 表示利用一个对象引用，赋值给 static INSTANCE 也许 jvm 会优化为：先执行 24，再执行 21。如果两个线程 t1，t2 按如下时间序列执行： 通俗一点就是，线程t2执行第一个if(safeSingleton==null)时,线程t1已经执行到第二个if(safeSingleton==null)中的safeSingleton=new SafeSingleton();，但是由于jvm指令重排的关系，可能会先执行对safeSingleton的引用赋值情况，但是new SafeSingleton()还未执行完毕。所以线程t2拿到返回的实例为未被初始化完毕的实例。 注意：对 INSTANCE 使用 volatile 修饰即可，可以禁用指令重排，但要注意在 JDK 5 以上的版本的 volatile 才会真正有效 最终解决方案： 123456789101112131415161718192021public class SafeSingleton { //给实例加上volatile关键字 加入内存屏障 private volatile static SafeSingleton safeSingleton=null; private SafeSingleton() { } public static SafeSingleton getInstance() {// 可见性：读：该屏障后面的代码都会从主存中读// 有序性：读：该屏障后面的代码都会在该屏障之后执行 if(safeSingleton==null) { synchronized (SafeSingleton.class) { if (safeSingleton == null) { //可见性：写：该屏障之前的代码都会写到主存中 //有序性，写：该屏障之前的代码后会在该屏障之前执行 //保证对变量safeSingleton的赋值为有序性，即先调用构造方法，再赋值引用给safeSingleton return safeSingleton=new SafeSingleton(); } } } return safeSingleton; }} 8、习题①balking 模式习题希望 doInit() 方法仅被调用一次，下面的实现是否有问题，为什么？ 123456789101112131415class TestVolatile{ volatile Boolean initialized=false; void init() { if (initialized) { return; } doInit(); initialized=true; } private void doInit() { //初始化的一些操作 }} 上述代码存在多线程并发操作，doInit()调用多次的情况, 修改如下： 1234567891011121314151617181920class TestVolatile{ volatile boolean initialized=false; void init() { if (initialized) { return; } synchronized (TestVolatile.class) { if(initialized){ return; } doInit(); initialized=true; } } private void doInit() { //初始化的一些操作 }} ②线程安全单例习题单例模式有很多实现方法，饿汉、懒汉、静态内部类、枚举类，试分析每种实现下获取单例对象（即调用 getInstance）时的线程安全，并思考注释中的问题 饿汉式：类加载就会导致该单实例对象被创建 懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建 实现1(饿汉式)：1234567891011121314151617//1、为什么加final? 答：防止子类对父类覆盖创建对象方法的干扰//2、如果实现了序列化接口，还要做什么来防止序列化破坏单例？ 答：加上一个readResovle方法public final class Singleton implements Serializable { //3、为什么设置为私有？ 答：防止通过new无限制的创建对象。 是否能防止反序列化创建新的实例？ 答：不能 private Singleton() { } //4、这样初始化能否保证线程安全问题? 答：在类加载的时候，该对象即被jvm创建，所有为线程安全的 private static final Singleton INSTANCE = new Singleton(); //5、为什么使用方法提供实例，而不是直接通过设置字段成员公有提供实例？ 答：更好的封装性，扩展性 public static Singleton getInstance() { return INSTANCE; } //若该类有readResolve方法，则使用该方法返回的对象，而不是使用序列化后的对象实例 public Object readResolve() { return INSTANCE; }} 实现2(懒汉式)：12345678910111213public class Singleton { private Singleton() { } private static Singleton INSTANCE=null; //对Singleton类对象上锁，性能比较低。 public static synchronized Singleton getInstance() { if (INSTANCE != null) { return INSTANCE; } INSTANCE=new Singleton(); return INSTANCE; }} 实现3(double-checked locking 双重检查)懒汉123456789101112131415161718192021public class Singleton { private Singleton() { } //加上volatile，防止在创建对象的时候指令重排 private static volatile Singleton INSTANCE=null; public static Singleton getInstance() { if (INSTANCE != null) { return INSTANCE; } synchronized (Singleton.class) { if(INSTANCE!=null){ return INSTANCE; } //创建对象 INSTANCE = new Singleton(); return INSTANCE; } }} 实现4(静态内部类)懒汉：1234567891011121314public class Singleton { private Singleton() { } //使用静态内部类，对外部不可见。 //jvm本身对类加载是懒惰的，即只调用到getInstance方法时，使用到LazyHolder对象时该内部类才会被加载，里面的实例才会被加载 private static class LazyHolder{ static final Singleton INSTANCE=new Singleton(); } //调用时才会加载此内部类 public static Singleton getInstance() { return LazyHolder.INSTANCE; }} 实现5(枚举)12345678910111213141516171819202122232425//反编译后的问题：继承Enum枚举类//final enum Singleton extends Enum{// 类加载时创建对象// public final static enum Singleton INSTANCE;// }//1、枚举单例是如何实现限制实例个数的？ 每个枚举实例，都是一个单例对象//2、枚举单例在创建时是否有有并发问题？ 没有，final static实例会在类初始化的时候创建//3、枚举单例能否被反序列化破坏单例？ 枚举类默认实现序列化接口，可被序列化和反序列，但是不破坏单例//4、枚举能否通过反射破坏单例？ 不能。//5、枚举单例属于饿汉式//6、枚举单例中可以加入一些字段和构造方法，来初始化单例的属性public enum Singleton { INSTANCE; public static Singleton GetInstance(){ return INSTANCE; }}class SingleTest{ public static void main(String[] args) { Singleton instance = Singleton.GetInstance(); Singleton instance1 = Singleton.INSTANCE;// true System.out.println(instance==instance1); }} Ⅴ、共享模型之无锁1、存取款问题①有锁方式synchronized 账户接口 123456789101112131415161718192021222324252627interface Account { //获取余额 Integer getBalance(); //取款 void withdraw(Integer amount); static void demo(Account account) { List&lt;Thread&gt; list = new ArrayList&lt;&gt;(); long start = System.currentTimeMillis(); for (int i = 0; i &lt; 1000; i++) { list.add(new Thread(() -&gt; { account.withdraw(10); })); } list.forEach(Thread::start); list.forEach(t -&gt; { try { t.join(); } catch (InterruptedException e) { e.printStackTrace(); } }); long end = System.currentTimeMillis(); System.out.println(account.getBalance() + \" cost:\" + (end - start)+\"ms\"); }} 实现接口 123456789101112131415161718192021222324public class T1 { public static void main(String[] args) { AcccountSafe safe = new AcccountSafe(10000); Account.demo(safe); }}class AcccountSafe implements Account { // 余额 private Integer balance; public AcccountSafe(Integer balance) { this.balance = balance; } @Override public synchronized Integer getBalance() { return this.balance; } @Override public synchronized void withdraw(Integer amount) { this.balance -= amount; }} 10 cost:126ms ②无锁方式CAS 账户接口 不变 实现接口 12345678910111213141516171819202122232425262728293031323334353637public class T1 { public static void main(String[] args) { AccountCAS cas=new AccountCAS(10000); Account.demo(cas); }}class AccountCAS implements Account{ //余额 //使用原子的Atomic private AtomicInteger balance; public AccountCAS(Integer balance) { this.balance = new AtomicInteger(balance); } @Override public Integer getBalance() { //获取最新的值 return balance.get(); } @Override public void withdraw(Integer amount) { //使用cas操作 while (true) { //获取最新的余额 int pre=balance.get(); //取钱之后的余额 int next=pre-amount; //期望最新值 操作完之后的值 if(balance.compareAndSet(pre, next)){ break; } } }} 10 cost:68ms 结果： 无锁的操作相比加锁确实效率提升了不少 120 cost:126ms //加锁0 cost:68ms //无锁 2、CAS与Volatile①CAS操作分析前面看到的 AtomicInteger 的解决方法，内部并没有用锁来保护共享变量的线程安全。那么它是如何实现的呢？ 1234567891011121314151617@Override public void withdraw(Integer amount) { //不断循环重试，知道成功为止 while (true) { //获取最新的余额 比如，拿到最新的值10000 int pre=balance.get(); //取钱之后的余额 操作 10000-10=9990 int next=pre-amount; //当前线程读取到的最新余额 ; 操作完之后的余额 //compareAndSet这个操作是原子性的 //例如，当该线程t1读取到当前的余额和操作之后的余额得到compareAndSet(10000,9990) //此外，线程t2再此原子操作之前修改了最新的余额为9990，即当前线程t1执行compareAndSet之前 //pre会和最新的期望余额值进行比较，如果不一致，则next作废，返回false,重试。否则没有其他线程对余额进行操作，返回true,退出循环 if(balance.compareAndSet(pre, next)){ break; } } } 其中的关键是 compareAndSet，它的简称就是 CAS （也有 Compare And Swap 比较交换 的说法），它必须是原子操作。 我们可以发现在 AtomicInteger 中 是使用volatile保证可见性 123456789101112131415161718public class AtomicInteger extends Number implements java.io.Serializable { private static final long serialVersionUID = 6214790243416807050L; // setup to use Unsafe.compareAndSwapInt for updates private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long valueOffset; static { try { valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField(\"value\")); } catch (Exception ex) { throw new Error(ex); } } private volatile int value; //** //**} 注意： 其实 CAS 的底层是 lock cmpxchg 指令（X86 架构），在单核 CPU 和多核 CPU 下都能够保证【比较-交 换】的原子性。 在多核状态下，某个核执行到带 lock 的指令时，CPU 会让总线锁住，当这个核把此指令执行完毕，再 开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子 的。 CAS 必须借助 volatile 才能读取到共享变量的新值来实现【比较并交换】的效果 ②为什么无锁效率高？ 无锁情况下，即使重试失败，线程始终在高速运行，没有停歇，而 synchronized 会让线程在没有获得锁的时 候，发生上下文切换，进入阻塞。打个比喻 线程就好像高速跑道上的赛车，高速运行时，速度超快，一旦发生上下文切换，就好比赛车要减速、熄火， 等被唤醒又得重新打火、启动、加速… 恢复到高速运行，代价比较大 但无锁情况下，因为线程要保持运行，需要额外 CPU 的支持，CPU 在这里就好比高速跑道，没有额外的跑 道，线程想高速运行也无从谈起，虽然不会进入阻塞，但由于没有分到时间片，仍然会进入可运行状态，还 是会导致上下文切换。 ③CAS特点结合 CAS 和 volatile 可以实现无锁并发，适用于线程数少、多核 CPU 的场景下 CAS 是基于乐观锁的思想：乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再 重试呗。 每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。 synchronized 是基于悲观锁的思想：悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想 改，我改完了解开锁，你们才有机会。 这种线程一旦得到锁，其他需要锁的线程就挂起的情况就是悲观锁 CAS 体现的是无锁并发、无阻塞并发，请仔细体会这两句话的意思 因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一 但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响 3、原子整数 java.util.concurrent.atomic下的 AtomicIntegerAtomicBooleanAtomicLong以AtomicInteger为例： 123456789101112131415161718192021222324252627282930public class T2 { public static void main(String[] args) {// 初始化值为0 AtomicInteger i = new AtomicInteger(1);// 先获取再自增1 返回：1 System.out.println(i.getAndIncrement()); //i++// 先自增1再获取 返回：3 System.out.println(i.incrementAndGet()); //++i// 先自减1再获取 返回：2 System.out.println(i.decrementAndGet());// --i;// 先获取再自减1 返回：2 System.out.println(i.getAndDecrement());// i--;// 直接获取值 返回：1 System.out.println(i.get());// 加上指定的值大小(先获取，再加) 返回：1 结果为11 System.out.println(i.getAndAdd(10));// 加上指定的值大小(先增加，再获取)// i.addAndGet(10)// 对指定的值进行更新操作 IntUnaryOperator函数式接口提供一个int类型参数，int类型的返回值的方法// 先更新后获取 返回：22 结果：22 System.out.println(i.updateAndGet(value -&gt; value * 2));// 对指定的值进行更新操作// 先获取后更新 返回22 结果2200 System.out.println(i.getAndUpdate(value -&gt; value * 100));// 先计算再获取 IntBinaryOperator函数式接口提供两个int类型参数 第一个为值i为2200，第二个为传来的参数200，返回一个int类型 // 返回2000 结果为2000 System.out.println(i.accumulateAndGet(200, (p, x) -&gt; p - x)); }} 即我们可以将上述取钱的操作修改： 12345678910111213141516@Override public void withdraw(Integer amount) {// //使用cas操作// while (true) {// //获取最新的余额// int pre=balance.get();// //取钱之后的余额// int next=pre-amount;// //期望最新值 操作完之后的值// if(balance.compareAndSet(pre, next)){// break;// }// } //取钱加一个负数即可 balance.addAndGet(-1*amount); } 手动实现UpdateAndGet方法： 1234567891011121314151617public class T3 { public static void main(String[] args) { AtomicInteger i = new AtomicInteger(10); System.out.println(updateAndGet(i, value -&gt; value * 10)); } static int updateAndGet(AtomicInteger i, IntUnaryOperator operator){ while (true) {// 获取最新的值 int pre = i.get(); int next = operator.applyAsInt(pre);// 调用cas操作 if(i.compareAndSet(pre, next)){ return next; } } }} AtomicInteger的UpdateAndGet方法源码： 12345678public final int updateAndGet(IntUnaryOperator updateFunction) { int prev, next; do { prev = get(); next = updateFunction.applyAsInt(prev); } while (!compareAndSet(prev, next)); return next; } 4、原子引用AtomicReferenceAtomicMarkableReferenceAtomicStampedReference①AtomicReference&lt;V&gt;的使用对引用类型进行原子操作 取款问题，若存取的操作为引用类型。则需要AtomicReference保护该类型 账户类 123456789101112131415161718192021222324252627interface AccountR { //获取余额 BigDecimal getBalance(); //取款 void withdraw(BigDecimal amount); static void demo(AccountR account) { List&lt;Thread&gt; list = new ArrayList&lt;&gt;(); long start = System.currentTimeMillis(); for (int i = 0; i &lt; 1000; i++) { list.add(new Thread(() -&gt; { account.withdraw(new BigDecimal(String.valueOf(10))); })); } list.forEach(Thread::start); list.forEach(t -&gt; { try { t.join(); } catch (InterruptedException e) { e.printStackTrace(); } }); long end = System.currentTimeMillis(); System.out.println(account.getBalance() + \" cost:\" + (end - start)+\"ms\"); }} 实现类 1234567891011121314151617181920212223242526272829303132public class T4 { public static void main(String[] args) { DecimalAccountCas cas=new DecimalAccountCas(new BigDecimal(String.valueOf(10000))); AccountR.demo(cas); }}class DecimalAccountCas implements AccountR{// 原子引用 &lt;要保护的类型&gt; private AtomicReference&lt;BigDecimal&gt; reference; public DecimalAccountCas(BigDecimal balance) { this.reference = new AtomicReference&lt;&gt;(balance); } @Override public BigDecimal getBalance() { return reference.get(); } @Override public void withdraw(BigDecimal amount) { while (true) { BigDecimal pre=reference.get(); //subtract减操作 BigDecimal next=pre.subtract(amount);// 使用cas if (reference.compareAndSet(pre, next)) { break; } } }} 10 cost:159ms ②ABA问题及其解决ABA问题12345678910111213141516171819202122232425@Slf4jpublic class T5 { static AtomicReference&lt;String&gt; ref=new AtomicReference&lt;&gt;(\"A\"); public static void main(String[] args) throws InterruptedException { log.info(\"main start...\");// 获取值 String value = ref.get(); //其他线程对变量修改 other(); Thread.sleep(1000);// 尝试修改为// 能否判断该变量value被其他线程修改过？ log.info(\"change A-&gt;C {}\",ref.compareAndSet(value, \"C\")); } static void other() throws InterruptedException { new Thread(()-&gt;{ log.info(\"change A-&gt;B {}\",ref.compareAndSet(ref.get(),\"B\")); },\"t1\").start(); Thread.sleep(500); new Thread(()-&gt;{ log.info(\"change B-&gt;A {}\",ref.compareAndSet(ref.get(),\"A\")); },\"t2\").start(); }} 123419:04:04.348 [main] INFO org.lc.cas.T5 - main start...19:04:04.386 [t1] INFO org.lc.cas.T5 - change A-&gt;B true19:04:04.886 [t2] INFO org.lc.cas.T5 - change B-&gt;A true19:04:05.886 [main] INFO org.lc.cas.T5 - change A-&gt;C true 我们发现，在主线程main执行cas操作的时候，并不能感知其他线程对其值value修改过的操作。只是表面上的一致。中间操作还是被其他线程修改过。 主线程仅能判断出共享变量的值与初值 A 是否相同，不能感知到这种从 A 改为 B 又 改回 A 的情况，如果主线程 希望： 只要有其它线程【动过了】共享变量，那么自己的 cas 就算失败，这时，仅比较值是不够的，需要再加一个版本号 ③AtomicStampedReference&lt;V&gt;解决ABA问题(加版本号)保证期望值匹配和版本号匹配CAS才能成功 123456789101112131415161718192021222324252627282930313233343536373839@Slf4jpublic class T6 { //赋初值的时候加版本号 static AtomicStampedReference&lt;String&gt; ref=new AtomicStampedReference&lt;&gt;(\"A\",0); public static void main(String[] args) throws InterruptedException { log.info(\"main start...\");// 获取值 String value = ref.getReference();// 获取版本号 int stamp = ref.getStamp(); log.info(\"值为:{},版本号为:{}\",value,stamp); //其他线程对变量修改 other(); Thread.sleep(1000); log.info(\"值为:{},版本号为:{}\",value,stamp);// 尝试修改为// 期望的值；新值；期望的版本号；新的版本号// stamp为0，但是other中的方法对已经对stamp进行了修改为2，版本号不匹配，即此CAS操作失败 log.info(\"change A-&gt;C {}\",ref.compareAndSet(value,\"C\",stamp, stamp+1));// 输出为A. 是other中的线程t2的cas操作的结果 System.out.println(ref.getReference()); } static void other() throws InterruptedException { new Thread(()-&gt;{ String value=ref.getReference(); int stamp=ref.getStamp(); log.info(\"值为:{},版本号为:{}\",value,stamp); log.info(\"change A-&gt;B {}\",ref.compareAndSet(value,\"B\",ref.getStamp(),stamp+1)); },\"t1\").start(); Thread.sleep(500); new Thread(()-&gt;{ String value=ref.getReference(); int stamp=ref.getStamp(); log.info(\"值为:{},版本号为:{}\",value,stamp); log.info(\"change A-&gt;B {}\",ref.compareAndSet(value,\"A\",ref.getStamp(),stamp+1)); },\"t2\").start(); }} 12345678919:24:01.934 [main] INFO org.lc.cas.T6 - main start...19:24:01.936 [main] INFO org.lc.cas.T6 - 值为:A,版本号为:019:24:01.974 [t1] INFO org.lc.cas.T6 - 值为:A,版本号为:019:24:01.974 [t1] INFO org.lc.cas.T6 - change A-&gt;B true19:24:02.474 [t2] INFO org.lc.cas.T6 - 值为:B,版本号为:119:24:02.474 [t2] INFO org.lc.cas.T6 - change A-&gt;B true19:24:03.475 [main] INFO org.lc.cas.T6 - 值为:A,版本号为:019:24:03.475 [main] INFO org.lc.cas.T6 - change A-&gt;C falseA AtomicStampedReference 可以给原子引用加上版本号，追踪原子引用整个的变化过程，如： A -&gt; B -&gt; A -&gt; C ，通过AtomicStampedReference，我们可以知道，引用变量中途被更改了几次。但是有时候，并不关心引用变量更改了几次，只是单纯的关心是否更改过，所以就有了 AtomicMarkableReference ④AtomicMarkableReference&lt;V&gt;解决ABA问题(true/false标记)保证期望值匹配和标志匹配CAS才能成功 垃圾袋类 1234567891011121314151617//垃圾袋class GarbageBag{ String desc; public GarbageBag(String desc) { this.desc = desc; } public GarbageBag setDesc(String desc) { this.desc = desc; return this; } @Override public String toString() { return \"GarbageBag{\" + \"desc='\" + desc + '\\'' + '}'; }} 实现操作 1234567891011121314151617181920@Slf4jpublic class T7 { public static void main(String[] args) throws InterruptedException { GarbageBag bag=new GarbageBag(\"这是一个装满了垃圾的垃圾袋\");// 初始化并标记 标记为true，这里只是作为一个标记，其他线程修改该值时，将此标记改为false AtomicMarkableReference&lt;GarbageBag&gt; reference=new AtomicMarkableReference&lt;&gt;(bag, true); log.info(\"主线程 start...\"); GarbageBag prev = reference.getReference(); log.info(prev.toString()); Thread.sleep(1000); log.info(\"想换一只垃圾袋？\"); //CAS操作 //参数： 期望的值；修改后的值；期望的标记；修改后的标记 //先匹配prev的值是否被修改，再匹配第三个参数期望的标记是否为初始化时的标记为true. //都匹配，则cas成功。否则失败 boolean result = reference.compareAndSet(prev, new GarbageBag(\"新的垃圾袋\"), true, false); log.info(\"换成功没？ {}\",result); }} 123419:51:28.716 [main] INFO org.lc.cas.T7 - 主线程 start...19:51:28.718 [main] INFO org.lc.cas.T7 - GarbageBag{desc='这是一个装满了垃圾的垃圾袋'}19:51:29.719 [main] INFO org.lc.cas.T7 - 想换一只垃圾袋？19:51:29.719 [main] INFO org.lc.cas.T7 - 换成功没？ true 当其他线程对其prev修改时，主线程能否CAS成功? 123456789101112131415161718192021222324252627@Slf4jpublic class T7 { public static void main(String[] args) throws InterruptedException { GarbageBag bag=new GarbageBag(\"这是一个装满了垃圾的垃圾袋\");// 初始化并标记 AtomicMarkableReference&lt;GarbageBag&gt; reference=new AtomicMarkableReference&lt;&gt;(bag, true); log.info(\"主线程 start...\"); GarbageBag prev = reference.getReference(); log.info(prev.toString()); //此线程就是修改了prev的desc的变量值 new Thread(()-&gt;{ GarbageBag bag1 = reference.getReference(); log.info(\"打扫卫生的线程 start...\"); bag1.setDesc(\"垃圾已打扫，这是一个空垃圾袋\"); //cas成功 while (!reference.compareAndSet(bag1,bag1,true,false)){ } log.info(bag.toString()); },\"t1\").start(); Thread.sleep(1000); log.info(\"想换一只垃圾袋？\"); //cas失败 因为pre已经被修改，且新的期望值已经变为false. boolean result = reference.compareAndSet(prev, new GarbageBag(\"新的垃圾袋\"), true, false); log.info(\"换成功没？ {}\",result); }} 12345619:59:31.901 [main] INFO org.lc.cas.T7 - 主线程 start...19:59:31.903 [main] INFO org.lc.cas.T7 - GarbageBag{desc='这是一个装满了垃圾的垃圾袋'}19:59:31.947 [t1] INFO org.lc.cas.T7 - 打扫卫生的线程 start...19:59:31.947 [t1] INFO org.lc.cas.T7 - GarbageBag{desc='垃圾已打扫，这是一个空垃圾袋'}19:59:32.948 [main] INFO org.lc.cas.T7 - 想换一只垃圾袋？19:59:32.948 [main] INFO org.lc.cas.T7 - 换成功没？ false 5、原子数组AtomicIntegerArrayAtomicLongArrayAtomicReferenceArray①AtomicIntegerArray的使用对数组的每个索引处进行10000的累加操作。期望结果：[10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000] 123456789101112131415161718192021222324252627282930313233343536373839404142434445 /** *数组测试 * @param arraySupplier 提供数组，可以是线程不安全数组或线程安全数组 * @param lengthFun 获取数组长度的方法 * @param putConsume 自增方法，回传array,index * @param printConsume 打印数组的方法 * @param &lt;T&gt;类型定义 */ private static &lt;T&gt; void demo( // T get(); Supplier&lt;T&gt; arraySupplier, // R apply(T t); Function&lt;T,Integer&gt; lengthFun, // void accept(T t, U u); BiConsumer&lt;T,Integer&gt; putConsume, // void accept(T t); Consumer&lt;T&gt; printConsume){ List&lt;Thread&gt; ts=new ArrayList&lt;&gt;();// 获取数组 T array = arraySupplier.get();// 获取数组长度 Integer length = lengthFun.apply(array);// 循环10次 for (int i = 0; i &lt; length; i++) { //每个线程对数组10000次操作 ts.add(new Thread(()-&gt;{ //对每个索引的位置进行1000的累加操作 for (int j = 0; j &lt; 10000; j++) { //数组; 得到 0,1,2,3,4,5,6,7,8,9索引 putConsume.accept(array, j % length); } })); } ts.forEach(Thread::start); ts.forEach(thread -&gt; { try { thread.join(); } catch (InterruptedException e) { e.printStackTrace(); } }); //打印数组 printConsume.accept(array); }} 非安全操作： 12345678910111213public static void main(String[] args) { demo( //传递长度为10的int数组 ()-&gt;new int[10], //传入数组长度 (array-&gt;array.length), //对数组中的每个索引位10000次加1操作 //array[index]++,这里可能存在指令的交错。导致线程不安全 (array,index)-&gt;array[index]++, //打印操作完后的数组 array-&gt; System.out.println(Arrays.toString(array)) ); } 1[9312, 9230, 9238, 9229, 9222, 9210, 9291, 9263, 9247, 9230] 安全操作： 123456789101112public static void main(String[] args) { demo( //传递长度为10的int数组 ()-&gt;new AtomicIntegerArray(10), //传入数组长度 (array-&gt;array.length()), //对数组中的每个索引位10000次加1操作 (array,index)-&gt;array.getAndIncrement(index), //打印操作完后的数组 array-&gt; System.out.println(array) ); } 1[10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000] 6、字段更新器我们只能对对象进行原子保护，但是不能对对象中的字段进行保护。因为对象中属性的改变并不会导致期望值的改变。所以我们需要字段更新器 根据要修改的字段类型，决定使用什么类型： AtomicReferenceFieldUpdaterAtomicIntegerFieldUpdaterAtomicLongFieldUpdater①AtomicReferenceFieldUpdater的使用注意：要操作的字段必须加volatile 1234567891011121314151617181920212223242526272829303132333435363738public class T10 { public static void main(String[] args) throws InterruptedException { AtomicReferenceFieldUpdater fieldUpdater=AtomicReferenceFieldUpdater.newUpdater(Student.class,String.class, \"name\"); Student student=new Student(); new Thread(()-&gt;{ //下面的cas成功 student.setName(\"李四\"); //下面的cas失败 //student.setName(\"张三\"); },\"t1\").start(); Thread.sleep(500);// cas操作：将对象字段的预期值和操作的对象中的值进行比较。如果一致则cas成功，否则失败 //当前操作的对象; 对象字段的预期值(原始值); 更新自动后的值 System.out.println(fieldUpdater.compareAndSet(student, \"李四\", \"张三\")); System.out.println(student.toString()); }}class Student{ //这里必须要配合volatile操作 volatile String name; public String getName() { return name; } public Student setName(String name) { this.name = name; return this; } @Override public String toString() { return \"Student{\" + \"name='\" + name + '\\'' + '}'; }} 7、原子累加器LongAdder①比较 AtomicLong 与 LongAdder123456789101112131415161718192021222324252627282930313233public class T11 { public static void main(String[] args) { //20000000 cost:327 demo(() -&gt; new AtomicLong(), adder -&gt; adder.getAndIncrement()); //20000000 cost:49 demo(() -&gt; new LongAdder(), adder -&gt; adder.increment()); } private static &lt;T&gt; void demo(Supplier&lt;T&gt; adderSupplier, Consumer&lt;T&gt; action) { T adder = adderSupplier.get(); long start = System.nanoTime(); List&lt;Thread&gt; ts = new ArrayList&lt;&gt;();// 4个线程 每个线程累加50万 for (int i = 0; i &lt; 40; i++) { ts.add(new Thread(() -&gt; { for (int j = 0; j &lt; 500000; j++) { action.accept(adder); } })); } ts.forEach(t -&gt; t.start()); ts.forEach(t -&gt; { try { t.join(); } catch (InterruptedException e) { e.printStackTrace(); } }); long end = System.nanoTime(); System.out.println(adder + \" cost:\" + (end - start) / 1000_000); }} 性能提升的原因很简单，就是在有竞争时，设置多个累加单元，Therad-0 累加 Cell[0]，而 Thread-1 累加 Cell[1]… 后将结果汇总。这样它们在累加时操作的不同的 Cell 变量，因此减少了 CAS 重试失败，从而提高性 能。 Ⅵ、共享模型之不可变1、日期转换出现的线程安全问题1234567891011121314public class T1 { public static void main(String[] args) { SimpleDateFormat sdf=new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); for (int i = 0; i &lt; 10; i++) { new Thread(()-&gt;{ try { System.out.println(sdf.parse(\"2019-1-1 11:11:11\")); } catch (ParseException e) { e.printStackTrace(); } }).start(); } }} 12345678Exception in thread \"Thread-5\" java.lang.NumberFormatException: multiple points at sun.misc.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:1890) at sun.misc.FloatingDecimal.parseDouble(FloatingDecimal.java:110) at java.lang.Double.parseDouble(Double.java:538) at java.text.DigitList.getDouble(DigitList.java:169)......Tue Jan 01 11:11:11 GMT+08:00 2019Tue Jan 01 11:11:11 GMT+08:00 2019 多线程同时操作同一个日期转换对象可能出现异常 ①加锁synchronized效率比较低 ②使用不可变类12345678910111213141516public class T1 { public static void main(String[] args) { DateTimeFormatter sdf = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\"); for (int i = 0; i &lt; 10; i++) { new Thread(()-&gt;{ try { System.out.println(sdf.parse(\"2019-01-01 11:11:11\",(LocalDateTime::from))); //等价-&gt; // System.out.println(sdf.parse(\"2019-01-01 11:11:11\", (TemporalAccessor temporal) -&gt; LocalDateTime.from(temporal))); } catch (Exception e) { e.printStackTrace(); } }).start(); } }} 12345* @implSpec* This class is immutable and thread-safe. //类不可变且是线程安全的 public final class DateTimeFormatter { //... } 2、不可变类的设计另一个大家更为熟悉的 String 类也是不可变的，以它为例，说明一下不可变设计的要素 1234public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence { //.... } ①final的使用发现该类、类中所有属性都是 ﬁnal 的 属性用 ﬁnal 修饰保证了该属性是只读的，不能修改 类用 ﬁnal 修饰保证了该类中的方法不能被覆盖，防止子类无意间破坏不可变性 ②保护性拷贝例如String中的substring 方法 1234567891011public String substring(int beginIndex) { if (beginIndex &lt; 0) { throw new StringIndexOutOfBoundsException(beginIndex); } int subLen = value.length - beginIndex; if (subLen &lt; 0) { throw new StringIndexOutOfBoundsException(subLen); } //实际new了一个新的对象 return (beginIndex == 0) ? this : new String(value, beginIndex, subLen); } 通过创建副本对象来避 免共享的手段称之为【保护性拷贝（defensive copy）】 3、享元模式定义 英文名称：Flyweight pattern. 当需要重用数量有限的同一类对象时 ①包装类体现在JDK中 Boolean，Byte，Short，Integer，Long，Character 等包装类提供了 valueOf 方法，例如 Long 的 valueOf 会缓存 -128~127 之间的 Long 对象，在这个范围之间会重用对象，大于这个范围，才会新建 Long 对 象： Long对象 1234567public static Long valueOf(long l) { final int offset = 128; if (l &gt;= -128 &amp;&amp; l &lt;= 127) { // will cache return LongCache.cache[(int)l + offset]; } return new Long(l); } 注意: Byte, Short, Long 缓存的范围都是 -128~127 Character 缓存的范围是 0~127 Integer的默认范围是 -128~127 最小值不能变 但最大值可以通过调整虚拟机参数 -Djava.lang.Integer.IntegerCache.high 来改变 Boolean 缓存了 TRUE 和 FALSE ②BigInteger和BigDecimal体现我们可以发现在BigDecimal进行add操作时，也是通过new一个BigDecimal进行的累加操作，不存在线程安全问题。但是多个方法同时操作，多线程的情况下则存在线程安全问题。 ③实现简单的享元模式(数据库连接池)例如：一个线上商城应用，QPS（每秒查询率（QPS，Queries-per-second）是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。） 达到数千，如果每次都重新创建和关闭数据库连接，性能会受到极大影响。 这时 预先创建好一批连接，放入连接池。一次请求到达后，从连接池获取连接，使用完毕后再还回连接池，这样既节约 了连接的创建和关闭时间，也实现了连接的重用，不至于让庞大的连接数压垮数据库 连接对象 12345678910111213//模拟连接对象实现class MockConnection implements Connection{ private String connectionName; @Override public String toString() { return \"MockConnection{\" + \"connectionName='\" + connectionName + '\\'' + '}'; } //其他代码 略} 连接池 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465@Slf4jclass Pool{// 连接池大小 private final int poolSize;// 连接对象数组 private Connection[] connections;// 连接状态数组 0空闲 1表示繁忙 private AtomicIntegerArray states;// 构造方法初始化 public Pool(int poolSize) { this.poolSize = poolSize; this.connections = new Connection[poolSize]; this.states=new AtomicIntegerArray(new int[poolSize]); for (int i = 0; i &lt; poolSize; i++) {// 初始化所有连接 connections[i]=new MockConnection(\"连接\"+(i+1)); } } // 借连接 public Connection borrow() { while (true) { for (int i = 0; i &lt; poolSize; i++) {// 获取空闲连接// 使用cas操作 将该位置的连接更新为1 表示该位置的连接已被占用 if(states.compareAndSet(i, 0, 1)){// 获得连接 log.info(\"借到连接 {}\",connections[i]); return connections[i]; } }// 如果遍历完所有的连接池中的连接 还没有获得连接 synchronized (this){ try {// 等待连接 log.info(\"没有空闲连接，请等待...\"); this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } } /** * 归还连接 * @param connection 归还的连接对象 */ public void free(Connection connection){ for (int i = 0; i &lt; poolSize; i++) {// 找到归还的连接对象 if(connections[i]==connection){// 这里无需cas ,应为传过来的Conncetion对象已确定 states.set(i, 0); synchronized (this) { log.info(\"已释放该连接{}...\",connection); this.notify(); } break; } } }} 测试 1234567891011121314151617public class T3 { public static void main(String[] args) { Pool pool = new Pool(2); for (int i = 0; i &lt; 5; i++) { new Thread(()-&gt;{ Connection con = pool.borrow(); try { //模拟 随机1秒内的执行时间 Thread.sleep(new Random().nextInt(1000)); } catch (InterruptedException e) { e.printStackTrace(); } pool.free(con); },\"\"+(i+1)).start(); } }} 1234567891011121321:00:48.700 [3] INFO org.lc.flyweight_pattern.Pool - 没有空闲连接，请等待...21:00:48.700 [1] INFO org.lc.flyweight_pattern.Pool - 借到连接 MockConnection{connectionName='连接1'}21:00:48.703 [4] INFO org.lc.flyweight_pattern.Pool - 没有空闲连接，请等待...21:00:48.703 [5] INFO org.lc.flyweight_pattern.Pool - 没有空闲连接，请等待...21:00:48.700 [2] INFO org.lc.flyweight_pattern.Pool - 借到连接 MockConnection{connectionName='连接2'}21:00:49.183 [1] INFO org.lc.flyweight_pattern.Pool - 已释放该连接MockConnection{connectionName='连接1'}...21:00:49.183 [3] INFO org.lc.flyweight_pattern.Pool - 借到连接 MockConnection{connectionName='连接1'}21:00:49.668 [2] INFO org.lc.flyweight_pattern.Pool - 已释放该连接MockConnection{connectionName='连接2'}...21:00:49.669 [4] INFO org.lc.flyweight_pattern.Pool - 借到连接 MockConnection{connectionName='连接2'}21:00:49.748 [3] INFO org.lc.flyweight_pattern.Pool - 已释放该连接MockConnection{connectionName='连接1'}...21:00:49.748 [5] INFO org.lc.flyweight_pattern.Pool - 借到连接 MockConnection{connectionName='连接1'}21:00:49.752 [4] INFO org.lc.flyweight_pattern.Pool - 已释放该连接MockConnection{connectionName='连接2'}...21:00:50.464 [5] INFO org.lc.flyweight_pattern.Pool - 已释放该连接MockConnection{connectionName='连接1'}... 4、final原理①设置final变量的原理理解了 volatile 原理，再对比 ﬁnal 的实现就比较简单了 123public class TestFinal { final int a = 20; } 字节码: 12345670: aload_0 1: invokespecial #1 // Method java/lang/Object.\"&lt;init&gt;\":()V 4: aload_0 5: bipush 20 7: putfield #2 // Field a:I &lt;-- 写屏障 10: return 发现 ﬁnal 变量的赋值也会通过 putﬁeld 指令来完成，同样在这条指令之后也会加入写屏障，保证在其它线程读到 它的值时不会出现为 0 的情况 线程安全问题：当多线操作int a= 20时， a变量的赋值情况为先初始化0 ，然后再赋值20，再次过程中可能线程读到的为0，所以导致线程安全问题。加final修饰的变量可以解决此问题。 Ⅶ 、共享模型之工具1、自定义线程池 ThreadPool线程池：包含核心的线程数(总共的线程大小)，若任务的个数超过核心线程数的时候，会将多余的任务存入阻塞队列中的，等待线程池中的线程执行当前任务后，再从阻塞队列中获取。 Blocking Queue阻塞队列：存放多余任务的地方，由主线程提供任务，线程池消费阻塞队列中的任务。 ①自定义拒绝策略接口为阻塞队列之外的任务提供策略的抽象方法 12345678910111213/** * 拒绝策略接口 * 解决阻塞队列的任务满的时候，对多余的任务的处理的方式 */@FunctionalInterfaceinterface RejectPolicy&lt;T&gt;{ /** * 策略抽象 * @param queue 阻塞队列 * @param task 任务 */ void reject(BlockingQueue&lt;T&gt; queue,T task);} ②自定义阻塞任务队列123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164@Slf4jclass BlockingQueue&lt;T&gt;{// 1、任务队列 存放任务 双向队列 (先进先出) private Deque&lt;T&gt; queue=new ArrayDeque&lt;&gt;();// 2、锁 保证任务队列里的一个任务只有一个线程执行 private ReentrantLock lock=new ReentrantLock();// 3、生产者条件变量 保证队列满的时候，生产者不再生产任务 private Condition fullWaitSet=lock.newCondition();// 4、消费者条件变量 保证队列空的时候，线程不再消费任务 private Condition emptyWaitSet=lock.newCondition();// 5、容量 private int capcity; public BlockingQueue(int capcity) { this.capcity = capcity; } // 带超时的阻塞获取 消费者获取任务 public T pull(long timeout, TimeUnit unit) { lock.lock(); try { //我们传入的超时时间转换为纳秒 long nanos = unit.toNanos(timeout); //队列是否为空 while (queue.isEmpty()) { try { //返回的剩余时间小于0 证明已经超时 if (nanos &lt; 0) {// 无需等待直接返回 return null; }// 返回的值为：剩余等待的时间 = 设置的超时时间 - 已经等待的时间 nanos=emptyWaitSet.awaitNanos(nanos); } catch (InterruptedException e) { e.printStackTrace(); } } //不为空 开始获取任务 //从任务队列中移除第一个任务并返回该任务 T task=queue.removeFirst();// 唤醒生成者生产任务 fullWaitSet.signal(); return task; }finally { lock.unlock(); } }// 阻塞获取 消费者获取任务 public T take() { lock.lock(); try { //队列是否为空 while (queue.isEmpty()) { try { //为空等待 emptyWaitSet.await(); } catch (InterruptedException e) { e.printStackTrace(); } } //不为空 开始获取任务 //从任务队列中移除第一个任务并返回该任务 T task=queue.removeFirst();// 唤醒生成者生产任务 fullWaitSet.signal(); return task; }finally { lock.unlock(); } }// 阻塞添加 生成者生产任务 public void put(T task) { lock.lock(); try { //队列中的任务数是否和容量相等 while (queue.size() == capcity) {// 容量已满 阻塞 try { log.info(\"等待加入任务队列{}\",task); fullWaitSet.await(); } catch (InterruptedException e) { e.printStackTrace(); } } log.info(\"加入任务队列{}\",task); //没有满 添加任务 queue.addLast(task); //唤醒消费者线程 emptyWaitSet.signal(); }finally { lock.unlock(); } } // 带超时时间的阻塞添加 如果在指定的超时时间内该任务还没有进入队列则放弃执行该任务 public boolean offer(T task,long timeout,TimeUnit timeUnit) { lock.lock(); try { long nanos = timeUnit.toNanos(timeout); //队列中的任务数是否和容量相等 while (queue.size() == capcity) {// 容量已满 阻塞 try { if (nanos &lt; 0) { return false; } log.info(\"等待加入任务队列{}\",task); nanos=fullWaitSet.awaitNanos(nanos); } catch (InterruptedException e) { e.printStackTrace(); } } log.info(\"加入任务队列{}\",task); //没有满 添加任务 queue.addLast(task); //唤醒消费者线程 emptyWaitSet.signal(); return true; }finally { lock.unlock(); } } // 获取阻塞队列中任务数 public int size() { lock.lock(); try { return queue.size(); }finally { lock.unlock(); } } /** * 策略模式对阻塞队列已满的抽象处理 * @param rejectPolicy 策略对象 * @param task 任务 */ public void tryPut(RejectPolicy&lt;T&gt; rejectPolicy, T task) { lock.lock(); try {// 阻塞队列已满 if (queue.size() == capcity) { //具体策略由调用者实现 rejectPolicy.reject(this,task); }else{ //有空闲 log.info(\"加入任务队列{}\",task); //没有满 添加任务 queue.addLast(task); //唤醒消费者线程 emptyWaitSet.signal(); } }finally { lock.unlock(); } }} ③自定义线程池123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118/** * 线程池 */@Slf4jclass ThreadPool{// 任务队列 BlockingQueue&lt;Runnable&gt; taskQueue;// 线程集合 private HashSet&lt;Worker&gt; workes=new HashSet();// 核心的线程数(即线程池的线程总数) private int coreSize;// 获取任务的超时时间 private long timeout;// 时间单位 private TimeUnit timeUnit; /** * 拒绝策略对象 */ private RejectPolicy&lt;Runnable&gt; rejectPolicy; /** * 线程池中任务的创建 * @param task 任务对象 */ public void execute(Runnable task){// 当任务数没有超过coreSize时，直接交给Worker对象执行// 当任务数超过了的coreSize是，加入任务队列暂存// 当线程数还不够时，小于核心线程数时 该集合操作并不安全 需要加锁 synchronized (workes) { if (workes.size() &lt; coreSize) { //新建一个线程执行此任务 Worker worker = new Worker(task); log.info(\"新增worker{}, {}\",worker, task);// 加入到线程集合中 workes.add(worker);// 执行任务 线程中的run执行任务中的run方法 worker.start(); } else { // 队列已满 选择死等// taskQueue.put(task);// 策略模式的使用：具体实现由调用者选择。// 当阻塞队列任务满的时候，执行的策略有很多种// 1&gt;死等// 2&gt;超时等待// 3&gt;让调用者放弃任务执行// 4&gt;让调用者抛出异常// 5&gt;让调用者抛出异常// 这里我们通过策略模式来实现。 taskQueue.tryPut(rejectPolicy,task); } } } /** * 初始化线程池 * @param coreSize 核心线程数 * @param timeout 超时时间 * @param timeUnit 超时时间单位 * @param queueCapcity 阻塞队列容量 * @param rejectPolicy 拒绝策略的实现对象 */ public ThreadPool(int coreSize, long timeout, TimeUnit timeUnit,int queueCapcity,RejectPolicy&lt;Runnable&gt; rejectPolicy) { this.coreSize = coreSize; this.timeout = timeout; this.timeUnit = timeUnit; this.rejectPolicy=rejectPolicy; this.taskQueue=new BlockingQueue&lt;&gt;(queueCapcity); } /** * 自定义worker包装我们的线程类 */ class Worker extends Thread{ private Runnable task; public Worker(Runnable task) { this.task = task; } /** * worker具体的执行方法 */ @Override public void run() {// ①当task不为空，执行任务// ②当task执行完毕，再接着从任务队列获取任务并执行// 判断初始化的时候是否有任务 || 从阻塞队列中获取任务(执行全部任务)// while (task != null || (task=taskQueue.take())!=null) {// 获取阻塞队列中任务，使用带超时的获取方式。若等待一段时间，阻塞队列还没有任务则不等待 while (task != null || (task=taskQueue.pull(timeout, timeUnit))!=null) { try { log.info(\"正在执行...{}\",task); //相当于执行Runnable中的普通run方法 task.run(); } catch (Exception e) { e.printStackTrace(); }finally { //执行完毕后 将初始化的任务设为null task=null; } }// 所有阻塞的任务和初始化的任务都被执行完毕 移除线程 synchronized (workes) { log.info(\"worker被移除{}\",this); //移除当前线程 workes.remove(this); } } }} ④测试12345678910111213141516171819202122232425262728293031@Slf4jpublic class TestPool { public static void main(String[] args) { ThreadPool threadPool=new ThreadPool(1, 1000, TimeUnit.MILLISECONDS, 1,((queue,task)-&gt;{// 策略模式测试：// 1、实现 死等// queue.put(task);// 2、带超时的等待 设定的超时时间小于任务的执行时间则该任务放弃。// queue.offer(task, 1500, TimeUnit.MILLISECONDS);// 3、让调用者放弃任务执行// log.info(\"放弃任务{}\",task);// 4、让调用者抛出异常// throw new RuntimeException(\"任务执行失败\"+task);// 5、让调用者自己去执行任务 task.run(); }));// 当需要执行的任务超过阻塞队列的长度时 由调用者来实现我们的策略(即真正执行的方法) for (int i = 0; i &lt; 3; i++) { int j=i; threadPool.execute(()-&gt;{ try { //模拟执行很长 Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } log.info(\"{}\",j); }); } }} 1234567816:10:10.673 [main] INFO org.lc.Thread_pool.ThreadPool - 新增workerThread[Thread-0,5,main], org.lc.Thread_pool.TestPool$$Lambda$2/1030870354@22927a8116:10:10.676 [main] INFO org.lc.Thread_pool.BlockingQueue - 加入任务队列org.lc.Thread_pool.TestPool$$Lambda$2/1030870354@20fa23c116:10:10.676 [Thread-0] INFO org.lc.Thread_pool.ThreadPool - 正在执行...org.lc.Thread_pool.TestPool$$Lambda$2/1030870354@22927a8116:10:11.676 [main] INFO org.lc.Thread_pool.TestPool - 216:10:11.676 [Thread-0] INFO org.lc.Thread_pool.TestPool - 016:10:11.676 [Thread-0] INFO org.lc.Thread_pool.ThreadPool - 正在执行...org.lc.Thread_pool.TestPool$$Lambda$2/1030870354@20fa23c116:10:12.677 [Thread-0] INFO org.lc.Thread_pool.TestPool - 116:10:13.678 [Thread-0] INFO org.lc.Thread_pool.ThreadPool - worker被移除Thread[Thread-0,5,main] 2、ThreadPoolExecutorpackage java.util.concurrent; ①线程池状态ThreadPoolExecutor 使用 int 的高 3 位来表示线程池状态，低 29 位表示线程数量 从数字上比较，TERMINATED &gt; TIDYING &gt; STOP &gt; SHUTDOWN &gt; RUNNING（111 为负数） 这些信息存储在一个原子变量 ctl 中，目的是将线程池状态与线程个数合二为一，这样就可以用一次 cas 原子操作 进行赋值 12345// c 为旧值， ctlOf 返回结果为新值 ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c)))); // rs 为高 3 位代表线程池状态， wc 为低 29 位代表线程个数，ctl 是合并它们 private static int ctlOf(int rs, int wc) { return rs | wc; } ②构造方法12345678public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) {} corePoolSize 核心线程数目 （最多保留的线程数，核心线程不会超时） maximumPoolSize 最大线程数据(救急线程数+核心线程数) keepAliveTime 生存时间 - 针对救急线程 TimeUnit 时间单位 - 针对救急线程 workQueue 阻塞队列 threadFactory 线程工厂 - 可以为线程创建时起个好名字 handler 拒绝策略（救急线程用完，阻塞队列已满，会执行该策略） 工作方式： 线程池中刚开始还没有线程，当一个任务提交给线程池后，线程池会创建一个新任务来执行任务 当现场数达到corePoolSize并没有空闲线程，这时再加入任务，新加的任务会被加入workQqueue队列排队，直到有空闲的线程 如果队列选择了有界队列，那么任务超过了队列大小时，会创建 maximumPoolSize - corePoolSize 数目的线 程来救急（阻塞任务队列满的时候，会根据这个线程数目来创建救急线程执行多余的任务） 如果线程到达 maximumPoolSize 仍然有新任务这时会执行拒绝策略（救急线程也全部创建完毕，还有其他的任务，则会执行拒绝策略）。拒绝策略 jdk 提供了 4 种实现，其它 著名框架也提供了实现 AbortPolicy 让调用者抛出 RejectedExecutionException 异常，这是默认策略 CallerRunsPolicy 让调用者运行任务 DiscardPolicy 放弃本次任务 DiscardOldestPolicy 放弃队列中早的任务，本任务取而代之 ———————-其他框架实现————————— Dubbo 的实现，在抛出 RejectedExecutionException 异常之前会记录日志，并 dump 线程栈信息，方 便定位问题 Netty 的实现，是创建一个新线程来执行任务 ActiveMQ 的实现，带超时等待（60s）尝试放入队列，类似我们之前自定义的拒绝策略 PinPoint 的实现，它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略 当高峰过去后，超过corePoolSize 的救急线程如果一段时间没有任务做，需要结束节省资源，这个时间由 keepAliveTime 和 unit 来控制。 ③newFixedThreadPool1234567public class Executors { public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); }} 特点: 核心线程数 = 最大线程数（没有救急线程被创建），因此也无需超时时间 阻塞队列是无界的，可以放任意数量的任务 任务执行完毕后，核心线程不会主动结束。 使用场景：适用于任务量已知，相对耗时的任务 12345678910111213141516171819202122232425@Slf4jpublic class T1 { public static void main(String[] args) {// 创建两个核心线程数// ExecutorService pool = Executors.newFixedThreadPool(2);// 创建两个核心线程数 并自定义实现线程工厂 ExecutorService pool = Executors.newFixedThreadPool(2, new ThreadFactory() { private AtomicInteger t=new AtomicInteger(1); @Override public Thread newThread(Runnable r) {// 自定义线程名称 使用cas赋值自增名称 return new Thread(r,\"mypool_\"+t.getAndIncrement()); } }); pool.execute(()-&gt;{ log.info(\"1\"); }); pool.execute(()-&gt;{ log.info(\"2\"); }); pool.execute(()-&gt;{ log.info(\"3\"); }); }} 12319:46:08.701 [mypool_1] INFO org.lc.Thread_pool.T1 - 1 //线程1 执行任务119:46:08.701 [mypool_2] INFO org.lc.Thread_pool.T1 - 2 //线程2 执行任务219:46:08.704 [mypool_1] INFO org.lc.Thread_pool.T1 - 3 //线程1 执行任务3 ④newCachedThreadPool1234567public class Executors {public static ExecutorService newCachedThreadPool() { return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); }} 特定： 核心线程数是 0， 最大线程数是 Integer.MAX_VALUE，救急线程的空闲生存时间是 60s，意味着 全部都是救急线程（60s 后可以回收） 救急线程可以无限创建 队列采用了 SynchronousQueue 实现特点是，它没有容量，没有线程来取是放不进去的（一手交钱、一手交 货） 使用场景：整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完毕，空闲 1分钟后释放线 程。 适合任务数比较密集，但每个任务执行时间较短的情况 ⑤newSingleThreadExecutor12345678public class Executors {public static ExecutorService newSingleThreadExecutor() { return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())); }} 使用场景：希望多个任务排队执行。线程数固定为 1，任务数多于 1 时，会放入无界队列排队。任务执行完毕，这唯一的线程 也不会被释放。 区别： 自己创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，而线程池还会新建一 个线程，保证池的正常工作 Executors.newSingleThreadExecutor() 线程个数始终为1，不能修改 FinalizableDelegatedExecutorService 应用的是装饰器模式，只对外暴露了 ExecutorService 接口，因 此不能调用 ThreadPoolExecutor 中特有的方法，不能对核心线程数等参数进行修改。 Executors.newFixedThreadPool(1) 初始时为1，以后还可以修改 对外暴露的是 ThreadPoolExecutor 对象，可以强转后调用 setCorePoolSize 等方法进行修改 12345678910111213141516171819@Slf4jpublic class T3 { public static void main(String[] args) { ExecutorService pool = Executors.newSingleThreadExecutor(); pool.execute(()-&gt;{ int i=1/0; //出现异常的是否 当前线程会放弃该任务 log.info(\"task 1\"); }); pool.execute(()-&gt;{ log.info(\"task 2\"); }); pool.execute(()-&gt;{ log.info(\"task 3\"); }); }} 1234567Exception in thread \"pool-1-thread-1\" java.lang.ArithmeticException: / by zero at org.lc.Thread_pool.T3.lambda$main$0(T3.java:20) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748)22:50:39.111 [pool-1-thread-2] INFO org.lc.Thread_pool.T3 - task 222:50:39.113 [pool-1-thread-2] INFO org.lc.Thread_pool.T3 - task 3 ​","link":"/2020/07/24/thread/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"title":"github搜索技巧","text":"一、常用词含义介绍： watch 会持续收到该项目的动态 fork 复制某个项目到自己的giithub仓库中 star 可以理解为点赞 clone 将项目下载至本地 follow 关注你感兴趣的作者，会收到他们的动态 二、简单使用这里统一使用关键字’springboot‘，搜索的关键字忽略大小写 1、in用法①项目名称包含指定的关键字in:name springboot in:name ②项目描述包含指定的关键字in:descriptionspringboot in:description ③项目的readme文件中包含指定的关键字in:readme④组合使用查询关键字在: 项目名称或描述或readme文件中 springboot in:name,description,readme 2、stars/forks用法springboot stars:&gt;=5000 查询star大于等于5000的项目 springboot forks:&gt;=5000 查询fork大于等于5000的项目 springboot forks:2000..4000 stars:6000..8000 查询fork在2000-4000的 并且 stars在6000-8000的 springboot forks:5000..6000 stars:&gt;=1000 查询stars大于等于1000 并且 forks在5000-6000的 3、awesome使用搜索与springboot相关的项目 也叫awesome系列，一般是用来收集学习，工具，书籍类的资料。包括框架教程。这些项目也大多包含awesome关键字 awesome springboot 4、高亮显示代码①单号高亮显示地址后面紧跟 #L 数字 https://github.com/macrozheng/mall/blob/master/mall-common/src/main/java/com/macro/mall/common/api/CommonResult.java#L15 我们发现第15行高亮显示 ②多行高亮显示地址后面紧跟 #L 数字 - #L数字 https://github.com/macrozheng/mall/blob/master/mall-common/src/main/java/com/macro/mall/common/api/CommonResult.java#L15-L20 我们发现第15-20行高亮显示 5、项目内搜索在某个仓库中，按下按键 t 进入项目内搜索模式找到指定的文件 6、查找用户location: 所在地区 language: 语言 location:beijing language:java","link":"/2020/08/30/docker_linux_nginx_git_maven_gradle/github%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/"},{"title":"Gradle详解(待续)","text":"gradle简介​ 一个开源的项目自动化构建工具,建立在 Apache Ant 和 Apache Maven 概念的基础上,并引入了基于 Groovy 的特定领域语言(DSL),而不再使用 XML 形式管理构建脚本. DSL（Domain Specific Language）定义：针对某一领域，具有受限表达性的一种计算机程序设计语言。只针对一个领域做出来的简洁语言,而非为了通用而设计. gradle使用 Groovy 语言构建脚本,不再像 Maven 一样使用 XML Groovy /ˈɡruːvi/ Groovy与java对比1、什么是GrooovyGroovy 是基于Java虚拟机的一种敏捷的动态语言，它是一种成熟的OOP (面向对象)编程语言，既可以用于面向对象编程，又可以用作纯粹的脚本语言。使用该种语言不必编写过多的代码，同时又具有闭包和动态语言中的其他特性。 2、与 Java 相比,Groovy 的不同点或优势 Groovy 完全兼容 Java 语法,可做脚本也可做类 分号是可选的,一般不加分号,以换行作为结束 类,方法,字段都是公共的,没有访问权限限制 默认生成具名(名值对)参数构造器 key:value 字段不定义访问权限时,编译器自动给字段添加 getter/setter 方法 字段可使用点来获取,无访问权限的也可使用 getter/setter 来操作 方法可省略 return 关键字,自动检索最后一行的结果作为返回值 空值比较不会有NullPointerException异常抛出。 3、Groovy 的高级特性 assert 断言 : 可以用 assert 代替之前 Java 的断言语句 可选类型 : 可使用类 JavaScript 的弱类型,可使用 def 来表示任意类型 方法调用 : 调用带参方法时可省略括号. 字符串定义 : 字符串定义有三种方式,单引号,双引号,三个单引号 集合 API : 集合的定义和使用更加简单,API 和 Java 有所不同,但兼容 Java API 闭包 : Groovy 的一大特性,跟方法类似的代码块,可赋给一个变量也可以做为参数传递给一个方法, 像普通方法一样调用. 4、Groovy的安装下载地址： https://groovy.apache.org/download.html 配置bin目录下的环境变量 ,使用 groovy -v 查看是否安装成功 5、Groovy的使用与java的详细对比groovy 与 Java 比较： 1 JavaBean 的定义 1) 可省略分号 2) 可省略 getter/setter 3) 可省略 return 4) 无权限修饰符自动生成 getter/setter 5) 默认带有具名构造器 key:value 2 创建对象和操作字段 1) getter/setter 方式操作字段 2) 点方式调用字段 3) 调用自动生成的getter/setter方法 Student 1234567891011121314151617181920package org.lc.model//无需权限修饰符,默认使用publicclass Student{ //可省略分号 private String username //省略getter/setter(不生成),但是我们也可以使用点操作此字段 private String email //没有权限修饰符，自动生成getter/setter int age String getUsername() { //完成兼容java语法// System.out.println(\"java 语句！！！\") //可省略return关键字 username } void setUsername(String username) { this.username=username }} App 12345678910111213141516171819202122import org.lc.model.Student//以脚本的形式来书写代码//创建学生对象Student student=new Student()//使用getter/setterstudent.setUsername(\"张三\")println student.getUsername()//使用点的方式对字段赋值和获取值student.email = \"42@qq.com\"println student.email//调用无权限修饰符自动生成的getter/setterstudent.setAge(12)println student.getAge()//使用具名构造器为属性赋值Student student1=new Student(username: \"李四\",age: 20,email: \"123@qq.com\")print student1.username + student1.age + student1.email student2 弱类型语言，类型可以def声明 123456package org.lc.modelclass Student2 { def usename def email def age} 3 空值比较不抛出空指针异常4 变量的定义5 字符串的定义6 集合的定义7 闭包的定义闭包简单理解就是 { } 括起来的代码块,跟方法类似,可带参和不带参. 闭包可以赋给一个变量也可以当做参数传递给一个方法,在方法中调用闭包. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586println \"---------基本语法-------\"//变量的声明def name = '张三'age=20//比较null值不会抛出空指针//age=null//println age.equals(null) //true//调用带参数的方法可省略括号println(name+\":\"+age)println name+\":\"+age//断言//assert age==21println \"---------字符串的定义-------\"//定义普通字符串str1=\"grovvy\"//引用其他字符串str2=\"hello ${str1}\"//按照自定义格式输出字符串str3='''name:张三age:12'''println str1println str2println str3println \"---------List集合操作-------\"list=[\"李四\",\"8\",\"42119@qq.com\"]//添加元素list.add \"王五\"//添加元素list&lt;&lt;\"赵六\"//输出集合println list//获取集合类型println list.getClass() //class java.util.ArrayListprintln \"---------Map集合操作-------\"map = [\"username\": \"admin\", \"password\": \"123456\", age: 21]//添加元素map.put(\"email\",\"111@qq.com\")//添加元素map.address=\"wuhan\"//输出集合println map//获取集合类型println map.getClass() //class java.util.LinkedHashMapprintln \"---------闭包操作-------\"//不带参数的闭包c1={ println \"不带参数的闭包\"}//带参数的闭包c2={ val-&gt; println \"带参数:${val}\"}//方法定义必须加 def//定义方法形参时指定类型，接收不带参数的闭包方法def method1(Closure clo){// clo() //或者 clo.call()}//定义方法形参无指定类型，接受带参数闭包的方法def method2(p1){// p1(\"hello\")// 或者 p1.call(\"hello\")}//方法的调用method1 c1method2 c2//方法调用的时候直接定义闭包method1 {println \"直接定义不带参数的闭包\"}method2 {val-&gt;println \"直接定义带${val}的闭包\"} gradle安装及配置官网：https://gradle.org/releases/ 下载较慢 其他下载地址：https://www.moeinn.com/minipage/gradle/index.html 注意下载和idea对应的版本 下载后直接解压即可 配置path环境变量 查看安装后的版本 gradle -v 使用idea创建gradle项目","link":"/2020/08/30/docker_linux_nginx_git_maven_gradle/gradle%E8%AF%A6%E8%A7%A3/"},{"title":"Git详解","text":"一、Git和SVN的区别1、SVN​ SVN是集中式版本控制系统，版本库是集中放在中央服务器的，如果中央服务器挂了，那么我们的历史版本则只有当前的历史版本，即可能发生单点故障。 集中式的版本控制系统都有一个单一的集中管理的服务器，保存所有文件的修订版本，而协同工作的人们都通过客户端连到这台服务器，取出最新的文件或者提交更新。 优点：每个人都可以一定程度上看到项目中的其他人正在做些什么。而管理员也可以轻松掌控每个开发者的权限。 缺点：中央服务器的单点故障。 若是宕机一小时，那么在这一小时内，谁都无法提交更新、还原、对比等，也就无法协同工作。如果中央服务器的磁盘发生故障，并且没做过备份或者备份得不够及时的话，还会有丢失数据的风险。最坏的情况是彻底丢失整个项目的所有历史更改记录，被客户端提取出来的某些快照数据除外，但这样的话依然是个问题，你不能保证所有的数据都已经有人提取出来。 2、Git​ Git是分布式版本控制系统，每个机器都保存一份版本库，能够避免单点故障，如果中央服务器挂了，那么我们的本机也可以恢复历史版本。 在分布式版本控制系统中，客户端并不只提取最新版本的文件快照，而是把原始的代码仓库完整地镜像下来。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。这类系统都可以指定和若干不同的远端代码仓库进行交互。即此，你就可以在同一个项目中，分别和不同工作小组的人相互协作。你可以根据需要设定不同的协作流程。 优点 大部分操作在本地完成，不需要联网 完整性保证 尽可能添加数据而不是删除或修改数据 分支操作非常快捷流畅 与 Linux 命令全面兼容 二、Git结构(工作区&amp;暂存区&amp;本地库) 三、Git和代码托管中心1、局域网 GitLab 2、外网 GitHub 码云 四、本地库和远程库1、团队内部协作 2、跨团队协作 五、Git基本命令1、本地库初始化1)git init初始化本地仓库 2、设置签名1)形式 只是标识作用，无实际意义 用户名：tom Email 地址：：goodMorning@atguigu.com 2)作用 区分不同开发人员的身份 这里设置的签名和登录远程库(代码托管中心)的账号、密码没有任何关系。 3)命名 项目级别/仓库级别：仅在当前本地库范围内(当前.git下的项目)有效 git config user.name louchen 123- ```shell git config user.email 421192425@qq.com 查看签名保存位置 cat .git/config 1234567 - &lt;img src=&quot;http://img.louchen.top/2020/07/20200812113746.png&quot; style=&quot;zoom:80%;&quot; /&gt;- **系统用户级别：**登录当前操作系统的用户范围 - ```shell git config --global user.name louchen_glb git config --global user.email 421192425_glb@qq.com 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311 - **查看系统签名保存位置** - &lt;img src=&quot;http://img.louchen.top/2020/07/20200812114250.png&quot; style=&quot;zoom:80%;&quot; /&gt;- **级别优先级** - 就近原则：项目级别优先于系统用户级别，二者都有时采用项目级别 的签名 - 如果只有系统用户级别的签名，就以系统用户级别的签名为准 - 二者都没有不允许#### 3、基本操作##### 1)查看状态- `git status` 查看工作区、暂存区状态&lt;img src=&quot;http://img.louchen.top/2020/07/20200812120258.png&quot; style=&quot;zoom:80%;&quot; /&gt;##### 2)添加 将工作区的“新建/修改”添加到暂存区- `git add [filename] ` 添加指定文件- `git add .` 添加所有文件##### 3)提交 将暂存区的内容提交到本地库- `git commit -m &quot;commitmessage&quot; [filename] ` 提交指定文件到本地库- `git commit -m &quot;commitmessage&quot;` 提交所有文件都本地库##### 4)查看历史记录- **git log** - &lt;img src=&quot;http://img.louchen.top/2020/07/20200812122027.png&quot; style=&quot;zoom:80%;&quot; /&gt; - 多屏显示控制方式： 空格向下翻页， b 向上翻页， q 退出- **git log -pretty=oneline** - &lt;img src=&quot;http://img.louchen.top/2020/07/20200812145855.png&quot; style=&quot;zoom:80%;&quot; /&gt; - **git log --oneline** - 只能够显示过去的版本，不能显示回退后的未来的版本 - &lt;img src=&quot;http://img.louchen.top/2020/07/20200812150007.png&quot; style=&quot;zoom:80%;&quot; /&gt;- **git reflog** - &lt;img src=&quot;http://img.louchen.top/2020/07/20200812150034.png&quot; style=&quot;zoom:80%;&quot; /&gt; - HEAD@{移动到当前版本需要多少步}##### 5)版本的前进与后退- **本质** - HEAD指针对指定版本的指向 - &lt;img src=&quot;http://img.louchen.top/2020/07/20200812150034.png&quot; style=&quot;zoom:80%;&quot; /&gt;- **基于索引值操作[推荐]** - **git reset --hard [局部索引值]** - **git reset --hard c826707** - **版本的前进和后退都适用** - &lt;img src=&quot;http://img.louchen.top/2020/07/20200812151225.png&quot; style=&quot;zoom:80%;&quot; /&gt;- **使用^符号：只能后退** - **git reset --hard HEAD^** - 注：一个^表示后退一步，n 个表示后退 n 步 - **使用~符号：只能后退** - **git reset --hard HEAD~n** - 注：表示后退 n 步###### **①reset 命令的三个参数对比(版本回退后对应的状态)**`git reset --hard/soft/mixed [局部索引值]`- **--soft 参数** - 仅仅在本地库移动 HEAD 指针 - 相当于只add了并没有commit - &lt;img src=&quot;http://img.louchen.top/2020/07/20200812153112.png&quot; style=&quot;zoom: 67%;&quot; /&gt;- **--mixed 参数** - 在本地库移动 HEAD 指针 - 重置暂存区 - 没有add也没用commit - &lt;img src=&quot;http://img.louchen.top/2020/07/20200812153418.png&quot; style=&quot;zoom:67%;&quot; /&gt;- **--hard 参数** - 在本地库移动 HEAD 指针 - 重置暂存区 - 重置工作区 - 相当于版本会退回的add操作和commit都已经执行##### 6)找回删除的文件- 前提：删除前，文件存在时的状态提交到了本地库。 - 回退到文件存在的版本即可 ：**git reset --hard [回退的版本位置]** - **删除操作已经提交到本地库**：指针位置指向历史记录 - &lt;img src=&quot;http://img.louchen.top/2020/07/20200812154725.png&quot; style=&quot;zoom:80%;&quot; /&gt; - **删除操作尚未提交到本地库**：指针位置使用 HEAD - **git reset --hard HEAD** 回退到HEAD指针的位置(文件存在的位置) - &lt;img src=&quot;http://img.louchen.top/2020/07/20200812155619.png&quot; style=&quot;zoom:80%;&quot; /&gt; ##### 7)文件的比较- **git diff [文件名]** - 将工作区中的文件和暂存区进行比较 - **git diff [本地库中历史版本] [文件名]** - 例如： `git diff HEAD^ a.txt` 和HEAD指向的上一个版本比较 - 将工作区中的文件和本地库历史记录比较 - 不带文件名比较所有文件#### 4、分支管理##### 1)创建分支**git branch [分支名称]**##### 2)查看所有分支**git branch -v**&lt;img src=&quot;http://img.louchen.top/2020/07/20200812162607.png&quot; style=&quot;zoom:80%;&quot; /&gt;##### 3)切换分支**git checkout [分支名称]**##### 4)创建并切换分支**git checkout -b [分支名称]**##### 5)合并分支当前存在分支`hot_fix`和分支`master`, 存在文件`a.txt`- ①切换到修改的分支`hot_fix`，对文件进行修改操作，并add和commit - &lt;img src=&quot;http://img.louchen.top/2020/07/20200812163446.png&quot; style=&quot;zoom:80%;&quot; /&gt;- ②切换到需要合并的分支`master`上(将`hot_fix`分支修改的文件加到`master`分支上) - **git merge [修改内容的分支]** - &lt;img src=&quot;http://img.louchen.top/2020/07/20200812163645.png&quot; style=&quot;zoom:80%;&quot; /&gt;##### 6)解决冲突**注意：**两个分支必须都进行修改和提交后，合并才有效，否则会直接覆盖当前的分支内容- ①分支`hot_fix`对`a.txt`内容进行修改，add和commit - &lt;img src=&quot;http://img.louchen.top/2020/07/20200812175434.png&quot; style=&quot;zoom:80%;&quot; /&gt;- ②切换到主分支`master`对`a.txt`内容进行修改，add和commit - &lt;img src=&quot;http://img.louchen.top/2020/07/20200812175405.png&quot; style=&quot;zoom:80%;&quot; /&gt;- ③切换到`hot_fix`分支，合并`master`分支 - **git merge master** - 产生冲突 - &lt;img src=&quot;http://img.louchen.top/2020/07/20200812181623.png&quot; style=&quot;zoom:80%;&quot; /&gt;- ④到文件中解决冲突再合并 - `git add .` 加入到暂存区 - `git commit -m 'message' `提交### 六、远程库创建#### 1、创建远程库&lt;img src=&quot;http://img.louchen.top/2020/07/20200812202459.png&quot; style=&quot;zoom:80%;&quot; /&gt;#### 2、初始化本地库&lt;img src=&quot;http://img.louchen.top/2020/07/image-20200812202655101.png&quot; style=&quot;zoom:80%;&quot; /&gt;#### 3、将本地库和远程库管理**git remote -v** 查看远程库地址- **git remote add [别名] [远程地址]** - **git remote add origin https://github.com/RoyalNeverG/testgit.git** 设置远程库地址并起别名为`origin`- **git push [别名] [分支名]** - **git push origin master** 推送到远端地址别名为`origin`的`master`分支上(远端自动创建`master`分支)&lt;img src=&quot;http://img.louchen.top/2020/07/20200812203315.png&quot; style=&quot;zoom:80%;&quot; /&gt;#### 4、克隆操作**git clone [url]**&lt;img src=&quot;http://img.louchen.top/2020/07/20200812203739.png&quot; style=&quot;zoom:80%;&quot; /&gt;**克隆会直接帮我们完成以下操作：**- 完整的把远程库下载到本地 - 创建 origin 远程地址别名 - 初始化本地库#### 5、团队成员邀请当我们另一个小伙伴clone下来的项目时无法推送的，只能访问。需要该仓库创建人的邀请。&lt;img src=&quot;http://img.louchen.top/2020/07/20200812210047.png&quot; style=&quot;zoom:80%;&quot; /&gt;若在本机需要删除之前推送过的github的账户和密码，可在凭据管理器中删除&lt;img src=&quot;http://img.louchen.top/2020/07/20200812210208.png&quot; style=&quot;zoom:80%;&quot; /&gt;##### 1)github邀请成员可推送&lt;img src=&quot;http://img.louchen.top/2020/07/20200812210621.png&quot; style=&quot;zoom: 67%;&quot; /&gt;&lt;img src=&quot;http://img.louchen.top/2020/07/20200812211220.png&quot; style=&quot;zoom:80%;&quot; /&gt;- 被邀请人同意邀请&lt;img src=&quot;http://img.louchen.top/2020/07/20200812212220.png&quot; style=&quot;zoom:80%;&quot; /&gt;- 我们可以看到该成员已经加入该仓库的管理&lt;img src=&quot;http://img.louchen.top/2020/07/20200812212637.png&quot; style=&quot;zoom:80%;&quot; /&gt;****#### 6、拉取`git pull`=`git fetch`+`git merge `` git fetch [远程库地址别名] [远程分支名] ``git merge [远程库地址别名/远程分支名] ``git pull [远程库地址别名] [远程分支名]`#### 7、冲突解决- 如果不是基于 GitHub 远程库的最新版所做的修改，不能推送，必须先拉取。 - 即我们提交代码前，最好先 `git pull`拉取最新的代码- 拉取下来后如果进入冲突状态，则按照“分支冲突解决”操作解决即可。 #### 8、使用SSH免密推送`ssh-keygen -t rsa -C [github账户]`- 以下操作默认即可，直接回车&lt;img src=&quot;http://img.louchen.top/2020/07/20200812221608.png&quot; style=&quot;zoom:80%;&quot; /&gt;&lt;img src=&quot;http://img.louchen.top/2020/07/20200812221858.png&quot; style=&quot;zoom:80%;&quot; /&gt;- 赋值生成的秘钥到github中&lt;img src=&quot;http://img.louchen.top/2020/07/20200812222026.png&quot; style=&quot;zoom:80%;&quot; /&gt;- 项目使用&lt;img src=&quot;http://img.louchen.top/2020/07/20200812222347.png&quot; style=&quot;zoom:80%;&quot; /&gt;### 七、IDEA使用Git#### 1、初始化本地版本库![](http://img.louchen.top/2020/07/20200813111937.png)&lt;img src=&quot;http://img.louchen.top/2020/07/20200813112117.png&quot; style=&quot;zoom:80%;&quot; /&gt;#### 2、创建ignore文件两种方式①通过插件ignore在项目根目录下生成或手动创建 .gitignore文件②创建.git/info/exclude文件，并打开文件&lt;img src=&quot;http://img.louchen.top/2020/07/20200813114417.png&quot; style=&quot;zoom:80%;&quot; /&gt;```java# git ls-files --others --exclude-from=.git/info/exclude# Lines that start with '#' are comments.# For a project mostly in C, the following would be a good set of# exclude patterns (uncomment them if you want to use them):# *.[oa]# *~#忽略的文件.idea*.iml 3、版本的回退注意：在idea中只能进行版本的回退，若回退之后的版本想前进，那么只能用命令行操作 ①第一种方式：直接回退 查看历史版本，并选择回退的版本 回退成功 ②第二种方式：使用版本号回退 回退成功 4、创建和合并分支ctrl+shift+` 打开Git Branches界面 ①新建分支 在dev分支上新增一些内容并提交 ②切换到master分支，并合并dev分支 我们发现在dev分支提交的一些内容已经合并到master分支上 5、合并解决冲突1)主干分支添加和提交的内容 2)dev分支添加和提交的内容 3)切换到master主分支，合并dev分支 我们发现在第13行master分支和dev分支有不同的内容，合并即产生冲突 选择全部保留 查看历史结果 6、关联github远程仓库1)创建远程仓库并赋值仓库的地址 2)项目推送远端并关联地址 推送 若推送没有账户，则添加账户 ①添加github账户 ②添加gitee账户 搜索安装gitee插件 推送成功 7、拉取并解决冲突1)修改远程仓库内容并提交保存 2)本地仓库内容(需要更新一些内容后提交再合并其他分支，否则会覆盖) 拉取(手动merge) ①第一种方式 ②第二种方式 解决本地master分支合并远端的origin的master分支的冲突 手动解决冲突 将合并的后的代码提交到远端 本地内容 远端内容 注意：merge/pull/push的覆盖问题 git是比较时间戳的， 即某一个分支commit提交后，该分支push/pull/merge到其他比该commit提交时间晚的分支那么内容都会直接覆盖，不会产生冲突。 结论： 新的分支commit提交后的push/pull/merge的操作内容总是会覆盖旧的分支的内容。不会产生任何冲突 旧的分支commit提交后的push/pull/merge的操作的内容到新的提交的分支的内容，若有冲突，则会产生冲突 即我们在push/pull/merge操作时，最好重新commit提交当前的分支，让其当前分支为最新的提交 8、克隆项目 9、SSH免密登录 找到在上述6.8章生成的ssh公钥 添加ssh公钥到github/gitee上","link":"/2020/08/30/docker_linux_nginx_git_maven_gradle/Git%E8%AF%A6%E8%A7%A3/"},{"title":"Nginx详解","text":"一、Nginx简介1、Nginx概述Nginx (“engine x”) 是一个高性能的 HTTP 和反向代理服务器,特点是占有内存少，并发能 力强，事实上nginx的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用nginx 网站用户有：百度、京东、新浪、网易、腾讯、淘宝等 2、Nginx作为Web服务器Nginx 可以作为静态页面的 web 服务器，同时还支持 CGI 协议的动态语言，比如 perl、php 等。但是不支持 java。Java 程序只能通过与 tomcat 配合完成。Nginx 专为性能优化而开发， 性能是其最重要的考量,实现上非常注重效率 ，能经受高负载的考验,有报告表明能支持高 达 50,000 个并发连接数 3、正向代理与反向代理1)正向代理如果把局域网外的 Internet 想象成一个巨大的资源库，则局域网中的客户端要访 问 Internet，则需要通过代理服务器来访问，这种代理服务就称为正向代理。已知真实服务器 IP 地址 例如上图，我们要直接访问Google是不行的，我们需要一个代理服务器来代理我们的客户端去访问Google，所以我们的需要在客户端配置代理服务器，当我们在浏览器访问www.google.com时候，实际上是代理服务器代替客户端去访问，客户端知道真实服务器即Google的ip地址。 2)反向代理反向代理，其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只 需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返 回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器 地址，隐藏了真实服务器 IP 地址。 例如上图，我们要访问www.louchen.top，我们无需知道真实服务器的地址，代理服务器代理我们的真实服务器，所有我们的客户端无需配置代理服务器，客户端直接访问代理服务器即可，根据客户端的请求，代理服务器会更具不同的代理规则转发到指定真实的服务器 4、负载均衡和动静分离1)负载均衡增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们 所说的负载均衡 在这样的架构中 ， Nginx 所代表的角色叫做负载均衡服务器或者反向代理服务器，所有请求首先到达 Nginx 上，再由 Nginx 根据提前配置好的转发规则，将客户端发来的请求转发到某一个 Tomcat 上去 2)动静分离为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速 度。降低原来单个服务器的压力。 二、Nginx基本命令和配置文件1、基本命令详解安装过程请参考：https://blog.csdn.net/qq_37345604/article/details/90034424 使用 nginx命令前：必须进入nginx的目录，否则执行命令需要加 全路径 即 /usr/local/nginx/sbin ./nginx -v 或 /usr/local/nginx/sbin/nginx -v 查看nginx版本号 ./ 代表当前目录，当要执行本目录下的命令时，需要加 ./ ./nginx 或 /usr/local/nginx/sbin/nginx 启动nginx ./nginx -s stop 或 */usr/local/nginx/sbin/nginx -s stop * 停止nginx ./nginx -s reload 或 /usr/local/nginx/sbin/nginx -s reload 重新加载nginx 常用于修改配置文件后使用 ①若出现nginx: [error] open() “/usr/local/nginx/logs/nginx.pid” failed (2: No such file or directory) 报错 /usr/local/nginx/sbin/nginx -c /usr/local/nginx/conf/nginx.conf ②若出现nginx: [emerg] bind() to 0.0.0.0:80 failed (98: Address already in use) 报错 若使用 ps -ef | grep nginx 查看nginx是否启动。若启动 netstat -lnp | grep 80，查看80端口是否占用，若占用则kill掉，再执行①，然后重启nginx ./nginx -t 或 /usr/local/nginx/sbin/nginx -t 验证nginx配置文件是否正确 2、Nginx的配置文件nginx 安装目录下，其默认的配置文件都放在这个目录的 conf 目录下，而主配置文件 nginx.conf 也在其中，后续对 nginx 的使用基本上都是对此配置文件进行相应的修改 /usr/local/nginx/conf 详细配置文件123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#user nobody;worker_processes 1;#error_log logs/error.log;#error_log logs/error.log notice;#error_log logs/error.log info;#pid logs/nginx.pid;events { worker_connections 1024;}http { include mime.types; default_type application/octet-stream; #log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' # '$status $body_bytes_sent \"$http_referer\" ' # '\"$http_user_agent\" \"$http_x_forwarded_for\"'; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; upstream myserver { server 127.0.0.1:8080; server 127.0.0.1:8081; } server { listen 80; server_name 192.168.86.22; #charset koi8-r; #access_log logs/host.access.log main; location / { root html; #proxy_pass http://127.0.0.1:8080; proxy_pass http://myserver; index index.html index.htm; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ { # proxy_pass http://127.0.0.1; #} # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ { # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #} # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\\.ht { # deny all; #} } # another virtual host using mix of IP-, name-, and port-based configuration # #server { # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / { # root html; # index index.html index.htm; # } #} server { listen 9001; server_name 192.168.86.22; location ~ /a/ { proxy_pass http://127.0.0.1:8080; } location ~ /b/ { proxy_pass http://127.0.0.1:8081; } } # HTTPS server # #server { # listen 443 ssl; # server_name localhost; # ssl_certificate cert.pem; # ssl_certificate_key cert.key; # ssl_session_cache shared:SSL:1m; # ssl_session_timeout 5m; # ssl_ciphers HIGH:!aNULL:!MD5; # ssl_prefer_server_ciphers on; # location / { # root html; # index index.html index.htm; # } #}} 1)全局块从配置文件开始到 events 块之间的内容，主要会设置一些影响nginx 服务器整体运行的配置指令，主要包括配 置运行 Nginx 服务器的用户（组）、允许生成的 worker process 数，进程 PID 存放路径、日志存放路径和类型以 及配置文件的引入等。 比如上面第一行配置的： 1worker_processes 1; 这是 Nginx 服务器并发处理服务的关键配置，worker_processes 值越大，可以支持的并发处理量也越多，但是 会受到硬件、软件等设备的制约 2)events块123events { worker_connections 1024;} ​ events 块涉及的指令主要影响 Nginx 服务器与用户的网络连接，常用的设置包括是否开启对多 work process 下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个 word process 可以同时支持的最大连接数等。​ 上述例子就表示每个 work process 支持的最大连接数为 1024.​ 这部分的配置对 Nginx 的性能影响较大，在实际中应该灵活配置。 3)http块12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879http { include mime.types; default_type application/octet-stream; #log_format main '$remote_addr - $remote_user [$time_local] \"$request\" ' # '$status $body_bytes_sent \"$http_referer\" ' # '\"$http_user_agent\" \"$http_x_forwarded_for\"'; #access_log logs/access.log main; sendfile on; #tcp_nopush on; #keepalive_timeout 0; keepalive_timeout 65; #gzip on; server { listen 80; server_name 192.168.86.22; #charset koi8-r; #access_log logs/host.access.log main; location / { root html; proxy_pass http://127.0.0.1:8080; index index.html index.htm; } #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } # proxy the PHP scripts to Apache listening on 127.0.0.1:80 # #location ~ \\.php$ { # proxy_pass http://127.0.0.1; #} # pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000 # #location ~ \\.php$ { # root html; # fastcgi_pass 127.0.0.1:9000; # fastcgi_index index.php; # fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; # include fastcgi_params; #} # deny access to .htaccess files, if Apache's document root # concurs with nginx's one # #location ~ /\\.ht { # deny all; #} } # another virtual host using mix of IP-, name-, and port-based configuration # #server { # listen 8000; # listen somename:8080; # server_name somename alias another.alias; # location / { # root html; # index index.html index.htm; # } #}} 这算是 Nginx 服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。 需要注意的是：http 块也可以包括 http全局块、server 块。 ①http 全局块http全局块配置的指令包括文件引入、MIME-TYPE 定义、日志自定义、连接超时时间、单链接请求数上限等。 ②server 块 这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了 节省互联网服务器硬件成本。 每个 http 块可以包括多个 server 块，而每个 server 块就相当于一个虚拟主机。 而每个 server 块也分为全局 server 块，以及可以同时包含多个 locaton 块。 全局 server 块 最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或IP配置。 location 块 一个 server 块可以配置多个 location 块。 这块的主要作用是基于 Nginx 服务器接收到的请求字符串（例如 server_name/uri-string），对虚拟主机名称 （也可以是IP 别名）之外的字符串（例如 前面的 /uri-string）进行匹配，对特定的请求进行处理。地址定向、数据缓 存和应答控制等功能，还有许多第三方模块的配置也在这里进行。 4)location指令 location 指令说明 该指令用于匹配 URL。 语法如下： location [= | ~ | ~* | ^~] uri { } 123456789101112131415161718192021222324252627282930313233343536373839 1、= ：用于不含正则表达式的 uri 前，要求请求字符串与 uri 严格匹配，如果匹配 成功，就停止继续向下搜索并立即处理该请求。 2、~：用于表示 uri 包含正则表达式，并且区分大小写。 3、~\\*：用于表示 uri 包含正则表达式，并且不区分大小写。 4、^~：用于不含正则表达式的 uri 前，要求 Nginx 服务器找到标识 uri 和请求字 符串匹配度最高的 location 后，立即使用此 location 处理请求，而不再使用 location 块中的正则 uri 和请求字符串做匹配。 注意：如果 uri 包含正则表达式，则必须要有 ~ 或者 ~* 标识。 ### 三、Nginx配置实例-反向代理#### 1、nginx访问tomcat实例**1)域名模拟访问代理服务器**首先在主机配置文件中模拟我们的域名访问`C:\\Windows\\System32\\drivers\\etc` , 在hosts文件中添加内容： 192.168.86.22 www.test.com ，表示我们使用 www.test.com在本机进行域名访问时，会找到我们代理服务器192.168.86.22的地址我们服务器启动tomcat,并开放8080端口，访问时 www.test.com:8080 即访问到tomcat地址**2、修改nginx的nginx.conf配置文件**&lt;img src=&quot;http://img.louchen.top/2020/07/20200825231720.png&quot; style=&quot;zoom:80%;&quot; /&gt;- 重启nginx- 访问www.test.com，我们发现在本机通过域名解析相当于访问 192.168.86.22地址，nginx监听到该地址的被访问，将请求转发到**proxy_pass**的指定地址，该地址可以为服务器上的应用地址，使用127.0.0.1代表服务上的地址&lt;img src=&quot;http://img.louchen.top/2020/07/20200825232438.png&quot; style=&quot;zoom:80%;&quot; /&gt;#### 2、nginx访问多个tomcat实例- 在两个tomcat实例中，分别在webapp目录下，创建 - 8080端口 a/hello.html 内容为： - ```html &lt;h1&gt; 8080 ！！&lt;h1&gt; 8081端口 b/hello.html 内容为： &lt;h1&gt; 8081 ！！&lt;h1&gt; 1234567891011121314151617181920212223实际访问该页面的地址：`192.168.86.22:8080/a/hello.html `和 `192.168.86.22:8081/b/hello.html`- 修改nginx文件&lt;img src=&quot;http://img.louchen.top/2020/07/20200826001326.png&quot; style=&quot;zoom:80%;&quot; /&gt;- 重启nginx- 当我们访问 `192.168.86.22:9001/a/hello.html` 地址 - &lt;img src=&quot;http://img.louchen.top/2020/07/20200826001521.png&quot; style=&quot;zoom:80%;&quot; /&gt;- 当我们访问 `192.168.86.22:9001/b/hello.html` 地址 - &lt;img src=&quot;http://img.louchen.top/2020/07/20200826001606.png&quot; style=&quot;zoom:80%;&quot; /&gt;### 四、Nginx配置负载均衡#### 1、nginx配置负载均衡- 准备两个tomcat服务器，端口分别为8080 和 8081，在tomcat服务器下的webapp下分别创建下列文件 - 8080 ` a/hello.html `内容为 - ```html &lt;h1&gt; 8080!&lt;h1&gt; 8081 a/hello.html内容为 &lt;h1&gt; 8081!!!&lt;h1&gt; 123456789101112131415161718192021222324252627282930313233343536373839- 修改nginx.conf配置文件 - 配置**上游服务器** &lt;img src=&quot;http://img.louchen.top/2020/07/20200826110259.png&quot; style=&quot;zoom:80%;&quot; /&gt; - 配置访问的代理服务器地址 &lt;img src=&quot;http://img.louchen.top/2020/07/20200826110456.png&quot; style=&quot;zoom:80%;&quot; /&gt;- 重启nginx- 多次访问 `192.168.86.22/a/hello.html` - 我们发现每次访问都均匀将请求分配到配置的上游服务器中 - &lt;img src=&quot;http://img.louchen.top/2020/07/20200826110638.png&quot; style=&quot;zoom:80%;&quot; /&gt; - 再次访问 &lt;img src=&quot;http://img.louchen.top/2020/07/20200826110650.png&quot; style=&quot;zoom:80%;&quot; /&gt;#### 2、负载均衡策略##### 1)轮询(默认)每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器 down 掉，能自动剔除。 ##### 2)weightweight 代表权重,默认为 1,权重越高被分配的客户端越多 指定轮询几率，weight 和访问比率成正比，用于后端服务器性能不均的情况```shellupstream server_pool { server 192.168.5.21 weight=10; server 192.168.5.22 weight=10; } 3)ip_hash每个请求按访问 ip 的 hash 结果分配，这样每个访客固定访问一个后端服务器，可以解决 session 的问题。 12345upstream server_pool { ip_hash; server 192.168.5.21:80; server 192.168.5.22:80; } 4)fair(第三方)按后端服务器的响应时间来分配请求，响应时间短的优先分配。 12345upstream server_pool { server 192.168.5.21:80; server 192.168.5.22:80; fair; } 五、Nginx动静分离Nginx 动静分离简单来说就是把动态跟静态请求分开，不能理解成只是单纯的把动态页面和 静态页面物理分离。严格意义上说应该是动态请求跟静态请求分开，可以理解成使用 Nginx 处理静态页面，Tomcat 处理动态页面。动静分离从目前实现角度来讲大致分为两种， 一种是纯粹把静态文件独立成单独的域名，放在独立的服务器上，也是目前主流推崇的方案； 另外一种方法就是动态跟静态文件混合在一起发布，通过 nginx 来分开。 通过 location 指定不同的后缀名实现不同的请求转发。通过 expires 参数设置，可以使 浏览器缓存过期时间，减少与服务器之前的请求和流量。具体 Expires 定义：是给一个资 源设定一个过期时间，也就是说无需去服务端验证，直接通过浏览器自身确认是否过期即可， 所以不会产生额外的流量。此种方法非常适合不经常变动的资源。（如果经常更新的文件， 不建议使用 Expires 来缓存） 在服务器中添加如下目录和文件 /opt/nginx/data/conent hello.html 文件，内容为 &lt;h1&gt;test page!!&lt;/h1&gt; 1234567891011121314151617181920212223242526 - `/opt/nginx/data/images` - `1.jpg` 文件- 修改nginx.conf配置文件 ```shell server { listen 80; server_name 192.168.86.22; #charset koi8-r; #access_log logs/host.access.log main; location /content/ { root /opt/nginx/data/; index index.html index.htm; } location /images/ { root /opt/nginx/data/; autoindex on; } } 其中，autondex on 表示访问显示目录结构，例如 http://192.168.86.22/images/ 重启nginx 页面访问测试 访问服务器/opt/nginx/data/content/下的文件 , http://192.168.86.22/content/hello.html 访问服务器 /opt/nginx/data/images/下的文件，http://192.168.86.22/images/1.jpg 六、Nginx高可用集群 准备两台服务器192.168.86.22 192.168.86.23(不同ip即可)分别安装nginx yum install keepalived -y 安装keepalived 安装后会在 /etc/keepalived/ 目录下生成 keepalived.conf 配置文件","link":"/2020/08/30/docker_linux_nginx_git_maven_gradle/Nginx%E8%AF%A6%E8%A7%A3/"},{"title":"Maven详解","text":"一、Maven构建项目主要步骤①清理：删除以前的编译结果，为重新编译做好准备。 ②编译：将 Java 源程序编译为字节码文件。 ③测试：针对项目中的关键点进行测试，确保项目在迭代开发过程中关键点的正确性。 ④报告：在每一次测试后以标准的格式记录和展示测试结果。 ⑤打包：将一个包含诸多文件的工程封装为一个压缩文件用于安装或部署。Java 工程对应 jar 包，Web 工程对应 war 包。 ⑥安装：在 Maven 环境下特指将打包的结果——jar 包或 war 包安装到本地仓库中。 ⑦部署：将打包的结果部署到远程仓库或将 war 包部署到服务器上运行。 二、Maven仓库/插件镜像配置 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;settings xmlns=\"http://maven.apache.org/SETTINGS/1.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/SETTINGS/1.0.0 http://maven.apache.org/xsd/settings-1.0.0.xsd\"&gt; &lt;!--本地仓库路径--&gt; &lt;localRepository&gt;D:/maven-repository&lt;/localRepository&gt; &lt;mirrors&gt; &lt;!-- 阿里镜像及其他插件镜像的配置 --&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;central&lt;/id&gt; &lt;name&gt;Maven Repository Switchboard&lt;/name&gt; &lt;url&gt;http://repo1.maven.org/maven2/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;repo2&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://repo2.maven.org/maven2/&lt;/url&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;ibiblio&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://mirrors.ibiblio.org/pub/mirrors/maven2/&lt;/url&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;jboss-public-repository-group&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;JBoss Public Repository Group&lt;/name&gt; &lt;url&gt;http://repository.jboss.org/nexus/content/groups/public&lt;/url&gt; &lt;/mirror&gt; &lt;mirror&gt; &lt;id&gt;google-maven-central&lt;/id&gt; &lt;name&gt;Google Maven Central&lt;/name&gt; &lt;url&gt;https://maven-central.storage.googleapis.com &lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;!-- 中央仓库在中国的镜像 --&gt; &lt;mirror&gt; &lt;id&gt;maven.net.cn&lt;/id&gt; &lt;name&gt;oneof the central mirrors in china&lt;/name&gt; &lt;url&gt;http://maven.net.cn/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; &lt;/mirrors&gt; &lt;profiles&gt; &lt;!--编译配置--&gt; &lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; &lt;/profile&gt; &lt;/profiles&gt; 三、Maven基本命令1、查看maven版本mvn -v 2、生成项目编译后的文件mvn complie 3、生成编译后的测试文件mvn test-compile 4、打包到当前项目下mvn package 5、打包到当前项目和本地仓库mvn install 当前项目下 本地仓库下 5、删除当前项目下target的所有文件mvn clean 6、部署到私服(自动部署)mvn deploy 四、Maven坐标(gav)使用如下三个向量在 Maven 的仓库中唯一的确定一个 Maven 工程。 groupid：公司或组织的域名倒序+当前项目名称 artifactId：当前项目的模块名称 version：当前模块的版本 123&lt;groupId&gt;org.lc&lt;/groupId&gt;&lt;artifactId&gt;firstproject&lt;/artifactId&gt;&lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; 当我们执行mvn install生成项目的jar包后存储在本地仓库的路径形式为： 本地仓库路径/{groupId}/{artifactId}/{version}/{artifactId}-{version}.jar 本地仓库路径/org/lc/firstproject/1.0-SNAPSHOT/firstproject-1.0-SNAPSHOT.jar 五、Maven依赖管理1、自定义jar并被其他项目使用1)创建maven工程，写完功能后执行mvn install打包到本地仓库中 要打包的jar的pom 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;secondproject&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;&lt;/project&gt; 在本地仓库中生成的jar 2)引用在本地仓库中的jar进行使用 1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;firstproject&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;!--和jar创建的时候的pom的groupId，artifactId，version一致--&gt; &lt;dependency&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;secondproject&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2、依赖范围scope1)compile 在主程序有效 测试程序有效 并参与部署(打包) 2)test只在test阶段有依赖关系，例如junit 在主程序无效 测试程序有效 不参与部署(打包) 3)provided在runtime时并不输出依赖关系而是由容器提供，例如web war包都不包括servlet-api.jar，而是由tomcat等容器来提供 在主程序有效 测试程序有效 不参与部署(打包) 4)runtime编译的时候是用不到的，但是在运行的时候会用到，如在连接mysql中的JDBC 在主程序(编译)无效 测试程序有效 并参与部署(打包) 5)systemsystem范围依赖与provide类似，但是必须显示的提供一个对于本地系统中jar文件的路径。一般不推荐使用。 依赖范围 主程序运行(编译) 测试程序 运行时(打包) 例子 compile √ √ √ spring-core test √ junit provided √ √ servlet-api(由打包后的tomcat容器提供) runtime √ √ JDBC驱动 system √ √ 本地的，Maven之外地的仓库 3、依赖的传递性默认的依赖包括compile具有传递性，非compile的依赖没有传递性 A 依赖 B，B 依赖 C，A 能否使用 C 呢？那要看 B 依赖 C 的范围是不是 compile，如果是则可用，否则不 可用。 4、依赖的排除在mysql-connector-java的工程下的pom.xml中 1234567&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.protobuf&lt;/groupId&gt; &lt;artifactId&gt;protobuf-java&lt;/artifactId&gt; &lt;version&gt;3.6.1&lt;/version&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 排除我们当前工程下的mysql-connector-java中的protobuf-java依赖 123456789101112&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.20&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;artifactId&gt;protobuf-java&lt;/artifactId&gt; &lt;groupId&gt;com.google.protobuf&lt;/groupId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; 六、Maven执行的生命周期https://www.cnblogs.com/huxinga/p/6740897.html ​ Maven的生命周期就是对所有的构建过程进行抽象和统一。包含了项目的清理、初始化、编译、测试、打包、集成测试、验证、部署和站点生成等几乎所有的构建步骤。 ​ Maven的生命周期是抽象的，即生命周期不做任何实际的工作，实际任务由插件完成，类似于设计模式中的模板方法。 1、三套独立的生命周期分别是clean、default和site。每个生命周期包含一些阶段（phase），阶段是有顺序的，后面的阶段依赖于前面的阶段。 *1)clean *清理项目 pre-clean：执行清理前需要完成的工作 clean：清理上一次构建生成的文件 post-clean：执行清理后需要完成的工作 2)default生命周期：构建项目 validate：验证工程是否正确，所有需要的资源是否可用。 compile：编译项目的源代码。 test：使用合适的单元测试框架来测试已编译的源代码。这些测试不需要已打包和布署。 Package：把已编译的代码打包成可发布的格式，比如jar。 integration-test：如有需要，将包处理和发布到一个能够进行集成测试的环境。 verify：运行所有检查，验证包是否有效且达到质量标准。 install：把包安装到maven本地仓库，可以被其他工程作为依赖来使用。 Deploy：在集成或者发布环境下执行，将最终版本的包拷贝到远程的repository，使得其他的开发者或者工程可以共享。 3)site生命周期：建立和发布项目站点 pre-site：生成项目站点之前需要完成的工作 site：生成项目站点文档 post-site：生成项目站点之后需要完成的工作 site-deploy：将项目站点发布到服务器 2、命令行和生命周期各个生命周期相互独立，一个生命周期的阶段前后依赖。 mvn clean 调用clean生命周期的clean阶段，实际执行pre-clean和clean阶段 mvn test 调用default生命周期的test阶段，实际执行test以及之前所有阶段 mvn clean install 调用clean生命周期的clean阶段和default的install阶段，实际执行pre-clean和clean，install以及之前所有阶段 七、统一管理版本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;secondproject&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--以properties创建标签--&gt; &lt;properties&gt; &lt;!--自定义版本号标签--&gt; &lt;spring-version&gt;5.2.6.RELEASE&lt;/spring-version&gt; &lt;mysql.connection.version&gt;5.1.47&lt;/mysql.connection.version&gt; &lt;junit-version&gt;4.13&lt;/junit-version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;!--直接使用 ${标签名称} --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;${spring-version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;${spring-version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;${spring-version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;${mysql.connection.version}&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;${junit-version}&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 八、依赖的基础dependencyManagement1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;secondproject&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!--依赖关联的版本--&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;5.2.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.2.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.2.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;dependencies&gt; &lt;!--若没有写版本号 则会使用dependencyManagement中定义的版本号--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--若没有写版本号 则会使用dependencyManagement中定义的版本号--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--若写了verson版本号，则优先使用本标签定义的版本号--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;5.2.1.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 九、聚合工程这里我们以SpringBoot工程为例 1、父工程mall123456789101112131415161718192021222324&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;!--springboot版本统一管理 相当于dependencyManagement--&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;!--统一版本--&gt; &lt;version&gt;2.2.7.RELEASE&lt;/version&gt; &lt;relativePath/&gt;&lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;mall&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;modules&gt; &lt;module&gt;mallmail&lt;/module&gt; &lt;module&gt;mailserver&lt;/module&gt; &lt;/modules&gt;&lt;/project&gt; 1)子工程mallmail1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;mall&lt;/artifactId&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;mallmail&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;mail-service&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2)子工程mailserver12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;mall&lt;/artifactId&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;mailserver&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;modules&gt; &lt;module&gt;mail-commons&lt;/module&gt; &lt;module&gt;mail-model&lt;/module&gt; &lt;module&gt;mail-mapper&lt;/module&gt; &lt;module&gt;mail-service&lt;/module&gt; &lt;module&gt;mail-web&lt;/module&gt; &lt;/modules&gt;&lt;/project&gt; ①mail-commons1234567891011121314&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;mailserver&lt;/artifactId&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;mail-commons&lt;/artifactId&gt;&lt;/project&gt; ②mail-mapper1234567891011121314151617181920&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;mailserver&lt;/artifactId&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;mail-commons&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;mail-model&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; ③mail-model123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;mailserver&lt;/artifactId&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;mail-model&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;mail-commons&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; ④mail-service123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;mailserver&lt;/artifactId&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;mail-service&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;mail-mapper&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; ⑤mail-web123456789101112131415161718192021&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;parent&gt; &lt;artifactId&gt;mailserver&lt;/artifactId&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;mail-web&lt;/artifactId&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.example&lt;/groupId&gt; &lt;artifactId&gt;mail-service&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2、工程的打包和部署 若我们要部署程序，则直接打包父工程mall即可，其他工程也就随之打包 若我们在各模块直接要相互引入不同的模块，则直接在dependencies中引用即可 1)解决maven循环依赖的问题 每个模块的依赖情况 修改模块的依赖情况 刷新maven即可 十、nexus私服的使用https://www.cnblogs.com/endv/p/11204704.html 1、私服的作用​ 一般用作局域网，是种特殊的Maven仓库一般用于公司，比如三十个员工开发一个项目，需要每个人都联网去下载jar，每个人都很痛苦。此时公司可以搭建一个私服，让其中一人去私服下载jar，这样私服中就缓存了那些jar包，其他人在下载的时候就无需重新从远程仓库下载了，直接从私服缓存的地方拿下来即可。 2、Maven仓库的分类 本地仓库 远程仓库 中央仓库 私服 其它公共库。 私服是一种特殊的远程仓库，它是架设在局域网内的仓库服务，私服代理广域网上的远程仓库，供局域网内的Maven用户使用。当Maven需要下载构件的时候，它从私服请求，如果私服上不存在该构件，则从外部的远程仓库下载，缓存在私服上之后，再为Maven的下载请求提供服务。我们还可以把一些无法从外部仓库下载到的构件上传到私服上。 3、windows下的nexus的使用1)下载后解压的文件夹 2)初始化启动在bin目录下 nexus.exe /run 这个过程可能比较耗时，需等待 3)修改账号和访问地址 访问地址：http://localhost:8081 默认账号密码：admin/admin123 修改端口和地址 4)添加用户 5)仓库类型说明 6)修改中央仓库镜像 7)服务安装和卸载注意：若安装服务失败，则以管理员身份启动此命令提示符 安装服务 nexus /install 启动服务 nexus /start 停止服务 nexus /stop 卸载服务 nexus /uninstall 8)创建私服文件的存放地址 9)创建代理资源库","link":"/2020/08/30/docker_linux_nginx_git_maven_gradle/Maven%E8%AF%A6%E8%A7%A3/"},{"title":"Dokcer详解","text":"一、Docker官网与仓库地址docker官网：http://www.docker.com Docker Hub官网: https://hub.docker.com/ 二、Docker三要素1、镜像Docker 镜像（Image）就是一个只读的模板。镜像可以用来创建 Docker 容器，一个镜像可以创建很多容器。 2、容器Docker 利用容器（Container）独立运行的一个或一组应用。容器是用镜像创建的运行实例。 它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全的平台。 可以把容器看做是一个简易版的 Linux 环境（包括root用户权限、进程空间、用户空间和网络空间等）和运行在其中的应用程序。 容器的定义和镜像几乎一模一样，也是一堆层的统一视角，唯一区别在于容器的最上面那一层是可读可写的。 3、仓库仓库（Repository）是集中存放镜像文件的场所。仓库(Repository)和仓库注册服务器（Registry）是有区别的。仓库注册服务器上往往存放着多个仓库，每个仓库中又包含了多个镜像，每个镜像有不同的标签（tag）。 仓库分为公开仓库（Public）和私有仓库（Private）两种形式。最大的公开仓库是 Docker Hub(https://hub.docker.com/)，存放了数量庞大的镜像供用户下载。国内的公开仓库包括阿里云 、网易云 等 4、深入理解镜像/容器/仓库 Docker 本身是一个容器运行载体或称之为管理引擎。我们把应用程序和配置依赖打包好形成一个可交付的运行环境，这个打包好的运行环境就似乎 image镜像文件。只有通过这个镜像文件才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。 image 文件生成的容器实例，本身也是一个文件，称为镜像文件。 一个容器运行一种服务，当我们需要的时候，就可以通过docker客户端创建一个对应的运行实例，也就是我们的容器 至于仓储，就是放了一堆镜像的地方，我们可以把镜像发布到仓储中，需要的时候从仓储中拉下来就可以了。 三、Docker的安装与卸载官网教程：https://docs.docker.com/engine/install/centos/ 基于centos7 1、安装docker1)如果已经安装，则卸载旧的docker版本 12345678$ sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine 2)安装仓库 123456$ sudo yum install -y yum-utils#设置阿里云的镜像仓库地址$ sudo yum-config-manager \\ --add-repo \\ http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo 3)更新yum软件包索引 1yum makecache fast 4)安装docker yum -y install docker-ce -y 全部同意 docker-ce 安装社区版 5)启动docker服务 systemctl start docker 6)查看docker的版本 docker version 或者 docker -v 7)测试容器 docker run hello-world 2、阿里镜像加速配置 vim /etc/docker/daemon.json 添加镜像地址 { \"registry-mirrors\": [\"https://xxx.mirror.aliyuncs.com\"] } 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335- **systemctl daemon-reload** - 重新加载配置文件- **systemctl restart docker** - 重启docker服务#### 3、卸载docker - **systemctl stop docker** - 先停止docker- *yum remove docker-ce docker-ce-cli containerd.io*- *rm -rf /var/lib/docker*### 四、Docker的底层原理Docker是一个Client-Server结构的系统，Docker守护进程运行在主机上， 然后通过Socket连接从客户端访问，守护进程从客户端接受命令并管理运行在主机上的容器。 容器，是一个运行时环境，就是我们前面说到的集装箱。#### 1、为什么Docker比较比VM快- (1)docker有着比虚拟机更少的抽象层。由亍docker不需要Hypervisor实现硬件资源虚拟化,运行在docker容器上的程序直接使用的都是实际物理机的硬件资源。因此在CPU、内存利用率上docker将会在效率上有明显优势。- (2)docker利用的是宿主机的内核,而不需要Guest OS。因此,当新建一个容器时,docker不需要和虚拟机一样重新加载一个操作系统内核。仍而避免引寻、加载操作系统内核返个比较费时费资源的过程,当新建一个虚拟机时,虚拟机软件需要加载Guest OS,返个新建过程是分钟级别的。而docker由于直接利用宿主机的操作系统,则省略了返个过程,因此新建一个docker容器只需要几秒钟。### 五、Docker常用命令#### 1、其他命令- **docker version** 或者 **docker -v** - 查看docker的版本- **docker info** - 查看docker的更加详细信息- **systemctl [start|stop|restart] docker** - 【启动|停止|重启】docker服务- **systemctl enable docker** - 开启自启动docker- **docker --help** - 查看帮助命令#### 2、镜像操作&lt;img src=&quot;http://img.louchen.top/2020/07/20200821233115.png&quot; style=&quot;zoom:80%;&quot; /&gt;&gt; 各个选项说明:REPOSITORY：表示镜像的仓库源TAG：镜像的标签IMAGE ID镜像IDCREATED：镜像创建时间SIZE：镜像大小同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，我们使用 **REPOSITORY:TAG** 来定义不同的镜像。如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像- **docker images** - 查看本机上所有的镜像- **docker images [选项]** - 【选项】 - **-a** 列出本地所有的镜像（含**中间映像层**） - **-q** :只显示镜像ID。 - **--digests** 显示镜像的摘要信息 - **--no-trunc** 显示完整的镜像信息- **docker search [镜像名称]** - 查询镜像 - &lt;img src=&quot;http://img.louchen.top/2020/07/20200821234510.png&quot; style=&quot;zoom:80%;&quot; /&gt;- **docker search [选项] [镜像名称]** - 【选项】 - **-no-trunc** 显示完整的镜像描述 - **--filter=stars=[点赞数]** 列出收藏数不小于指定值的镜像。 - **-automated** 只列出 automated build类型的镜像；- **docker pull [镜像名:版本号]** - 拉取指定镜像 ，若不写版本号，则默认拉取的为【镜像名:latest】最近的版本- **docker rmi [镜像id/镜像名:TAG]** - 删除指定镜像 - 若存在多个相同镜像，，不指定镜像名的TAG会删除latest镜像- **docker rmi -f [镜像id/镜像名:TAG] [镜像id/镜像名:TAG]** - 强制删除镜像 - 若存在多个相同镜像，不指定镜像名的TAG会删除latest镜像- **docker rmi -f $(docker images -qa)** - 强制删除所有镜像 - 使用`docker images -qa`查询所有镜像id并批量删除#### 3、容器操作- **docker pull [镜像名称:TAG]** - 拉取指定镜像，若没有指定TAG则拉取latest - **docker run [选项] [镜像id/镜像名称]** - 新建并启动容器 - 【选项】 - **--name &quot;容器新名字&quot;** 为容器指定一个名称，若不指定名称，则随机分配一个 - **-d** 后台运行容器，并返回容器ID，也即启动守护式容器； - **-i** 以交互模式运行容器，通常与 -t 同时使用； - **-t** 为容器重新分配一个伪输入终端，通常与 -i 同时使用； - **-P** 随机端口映射； - **-p** 指定端口映射，有以下四种格式 - **-p [主机端口]:[容器端口]** 将主机的端口和容器中的端口进行映射对应 - **--restart=always** - docker服务重新启动时，容器也会启动 **①启动并进入容器** &gt; &lt;img src=&quot;http://img.louchen.top/2020/07/20200822140007.png&quot; style=&quot;zoom:80%;&quot; /&gt; &gt; &gt; 为centos镜像创建一个名称为mycentos的容器实例，启动后直接进入容器内部 &gt; &gt; - exit 后会关闭容器 &gt; - ctrl+p+q 不会关闭容器 **②以后台方式启动容器，并指定映射端口** &gt; `docker pull tomcat:8` &gt; &gt; `docker run -d --name mytomcat -p 8080:8080 tomcat:8` &gt; &gt; &lt;img src=&quot;http://img.louchen.top/2020/07/20200822174315.png&quot; style=&quot;zoom:80%;&quot; /&gt;- **docker ps [选项]** - 默认列出当前正在运行的所有容器信息（无选项时） - 【选项】 - **-a** 列出当前所有**正在运行的容器+历史上运行过的所有容器** - **-l** 显示上一次创建的容器。 - **-n [次数]** 显示最近指定次数创建的历史容器。 - **-q** 只显示容器编号。 - **--no-trunc** 不截断输出。- **退出容器** - **exit** 容器停止退出 - **ctrl+P+Q** 容器不停止退出- **docker start [容器id/容器名称]** - 启动指定容器- **docker restart [容器id/容器名称]** - 重启指定容器- **docker stop [容器id/容器名称]** - 停止指定容器- **docker kill [容器id/容器名称]** - 强制停止指定容器- **删除容器** - **docker rm [容器id/容器名称]** 删除已停止的容器 - 一次性删除多个容器 - **docker rm [容器1] [容器2]** - **docker rm -f $(docker ps -a -q)** - **docker ps -a -q | xargs docker rm**- **docker logs [选项] [容器id/容器名称]** - 查看容器日志 - 【选项】 - **-t** 是加入时间戳 - **-f** 跟随最新的日志打印 - **--tail [数字]** 显示最后多少条- **docker top [容器id/容器名称]** - 查看容器内运行的进程- **docker inspect [容器id/容器名称]** - 查看容器内部细节- **进入容器内部进行命令交互** - **docker exec -it [容器id/容器名称] bash** - **docker attach [容器id/容器名称]** - 区别： - attach 直接进入容器启动命令的终端，不会启动新的进程。**exit退出后会关闭容器** - exec 是在容器中打开新的终端，并且可以启动新的进程 。**exit退出后不会关闭容器**- **docker exec -it [容器id/容器名] ls -l /tmp** - 输出容器中的 /tmp目录下的文件 - &lt;img src=&quot;http://img.louchen.top/2020/07/20200822144310.png&quot; style=&quot;zoom:80%;&quot; /&gt;- **docker cp [容器id/容器名]:[容器内路径] [目的主机路径]** - 从容器内指定文件拷贝到主机指定位置 - &lt;img src=&quot;http://img.louchen.top/2020/07/20200822150103.png&quot; style=&quot;zoom:80%;&quot; /&gt; - 拷贝mycentos容器下的 /etc/profile文件拷贝到 / 路径下### 六、Docker镜像#### 1、什么是镜像镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它**包含运行某个软件所需的所有内容，包括代码、运行时、库、环境变量和配置文件**。#### 2、Docker镜像加载原理 docker的镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。bootfs(boot file system)主要包含bootloader和kernel, bootloader主要是引导加载kernel, Linux刚启动时会加载bootfs文件系统，在Docker镜像的最底层是bootfs。这一层与我们典型的Linux/Unix系统是一样的，包含boot加载器和内核。当boot加载完成之后整个内核就都在内存中了，此时内存的使用权已由bootfs转交给内核，此时系统也会卸载bootfs。rootfs (root file system) ，在bootfs之上。包含的就是典型 Linux 系统中的 /dev, /proc, /bin, /etc 等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。 &gt; 平时我们安装进虚拟机的CentOS都是好几个G，为什么docker这里才200M？？对于一个精简的OS，rootfs可以很小，只需要包括最基本的命令、工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供 rootfs 就行了。由此可见对于不同的linux发行版, bootfs基本是一致的, rootfs会有差别, 因此不同的发行版可以公用bootfs。#### 3、分层的镜像以我们的pull为例，在下载的过程中我们可以看到docker的镜像好像是在一层一层的在下载**为什么 Docker 镜像要采用这种分层结构呢**?最大的一个好处就是 - 共享资源比如：有多个镜像都从相同的 base 镜像构建而来，那么宿主机只需在磁盘上保存一份base镜像，同时内存中也只需加载一份 base 镜像，就可以为所有容器服务了。而且镜像的每一层都可以被共享。#### 4、容器commit为镜像docker commit提交容器副本使之成为一个新的镜像- **docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; [容器ID/容器名称] [要创建的目标镜像名]:[标签名]****①生成镜像**&lt;img src=&quot;http://img.louchen.top/2020/07/20200822175351.png&quot; style=&quot;zoom:80%;&quot; /&gt;**②创建自定义镜像的容器**&lt;img src=&quot;http://img.louchen.top/2020/07/20200822175603.png&quot; style=&quot;zoom:80%;&quot; /&gt;### 七、Docker容器数据卷#### 1、基本概念先来看看Docker的理念：* 将运用与运行的环境打包形成容器运行 ，运行可以伴随着容器，但是我们对数据的要求希望是持久化的* 容器之间希望有可能共享数据Docker容器产生的数据，如果不通过docker commit生成新的镜像，使得数据做为镜像的一部分保存下来，那么当容器删除后，数据自然也就没有了。为了能保存数据在docker中我们使用卷。卷就是目录或文件，存在于一个或多个容器中，**由docker挂载到容器**，但不属于联合文件系统，因此能够绕过Union File System提供一些用于持续存储或共享数据的特性： 卷的设计目的就是数据的持久化，完全独立于容器的生存周期，因此Docker不会在容器删除时删除其挂载的数据卷特点：1：数据卷可在容器之间共享或重用数据2：卷中的更改可以直接生效3：数据卷中的更改不会包含在镜像的更新中4：数据卷的生命周期一直持续到没有容器使用它为止- 容器的持久化- 容器间继承+共享数据#### 2、容器数据卷添加(目录挂载)说白了就是将宿主机上的某一个路径与容器中的某一路径产生关联，**也就是挂载**##### 1)命令添加- **docker run -it -v [宿主机绝对路径目录]:[容器内目录] [镜像名/镜像id]** - 启动容器时挂载目录 - &gt; 案例 - ①&lt;img src=&quot;http://img.louchen.top/2020/07/20200822214127.png&quot; style=&quot;zoom:80%;&quot; /&gt; - 创建容器名为mycentos的容器，并将宿主机上的 `/tempVolume `目录 和 容器中的 `/containerVolume`挂载 - ②容器&lt;img src=&quot;http://img.louchen.top/2020/07/20200822214439.png&quot; style=&quot;zoom:80%;&quot; /&gt; - ③宿主机&lt;img src=&quot;http://img.louchen.top/2020/07/20200822214550.png&quot; style=&quot;zoom:80%;&quot; /&gt;###### ①查看容器挂载情况- **使用 docker inspect [容器名称/容器id]** - &lt;img src=&quot;http://img.louchen.top/2020/07/20200822214904.png&quot; style=&quot;zoom:80%;&quot; /&gt;###### ②容器和宿主机之间数据共享###### ③容器停止退出后，主机修改后，容器再次启动数据同步###### ④带权限读写- **docker run -it -v [宿主机绝对路径目录]:[容器内目录]:ro [镜像名/镜像id]** - ro （read only）表示在宿主机上可以对挂载的目录中的内容进行修改和查看，容器中只能读，不能做修改操作##### 2)使用DockerFile添加VOLUME[&quot;/dataVolumeContainer&quot;,&quot;/dataVolumeContainer2&quot;,&quot;/dataVolumeContainer3&quot;]说明：**出于可移植和分享的考虑**，用-v 主机目录:容器目录这种方法不能够直接在Dockerfile中实现。由于宿主机目录是依赖于特定宿主机的，并不能够保证在所有的宿主机上都存在这样的特定目录。**注意：**使用DockerFile不能指定宿主机目录(自动生成)，但可以指定多个容器的目录，并使用DockerFile构建的新的镜像具有可移植性&gt; 案例①在宿主机上新建DockerFile文件 - **vim DockerFile** - 添加内容 - VOLUME：容器中对应的多个挂载目录，分别为 `/dataVolumeContainer1`，`/dataVolumeContainer2` - ```shell # volume test FROM centos VOLUME [&quot;/dataVolumeContainer1&quot;,&quot;/dataVolumeContainer2&quot;] CMD echo &quot;finished,--------success1&quot; CMD /bin/bash ②通过DockerFile构建新的镜像文件 docker build -f [DockerFile文件位置] -t [构建的镜像名称:TAG] [DockerFile目录位置] 【选项】 -f [DockerFile文件位置] 指定DockerFile位置 -t [构建的镜像名称:TAG] 指定名称以及“ name：tag”格式的标签 若为当前路径，则[DockerFile目录位置]为 . ③通过DockerFile构建的镜像创建容器 docker run -it –name [容器名称] [容器id/容器名称] 启动容器，并进入容器 ，按ctrl+p+q不关闭容器 ④查看容器挂载情况 docker inspect [容器id/容器名称] ⑤进入容器是否生成对应目录 ⑥通过docker inspect查看宿主机对应的挂载目录，添加文件，发现容器中的挂载目录文件共享 3)可能出现的问题Docker挂载主机目录Docker访问出现cannot open directory .: Permission denied解决办法：在挂载目录后多加一个–privileged=true参数即可 3、容器间传递共享(–volumes-from) docker run -it –name [新建容器名称] –volumes-from [要继承的容器名称] [镜像名称/镜像id] 通过指定镜像创建一个容器，并继承指定容器的数据卷(挂载目录) 容器之间配置信息+的传递，数据卷的生命周期一直持续到没有容器使用它为止， 即继承的容器挂载目录中相互之间数据共享 八、DockerFile详解1、DockerFile是什么？ Dockerfile是用来构建Docker镜像的构建文件，是由一系列命令和参数构成的脚本。 构建步骤 编写Dockerfile文件 docker build docker run 例如：centos7.7的DockerFile文件 123456789101112131415FROM scratchADD centos-7-x86_64-docker.tar.xz /LABEL \\ org.label-schema.schema-version=\"1.0\" \\ org.label-schema.name=\"CentOS Base Image\" \\ org.label-schema.vendor=\"CentOS\" \\ org.label-schema.license=\"GPLv2\" \\ org.label-schema.build-date=\"20200809\" \\ org.opencontainers.image.title=\"CentOS Base Image\" \\ org.opencontainers.image.vendor=\"CentOS\" \\ org.opencontainers.image.licenses=\"GPL-2.0-only\" \\ org.opencontainers.image.created=\"2020-08-09 00:00:00+01:00\"CMD [\"/bin/bash\"] 2、DockerFile构建过程解析①注意事项 每条保留字指令都必须为大写字母且后面要跟随至少一个参数 指令按照从上到下，顺序执行 #表示注释 每条指令都会创建一个新的镜像层，并对镜像进行提交 ②Docker执行DockerFile的大致流程 （1）docker从基础镜像运行一个容器 （2）执行一条指令并对容器作出修改 （3）执行类似docker commit的操作提交一个新的镜像层 （4）docker再基于刚提交的镜像运行一个新容器 （5）执行dockerfile中的下一条指令直到所有指令都执行完成 ③总结从应用软件的角度来看，Dockerfile、Docker镜像与Docker容器分别代表软件的三个不同阶段， Dockerfile是软件的原材料 Docker镜像是软件的交付品 Docker容器则可以认为是软件的运行态。 Dockerfile面向开发，Docker镜像成为交付标准，Docker容器则涉及部署与运维，三者缺一不可，合力充当Docker体系的基石。 1)Dockerfile，需要定义一个Dockerfile，Dockerfile定义了进程需要的一切东西。Dockerfile涉及的内容包括执行代码或者是文件、环境变量、依赖包、运行时环境、动态链接库、操作系统的发行版、服务进程和内核进程(当应用进程需要和系统服务和内核进程打交道，这时需要考虑如何设计namespace的权限控制)等等; 2)Docker镜像，在用Dockerfile定义一个文件之后，docker build时会产生一个Docker镜像，当运行 Docker镜像时，会真正开始提供服务; 3)Docker容器，容器是直接提供服务的。 3、DockerFile保留字指令介绍 FROM 基础镜像，当前新镜像是基于哪个镜像的 MAINTAINER 镜像维护者的姓名和邮箱地址 RUN 容器构建时需要运行的命令 EXPOSE 当前容器对外暴露出的端口 WORKDIR 指定在创建容器后，终端默认登陆的进来工作目录，一个落脚点 ENV 用来在构建镜像过程中设置环境变量 ENV MY_PATH /usr/mytest 这个环境变量可以在后续的任何RUN指令中使用，这就如同在命令前面指定了环境变量前缀一样； 也可以在其它指令中直接使用这些环境变量， #代表路径为MY_PATH定义的 /usr/mytest 比如：WORKDIR $MY_PATH 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869- **ADD** - 将宿主机目录下的文件拷贝进镜像且ADD命令会自动处理URL和解压tar压缩包(**拷贝且压缩）**- **COPY** - 类似ADD，拷贝文件和目录到镜像中。(**仅拷贝**) 将从构建上下文目录中 &lt;源路径&gt; 的文件/目录复制到新的一层的镜像内的 &lt;目标路径&gt; 位置 - **COPY src dest** - **COPY [&quot;src&quot;, &quot;dest&quot;]**- **VOLUME** - 容器数据卷，用于数据保存和持久化工作- **CMD** - 指定一个容器启动时要运行的命令 - Dockerfile 中可以有**多个 CMD 指令，但只有最后一个生效**，CMD 会被 docker run 之后的参数**替换**- **ENTRYPOINT** - 指定一个容器启动时要运行的命令 - ENTRYPOINT 的目的和 CMD 一样，都是在**指定容器启动程序及参数**，但是会将docker run后指定的参数**追加**到CMD最后一条指令上- **ONBUILD** - 当构建一个被继承的Dockerfile时运行命令，父镜像在被子继承后父镜像的onbuild被触发#### 4、案例##### 1)Base镜像(scratch)Docker Hub 中 99% 的镜像都是通过在 base 镜像中安装和配置需要的软件构建出来的##### 2)自定义centos镜像&gt; 构建目标镜像的任务： - 进入容器后的指定默认路径 - 支持vim编辑器 - 查看网络配置ifconfig支持&gt; 步骤①构建DockerFile文件- 在宿主机上新建 **vim DockerFileCentos** - 添加以下内容 - ```shell #指定镜像源 FROM centos #作者及邮箱 MAINTAINER lc&lt;421192425@qq.com&gt; #创建环境路径(便于后续命令引用) ENV MYPATH /usr/local #创建工作路径(进入容器的初始路径) WORKDIR $MYPATH #安装vim RUN yum -y install vim #安装ifconfig RUN yum -y install net-tools #暴露端口 80 EXPOSE 80 #构建时输出路径MYPATHCMD CMD echo $MYPATHCMD #构建时输出指定的语句 CMD echo &quot;success--------------ok&quot; CMD [&quot;/bin/bash&quot;] ②通过DockerFile构建镜像 docker build -f [DockerFile文件位置] -t [构建的镜像名称:TAG] [DockerFile目录位置] ③查看构建的镜像和镜像的构建步骤 docker history [镜像id/镜像名] 查看构建镜像的步骤 ④根据构建的镜像创建容器 我们发现进入容器的初始目录以及变为 /usr/lcoal ifconfig命名也能使用 九、阿里镜像仓库上传1、使用docker commit 或 DockerFile构建要上传的镜像2、登录阿里云创建自己的镜像仓库https://cr.console.aliyun.com/cn-qingdao/instances/repositories 创建好的仓库 **** 3、推送镜像 docker login –username=421192425@qq.com registry.cn-qingdao.aliyuncs.com 登录远程仓库 docker tag [镜像id] registry.cn-qingdao.aliyuncs.com/docker_lc/mycentos:[镜像版本号] 要上传的指定的镜像id，并指定上传后的镜像版本号 docker_lc 远端镜像命名空间 mycentos 远端仓库名称 一个仓库对应多个镜像的版本号 docker push registry.cn-qingdao.aliyuncs.com/docker_lc/mycentos:[镜像版本号] 推送镜像，保证指定的镜像版本号与上一步指定上传后的镜像版本号一致 docker_lc/mycentos 命名空间/仓库名称 的镜像搜索 远端查看推送的镜像 没推送到指定仓库就对应一次版本 拉取时指定仓库的后的版本及得到相应的镜像 4、搜索镜像 5、拉取指定镜像 docker pull registry.cn-qingdao.aliyuncs.com/docker_lc/mycentos:[镜像版本号] docker_lc 命名空间 mycentos 仓库名称 镜像版本号为指定仓库中的镜像版本号 查看拉取的镜像 十、常见镜像安装1、安装mysql5.71)拉取mysql指定版本的镜像 docker pull mysql:5.7 2)运行容器 docker run -d --name mysql01 --restart=always -p 3306:3306 -v /opt/mysql_5.7/conf:/etc/mysql/conf.d -v /opt/mysql_5.7/logs:/logs -v /opt/mysql_5.7/data:/var/lib/mysql -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7 123456789101112131415161718192021222324252627282930313233343536- 将宿主机上的目录 `/opt/mysql_5.7/conf` 挂载为容器对应的 `/etc/mysql/conf.d ` (对应mysql配置目录) 将宿主机上的目录 `/opt/mysql_5.7/logs` 挂载为容器对应的 `/logs` (对应日志目录) 将宿主机上的目录 `/opt/mysql_5.7/data` 挂载为容器对应的 `/var/lib/mysql` (对应数据每目录) `-e MYSQL_ROOT_PASSWORD=123456` 设置root初始密码为123456&lt;img src=&quot;http://img.louchen.top/2020/07/20200823204414.png&quot; style=&quot;zoom:80%;&quot; /&gt;3)进入容器- **docker exec -it mysql01 bash**- 进入容器后进入登录mysql目录行 - &lt;img src=&quot;http://img.louchen.top/2020/07/20200823205057.png&quot; style=&quot;zoom:80%;&quot; /&gt; - 创建数据库 **create database vhr;** - 使用数据库 **use vhr;** - 创建表 **create table hr(id int primary key identity_increment,name varchar(20) not null);**、 - quit退出mysql命令行，exit退出mysql容器4)放行3306端口，使用外部工具连接测试#### 2、安装Redis1)拉取redis镜像- **docker pull redis**2)运行容器- ```shell docker run -d --restart=always --name myredis -p 6379:6379 -v /opt/myredis/data:/data -v /opt/myredis/conf/redis.conf:/usr/local/etc/redis/redis.conf redis redis-server /usr/local/etc/redis/redis.conf --appendonly yes 宿主机上的aof数据/opt/myredis/data对应容器的 /data (持久化文件) 宿主机上/opt/myredis/conf/redis.conf对应容器的 /usr/local/etc/redis/redis.conf (redis配置文件) redis-server /usr/local/etc/redis/redis.conf运行时启动redis --appendonly yes 开启aop持久化 3)进入容器 docker exec -it myredis redis-cli 3、安装Nginxhttps://blog.csdn.net/Superman_peng/article/details/108181155 1)拉取镜像 docker pull nginx 2)创建并运行容器 1234docker run -d --restart=always -p 80:80 --name mynginx -v /opt/nginx/html:/usr/share/nginx/html -v /opt/nginx/logs:/var/log/nginx -v /opt/nginx/conf.d:/etc/nginx/conf.d nginx 宿主机路径 /opt/nginx/html 映射容器路径 /usr/share/nginx/html (访问的主页路径) 宿主机路径 /opt/nginx/logs 映射容器路径/var/log/nginx (日志) 宿主机路径 /opt/nginx/conf.d 映射容器路径/etc/nginx/conf.d (配置文件目录) 宿主机目录如果不存在，则会自动生成，不需要手动创建 3)刚创建的容器因为目录挂载的原因，没有配置文件和访问的主页路径，我们需要创建一个测试容器，然后进容器将对应的配置文件和主页路径复制到对应宿主机的路径 ng1为测试的容器名称 docker cp ng1:/etc/nginx/conf.d/default.conf /opt/nginx/conf.d/ 复制配置文件，注意不同nginx版本对应的配置文件不同 docker cp ng1:/usr/share/nginx/html/index.html /opt/nginx/html/ 复制index.html docker cp ng1:/usr/share/nginx/html/50x.html /opt/nginx/html/ 复制50x.html 4)若为虚拟机则防火墙打开80端口，若为阿里云则打开80安全组 5)访问到则成功的页面 4、安装tomcat1)拉取指定镜像 docker pull tomcat:8 2)创建并启动容器 12docker run -d --restart=always --name mytomcat -p 8080:8080 -v /opt/tomcat/webapps:/usr/local/tomcat/webapps tomcat:8 宿主机目录/opt/tomcat/webapps 对应宿主机目录 /usr/local/tomcat/weapps （放置war包的位置） 3)若没有显示默认的tomcat启动页则进入容器 cp -r /usr/local/tomcat/webapps.dist/* /usr/local/tomcat/webapps 4)若需要创建多个tomcat容器则 只需要修改相应的端口号即可 12docker run -d --restart=always --name mytomcat01 -p 8081:8080 -v /opt/tomcat01/webapps:/usr/local/tomcat/webapps tomcat:8","link":"/2020/08/30/docker_linux_nginx_git_maven_gradle/Docker%E8%AF%A6%E8%A7%A3/"},{"title":"Linux详解","text":"一、常用通用命令 重启虚拟机网络 1service network restart 清屏 1clear 查看IP地址 12#推荐使用这种方式ip addr 或者 1ifconfig -a 查询系统版本 1uname -a 二、Linux的目录结构linux 的文件系统是采用级层式的树状目录结构，在此结构中的最上层是根目录 “/”，然后在此目录下再创建其他的目录。 目录结构详解 /bin [重点] (/usr/bin 、 /usr/local/bin) 是Binary的缩写, 这个目录存放着最经常使用的命令 /sbin (/usr/sbin 、 /usr/local/sbin) s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。 /home [重点] 存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般 该目录名是以用户的账号命名的。 /root [重点] 该目录为系统管理员，也称作超级权限者的用户主目录。 /lib 系统开机所需要最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几 乎所有的应用程序都需要用到这些共享库。 /lost+found 这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。 /etc [重点] 所有的系统管理所需要的配置文件和子目录 my.conf /usr [重点] 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与 windows下的program files目录。 /boot [重点] 存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件 /proc 这个目录是一个虚拟的目录，它是系统内存的映射，访问这个目录来获取系统信息 /srv service缩写，该目录存放一些服务启动之后需要提取的数据。 /sys 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs /tmp 这个目录是用来存放一些临时文件的。 /dev 类似于windows的设备管理器，把所有的硬件用文件的形式存储。 /media [重点] linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux 会把识别的设备挂载到这个目录下。 /mnt [重点] 系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂 载在/mnt/上，然后进入该目录就可以查看里的内容了。 d:/myshare /opt 这是给主机额外安装软件所摆放的目录。如安装ORACLE数据库就可放到该目录下。 默认为空。 /usr/local [重点] 这是另一个给主机额外安装软件所安装的目录。一般是通过编译源码方式安装的程序 /var [重点] 这个目录中存放着在不断扩充着的东西，习惯将经常被修改的目录放在这个目录下。 包括各种日志文件。 /selinux [security-enhanced linux] 360 SELinux是一种安全子系统,它能控制程序只能访问特定文件。 三、vi和vim​ 所有的 Linux 系统都会内建 vi 文本编辑器。 ​ Vim 具有程序编辑的能力，可以看做是 Vi 的增强版本，可以主动的以字体颜色辨别语法的正确性，方便程序设计。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。 若提示没有安装vim则安装 vim编辑器需要安装三个包： 123vim-enhanced-7.0.109-7.el5vim-minimal-7.0.109-7.el5vim-common-7.0.109-7.el5 确认一下你的VIM是否已经安装 1rpm -qa|grep vim 缺少了其中某个，比如说： vim-enhanced这个包少了 则执行 1yum -y install vim-enhanced 如果上面三个包一个都没有显示，则直接输入命令： 1yum -y install vim* 1、三种模式1)正常模式/一般模式(esc退出到正常模式)在正常模式下，我们可以使用快捷键。 以 vim 打开一个档案就直接进入一般模式了(这是默认的模式)。在这个模式中， 你可以使用『上下左右』按键来移动光标，你可以使用『删除字符』或『删除整行』来处理档案内容， 也可以使用 『复制、贴上』来处理你的文件数据。 常用命令 yy 赋值当前行 4yy 赋值当前光标下的4行 p 粘贴到光标位置 dd 删除光标下的当前行 4dd 删除当前光标下的4行 /words 查找关键字words ，若匹配到多个则按 n 到光标移到到下一个匹配的位置 G 跳到文件末行 gg 跳到文件开头 u 撤销保存之前的所有修改操作 ctrl+r 反撤销 跳转到指定行号 ①显示行号 :set nu ②输入20 (跳转到20行) ③按 shift+g ctrl+f---&gt;向下翻一页代码 ctrl+b---&gt;向上翻一页代码 ctrl+d---&gt;向下翻半页代码 ctrl+u---&gt;向上翻半页代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849##### 2)插入模式/编辑模式(按 i 或者 insert键)在模式下，程序员可以输入内容。按下 i, I, o, O, a, A, r, R 等任何一个字母之后才会进入编辑模式, **一般来说按 i 即可**##### 3)命令行模式(输入 : )在这个模式当中， 可以提供你相关指令，**完成读取、存盘、替换、离开 vim 、显示行号**等的动作则是在此模式中达成的！&gt; 常用命令：- **q** 退出(未做任何修改，不会保存)- **q!** 保存并强制退出(做了修改，不会保存)- **wq** 保存并且退出- w 保存不退出- e! 放弃所有修改，从上次保存文件开始再编辑- wq! 强制保存文件，并退出- w! 强制保存，不推出、- w file 将修改另外保存到file中，不退出- **set nu** 显示行号- **set nonu** 取消行号的显示#### 2、三种模式的转换&lt;img src=&quot;http://img.louchen.top/2020/07/20200818194501.png&quot; style=&quot;zoom:80%;&quot; /&gt;### 四、开机重启、用户登录注销#### 1、关机和重启- **shutdown -h now** 立即关机- **shutdown -h 1** 一分钟后关机- **shutdown -r now** 立即重启- **halt** 直接使用，效果等价于关机- **reboot** 重启- **syn** 把内存数据同步到磁盘(关机前的一般操作) - 当我们关机或者重启时，都应该先执行以下 sync 指令，把内存的数据写入磁盘，防止数据丢失。#### 2、用户登录与注销- **logout** 注销用户#### 3、用户的切换```shellsu 用户名 在root用户下可直接切换 在普通用户下切换root需要输入root的密码 五、用户管理 1) Linux 系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。 2) Linux 的用户需要至少要属于一个组。 1、用户和密码的添加 添加用户 useradd [选项] 用户名 默认在 /home下创建和用户名同名的家目录 useradd xm 1234567891011 - **useradd -d 指定目录 用户名** - 在指定目录下创建用户名和指定家目录- **密码添加****passwd 用户名**```shellpasswd xm 2、删除用户 删除用户，保留家目录 userdel 用户名 删除用户及家目录 userdel -r 用户名 注意：一般我们要保留组目录。 3、查询用户及用户切换 查询用户 id 用户名 whoami 查看当前用户名 切换用户 su 用户名 从权限高的用户切换到权限低的用户，不需要输入密码，反之需要。 当需要返回到原来用户时，使用 exit 指令 4、组的增加和修改 添加组名 groupadd 组名 删除组名 groupdel 组名 增加用户时直接指定组名 ①首先创建组名 groupadd 组名 ②创建用户时指定组名 useradd -g 组名 用户名 修改用户的组 ①创建新组名 groupadd 新组名 ②修改用户组 usermod -g 新组名 用户名 5、用户和组的相关文件/etc/passwd 文件用户（user）的配置文件，记录用户的各种信息 每行的含义：用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录 Shell /etc/shadow 文件口令的配置文件 每行的含义：登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志 /etc/group 文件组(group)的配置文件，记录 Linux 包含的组的信息每行含义：组名:口令:组标识号:组内用户列表 六、运行级别及root密码找回(基于centos7)1、系统运行级别在 /etc/inttab文件下 运行级别对应的含义 init级别 systemctl target 0 shutdown.target 1 emergency.target 2 rescure.target 3 multi-user.target 4 无 5 graphical.target 6 无 12# multi-user.target类似于runlevel 3;# graphical.target类似于runlevel 5 1)获取默认运行级别12#查看默认运行级别的方式为systemctl get-default 2)设置运行级别① systemctl [command] [unit.target] 等同于 init [0/1/2/3/5] [command指令]: get-default :取得当前的target set-default :设置指定的target为默认的运行级别 isolate :在不重启的情况下，切换到指定的运行级别 *[unit.target]指定的运行级别*： 参考运行级别对应的target表 ② runlevel 第一个数为之前的运行级别，第二个数为当前运行级别 ③ init [0/1/2/3/5] 设置运行级别 2、centos7忘记root密码https://blog.csdn.net/ClearLoveQ/article/details/90635333 七、实用指令1、帮助指令1)man [指令]查询某个指令的用法 2)help [指令]查询某个指令的用法 2、文件目录指令1)pwd显示当前工作目录的绝对路径 2)ls ls 普通显示 ls -l (可简写为ll) 以列表形式显示 ls -al 以列表形式先所有以 . 开头的文件 ll [目录路径] 或者 ls -l [目录路径] 以列表形式列出指定目录下的所有文件 ls -lh [文件目录] 以列表的形式查看文件或目录的大小 3)cd cd ~ 或者 cd 回到当前用户的家目录 cd . 就是代表的当前目录 cd .. 回到当前目录的上一级目录 cd ../../ 回到当目录的上上级目录 4)mkdir/rmdir mkdir命令 makdir [目录路径] 只能创建一个目录 创建person文件夹 makdir -p [目录路径] 可同时创建多级目录 创建man和zs文件夹 rmdir命令 rmdir [目录路径] 删除的目录下必须是空的 rm -rf [目录路径] 可删除里面有文件的文件夹 6)touch *touch [文件名] * 创建空文件 touch [文件名1] [文件名2] 同时创建多个空文件 7)cp cp [源文件] [目标目录] 拷贝单个文件到指定目录 cp -r [源目录] [目标目录] 递归拷贝源目录到指定目录 1)将aaa目录的所有文件拷贝到bbb目录(不拷贝aaa目录)、 cp -r aaa/* bbb/ 1234567- 2)将**aaa目录**拷贝到bbb目录(直接拷贝aaa目录到bbb目录) - ```sh cp -r aaa/ bbb/ 或者 cp -r aaa bbb \\cd -r [源目录] [目标目录] 若有重复的文件则强制覆盖，不提示。 8)rm删除文件或文件夹 rm [文件名] 删除文件 rm -f [文件名] 强制删除，不提示 rm -rf [目标路径] 递归删除目录(包括其中的文件)，不提示 9)mv移动文件与目录或重命名 mv [旧文件名] [新文件名] 文件重命名，实质时移动到同一目录达到文件的覆盖效果 mv [目标文件] [目标路径] 移动文件到指定目录 10)cat/more/less cat命令 cat [目标文件] 一次性加载全部文件内容 cat -n [目标文件] | more 以带行号和分页显示目标文件内容， -n 携带行号 空格向下翻页，shift+\\ 向上翻页 more命令 more [目标文件] 空格 向下翻一页 Enter 向下翻一行 *q * 退出显示 ctrl+f 向下滚动一屏 ctrl+b 向上滚动一屏 = 输出当前的行号 :f 输出文件名和当前行的行号 less命令 less 指令用来分屏查看文件内容，它的功能与 more 指令类似，但是比 more 指令更加强大，支持各种显示终端。less 指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，对于显示大型文件具有较高的效率。 less [目标文件] 11) &gt; 指令和 &gt;&gt; 指令 &gt; 指令 输出重定向 : 会将原来的文件的内容覆盖 &gt;&gt; 指令 不会覆盖原来文件的内容，而是追加到文件的尾部。 ls -l &gt; [文件名] 将当前目录下的显示内容写入到指定的文件中(覆盖文件) 将当前下的文件覆盖写入到a.txt文件中，若不存在此文件则创建 ls -l &gt;&gt; [文件名] 将当前目录下的显示内容追加到指定的文件中(追加内容到文件) cat [文件名1] &gt; [文件名2] 将文件 1 的内容覆盖到文件 2 cat [文件名1] &gt;&gt; [文件名2] 将文件 1 的内容追加到文件 2、 echo “内容” &gt; [文件名] 使用echo输出内容到控制台后覆盖写入到指定的文件中 12)echo输出内容到控制台 echo “hello world” 输出内容hello world到控制台 echo $PATH 输出liunx的环境变量到控制台 13)head/tail head [文件名] 默认显示文件的头十行 head -n [行数] [文件名] 显示指定文件的头部的指定行数 tail [文件名] 默认显示的文件后十行 tail -n [行数] [文件名] 显示指定文件的末尾的指定行数 tail -f [文件名] 实时追踪该文档的所有更新(常用指令) 14)ln软链接也叫符号链接，类似于 windows 里的快捷方式，主要存放了链接其他文件的路径 ln -s [文件或目录] [软连接名称] 创建文件或目录的指定软连接 rm -rf [软连接名称] 删除指定软连接，注意不要在软连接名称后边加 / 当我们使用 pwd 指令查看目录时，仍然看到的是软链接所在目录。 15)history查看已经执行过历史命令,也可以执行历史指令 history 直接显示所有执行过的命令 history [条数] 显示最近使用指令的指定条数 ! [指令编号] 使用指令编号执行历史命令 3、时间日期指令1)date date 显示日期时间 date +%Y 显示年份 date +%m 显示月份 date +%d 显示日 date “+%Y-%m-%d %H:%M:%S” 显示年月日，时分秒 date -s “字符串时间” 设置系统日期 data -s “2020-01-10 8:33:33” 2)cal cal 显示本月日历 cal [年份] 显示指定年份的所有月份 4、搜索查找指令1)find find [搜索范围] [选项] [选项对应的条件] 搜索范围：指定目录 选项 功能 -name 按照指定的文件名查找文件 -user 按照指定的用户名查找文件 -size 按照指定大小查找文件 实例： find /home -name hello.txt 查找/home目录下的名称为hello.txt的文件 find /home -user root 查找/home目录下的用户为root的文件 find / -size +20M 查询 / 目录下大小超过20M的文件 find / -size -20M 查询 / 目录下大小小于20M的文件 find / -size 20M 查询 / 目录下等于20M的文件 find / -name \\*.txt 查询 / 目录下文件名为 .txt结尾的文件 2)locate​ locaate 指令可以快速定位文件路径。locate 指令利用事先建立的系统中所有文件名称及路径的locate 数据库实现快速定位给定的文件。Locate 指令无需遍历整个文件系统，查询速度较快。为了保证查询结果的准确度，管理员必须定期更新 locate 时刻。 由于 locate 指令基于数据库进行查询，所以第一次运行前，必须使用 updatedb 指令创建 locate 数据库。 若提示 updatedb 命令无法识别则安装 yum install mlocate updatedb 创建locate数据库 locate [文件名] 查找指定文件名 3)grep和管道符号|grep 过滤查找 ， 管道符，“|”，表示将前一个命令的处理结果输出传递给后面的命令处理。 grep [选项] [查找内容] [查找的目标文件] 在指定文件中查找指定内容并输出到控制台 [选项]可省略 -n 显示匹配行及行号 -i 忽略字母大小写 实例 hello.txt文件内容 grep hello hello.txt 在hello.txt文件中查找hello字符串(默认区分大小写) grep -n hello hello.txt 在hello.txt文件中查找hello字符串并携带行号 grep -ni hello hello.txt 在hello.txt文件中查找hello字符串(不区分大小写)并携带行号 grep联合管道操作符一同实现上述相同操作 cat hello.txt | grep -n hello 查找hello.txt文件中 字符串为hello的内容并携带行号 cat hello.txt | grep hello 查找hello.txt文件中 字符串为hello的内容 cat hello.txt | grep -ni hello 查找hello.txt文件中 字符串为hello的内容(不区分大小写)并携带行号 5、压缩和解压1)gzip/gunzip压缩文件，只能将文件压缩为*.gz 文件，当我们使用 gzip 对文件进行压缩后，不会保留原来的文件。解压后也不会保留*.gz的压缩文件 gzip [文件名] 压缩指定文件 gunzip [文件名] 解压指定文件 2)zip/unzipzip 用于压缩文件， unzip 用于解压的，这个在项目打包发布中很有用的 压缩和解压都会保留之前的文件 若没有安装则 yum install zip unzip zip [选项] xxx.zip [要压缩的文件或目录] 压缩指定的文件或目录为xxx.zip [选项]可省略 -r 递归压缩，即压缩目录 unzip [选项] xxx.zip 解压指定的zip文件 [选项]可省略 -d [解压的目录] 解压到指定目录 压缩文件 解压文件 压缩目录 解压到指定目录 3)tartar 指令 是打包指令，最后打包后的文件是 .tar.gz 的文件。 tar [选项] xxx.tar.gz [要打包的文件或目录] [选项]不可省略 -c 产生.tar打包文件 -v 显示详细信息 -f 指定压缩后的文件名 -z 打包同时压缩 -x 解压.tar文件 tar -zcvf xxx.tar.gz [文件1] [文件2] 打包多个文件并自定义命名压缩后的文件名xxx.tar.gz 打包a.txt和b.txt文件并将打包后的文件命名为myab.tar.gz tar -zcvf xxx.tar.gz [目录] 压缩指定目录到当前目录 tar -zxvf xxx.tar.gz 解压指定压缩文件到当前目录 tar -zxvf xxx.tar.gz -C [解压的指定目录] 解压指定文件到指定目录(该目录必须存在) 八、组管理 其他组：除文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组. 1、查看文件或目录的所属用户及所属组 ls -lh 或者 ll 2、创建用户的同时指定组 ①创建组 groupadd 组名 ②创建用户时指定组 useradd -g 组名 用户名 3、修改文件或目录所有者 chown [用户名] [文件名] 修改文件所有者 chown -R [用户名] [目录下的所有] 递归修该指定目录下的所有文件的所有者 （在目录后写 /* 代表所有文件） chown [用户名]:[组名] 文件 同时改变文件的所有者和所有组 4、修改文件或目录所在组 chgrp [组名] [文件名] 修改文件所在组 chgrp -R [组名] [目录位置] 递归修改指定目录下所有文件的所有组 （在目录后写 /* 代表所有文件） 5、修改用户所在组 usermod -g [组名] [用户名] 九、文件的权限管理1、文件及文件夹的权限介绍(重点) 1)rwx权限介绍①rwx作用到文件： [ r ]代表可读(read): 可以读取,查看 [ w ]代表可写(write): 可以修改,但是不代表可以删除该文件,删除一个文件的前提条件是对该文件所在的目录有写权限，才能删除该文件 [ x ]代表可执行(execute):可以被执行 ②rwx作用到目录 [ r ]代表可读(read): 可以读取，ls 查看目录内容 [ w ]代表可写(write): 可以修改,目录内创建+删除+重命名目录 [ x ]代表可执行(execute):可以进入该目录 第1位： 代表文件类型： 文件 (-),目录(d),软链接(l) 第2,3,4位： 文件拥有者的权限 第5,6,7位： 与文件拥有者同一组的用户的权限 第8,9,10位: 不与文件拥有者同组的其他用户的权限 2)其他 文件大小为字节 2、修改文件权限①使用+ 、-、= 变更权限u:所有者 g:所有组 o:其他人 a:所有人(u、g、o 的总和) =:重新赋予权限(覆盖) - :去掉权限 +:增加权限 chmod u=rwx,g=rx,o=x [文件或目录] 修改指定文件或目录的 u所有者的权限为[读写执行]，g所有组的权限为[读和执行]，o其他的人的权限为[执行] chmod u-x,g-rwx,o-rwx [文件或目录] 给指定文件或目录的 ，u用户权限去掉【执行】，g组权限去掉【读写执行】，o其他用户撤销【读写执行】 chmod a+r [文件或目录] 给指定文件或目录为所有用户赋予【读】权限 （在目录后写 /* 代表所有文件） ②通过数字变更权限r=4 w=2 x=1 例如：rwx=4+2+1=7 chmod u=rwx,g=rx,o=x [指定文件或目录] 相当于==&gt; chmod 751 [指定文件或目录] 十、定时任务调度任务调度：是指系统在某个时间执行的特定的命令或程序。 任务调度分类： ​ 1.系统工作：有些重要的工作必须周而复始地执行。如病毒扫描等 ​ 2.个别用户工作：个别用户可能希望执行某些程序，比如对 mysql 数据库的备份。 crontab [选项] 【选项】 -e 编辑crontab定时任务 -l 查询crontab任务 -r 删除当前用户所有的crontab任务 service crond restart 重启任务调度 实例 ①执行 crontab -e 进入任务调度编辑文件 ②输入任务到调度文件中保存退出，即任务调度开始 将/etc/目录下以行显示的内容覆盖到/home/ct.txt文件中。 每1分钟执行一次 cron表达式说明： 特殊符号说明： 特定任务执行案例： 1、使用shell文件来执行调度任务 案例 1)每隔一分钟，追加当前日期时间到指定文件中 ①编写文件/home/mytask.sh 添加内容 date &gt;&gt; datet.txt ②为/home/mytask.sh添加执行权限 chmod 744 /home/mytask.sh ③编辑定时任务 crontab -e 添加内容 */1 * * * * /home/mytask.sh 保存退出 ④定时任务即可生效 2) 每天凌晨 2:00 将 mysql 数据库 testdb ，备份到文件中mydb.bak。 ①先编写一个文件 /home/mytask3.sh /usr/local/mysql/bin/mysqldump -u root -proot testdb &gt; /tmp/mydb.bak ②给 mytask3.sh 一个可以执行权限 chmod 744 /home/mytask3.sh ③执行crontab -e 编辑任务调度 0 2 * * * /home/mytask3.sh 十一、Linux磁盘分区和挂载1、Linux分区1)基本原理1)Linux 来说无论有几个分区，分给哪一目录使用，它归根结底就只有一个根目录，一个独立且唯一的文件结构 , Linux 中每个分区都是用来组成整个文件系统的一部分。 2)Linux 采用了一种叫“载入”的处理方法，它的整个文件系统中包含了一整套的文件和目录， 且将一个分区和一个目录联系起来。这时要载入的一个分区将使它的存储空间在一个目录下获得。 2)查询分区情况 *lsblk-f * (巧记：老师不离开) 查看分区情况： lsblk 查看存储各分区存储大小 2、磁盘情况查询1)查询磁盘使用情况 df [选项] 【选项】可省略 -h 带单位的列表查看所有的磁盘情况 du -ach –max-depth=1 [指定目录] 查询指定目录的深度为1磁盘占用情况，默认为当前目录 -s 指定目录占用大小汇总 -h 带计量单位 -a 含文件 –max-depth=1 子目录深度为1 -c 列出明细的同时，增加汇总值 2)统计文件或文件夹个数 统计指定文件夹下的文件个数 ls -l [指定目录] | grep “^-“ | wc -l ”^-“ ：表示以 - 开头的即文件。wc：表示word count 统计指定文件夹个数 ls -l [指定目录] | grep “^d” | wc -l “^d”: 表示以d开头的文件，即文件夹 递归统计文件的个数和子文件中的文件个数 ls -lR /home | grep “^-“ | wc -l -R：递归统计 递归统计文件夹个数和子文件夹个数 ls -lR /home | grep “^d” | wc -l 3)以树状显示目录结构若没有安装此命令则 1yum intall tree tree [指定目录] 若不指定目录则显示当前目录 十二、进程管理1、进程详细信息介绍 STAT：进程状态，其中 S-睡眠，s-表示该进程是会话的先导进程，N-表示进程拥有比普通优先级更低的优先级，R-正在运行，D-短期等待，Z-僵死进程，T-被跟踪或者被停止等等 TIME：CPU 时间，即进程使用 CPU 的总时间 父进程有关介绍： • UID：用户 ID • PID：进程 ID • PPID：父进程 ID • C：CPU 用于计算执行优先级的因子。数值越大，表明进程是 CPU 密集型运算，执行优先级会降低；数值越小，表明进程是 I/O 密集型运算，执行优先级会提高 • TIME：CPU 时间，即进程使用 CPU 的总时间 2、显示系统进程ps ps -aux 【选项】 -a 显示当前终端的所有进程信息 -u 以用户格式显示进程信息 -x 显示后台进程运行参数 ps -aux | more 查询所有进程信息，并以more命令形式查看 ps -aux |grep [服务名称] 查询指定服务进程 查询ssh相关的进程服务 ps -ef | more 以全格式显示当前所有的进程，主要用于查看进程的父进程。 【选项】 -e 显示所有进程 -f 全格式 ps -ef | grep [服务名称] 主要查找指定服务的父进程 3、终止进程kill/killall若是某个进程执行一半需要停止时，或是已消了很大的系统资源时，此时可以考虑停止该进程。使用 kill 命令来完成此项任务。 kill [选项] [进程号PID] 杀死指定进程 【选项】可省略 -9 强迫进程立即停止 killall [进程名称] 通过进程名称杀死进程，也支持通配符，这在系统因负载过大而变得很慢时很有用 例如：killall grep 4、查看进程树若没有安装命令则安装 1yum -y install psmisc pstree [选项] 可以更加直观的来看进程信息 【选项】 -p 显示进程的 PID -u 显示进程的所属用户 5、服务管理systemctl服务(service) 本质就是进程，但是是运行在后台的，通常都会监听某个端口，等待其它程序的请求，比如(mysql , sshd 防火墙等)，因此我们又称为守护进程，是 Linux 中非常重要的知识点 在 CentOS7.0 后 不再使用 service ,而是 systemctl systemctl [status|stop|restart|reload|start] 服务名 对指定的服务的操作[查看状态|停止|重启|重新加载|启动] 1)防火墙管理 systemctl status firewalld 或者 firewall-cmd –state 查看防火墙状态 systemctl status firewalld 关闭防火墙 systemctl start firewalld 启用防火墙 systemctl restart firewalld 或者 firewall-cmd –reload 重启防火墙 注意： 关闭或者启用防火墙后，立即生效 ①端口的打开与关闭 firewall-cmd –zone=public –add-port=[端口]/tcp –permanent 打开TCP的指定端口 firewall-cmd –zone=public –add-port=[端口]/udp –permanent 打开UDP的指定端口 【选项】 –zone 作用域 –add-port=[端口]/tcp 添加端口，格式为：端口/通讯协议 –permanent 永久生效,没有此参数重启后失效 firewall-cmd –zone=public –remove-port=[端口]/tcp –permanent 移除开放的指定端口 firewall-cmd –query-port=[端口]/tcp 查询指定端口是否开启防火墙 firewall-cmd –list-port 查询哪些端口开放 2)使用systemctl对服务的管理centos 7 中使用systemctl工具来管理服务程序，包括了service和chkconfig https://blog.51cto.com/29498359/1910747 systemctl 列出正在运行的服务状态 systemd-cgls 以树形列出正在运行的进程，它可以递归显示控制组内容。 systemctl list-unit-files|grep enabled 查看已启动的服务列表 启动一个服务：systemctl start postfix.service 关闭一个服务：systemctl stop postfix.service 重启一个服务：systemctl restart postfix.service 显示一个服务的状态：systemctl status postfix.service 在开机时启用一个服务：systemctl enable postfix.service 在开机时禁用一个服务：systemctl disable postfix.service 查看服务是否开机启动：systemctl is-enabled postfix.service;echo $? 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556- **systemctl reload apache.service** - 重新加载一个服务的配置文件 - **systemctl daemon-reload** - 重载所有修改过的配置文件#### 6、动态进程监控top- **top** - 默认3s更新一次进程信息- **top [选项]** - [选项]可省略 - **-d [秒数]** 指定秒数更新进程信息 - **-i** 使top不显示任何闲置或者僵尸进程 - **-p** 通过指定监控进程id来仅仅监控某个进程的状态&gt; 交互操作，即输入top命令后在监控时的操作- **P** 以cpu使用率排序，默认就是此选项- **M** 以内存使用率排序- **N** 以PID排序- **q** 退出top- 按 **u** 输入 **[用户名]** 查看指定用户的进程- 按 **k** 输入 **[进程号]** 结束指定进程#### 7、查看网络连接情况及端口netstat- **netstat -lnp** - 查询所有网络连接情况- **netstat -lnp|grep [端口号]** - 根据**端口号**查找指定进程 - 【选项】 - **-a** 显示所有连接 - **-l** 仅列出在Listen(监听)的服务状态 - **-n** 拒绝显示别名，能显示数字的全部转化为数字 - **-p** 显示建立相关链接的程序名- &lt;img src=&quot;http://img.louchen.top/2020/07/20200820175141.png&quot; style=&quot;zoom:80%;&quot; /&gt;#### 8、测试网络端口的连通性telnet- **telnet [IP地址] [端口号]** - 测试指定ip地址的端口号的连通性 - ```shell #测试192.168.86.22的22端口是否连通 telnet 192.168.86.22 22 十三、RPM和YUM包管理1、RPM的使用​ 一种用于互联网下载包的打包及安装工具，它包含在某些 Linux 分发版中。它生成具有.RPM 扩展名的文件。RPM 是 RedHat Package Manager（RedHat 软件包管理工具）的缩写，类似 windows 的 setup.exe，这一文件格式名称虽然打上了 RedHat 的标志，但理念是通用的。 Linux 的分发版本都有采用（suse,redhat, centos 等等），可以算是公认的行业标准了。 1)安装包的的查询 rpm -qa 查询所安装的所有 rpm 软件包 rpm -qa | more 分页显示所有rpm软件包 rpm -qa | grep [软件包] 搜索指定本机的软件包 rpm -qi [软件包] 查询指定软件包的详细信息 rpm -ql [软件包] 查询指定软件包中安装的文件位置 rpm -qf [文件路径] 查询指定文件所属那个rpm包 2)安装包的卸载 rpm -e [软件包] 卸载指定rpm软件包 rpm -e –nodeps [软件包] 强制卸载指定rpm软件包 3)安装rpm包 rpm -ivh [安装包全路径名称] i=install 安 装 v=verbose 提 示 h=hash 进度条 2、YUM包管理(常用)Yum 是一个 Shell 前端软件包管理器。基于 RPM 包管理，能够从指定的服务器自动下载 RPM 包并且安装，可以自动处理依赖性关系，并且一次安装所有依赖的软件包。使用 yum 的前提是可以联网。 yum list|grep [软件包] 从yum服务器上查询指定软件包是否存在 yum [选项] install [软件包] 安装指定软件包 【选项】 -y 安装时全部同意 十四、java常用软件的安装1、安装jdk1.8https://blog.csdn.net/weixin_42266606/article/details/80863781 ①下载对应的jdk安装包后，解压到指定目录即可 ②编辑/etc/profile 文件来添加jdk环境变量 在文件默认增加以下内容 ③测试 java -version 查看安装的版本 编写Hello.java文件 javac Hello.java 编译此源文件 java Hello 运行此编译的class文件 2、安装tomcat8 下载解压后启动 或者进入到bin目录执行 若在虚拟机外部访问tomcat地址，则需要先关闭防火墙 systemctl stop firewalld 或者防火墙单独放行tomcat 8080端口 firewall-cmd –add-port=8080/tcp –permanent 移除放行的端口 firewall-cmd –reomve-port=8080/tcp –permanent 重启防火墙 systemctl restart firewalld 常见问题1、关于Centos7在VMware使用NAT模式无法连接网络的情况https://www.cnblogs.com/passer101/p/9899202.html 2、安装ifconfig1yum install net-tools.x86_64 3、校准日期时间(需联网)1yum -y install ntp 1ntpdate ntp1.aliyun.com 4、解决所有命令无法使用大概是/etc/profile文件的问题 1export PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin","link":"/2020/08/30/docker_linux_nginx_git_maven_gradle/Linux%E8%AF%A6%E8%A7%A3/"}],"tags":[{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"ActiveMQ","slug":"ActiveMQ","link":"/tags/ActiveMQ/"},{"name":"消息服务","slug":"消息服务","link":"/tags/%E6%B6%88%E6%81%AF%E6%9C%8D%E5%8A%A1/"},{"name":"Session","slug":"Session","link":"/tags/Session/"},{"name":"IDEA","slug":"IDEA","link":"/tags/IDEA/"},{"name":"MongoDB","slug":"MongoDB","link":"/tags/MongoDB/"},{"name":"Redis","slug":"Redis","link":"/tags/Redis/"},{"name":"Nginx","slug":"Nginx","link":"/tags/Nginx/"},{"name":"Maven","slug":"Maven","link":"/tags/Maven/"},{"name":"Spring Boot","slug":"Spring-Boot","link":"/tags/Spring-Boot/"},{"name":"RESTful","slug":"RESTful","link":"/tags/RESTful/"},{"name":"SpringBoot","slug":"SpringBoot","link":"/tags/SpringBoot/"},{"name":"Spring Security","slug":"Spring-Security","link":"/tags/Spring-Security/"},{"name":"WebSocket","slug":"WebSocket","link":"/tags/WebSocket/"},{"name":"Shiro","slug":"Shiro","link":"/tags/Shiro/"},{"name":"Java基础","slug":"Java基础","link":"/tags/Java%E5%9F%BA%E7%A1%80/"},{"name":"多数据源","slug":"多数据源","link":"/tags/%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90/"},{"name":"泛型","slug":"泛型","link":"/tags/%E6%B3%9B%E5%9E%8B/"},{"name":"代理模式","slug":"代理模式","link":"/tags/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F/"},{"name":"JAR","slug":"JAR","link":"/tags/JAR/"},{"name":"WAR","slug":"WAR","link":"/tags/WAR/"},{"name":"Ehcache","slug":"Ehcache","link":"/tags/Ehcache/"},{"name":"定时任务","slug":"定时任务","link":"/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"},{"name":"Swagger2","slug":"Swagger2","link":"/tags/Swagger2/"},{"name":"Quartz","slug":"Quartz","link":"/tags/Quartz/"},{"name":"OAuth2","slug":"OAuth2","link":"/tags/OAuth2/"},{"name":"JWT","slug":"JWT","link":"/tags/JWT/"},{"name":"反射","slug":"反射","link":"/tags/%E5%8F%8D%E5%B0%84/"},{"name":"RabbitMQ","slug":"RabbitMQ","link":"/tags/RabbitMQ/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"FastDFS","slug":"FastDFS","link":"/tags/FastDFS/"},{"name":"SSM","slug":"SSM","link":"/tags/SSM/"},{"name":"邮件服务","slug":"邮件服务","link":"/tags/%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1/"},{"name":"MySQL","slug":"MySQL","link":"/tags/MySQL/"},{"name":"Spring","slug":"Spring","link":"/tags/Spring/"},{"name":"JDK1.8","slug":"JDK1-8","link":"/tags/JDK1-8/"},{"name":"SpringMVC","slug":"SpringMVC","link":"/tags/SpringMVC/"},{"name":"Servlet","slug":"Servlet","link":"/tags/Servlet/"},{"name":"JVM","slug":"JVM","link":"/tags/JVM/"},{"name":"多线程","slug":"多线程","link":"/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"Gradle","slug":"Gradle","link":"/tags/Gradle/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"}],"categories":[{"name":"Spring Boot","slug":"Spring-Boot","link":"/categories/Spring-Boot/"},{"name":"IDEA","slug":"IDEA","link":"/categories/IDEA/"},{"name":"Redis","slug":"Redis","link":"/categories/Redis/"},{"name":"项目构建部署","slug":"项目构建部署","link":"/categories/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E9%83%A8%E7%BD%B2/"},{"name":"SpringBoot","slug":"SpringBoot","link":"/categories/SpringBoot/"},{"name":"Spring Security","slug":"Spring-Security","link":"/categories/Spring-Security/"},{"name":"Java基础","slug":"Java基础","link":"/categories/Java%E5%9F%BA%E7%A1%80/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"Spring Cache","slug":"Spring-Cache","link":"/categories/Spring-Cache/"},{"name":"SSM","slug":"SSM","link":"/categories/SSM/"},{"name":"MySQL","slug":"MySQL","link":"/categories/MySQL/"},{"name":"Spring","slug":"Spring","link":"/categories/Spring/"},{"name":"SpringMVC","slug":"SpringMVC","link":"/categories/SpringMVC/"},{"name":"JavaWeb","slug":"JavaWeb","link":"/categories/JavaWeb/"},{"name":"并发编程","slug":"并发编程","link":"/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"name":"版本管理工具","slug":"版本管理工具","link":"/categories/%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86%E5%B7%A5%E5%85%B7/"},{"name":"项目部署","slug":"项目部署","link":"/categories/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"},{"name":"容器化技术","slug":"容器化技术","link":"/categories/%E5%AE%B9%E5%99%A8%E5%8C%96%E6%8A%80%E6%9C%AF/"},{"name":"JVM","slug":"JVM","link":"/categories/JVM/"}]}