{"pages":[{"title":"关于我","text":"渣渣二本毕业，希望通过写文章的方式，提高自己的技能！","link":"/about/index.html"},{"title":"tags","text":"","link":"/tags/index.html"}],"posts":[{"title":"springboot整合JDBCTemplate及多数据源","text":"springboot整合JDBCTemplate源码分析==&gt; 当我们没有配置任何jdbcTemplate时，springboot自动为我们创建了一个jdbctemplate 当我们配置了jdbctemplate时候，自动配置失效 org.springframework.boot.autoconfigure.jdbc.JdbcTemplateConfiguration==&gt; 123456789101112131415161718192021@Configuration( proxyBeanMethods = false)@ConditionalOnMissingBean({JdbcOperations.class})class JdbcTemplateConfiguration { JdbcTemplateConfiguration() { } @Bean @Primary JdbcTemplate jdbcTemplate(DataSource dataSource, JdbcProperties properties) { JdbcTemplate jdbcTemplate = new JdbcTemplate(dataSource); Template template = properties.getTemplate(); jdbcTemplate.setFetchSize(template.getFetchSize()); jdbcTemplate.setMaxRows(template.getMaxRows()); if (template.getQueryTimeout() != null) { jdbcTemplate.setQueryTimeout((int)template.getQueryTimeout().getSeconds()); } return jdbcTemplate; }} 12345678910111213public class JdbcTemplate extends JdbcAccessor implements JdbcOperations { private static final String RETURN_RESULT_SET_PREFIX = \"#result-set-\"; private static final String RETURN_UPDATE_COUNT_PREFIX = \"#update-count-\"; private boolean ignoreWarnings = true; private int fetchSize = -1; private int maxRows = -1; private int queryTimeout = -1; private boolean skipResultsProcessing = false; private boolean skipUndeclaredResults = false; private boolean resultsMapCaseInsensitive = false; //**** //****} 单数据源配置：pom.xml 1234567891011121314151617181920212223242526272829303132&lt;dependencies&gt; &lt;!-- test --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;!--只会在测试时使用 不会被打包--&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--jdbctemplate操作--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--阿里的starter--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.18&lt;/version&gt; &lt;/dependency&gt; &lt;!--mysql驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;!--只会在项目运行和测试时有效 不会随着项目一起打包发布--&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;version&gt;5.1.27&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 12345678910111213spring:# 数据源配置 datasource:#数据源类型 type: com.alibaba.druid.pool.DruidDataSource# 驱动类 driver-class-name: com.mysql.jdbc.Driver# 数据库地址 url: jdbc:mysql://127.0.0.1:3306/test# 用户名 username: root# 密码 password: 123456 12345678public class User { private Integer id; private String username; private String address; //settter //getter //toStr·ing} 123456CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(20) DEFAULT NULL, `address` varchar(50) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8mb4; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960@Servicepublic class UserService { @Autowired private JdbcTemplate jdbcTemplate; /** * 添加操作 * @param user * @return */ public Integer addUser(User user){ return jdbcTemplate.update(\"insert into user(username,address) values(?,?)\", user.getUsername(), user.getAddress()); } /** * 删除操作 * @param integer * @return */ public Integer deleteUser(Integer integer) { return jdbcTemplate.update(\"delete from user where id =?\", integer); } /** * 更新操作 * @param user * @return */ public Integer updateUser(User user) { return jdbcTemplate.update(\"update user set address=? where id=?\", user.getAddress(), user.getId()); } /** * 获取所有 并传递参数 * 一般属性名和数据库字段名不一致时手动设置值 * @return */ public List&lt;User&gt; getAllUser(User user){ return jdbcTemplate.query(\"select * from user where address =?\",new Object[]{user.getAddress()}, new RowMapper&lt;User&gt;() { @Override public User mapRow(ResultSet resultSet, int i) throws SQLException { User user=new User(); user.setId(resultSet.getInt(\"id\")); user.setUsername(resultSet.getString(\"username\")); user.setAddress(resultSet.getString(\"address\")); return user; } }); } /** * 属性名和数据库字段名一致的情况 * @param user * @return */ public List&lt;User&gt; getAllUserSameArgs(User user){ return jdbcTemplate.query(\"select * from user where address =?\", new Object[]{user.getAddress()}, new BeanPropertyRowMapper&lt;&gt;(User.class)); }} 测试使用： 123456789101112131415161718192021222324252627282930313233@SpringBootTest(classes = JDBCTemplateApplication.class)@RunWith(SpringRunner.class)public class JDBCTemplateTest { @Autowired private UserService userService; @Test public void test01() { User user=new User(); user.setUsername(\"张三\").setAddress(\"湖北孝感\"); Integer integer = userService.addUser(user); System.out.println(integer); } @Test public void test02() { Integer integer = userService.deleteUser(1); System.out.println(integer); } @Test public void test03() { Integer integer = userService.updateUser(new User().setId(1).setAddress(\"上海\")); System.out.println(integer); } @Test public void test04() { List&lt;User&gt; allUser = userService.getAllUserSameArgs(new User().setAddress(\"武汉\")); System.out.println(allUser); }} 多数据源配置：pom.xml和单数据源一致 这里注意，在yaml文件中，属性名的字母不要写大写，大写字母前加 - 后转小写 12345678910111213141516171819#配置多数据后，所有的数据源自动配置将会失效spring:#数据源1 datasourceone: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver #传输时 使用统一的utf-8编码 url: jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=UTF-8 username: root password: 123456#数据源2 datasourcetwo: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver #传输时 使用统一的utf-8编码 url: jdbc:mysql://47.96.141.44:3306/test?useUnicode=true&amp;characterEncoding=UTF-8 username: root password: xxxxxxx 数据源配置注入==&gt; 1234567891011121314151617@Configurationpublic class DataSourceConfig { @Bean //配置前缀和yaml中的属性对应，完成属性的安全注入 @ConfigurationProperties(prefix = \"spring.datasourceone\") public DataSource dataSourceOne(){ return DruidDataSourceBuilder.create().build(); } @Bean @ConfigurationProperties(prefix = \"spring.datasourcetwo\") public DataSource dataSourceTwo(){ return DruidDataSourceBuilder.create().build(); }} jdbcTemplate配置==&gt; @Autowired 默认按照类型进行注入``（多个或者找不到报错） @Qualifier 按照名称进行配置 一般是结合起来使用==&gt; 如： @Qualifier(“dataSourceOne”)@Autowiredprivate DataSource dataSourceOne @Resource 默认直接按照名称进行注入 （可同时指定name和type一起查找注入，也可都省略）注意@Resource不能存在于方法的参数上 如： @Resource(name = “dataSourceTwo”) DataSource dataSourceTwo; 123456789101112131415@Configurationpublic class JDBCTemplateConfig { @Bean public JdbcTemplate jdbcTemplateOne(@Qualifier(\"dataSourceOne\")DataSource dataSource){ return new JdbcTemplate(dataSource); } @Resource(name = \"dataSourceTwo\")DataSource dataSource; @Bean public JdbcTemplate jdbcTemplateTwo(){ return new JdbcTemplate(dataSource); }} 这里数据库的结构和实体两个数据源中的保持一致 先从数据源一查询一个用户，再把该用户插入另一个数据源==&gt; 12345678910111213141516171819202122@Servicepublic class UserToUserService { @Qualifier(\"jdbcTemplateOne\") @Autowired private JdbcTemplate jdbcTemplateOne; @Qualifier(\"jdbcTemplateTwo\") @Autowired private JdbcTemplate jdbcTemplateTwo; public Integer userToAddUser(User user) { List&lt;User&gt; list= jdbcTemplateOne.query(\"select * from user where id =?\", new Object[]{user.getId()}, new BeanPropertyRowMapper&lt;&gt;(User.class)); if(list!=null&amp;&amp;!list.isEmpty()&amp;&amp;list.size()==1){ User resUser = list.get(0); int update = jdbcTemplateTwo.update(\"insert into user(id,username,address) values (?,?,?)\", resUser.getId(), resUser.getUsername(), resUser.getAddress()); if(update==1){ return 1; } } return 0; }} 注意：当我们有多个数据源和多个jdbcTemplate配置的时候，我们在注入jdbctemplate的时候必须加限定名，即哪个jdbctemplate。 1234567@Servicepublic class UserService { @Qualifier(\"jdbcTemplateTwo\") @Autowired private JdbcTemplate jdbcTemplate;} 否则需要在数据源和jdbctemplate配置上加默认配置 即注解@Primary 1234567891011121314151617@Configurationpublic class DataSourceConfig { @Primary @Bean @ConfigurationProperties(prefix = \"spring.datasourceone\") public DataSource dataSourceOne(){ return DruidDataSourceBuilder.create().build(); } @Bean @ConfigurationProperties(prefix = \"spring.datasourcetwo\") public DataSource dataSourceTwo(){ return DruidDataSourceBuilder.create().build(); }} 1234567891011121314151617@Configurationpublic class JDBCTemplateConfig { @Primary @Bean public JdbcTemplate jdbcTemplateOne(@Qualifier(\"dataSourceOne\")DataSource dataSource){ return new JdbcTemplate(dataSource); } @Resource(name = \"dataSourceTwo\")DataSource dataSource; @Bean public JdbcTemplate jdbcTemplateTwo(){ return new JdbcTemplate(dataSource); }} 我们在使用时，直接注入即可（默认注入标记的默认数据源） 12345@Servicepublic class UserService { @Autowired private JdbcTemplate jdbcTemplate;} 注解@Autowired 默认按照类型进行注入（多个或者找不到报错） @Qualifier 按照名称进行配置 一般是结合起来使用==&gt; 如： @Qualifier(“dataSourceOne”)@Autowiredprivate DataSource dataSourceOne @Resource 默认直接按照名称进行注入 （可同时指定name和type一起查找注入，也可都省略）注意@Resource不能存在于方法的参数上 如： @Resource(name = “dataSourceTwo”)DataSource dataSourceTwo; @Primary当有多个配置文件时 标记为默认的注入配置","link":"/2020/04/17/multipledatasource/%E6%95%B4%E5%90%88JDBCTemplate%E5%8F%8A%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90/"},{"title":"Git基本操作","text":"1、添加、提交、推送123456789101112131415161718192021//直接克隆代码git clone 'https://gitee.com'//初始化仓库git init//添加所有文件到暂存区git add . //提交到仓库区&lt;!-- more --&gt;git commit -m '添加的消息' //初始添加远端仓库地址git remote add origin 'https://gitee.com'//将本地的master分支推送到远端主机master，同时指定origin为默认主机，以后直接使用git pushgit push -u origin master 或者 git push --set-upstream origin master//推送当前分支到已设置的远端地址git push//提交到远端的指定分支git push origin branchName//推送到远端地址(默认推送当前分支)git push 'https://gitee.com' //推送到远端地址的master分支git push 'https://gitee.com' master 2、分支操作12345678910111213141516//创建分支git branch branchName//切换分支git checkout branchName//创建并切换分支git checkout -b branchName//查看所有分支 有 * 的为当前分支git branch //将当前分支合并到指定分支（合并后的分支，对合并之前的当前分支和指定分支都有影响）git merge branchName//将当前分支移动到指定分支，当做指定分支的子节点。指定分支再移动到子节点即到同一分支git rebase branchName//从远程仓库下载本地仓库中缺失的提交记录 更新远程分支指针git fetch//拉取代码 相当于git pull 和 git fetchgit pull","link":"/2020/04/17/git/git%E6%9E%81%E7%AE%80/"},{"title":"SpringBoot整合ActiveMQ","text":"SpringBoot整合ActiveMQ一、安装ActiveMQ这里我们采用docker安装 1、搜索镜像docker search activemq 2、拉取镜像 docker pull webcenter/activemq 3、初始化容器61616 为通信端口 8161 为管理界面 docker run -d --name activemq01 -p 61616:61616 -p 8161:8161 webcenter/activemq 4、访问activemqxxx.xxx.xxx.xxx:8161 默认用户名和密码为 admin/admin 二、springboot整合ActiveMQ1、pom.xmlspring-boot-starter-activemq 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;activemq&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;activemq&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-activemq&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、实体消息bean12345678910111213@Getter@Setter@ToStringpublic class Message implements Serializable { /** * 发送的消息内容 */ private String content; /** * 发送的日期 */ private Date sendDate;} 3、队列配置1234567891011@Configurationpublic class QueueConfig { /** * 新建队列 * @return */ @Bean Queue queue() { return new ActiveMQQueue(\"hello.lc\"); }} 4、jms配置 1234567891011121314151617181920212223242526272829303132@Componentpublic class JmsComponent { /** * jms(java messgae service(java消息服务) )消息模板 */ @Autowired JmsMessagingTemplate jmsMessagingTemplate; @Autowired Queue queue; /** * 生产者 * @param message */ public void send(Message message) { //发送的目的地(指定队列) ; 发送的消息对象 jmsMessagingTemplate.convertAndSend(this.queue,message); } /** * 消费者 * JmsListener监听消息队列 destination 指定队列的名称 * @param message */ @JmsListener(destination = \"hello.lc\") public void receive(Message message){ System.out.println(message); }} 4、properties配置1234567#activemq代理的urlspring.activemq.broker-url=tcp://47.96.141.44:61616#发送消息时可为字符串或者一个对象。若为一个对象，则需要设为true#信任所有的包 如果传输的对象是Obeject 这里必须加上这句或者指定信任的包 否则会导致对象序列化失败spring.activemq.packages.trust-all=truespring.activemq.user=adminspring.activemq.password=admin 5、测试使用12345678910111213141516@SpringBootTestclass ActivemqApplicationTests { //默认注入单例 @Autowired JmsComponent jmsComponent; @Test void contextLoads() { Message message = new Message(); message.setContent(\"hello lc\"); message.setSendDate(new Date()); jmsComponent.send(message); }}","link":"/2020/04/17/mq/SpringBoot%E6%95%B4%E5%90%88ActiveMQ/"},{"title":"springboot整合MongoDB","text":"springboot整合MongoDB一、docker安装mongodb1、拉取最近的镜像docker pull 2、初始化mongo容器 -d 后台运行 -p 端口映射 –name 容器名称 –restar docker每次重启后，该容器也启动 -e 参数设置 初始化用户名为root 密码为你的密码 docker run -d -p 27017:27017 --name mongo01 --restart=always -e MONGO_INITDB_ROOT_USERNAME=root -e MONGO_INITDB_ROOT_PASSWORD=你的密码 mongo 3、每个数据库有独立的账号和密码①进入容器docker exec -it 容器id bash ②进入mongomongo ③切换到admin数据库use admin ④添加用户操作的对应数据库db.createUser({user:&quot;admin&quot;,pwd:&quot;xiiasdfiik34&quot;,roles:[{role: 'root', db: 'admin'}]}) ⑤ 验证db.auth('admin', 'xiiasdfiik34') // 返回1 就是认证成功 二、使用MongoRepository1、pom.xmlspring-boot-starter-data-mongodb 1234567891011121314151617181920212223&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2、yaml配置1234567891011spring: data: mongodb: # mongodb每个库都有自己的认证方式 authentication-database: lc username: root password: 你的密码 port: 27017 database: lc uri: mongodb://root:你的密码@47.96.141.44:27017/lc# host: 47.96.141.44 3、实体12345678@Getter@Setter@ToStringpublic class Book { private Integer id; private String name; private String author;} 4、dao接口123456789101112131415/** * 继承MongoRepository * 第一个参数为 操作的实体 * 第二个参数为 操作的主键类型 */public interface BookDao extends MongoRepository&lt;Book,Integer&gt; { /** * 和jap一致 遵循方法名称的表达式进行查询 * @param name * @return */ List&lt;Book&gt; findBooksByNameContaining(String name);} 5、测试使用12345678910111213141516171819202122232425262728@RunWith(SpringRunner.class)@SpringBootTest(classes = RedisApplication.class)public class mongoTest { @Autowired private BookDao bookDao; //插入一条数据 @Test public void Test1() { Book b = new Book(); b.setId(3); b.setName(\"红楼梦\"); b.setAuthor(\"曹雪芹\"); bookDao.insert(b); } @Test public void Test2() { //查询所有 List&lt;Book&gt; all = bookDao.findAll(); System.out.println(all); //查询包含书名称为 “红” 的book //这里满足名称表达式 和jpa类似 List&lt;Book&gt; list = bookDao.findBooksByNameContaining(\"红\"); System.out.println(list); }} 三、使用MongoTemplate1、pom.xml和上面配置一致 2、yaml配置和上面配置一致 3、实体和上面配置一致 4、直接使用（和RedisTmeplate类似）12345678910111213141516171819202122@RunWith(SpringRunner.class)@SpringBootTest(classes = RedisApplication.class)public class mongoTest { @Autowired private MongoTemplate mongoTemplatel; @Test public void Test3() { Book book = new Book(); book.setId(4); book.setName(\"水浒传\"); book.setAuthor(\"施耐庵\"); //插入数据 mongoTemplatel.insert(book); //查询所有 List&lt;Book&gt; all = mongoTemplatel.findAll(Book.class); System.out.println(all); }}","link":"/2020/04/17/nosql/springboot%E6%95%B4%E5%90%88mongodb/"},{"title":"Maven基础知识","text":"1、dependencyManagement和dependencies的区别 123456789101112131415161718192021222324 &lt;!--定义父版本--&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.4.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt;&lt;dependencies&gt; &lt;dependency&gt; &lt;!--如果没有指定版本 则使用父版本 否则使用指定的版本--&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--json格式工具--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; ①定义 123 在Maven中dependencyManagement的作用其实相当于一个对所依赖jar包进行版本管理的管理器。 在dependencyManagement下申明的dependencies，Maven并不会去实际下载所依赖的jar包，而是 在dependencyManagement中用一个Map记录了jar的三维坐标。 ②jar的版本1234567 这个是一个重要的概念，也是dependencyManagement独有的特色。 1：如果dependencies里的dependency自己没有声明version元素，那么maven就 会倒dependencyManagement里面去找有没有对该artifactId和groupId进行过版本声明，如果有，就继承它，如果没有就会报错，告诉你必须为dependency声明一个version 2：如果dependencies中的dependency声明了version，那么无论dependencyManagement中有无对该jar的version声明，都以dependency里的version为准。 2、maven 常用命令(工具)①clean1清除项目中编译文件和本地仓库中已打包的文件 ②compile1编译项目中的java文件，并存放在项目的编译目录（根据不同的配置，编译目录也不一样） ③test1运行项目中的测试用例文件，如果测试用例未通过，也会打包失败，另，这里的test过程可以在pom中通过配置跳过 ④package123依次执行了clean、resources、compile、testResources、testCompile、test、jar(打包)等７个阶段。package命令完成了项目编译、单元测试、打包功能，但没有把打好的可执行jar包（war包或其它形式的包）布署到本地maven仓库和远程maven私服仓库 ⑤install123依次执行了clean、resources、compile、testResources、testCompile、test、jar(打包)、install等8个阶段install命令完成了项目编译、单元测试、打包功能，同时把打好的可执行jar包（war包或其它形式的包）布署到本地maven仓库，但没有布署到远程maven私服仓库 ⑥deploy123依次执行了clean、resources、compile、testResources、testCompile、test、jar(打包)、install、deploy等９个阶段。deploy命令完成了项目编译、单元测试、打包功能，同时把打好的可执行jar包（war包或其它形式的包）布署到本地maven仓库和远程maven私服仓库 3、dependency中scope的用法 compile，缺省值，适用于所有阶段，会随着项目一起发布。 provided，类似compile，期望JDK、容器或使用者会提供这个依赖。如servlet.jar。 runtime，只在运行时使用，如JDBC驱动，适用运行和测试阶段。 test，只在测试时使用，用于编译和运行测试代码。不会随项目发布。 system，类似provided，需要显式提供包含依赖的jar，Maven不会在Repository中查找它。 123456&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;version&gt;1.16.20&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt;&lt;/dependency&gt; 依赖范围控制哪些依赖在哪些classpath 中可用，哪些依赖包含在一个应用中。让我们详细看一下每一种范围： ① compile （编译范围）compile是默认的范围；如果没有提供一个范围，那该依赖的范围就是编译范围。编译范围依赖在所有的classpath 中可用，同时它们也会被打包。 ②provided （已提供范围）provided 依赖只有在当JDK 或者一个容器已提供该依赖之后才使用。例如， 如果你开发了一个web 应用，你可能在编译 classpath 中需要可用的Servlet API 来编译一个servlet，但是你不会想要在打包好的WAR 中包含这个Servlet API；这个Servlet API JAR 由你的应用服务器或者servlet 容器提供。已提供范围的依赖在编译classpath （不是运行时）可用。它们不是传递性的，也不会被打包。 ③runtime （运行时范围）runtime 依赖在运行和测试系统的时候需要，但在编译的时候不需要。比如，你可能在编译的时候只需要JDBC API JAR，而只有在运行的时候才需要JDBC驱动实现。 ④test （测试范围）test范围依赖 在一般的编译和运行时都不需要，它们只有在测试编译和测试运行阶段可用。 ⑤system （系统范围）system范围依赖与provided 类似，但是你必须显式的提供一个对于本地系统中JAR 文件的路径。这么做是为了允许基于本地对象编译，而这些对象是系统类库的一部分。这样的构件应该是一直可用的，Maven 也不会在仓库中去寻找它。如果你将一个依赖范围设置成系统范围，你必须同时提供一个 systemPath 元素。注意该范围是不推荐使用的（你应该一直尽量去从公共或定制的 Maven 仓库中引用依赖）。 4、指定maven编译 Compiler插件编译时和编译后运行的JVM版本12345678910111213&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;source&gt;8&lt;/source&gt; &lt;target&gt;8&lt;/target&gt; &lt;encoding&gt;utf-8&lt;/encoding&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 5、idea创建项目Group: 会作为包名的前一部分 Artifact: 会作为包的最后一部分 例如：Group：com.mybatis ​ Artifact: spring-boot-lc-mybatis 然后设置项目名 随便设置，不会影响项目内容 最后生成的项目： 12&lt;groupId&gt;com.mybatis&lt;/groupId&gt;&lt;artifactId&gt;spring-boot-lc-mybatis&lt;/artifactId&gt; 生成的包名： com.mybatis.springbootlcmybatis 6、Maven 中 SHAPSHOT 和 RELEASE 版本的区别？1、Snapshot版本代表不稳定、尚处于开发中的版本 2、Release版本则代表稳定的版本","link":"/2020/04/17/projectBuildAndDev/Maven%E7%9A%84%E4%BD%BF%E7%94%A8/"},{"title":"SpringBoot应用监控可视化","text":"SpringBoot应用监控可视化Spring Boot Admin监控系统SBA则是基于Actuator更加进化了一步，其是一个针对Actuator接口进行UI美化封装的监控工具。 一、创建服务端1.pom.xmlspring-boot-admin-starter-server 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;admin&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;admin&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-boot-admin.version&gt;2.2.1&lt;/spring-boot-admin.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-starter-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-dependencies&lt;/artifactId&gt; &lt;version&gt;${spring-boot-admin.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、启用Spring Boot Admin12345678@SpringBootApplication//开启admin服务@EnableAdminServerpublic class AdminApplication { public static void main(String[] args) { SpringApplication.run(AdminApplication.class, args); }} 3、访问监控页面 localhost:8080/index.html ![](F:\\桌面内容\\springboot2\\springboot应用监控\\images\\批注 2020-04-08 210708.png) 二、创建client(监控的Spring Boot应用)1、pom.xmlspring-boot-admin-starter-client spring-boot-starter-actuator 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;client&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;client&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-boot-admin.version&gt;2.2.1&lt;/spring-boot-admin.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-starter-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-dependencies&lt;/artifactId&gt; &lt;version&gt;${spring-boot-admin.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、配置客户端的一些信息12345#暴露所有端口信息management.endpoints.web.exposure.include=*server.port=8081#声明该客户端的url地址spring.boot.admin.client.url=http://localhost:8080 3、启动该程序三、访问服务端监控页面 localhost:8080/index.html ![](F:\\桌面内容\\springboot2\\springboot应用监控\\images\\批注 2020-04-08 211142.png)","link":"/2020/04/17/projectcontrol/SpringBoot%E5%BA%94%E7%94%A8%E7%9B%91%E6%8E%A7%E5%8F%AF%E8%A7%86%E5%8C%96/"},{"title":"springboot实现session共享","text":"一、springboot实现session共享注意①redis的配置和springSecutiy的引入 1、基本配置①pom.xml spring-session-data-redis spring-boot-starter-data-redis spring-boot-starter-security 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;redis&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--spring session 与redis应用基本环境配置,需要开启redis后才可以使用，不然启动Spring boot会报错 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; ②yaml配置12345678910111213spring: redis:# 主机 host: 47.96.141.44# 默认使用的数据库（第一个） database: 0 port: 6379 password: 你的密码# 配置lettuce连接池的相关属性#需要设置启动的服务器server: port: 8080 ③控制器123456789101112131415161718@RestControllerpublic class UserController { // 这个必须配置启动的服务器 @Value(\"${server.port:8080}\") Integer port; @GetMapping(\"/set\") public String set(HttpSession httpSession){ httpSession.setAttribute(\"name\", \"lcc\"); return String.valueOf(port); } @GetMapping(\"/get\") public String get(HttpSession httpSession) { return (String) httpSession.getAttribute(\"name\")+port; }} ④模拟两个服务器启动分别启动两个不同端口的jar包==&gt; 服务器1==&gt; java -jar redis-1.0-SNAPSHOT.jar --server.port=8080 服务器2==&gt; java -jar redis-1.0-SNAPSHOT.jar --server.port=8081 请求8080的set接口：http://localhost:8080/set 设置session值 请求8081的get接口：http://localhost:8081/get 得到session值 结论:==&gt; 这时我们发现请求的服务1的接口输入user用户名和密码后，再去请求服务器2的接口后无需输入user和密码， 因为此时redis中，已经帮我们存取了session的详细对象。即操作的为同一个session。 2、使用nginx服务器很简单，进入 Nginx 的安装目录的 conf 目录下（默认是在 /usr/local/nginx/conf），编辑 nginx.conf 文件: 在这段配置中： upstream 表示配置上游服务器 javaboy.org 表示服务器集群的名字，这个可以随意取名字 upstream 里边配置的是一个个的单独服务 weight 表示服务的权重，意味者将有多少比例的请求从 Nginx 上转发到该服务上 location 中的 proxy_pass 表示请求转发的地址，/ 表示拦截到所有的请求，转发转发到刚刚配置好的服务集群中 proxy_redirect 表示设置当发生重定向请求时，nginx 自动修正响应头数据（默认是 Tomcat 返回重定向，此时重定向的地址是 Tomcat 的地址，我们需要将之修改使之成为 Nginx 的地址）。 配置完成后，将本地的 Spring Boot 打包好的 jar 上传到 Linux ，然后在 Linux 上分别启动两个 Spring Boot 实例： 12nohup java -jar sessionshare-0.0.1-SNAPSHOT.jar --server.port=8080 &amp;nohup java -jar sessionshare-0.0.1-SNAPSHOT.jar --server.port=8081 &amp; 其中 nohup 表示当终端关闭时，Spring Boot 不要停止运行 &amp; 表示让 Spring Boot 在后台启动 配置完成后，重启 Nginx： 1/usr/local/nginx/sbin/nginx -s reload Nginx 启动成功后，我们首先手动清除 Redis 上的数据，然后访问 192.168.66.128/set 表示向 session 中保存数据，这个请求首先会到达 Nginx 上，再由 Nginx 转发给某一个 Spring Boot 实例： 如上，表示端口为 8081 的 Spring Boot 处理了这个 /set 请求，再访问 /get 请求： 可以看到，/get 请求是被端口为 8080 的服务所处理的。","link":"/2020/04/17/nosql/springboot%E5%AE%9E%E7%8E%B0session%E5%85%B1%E4%BA%AB/"},{"title":"Redis位图的操作","text":"Redis位图的操作一、基本介绍​ 用户一年的签到记录，如果你用 string 类型来存储，那你需要 365 个 key/value，操作起来麻烦。通过位图可以有效的简化这个操作。 它的统计很简单： 01111000111 ​ 每天的记录占一个位，365 天就是 365 个位，大概 46 个字节，这样可以有效的节省存储空间，如果有一天想要统计用户一共签到了多少天，统计 1 的个数即可。 对于位图的操作，可以直接操作对应的字符串（get/set），可以直接操作位（getbit/setbit）. 二、基本操作1、零存整取存储的方式以二进制形式，取出的方式以字符串 例如：存储字符串Java 字符 ASCII 十进制 J 74 01001010 a 97 01100001 v 118 01110110 在redis中使用set [key] [offset] [value]的形式设置当前字母的bit位，设置1的位置即可，0无需设置 修改 key 对应的 value 在 offset(偏移) 处的 bit 值 设置J set name 1 1 set name 4 1 set name 6 1 设置a set name 9 1 set name 10 1 set name 15 1 设置v set name 17 1 set name 18 1 set name 19 1 set name 21 1 set name 22 1 设置a set name 25 1 set name 26 1 set name 31 1 取出字符串: 1get name #==&gt; \"Java\" 2、整存零取存一个字符串进去，但是通过位操作获取字符串 设置值： 1set k1 louchen.top 此时字符串一共有11*8位=88个二进制字符 获取二进制位： key 对应的 value 在 offset 处的 bit 值。 getbit [key] [offset] 1234getbit k1 0getbit k1 1......getbit k1 87 三、统计1、bitcount统计二进制中1的个数 注意：这里的start和end表示字符的起始（包含start,end），而不是bit位的起始 bitcount [key] [start] [end] 2、bitpos统计在0或1第一次出现的位置 bit ：0或1 start/end: 字符出现的位置(包含start，end),不是bit位的起始 bitpos [key] [bit] [start] [end] 四、Bit批处理在 Redis 3.2 之后，新加了一个功能叫做 bitfiled ，可以对 bit 进行批量操作。 1、bitfield单个获取BITFIELD name get u4 0 表示获取 name 中的位，从 0 开始获取，获取 4 个位，返回一个无符号数字。 u 表示无符号数字 i 表示有符号数字，有符号的话，第一个符号就表示符号位，1 表示是一个负数。 BITFIELD name get u4 0 即 0100 ==&gt; 6 BITFIELD name get i4 0 即0100 ==&gt; 6 bitfield name get u4 1 即 1001==&gt;9 bitfield name get i4 1 即 1001 ，首位为1那么这个二进制位负数 ，则 -8+1=-7 批量获取：bitfield name get u4 1 get i4 1 get u4 0 get i4 0 2、setfieldbitfield name set u8 8 98 表示从第8位开始获取8个无符号二进制位大小的数替换为98 此时的Java==&gt;Jbva 3、incrby对指定范围进行自增操作，自增操作可能会出现溢出，既可能是向上溢出，也可能是向下溢出。Redis 中对于溢出的处理方案是折返。 8位无符号数 255 加 1 溢出变为 0；8 位有符号数 127，加 1 变为 - 128. 默认的的溢出策略： 在Jbva基础上操作 bitfield name incrby u2 6 1 设置第6位开始，将2个bit位后面加1 ，即10 加1，得 11 ==&gt; 01001011 get name ==&gt; &quot;Kbva&quot; bitfield name incrby u2 6 1 还是从第六位开始，在两个bit位后面加1，即 11 加 1，溢出。 则将这两位全部置为0 ==&gt; 01001000 get name ==&gt; &quot;Hbva&quot; 修改默认的溢出策略： 在我们对Hbva基础上操作 H: 010010 00 fail策略： bitfield name overflow fail incrby u2 6 1 执行上述命令三次 get name ==&gt; &quot;Kbva&quot; 此时K: 010010 11 再次执行 bitfield name overflow fail incrby u2 6 1 1) (nil) 操作失败！ 此时的值还是为 “Kbva” sat策略 bitfield name overflow fail incrby u2 6 1 无论执行多少次，值还是不会变。保持原来的最大或最小值 1) (integer) 3","link":"/2020/04/25/redis/Redis%E4%BD%8D%E5%9B%BE%E6%93%8D%E4%BD%9C/"},{"title":"SpringBoot邮件监控报警","text":"SpringBoot邮件监控报警但我们要用SBA(Spring-Boot-Admin)实现应用的监控并实时了解应用的上下线时，我们可以使用邮件报警的方式 一、服务端配置1、pom.xmlspring-boot-admin-starter-server spring-boot-starter-mail 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;admin&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;admin&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-boot-admin.version&gt;2.2.1&lt;/spring-boot-admin.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-starter-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-dependencies&lt;/artifactId&gt; &lt;version&gt;${spring-boot-admin.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、properties配置12345678910111213141516171819202122#指定邮件服务器的地址 这里我们使用qq的smtp服务器发送邮件spring.mail.host=smtp.qq.com# 服务器的端口号修改成465或587；spring.mail.port=587# 邮件发送者的邮件spring.mail.username=421192425@qq.com# 这里使用的为授权码（不能使用邮箱密码）spring.mail.password=eqsdqizwdnenbgif#设置默认编码spring.mail.default-encoding=UTF-8#设置ssl协议spring.mail.properties.mail.smtp.socketFactory.class=javax.net.ssl.SSLSocketFactory#打印发送邮件的日志spring.mail.properties.mail.debug=true#邮件发送给谁spring.boot.admin.notify.mail.to=421192425@qq.com#谁发的spring.boot.admin.notify.mail.from=421192425@qq.com#忽略的事件（这里没有配置，则应用的上线和下线都要发送邮件）spring.boot.admin.notify.mail.ignore-changes= 3、开启admin服务12345678@SpringBootApplication//开启admin服务@EnableAdminServerpublic class AdminApplication { public static void main(String[] args) { SpringApplication.run(AdminApplication.class, args); }} 二、客户端配置(监控的应用)1、pom.xmlspring-boot-starter-actuator spring-boot-admin-starter-client 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;client&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;client&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;spring-boot-admin.version&gt;2.2.1&lt;/spring-boot-admin.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-starter-client&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;de.codecentric&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-admin-dependencies&lt;/artifactId&gt; &lt;version&gt;${spring-boot-admin.version}&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、客户端信息配置12345#暴露所有端口信息management.endpoints.web.exposure.include=*server.port=8081#声明该客户端的url地址spring.boot.admin.client.url=http://localhost:8080 3、启动应用三、应用上下线邮件提示1、上线邮件模板spring-boot-application (65685b0ef8f8) is UPInstance 65685b0ef8f8 changed status from UNKNOWN to UP Status DetailsRegistrationService Url http://LAPTOP-LJJM9R29:8081/Health Url http://LAPTOP-LJJM9R29:8081/actuator/healthManagement Url http://LAPTOP-LJJM9R29:8081/actuator 2、下线邮件模板spring-boot-application (65685b0ef8f8) is OFFLINEInstance 65685b0ef8f8 changed status from UP to OFFLINE Status Detailsexceptionio.netty.channel.AbstractChannel$AnnotatedConnectExceptionmessageConnection refused: no further information: LAPTOP-LJJM9R29/169.254.1.137:8081RegistrationService Url http://LAPTOP-LJJM9R29:8081/Health Url http://LAPTOP-LJJM9R29:8081/actuator/healthManagement Url http://LAPTOP-LJJM9R29:8081/actuator","link":"/2020/04/17/projectcontrol/SpringBoot%E9%82%AE%E4%BB%B6%E7%9B%91%E6%8E%A7%E6%8A%A5%E8%AD%A6/"},{"title":"IDEA快捷键详解","text":"一、idea快捷键1234567891011121314151617181920212223242526272829303132333435363738394041ctrl + D 赋值ctrl + y 删除该行ctrl + / 单行注释ctrl +shift +/ 多行注释ctrl +alt +T 快速插入包围的代码 try catch if whilectrl + alt +v 快速生成返回类型ctrl + alt +L 整理代码格式ctrl+shift+F10 执行代码ctrl+shift+alt+N 搜索类ctrl+F12 查看当前类下的所有方法ctrl+alt+b 查看所有实现或继承该接口的类ctrl+o 查看可重写该类 方法ctrl+h 查看该类的继承数关系ctrl+w 按照范围由小到大选择代码区域ctrl+f9 重新编译ctrl+N 全局查找ctrl+shift+N 查找ctrl+F 当前文件查询ctrl+R 查找替换ctrl+E 弹出最近使用的文件ctrl+F4 关闭当前窗口ctrl+alt+shift+u 展示树状图类的继承关系ctrl+insert 复制选中的内容ctrl+shift 粘贴选中的内容ctrl+shift+u 将选中的单词全部转为大写/小写Ctrl+shift+enter 整理当前行代码格式/结束当前语句/加分号ctrl+j 插入代码模板shift+enter 换行shift 搜索全局文件shift + F6 选中文件和文件夹 修改名称shift+alt 鼠标点击多出，生成多个光标alt+Enter 快速导包alt+/ 代码提示alt+insert 快速插入属性，tostring 构造函数alt+insert 选中文件夹，快速创建一个文件alt+E 打开最近的文件选中项目+F4 //查看项目结构配置选中文件夹+F6 //移动文件夹到别的目录 二、代码多选和多选换行：多选换行：按住alt键选中多行，再按shift后回车。可多选换行。三、强制刷新浏览器12CTRL+F5 //强制刷新浏览器（清除缓存保留的js和css,等）CTRL+sift+del //快捷键 清除浏览器cookie和session 四、定义代码片段1、定义list后缀补全片段①File–&gt;Setting–&gt;Editor–&gt;General–&gt;Postfix Completion ②点击＋号–&gt;选择java–&gt;输入key为list–&gt;选择java1.8及以上(Minimum language level:8-lambdas,type annotations etc) ③定义表达式： 1List&lt;$EXPR$&gt; $END$ =new ArrayList&lt;&gt;(); ④使用： 1集合类型.list 2、定义mapper.xml模板①File–&gt;New–&gt;Edit File Templates–&gt;默认在Files下 ②点击+号–&gt;输入Name为模板名称–&gt;Extension为文件扩展类型 ③定义模板内容： 123456&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" &gt;&lt;mapper namespace=\"#[[$Title$]]#\"&gt; &lt;/mapper&gt; ④勾选√ Enabled Live Templates (启用激活模板) 3、定义单元测试片段①ctrl+j–&gt;点击灯泡–&gt; 或者 File–&gt;Setting–&gt;Editor–&gt;Live Templates ②点击+号–&gt;自定义一个组(Template Group)/直接定义一个片段(Live Tempalte)–&gt;在Abbreviation输入片段名称–&gt;输入描述 ③定义代码片段： $name$ :变量输入的位置 $END$: 光标最后的停留位置 1234@Testpublic void $name$Test(){ $END$} ④点击Define ， 勾选只在java中使用","link":"/2020/04/17/other/idea%E4%BD%BF%E7%94%A8/"},{"title":"Redis正确安装的几种姿势","text":"Redis正确安装的几种姿势一、在线体验RedisRedis官网 http://try.redis.io/ ####二、直接编译安装 1、准备gcc环境 基于c++1yum install gcc-c++ 2、下载安装Redis12345678910#下载安装包wget http://download.redis.io/releases/redis-5.0.8.tar.gz#解压tar -zxvf redis-5.0.8.tar.gz #切换到解压目录cd redis-5.0.8#编译make#安装make install 3、启动Redis1redis-server redis.conf 4、后台启动Redis1234#修改安装目录下的 redis.conf文件daemonize no 变更为: daemonize yes #保存退出，再次启动redis-server redis.conf 5、关闭redis①redis-cli shutdown②kill -9 ‘pid’12#搜索到该进程 强行关闭ps -ef|grep redis 6、redis外网访问并设置永久密码修改redis.conf文件 12345bind 127.0.0.1注释掉，即变更为：#bind 127.0.0.1#去掉保护模式(有密码时无需设置)protected-mode yes 修改为 protected-mode no #设置永久密码(默认无需密码)#requirepass footbared 修改为 requirepass 自己的密码 7、进入命令行1redis-cli -a '密码' 三、docker安装(推荐方式)1、镜像安装与容器创建1234//拉取镜像docker pull redis//创建容器 --requirepass 123 设置密码123docker run -d -p 6379:6379 --restart=always --name myredis 镜像名 --requirepass 123 2、查看redis版本docker exec -it 9a7d1cf2c234 redis-cli -v //查看版本 3、修改redis密码（临时，重启失效）①进入redis管理页面不带密码进入（进入后需验证）==&gt; docker exec -it 9a7d1cf2c234 redis-cli //进入redis管理界面 带密码进入（进入后无需验证）==&gt; docker exec -it 9a7d1cf2c234 redis-cli -a '密码' //带密码进入管理界面 ②查询密码config get requirepass //查看密码(初始为空) ③设置密码config set requirepass 密码 //设置密码 ④验证密码auth 密码 //验证密码才能够进行查询密码和设置密码等操作 4、redis-cli连接docker上的redis①宿主机上的客户端(redis-cli)连接docker中的服务端1redis-cli -a '密码' ②进入docker容器中操作服务端1docker exec -it 9a7d1cf2c234 redis-cli 四、直接安装centos:1yum insatll redis ubuntu:1apt-get install redis mac:1brew install redis","link":"/2020/04/20/redis/Redis%E5%AE%89%E8%A3%85%E6%96%B9%E5%BC%8F/"},{"title":"Jedis和Letture客户端连接Redis","text":"Jedis和Letture客户端连接Redis一、JedisJedis官网地址： https://github.com/xetorthio/jedis 基本配置使用①、pom.xml1234567&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt; ②、简单的配置12345678910111213141516171819public class MyJedis { public static void main(String[] args) {// 1、构造一个jedis对象，并设置端口（默认6379） Jedis jedis=new Jedis(\"47.96.141.44\",6379);// 2、密码验证 jedis.auth(\"你的密码\");// 3、测试是否连接成功 String ping = jedis.ping();// 输出pong 表示连接成功 System.out.println(ping);// 在jedis中，操作键值的方法和在Redis命令行中的api完成一致。这里不再过多赘述// jedis.set()// jedis.zadd()// jedis.hset()// jedis.lpush()// jedis.sadd() }} ②、连接池配置在实际应用中，Jedis 实例我们一般都是通过连接池来获取，由于 Jedis 对象不是线城安全的，所以，当我们使用 Jedis 对象时，从连接池获取 Jedis，使用完成之后，再还给连接池。 12345678910111213141516171819 public static void main(String[] args) { Jedis jedis=null;// 1、构造一个jedis连接池 JedisPool pool = new JedisPool(\"47.96.141.44\", 6379);// 2、从连接池中获取一个jedis连接 jedis = pool.getResource(); try {// 3、jedis测试连接操作 String ping = jedis.ping(); System.out.println(ping); } catch (Exception e) { e.printStackTrace(); } finally {// 4、归还连接 if (jedis!=null) { jedis.close(); } } } try语法糖的使用： 这里我们使用一个语法糖，只是一种简写的方式，编译最后其实还是转为try-catch-finally的形式 1234567891011public static void main(String[] args) {// 1、构造一个jedis连接池 JedisPool pool = new JedisPool(\"47.96.141.44\", 6379);// 2、从连接池中获取一个jedis连接 try(Jedis jedis = pool.getResource()){// 认证密码 jedis.auth(\"你的密码\"); String ping=jedis.ping(); System.out.println(ping); } } 最后的编译的文件 1234567891011121314151617181920212223242526public static void main(String[] args) { JedisPool pool = new JedisPool(\"47.96.141.44\", 6379); Jedis jedis = pool.getResource(); Throwable var3 = null; try { jedis.auth(\"你的密码\"); String ping = jedis.ping(); System.out.println(ping); } catch (Throwable var12) { var3 = var12; throw var12; } finally { if (jedis != null) { if (var3 != null) { try { jedis.close(); } catch (Throwable var11) { var3.addSuppressed(var11); } } else { jedis.close(); } } } } ③、对连接池的改进，实现强约束 CallWithJedis 123public interface CallWithJedis { void call(Jedis jedis);} Redis 12345678910111213141516171819202122232425262728293031public class Redis { private JedisPool jedisPool; public Redis() {// 连接池配置对象 GenericObjectPoolConfig config=new GenericObjectPoolConfig();// 连接池最大空闲数 config.setMaxIdle(300);// 最大连接数 config.setMaxTotal(1000);// 连接最大等待时间（毫秒）。-1表示无限制 config.setMaxWaitMillis(30000);// 在空闲时检查有效性 config.setTestOnBorrow(true); /** * 1、连接池配置 * 2、redis地址 * 3、端口 * 4、超时时间 * 5、密码 */ jedisPool = new JedisPool(config, \"47.96.141.44\",6379,30000,\"你的密码\"); } public void execute(CallWithJedis callWithJedis) { try (Jedis jedis=jedisPool.getResource()) { callWithJedis.call(jedis); } }} 测试使用： 1234567891011public class JedisPoolUtil { public static void main(String[] args) {// 初始化连接池 Redis redis=new Redis();// 完成jedis的获取，并执行实现 redis.execute(jedis -&gt; { String ping = jedis.ping(); System.out.println(ping); }); }} 二、Lettureletture官网地址：https://github.com/lettuce-io/lettuce-core 基本配置使用①、pom.xml12345&lt;dependency&gt; &lt;groupId&gt;io.lettuce&lt;/groupId&gt; &lt;artifactId&gt;lettuce-core&lt;/artifactId&gt; &lt;version&gt;5.1.2.RELEASE&lt;/version&gt; &lt;/dependency&gt; ②、使用1234567891011public class LettuceTest { public static void main(String[] args) {// 注意这里的redis密码可以写在url地址中 RedisClient redisClient = RedisClient.create(\"redis://你的密码@47.96.141.44\"); StatefulRedisConnection&lt;String, String&gt; connect = redisClient.connect(); RedisCommands&lt;String, String&gt; sync = connect.sync(); sync.set(\"name\", \"lc\"); String s = sync.get(\"name\"); System.out.println(s); }} 三、Jedis和Lettuce的比较共同点：Lettuce和Jedis的定位都是Redis的cilent,所以他们当然可以直接连接redis server 不同点：①应用场景Jedis：是Redis的Java实现客户端，提供了比较全面的Redis命令的支持。使用阻塞的I/O，且其方法调用都是同步的，程序流需要等到sockets处理完I/O才能执行，不支持异步。Jedis客户端实例不是线程安全的，所以需要通过连接池来使用Jedis。 Lettuce：高级Redis客户端，用于线程安全同步，异步和响应使用，支持集群，Sentinel，管道和编码器。 基于Netty框架的事件驱动的通信层，其方法调用是异步的。Lettuce的API是线程安全的，所以可以操作单个Lettuce连接来完成各种操作。主要在一些分布式缓存框架上使用比较多。 ②线程安全Jedis：在实现上是直接连接的Redis Server，如果在多线程环境下是非线程安全的。每个线程都去拿自己的 Jedis 实例，当连接数量增多时，资源消耗阶梯式增大，连接成本就较高了。 解决方式: 使用连接池，为每个Jedis实例增加物理连接 Lettuce： Lettuce的连接是基于Netty的，连接实例（StatefulRedisConnection）可以在多个线程间并发访问，应为StatefulRedisConnection是线程安全的，所以一个连接实例（StatefulRedisConnection）就可以满足多线程环境下的并发访问，当然这个也是可伸缩的设计，一个连接实例不够的情况也可以按需增加连接实例。 总结1、Jedis 在实现的过程中是直接连接 Redis 的，在多个线程之间共享一个 Jedis 实例，这是线程不安全的，如果想在多线程场景下使用 Jedis，就得使用连接池，这样，每个线程都有自己的 Jedis 实例。 2、Lettuce 基于目前很火的 Netty NIO 框架来构建，所以克服了 Jedis 中线程不安全的问题，Lettuce 支持同步、异步 以及 响应式调用，多个线程可以共享一个连接实例。","link":"/2020/04/23/redis/Redis%E7%9A%84java%E5%AE%A2%E6%88%B7%E7%AB%AF/"},{"title":"是否担心配置文件被盗获取密码？","text":"SpringBoot配置文件加密​ 当我们在发布项目部署的时候，是否会发现配置文件被暴露在环境中，且配置文件里面的密码为明文，这样非常不安全。 例如： 123456789101112spring: datasource: driver-class-name: com.mysql.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource username: root #明文 不安全 password: 123456 redis: database: 0 #明文 不安全 password: 123456 port: 6379 这是我们需要一个加密组件jasypt-spring-boot 一、引入组件依赖123456&lt;!--配置文件加密--&gt;&lt;dependency&gt; &lt;groupId&gt;com.github.ulisesbocchio&lt;/groupId&gt; &lt;artifactId&gt;jasypt-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.0.2&lt;/version&gt;&lt;/dependency&gt; 二、加入加密密钥(盐)我们在application.yaml中加入以下配置 123jasypt: encryptor: password: louchen 可以理解为jasypt会使用这个自定义加密密钥，对配置文件里的重要项进行加密。 三、加密测试使主配置类实现CommandLineRunner接口,在启动程序时输出指定内容 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@SpringBootApplicationpublic class VrhApplication implements CommandLineRunner { @Autowired private ApplicationContext appCtx @Autowired private StringEncryptor stringEncryptor; public static void main(String[] args) { SpringApplication.run(VrhApplication.class, args); } @Override public void run(String... args) throws Exception { //读取配置文件 Environment environment = appCtx.getBean(Environment.class); // 首先获取配置文件里的原始明文信息 String mysqlOriginPswd = environment.getProperty(\"spring.datasource.password\"); String redisOriginPswd = environment.getProperty(\"spring.redis.password\"); String mysqlencrypt = encrypt(mysqlOriginPswd); System.out.println(\"加密:\"+mysqlOriginPswd+\"&gt;&gt;&gt;&gt;&gt;密文:\"+ mysqlencrypt); System.out.println(\"解密:&gt;&gt;&gt;&gt;&gt;明文:\"+decrypt(mysqlencrypt)); System.out.println(\"----------------\"); String redisencrypt = encrypt(redisOriginPswd); System.out.println(\"加密:\"+mysqlOriginPswd+\"&gt;&gt;&gt;&gt;&gt;密文:\"+ redisencrypt); System.out.println(\"解密:&gt;&gt;&gt;&gt;&gt;明文:\"+decrypt(redisencrypt)); } /** * 加密 * @param orginPws 明文 * @return */ private String encrypt(String orginPws){ return stringEncryptor.encrypt(orginPws); } /** *解密 * @param depryptPwd 密文 * @return */ private String decrypt(String depryptPwd){ return stringEncryptor.decrypt(depryptPwd); }} 四、修改配置文件替换明文123456789101112spring: datasource: driver-class-name: com.mysql.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource username: root #替换的密文 password: ENC(HRdQoZQEkagFOmHEFP3+FAPHasQJoxHmgezz559eMnBhGj2W1nj) redis: database: 0 #替换的密文 password: ENC(YJvMXx9L4h3dr3gPFr+lm1wA1WGTordEGSDhymm8YtnN43yReAp5udGy662) port: 6379 这里我们可以看出。在代码中使用时，jasypt-spring-boot组件会自动将ENC()语法包裹的配置项加密字段自动解密，数据得以还原。 五、加密密钥为什么在ENC()中，可以更改吗？自定义加密前缀12345jasypt: encryptor: property: prefix: lc( suffix: ) 再次修改application.yaml文件 123456789101112spring: datasource: driver-class-name: com.mysql.jdbc.Driver type: com.alibaba.druid.pool.DruidDataSource username: root #替换的密文 password: lc(HRdQoZQEkagFOmHEFP3+FAPHasQJoxHmgezz559eMnBhGj2W1nj) redis: database: 0 #替换的密文 password: lc(YJvMXx9L4h3dr3gPFr+lm1wA1WGTordEGSDhymm8YtnN43yReAp5udGy662) port: 6379 六、担心jasypt.encryptor.password设置的盐被泄露？我们的加密密钥放在配置application.yaml中难免有些不安全，这时我们可以使用自定义加密器 使用自定义加密器我们自自定义一个加密器配置类即可 123456789101112131415161718192021222324@Configurationpublic class ConfigEncryptBean { @Bean public StringEncryptor lcEncryptBean() { PooledPBEStringEncryptor encryptor=new PooledPBEStringEncryptor(); SimpleStringPBEConfig config=new SimpleStringPBEConfig();// 设置盐 config.setPassword(\"louchen\");// 设置加密算法 config.setAlgorithm(\"PBEWITHHMACSHA512ANDAES_256\");// 迭代次数 config.setKeyObtentionIterations(\"1000\");// 池的大小 config.setPoolSize(\"1\"); config.setProviderName(\"SunJCE\"); config.setSaltGeneratorClassName(\"org.jasypt.salt.RandomSaltGenerator\"); config.setIvGeneratorClassName(\"org.jasypt.iv.RandomIvGenerator\"); config.setStringOutputType(\"base64\"); encryptor.setConfig(config); return encryptor; }} 注意：上面bean的名字默认为方法名。我们可以使用@Bean注解更改bean的名称· 更改application.yaml 1234567# 加密配置jasypt: encryptor: property: prefix: lc( suffix: ) bean: lcEncryptBean 这是我们的密钥盐就在bean中，比较安全的防止别人获取盐 七、其他密钥设置方式方式一：直接作为程序启动时的命令行参数来带入 java -jar yourproject.jar --jasypt.encryptor.password=louchen 方式二：直接作为程序启动时的应用环境变量来带入 java -Djasypt.encryptor.password=louchen -jar yourproject.jar 方式三：甚至可以作为系统环境变量的方式来带入 比方说，我们提前设置好系统环境变量JASYPT_ENCRYPTOR_PASSWORD = louchen，则直接在Spring Boot的项目配置文件中做如下配置即可： jasypt.encryptor.password=${JASYPT_ENCRYPTOR_PASSWORD:} 这时候也会安全得多。","link":"/2020/04/25/springboot/SpringBoot%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%A0%E5%AF%86/"},{"title":"springboot开发者工具及单元测试","text":"springboot开发者工具及单元测试一、使用devtools热部署1、idea与eclipse运行和编译的区别:①eclipse没有自动保存的功能，所有我们在使用eclipse时，保存之后，eclipse就进行编译了，点击运行就直接运行了，所以启动时，eclipse相对较快 ②idea是点击运行的时候，才进行编译，然后运行的。 2、使用热部署后，我们只需要点击编译，项目即重新编译运行。3、热部署默认只会对类的修改进行重新编译，对静态资源无效①配置静态资源的热部署任选一种即可 1234567spring: devtools: restart:# 包含能够热部署的位置 （需要从src下进行配置） additional-paths: src/main/resources/static# 排除默认配置中不能热部署的位置# exclude: classpath:/static/** pom.xmlspring-boot-devtools 123456789101112131415161718192021222324252627&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;!--只在运行时有效--&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;!--防止devtools传递到其他模块 即修改该类时，引用该模块的不需要动态更新--&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 4、使用liveReload插件动态更新静态资源google下载liveReload插件 这里我们禁用了只要修改文件就自动编译。而是我们修改之后去手动点击编译。 修改静态文件后==&gt; 点击编译==&gt;点击浏览器liveReload即可动态刷新页面 禁止自动更新页面: 1234spring: devtools: livereload: enabled: false 5、禁用热部署（如果pom中有此依赖）1234spring: devtools: restart: enabled: false 或者==&gt; 123456789@SpringBootApplicationpublic class JpaRestApplication { public static void main(String[] args) { System.setProperty(\"spring.devtools.restart.enabled\", \"false\"); SpringApplication.run(JpaRestApplication.class, args); }} 6、使用触发文件进行重启1234spring: devtools: restart: trigger-file: .trigger-file 在resources下新建一个名为.trigger-file.txt的文件==&gt; 当类修改时，编译不会重启，修改.trigger-file.txt ，再点击编译 ，即可重启 当类没有修改时，编译不会重启，修改.trigger-file.txt，再点击编译，也不会重启 7、使用全局触发文件当我们使用微服务的时候，只要引用了该修改的模块的都重新加载 在我们当前用户下新建一个 .spring-boot-devtools.properties 文件==&gt; 1spring.devtools.restart.trigger-file=.trigger-file 在resources下新建一个 .trigger-file 文件==&gt; 修改此内容则全局更新引用了该模块的内容 二、springboot中使用单元测试1、基本配置①pom.xml12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; ②Test@RunWith(SpringRunner.class): 使用junit4测试 @SpringBootTest(classes = JpaRestApplication.class) ： 找到主程序 在springboot我们可以省略指定主程序，springboo自动帮我们寻找主程序 @SpringBootTest即可 123456789101112@RunWith(SpringRunner.class)@SpringBootTest(classes = JpaRestApplication.class)class JpaRestApplicationTests { @Autowired private BookService bookService; @Test void contextLoads() { bookService.hello(); }} 2、对接口进行测试①使用MockMVcbean==&gt; 12345678@Setter@Getter@ToStringpublic class Book { private Integer id; private String name; private String author;} controller==&gt; 12345678910111213@RestControllerpublic class HelloController { @GetMapping(\"/hello\") public String hello(String name){ return \"hello\"+name; } @PostMapping(\"/book\") public Book addBook(@RequestBody Book book) { return book; }} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465@RunWith(SpringRunner.class)@SpringBootTest(classes = JpaRestApplication.class)//开启MockMvc自动配置@AutoConfigureMockMvcclass JpaRestApplicationTests { @Autowired WebApplicationContext webApplicationContext; @Autowired MockMvc mockMvc;// 每次只需test方法之前 初始化MockMvc @Before public void before() { mockMvc = MockMvcBuilders.webAppContextSetup(webApplicationContext).build(); } @Test void test1() throws Exception { MvcResult mvcResult = mockMvc.perform(// get请求地址 MockMvcRequestBuilders.get(\"/hello\") //请求头类型 .contentType(MediaType.APPLICATION_FORM_URLENCODED)// 请求参数 .param(\"name\", \"lccc\"))// 期望的结果 .andExpect(MockMvcResultMatchers.status().isOk())// 对结果的处理 打印 .andDo(MockMvcResultHandlers.print())// 返回该对象 .andReturn();// 从结果的响应 打印 System.out.println(mvcResult.getResponse().getContentAsString()); } @Test void test2() throws Exception { Book book=new Book(); book.setId(1); book.setAuthor(\"罗贯中\"); book.setName(\"三国演义\"); //对象转为字符串形式的json String s = new ObjectMapper().writeValueAsString(book); MvcResult mvcResult = mockMvc.perform( //post请求 MockMvcRequestBuilders.post(\"/book\")// 设置请求头类型 .contentType(MediaType.APPLICATION_JSON)// 内容 .content(s))// 期望的目标 .andExpect(MockMvcResultMatchers.status().isOk())// 返回结果 .andReturn(); MockHttpServletResponse response = mvcResult.getResponse();// 设置编码 response.setCharacterEncoding(\"UTF-8\"); System.out.println(response.getContentAsString()); }} ②使用RestTemplate此方法不需要开启主程序 他默认帮我们启动了一个servlet为已定义的端口 123456789101112131415161718@RunWith(SpringRunner.class)//使用环境中确定的端口@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.DEFINED_PORT)class TestTemplate { @Autowired private TestRestTemplate restTemplate; @Test public void test() { /**\"/hello?name={1}\" 请求的地址 * String.class 响应的类型 * \"lcccc\" 参数 */ String lcccc = restTemplate.getForObject(\"/hello?name={1}\", String.class, \"lcccc\"); System.out.println(lcccc); }} 3、json测试……","link":"/2020/04/17/springboot/springboot%E5%BC%80%E5%8F%91%E8%80%85%E5%B7%A5%E5%85%B7%E5%8F%8A%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"},{"title":"Spring-Security使用JSON登录","text":"SpringSecurity 整合JSON登录1、pom.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;&lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;springsecurity-json&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;springsecurity-json&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、yaml配置临时的用户名密码配置 12345spring: security: user: name: lc password: 123 3、核心配置①自定义认证过滤器在这里我们只是扩展UsernamePasswordAuthenticationFilter的attemptAuthentication获得用户名和参数的规则 123456789101112131415161718192021222324252627282930313233343536373839public class MyAuthenticationFilter extends UsernamePasswordAuthenticationFilter { @Override public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException {// 若为非post请求 if (!request.getMethod().equals(\"POST\")) { throw new AuthenticationServiceException(\"Authentication method not supported: \" + request.getMethod()); }// 如果是以json形式的登录方式 if (request.getContentType().equals(MediaType.APPLICATION_JSON_VALUE)) {// 有body的才有流，能够用流去解析 。get和delete没有流 String username = null; String password = null; try {// 从请求流中获取 参数对象 Map&lt;String,String&gt; map = new ObjectMapper().readValue(request.getInputStream(), Map.class); username = map.get(\"username\"); password = map.get(\"password\"); } catch (IOException e) { e.printStackTrace(); } if (username == null) { username = \"\"; } if (password == null) { password = \"\"; } username = username.trim(); UsernamePasswordAuthenticationToken authRequest = new UsernamePasswordAuthenticationToken(username, password); this.setDetails(request, authRequest); return this.getAuthenticationManager().authenticate(authRequest); }// 以key value形式 return super.attemptAuthentication(request, response); }} ②Security配置123456789101112131415161718192021222324252627282930313233343536@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .anyRequest().authenticated() .and()// 登录相关的都运行访问（这里的是默认的登录页） .formLogin().permitAll() .and() .csrf().disable(); http.addFilterAt(myAuthenticationFilter(), UsernamePasswordAuthenticationFilter.class); } @Bean MyAuthenticationFilter myAuthenticationFilter() throws Exception { MyAuthenticationFilter filter = new MyAuthenticationFilter();// 自定义登录成功的处理方法 filter.setAuthenticationSuccessHandler(new AuthenticationSuccessHandler(){ @Override public void onAuthenticationSuccess(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Authentication authentication) throws IOException, ServletException { PrintWriter printWriter=httpServletResponse.getWriter(); httpServletResponse.setContentType(\"text/html\"); printWriter.write(\"hello\"); printWriter.flush(); printWriter.close(); } });// 失败的处理方法 //....... filter.setAuthenticationManager(authenticationManagerBean()); return filter; }} 4、controller12345678910@RestControllerpublic class HelloController { @GetMapping(\"/hello\") public String hello() { return \"hello securtiy\"; }} 5、接口请求测试经过以上的扩展配置，可同时支持post的key-value形式的请求登录和json形式的请求登录 ①key-value形式POST: http://localhost:8080/login content-type: x-www-form-urlencoded 请求参数==&gt; key:username value: lc key:password value:123 ②json形式POST: http://localhost:8080/login content-type: application/json 请求参数==&gt; 1234{ \"username\":\"lc\", \"password\":\"123\"}","link":"/2020/04/17/springsecurity/Spring-Security%E4%BD%BF%E7%94%A8JSON%E7%99%BB%E5%BD%95/"},{"title":"Redis中的HyperLogLog","text":"Redis中的HyperLogLog一、HyperLogLog：1、特点高级不精确去重的数据结构.(一般是超过一百个就开始不准确了)占用空间小(一个键最多12k,可以计算2^64个元素)没有contains操作 因此有些他就支持不了,拓展到 布隆过滤器 适用于一个热点页面的去重访问次数.不适合单个用户的数据统计 2、背景一般我们评估一个网站的访问量，有几个主要的参数： pv，Page View，网页的浏览量 uv，User View，访问的用户 一般来说，pv 或者 uv 的统计，可以自己来做，也可以借助一些第三方的工具，比如 cnzz，友盟 等。 如果自己实现，pv 比较简单，可以直接通过 Redis 计数器就能实现。但是 uv 就不一样，uv 涉及到另外一个问题，去重。 我们首先需要在前端给每一个用户生成一个唯一 id，无论是登录用户还是未登录用户，都要有一个唯一 id，这个 id 伴随着请求一起到达后端，在后端我们通过 set 集合中的 sadd 命令来存储这个 id，最后通过 scard 统计集合大小，进而得出 uv 数据。 如果是千万级别的 UV，需要的存储空间就非常惊人。而且，像 UV 统计这种，一般也不需要特别精确，800w 的 uv 和 803w 的 uv，其实差别不大。所以，我们要介绍今天的主角—HyperLogLog Redis 中提供的 HyperLogLog 就是专门用来解决这个问题的，HyperLogLog 提供了一套不怎么精确但是够用的去重方案，会有误差，官方给出的误差数据是 0.81%，这个精确度，统计 UV 够用了。 二、在Redis中的基本命令1、pfadd用来添加记录，类似于 sadd ，添加过程中，重复的记录会自动去重。 element：用户的标识 pfadd [key] [element...] 2、pfcount统计一个或多个key的值的个数。取并集（去重），这种操作不会改变原key的大小 pfcount [key] [key...] 12345pfadd k1 u1 u2 u3 u4pfcount k1 #==&gt; 4pfadd k2 u4 u5pfcount k2 #==&gt; 2pfcount k1 k2 #===&gt; 5 3、pfmerge合并多个key到某一个key中，会去重。会改变目标key的大小 destkey :目标key sourcekey 源key pfmerge destkey sourcekey [sourcekey...] 1234pfcount uv #==&gt; 994pfadd u1 aa bb #==&gt;添加不在uv的两个值 aa bbpfmerge u1 uv #==&gt;合并uv到u1中pfcount u1 #==&gt; 996 三、通过java代码来模拟大数据量的用户访问先准备连接redis代码 1234567891011121314151617181920212223242526272829303132public class Redis { private JedisPool jedisPool; public Redis() {// 连接池配置对象 GenericObjectPoolConfig config=new GenericObjectPoolConfig();// 连接池最大空闲数 config.setMaxIdle(300);// 最大连接数 config.setMaxTotal(1000);// 连接最大等待时间（毫秒）。-1表示无限制 config.setMaxWaitMillis(30000);// 在空闲时检查有效性 config.setTestOnBorrow(true); /** * 1、连接池配置 * 2、redis地址 * 3、端口 * 4、超时时间 * 5、密码 */ jedisPool = new JedisPool(config, \"主机\",6379,30000,\"你的密码\"); } public void execute(CallWithJedis callWithJedis) { try (Jedis jedis=jedisPool.getResource()) { callWithJedis.call(jedis); } }} 123public interface CallWithJedis { void call(Jedis jedis);} 1234567891011121314public class HyperLogLogTest { public static void main(String[] args) { Redis redis = new Redis(); redis.execute(jedis -&gt; { for (int i = 0; i &lt; 1000; i++) {// 理论上我们累加的为1001次 jedis.pfadd(\"uv\", \"u\"+i,\"u\"+(i+1)); } long uv = jedis.pfcount(\"uv\"); //实际输出 994 System.out.println(uv); }); }} 理论值是 1001，实际打印出来 994，有误差，但是在可以接受的范围内。","link":"/2020/04/27/redis/Redis%E4%B9%8BHyperLogLog/"},{"title":"SpringSecurity项目使用总结","text":"SpringSecurity项目使用总结一、在SpringSecurity中获取和设置的登录用户信息在任何地方获取和设置用户登录信息 直接注入Authentication对象 通过getPrincipal()获取用户信息 1234@GetMapping(\"/hr/info\")public Hr getCurrentHr(Authentication authentication) { return ((Hr) authentication.getPrincipal());} SecurityContextHolder.getContext().getAuthentication() 是一个静态方法，也就是利用这个方法，我们可以随时随地拿到用户信息（需要注意 ThreadLocal 的限制），即当前获取的不能为其他线程或子线程，必须为当前的本地线程 获取用户信息： 1Authentication authentication = SecurityContextHolder.getContext().getAuthentication(); 设置用户信息： authResult为Authentication对象 SecurityContextHolder.getContext().setAuthentication(authResult); 123456 @PutMapping(\"/hr/info\")//这里直接注入Authentication public ResponseBean updateHr(@RequestBody Hr hr,Authentication authentication){ SecurityContextHolder.getContext().setAuthentication(new UsernamePasswordAuthenticationToken(hr,authentication.getCredentials(),authentication.getAuthorities())); } 二、SpringSecurity登录流程","link":"/2020/04/17/springsecurity/SpringSecurity%E9%A1%B9%E7%9B%AE%E9%97%AE%E9%A2%98/"},{"title":"sprinboot与mongodb构建restful风格","text":"sprinboot与mongodb构建restful风格所有的请求模式和jpa构建的restful一致 1、pom.xmlspring-boot-starter-data-rest spring-boot-starter-data-mongodb 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;jpa-rest&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;jpa-rest&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-mongodb&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-rest&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、实体bean12345678@Setter@Getter@ToStringpublic class Book { private Integer id; private String name; private String author;} 3、dao接口配置123public interface BookDao extends MongoRepository&lt;Book,Integer&gt; {} 4、yaml配置1234567891011spring: data: mongodb: # mongodb每个库都有自己的认证方式 authentication-database: lc username: root password: 你的密码 port: 27017 database: lc uri: mongodb://root:你的密码@47.96.141.44:27017/lc# host: 47.96. 5、接口测试1、添加数据post: http://localhost:8080/books 123456789101112{ \"name\": \"曹雪芹\", \"author\": \"红楼梦\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/books/1\" }, \"book\": { \"href\": \"http://localhost:8080/books/1\" } }} 2、查询所有get: http://localhost:8080/books 123456789101112131415161718192021222324252627282930313233{ \"_embedded\": { \"books\": [ { \"name\": \"曹雪芹\", \"author\": \"红楼梦\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/books/1\" }, \"book\": { \"href\": \"http://localhost:8080/books/1\" } } } ] }, \"_links\": { \"self\": { \"href\": \"http://localhost:8080/books{?page,size,sort}\", \"templated\": true }, \"profile\": { \"href\": \"http://localhost:8080/profile/books\" } }, \"page\": { \"size\": 20, \"totalElements\": 1, \"totalPages\": 1, \"number\": 0 }}","link":"/2020/04/17/restful/mongodb%E6%9E%84%E5%BB%BArestful%E9%A3%8E%E6%A0%BC/"},{"title":"Windows常用命令","text":"命令 -help //第1种形式的使用帮助 命令 /? //第2种形式的使用帮助 1，列出所有任务及进程号，杀进程 ​ tasklist ​ tasklist /? 获取使用帮助 ​ taskkill ​ taskkill /? 获取使用帮助 2，cd 切换目录 cd /? //获取使用帮助 cd \\ //跳转到硬盘的根目录 cd C:\\WINDOWS //跳转到当前硬盘的其他文件 d: //跳转到其他硬盘 cd /d e:\\software //跳转到其他硬盘的其他文件夹 注意此处必须加/d参数。否则无法跳转。 cd.. //跳转到上一层目录 3，netstat 查看网络连接状态1234567显示协议统计信息和当前 TCP/IP 网络连接。该命令可以查看当前机器建立的所有网络链接状态，以及对应哪个进程。netstat -help 获取命令行使用帮助信息netstat -ano //查看所有网络连接、状态以及对应的进程idnetstat -ano|findstr \"8081\" //查看被占用端口对应的 PIDtasklist|findstr \"9088\" //查看指定 PID 的进程taskkill /PID 9088 //终止 pid 为 9088的进程taskkill /T /F /PID 9088 //强制（/F参数）杀死 pid 为 9088 的所有进程包括子进程（/T参数） 5，ping 查看网络连通性​ ping -help 6，tracerttracert也被称为Windows路由跟踪实用程序，在命令提示符（cmd）中使用tracert命令可以用于确定IP数据包访问目标时所选择的路径。 tracert /? 获取使用帮助 例子：tracert www.baidu.com7、ipconfig #查看自己的ip8、cls 清屏9、telnet使用测试连接指定主机的端口地址 telnet 47.96.141.44 8081","link":"/2020/04/17/shell/windows-10/"},{"title":"Springboot整合Shiro","text":"Springboot整合Shiro拦截器介绍 https://www.jianshu.com/p/54b573c7b4db https://blog.csdn.net/fenglixiong123/article/details/77119857 一、整合Shiro1、pom.xml shiro-spring shiro-web 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;springboot-shiro&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;springboot-shiro&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-web&lt;/artifactId&gt; &lt;version&gt;1.4.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt; &lt;version&gt;1.4.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、Realm配置12345678910111213141516public class MyRealm extends AuthorizingRealm { @Override protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principalCollection) { return null; } @Override protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authenticationToken) throws AuthenticationException { String username = (String) authenticationToken.getPrincipal(); if (\"lc\".equals(username)) { return new SimpleAuthenticationInfo(username, \"123\", getName()); } return null; }} 3、shiro配置123456789101112131415161718192021222324@Configurationpublic class ShrioConfig { @Bean Realm realm() { TextConfigurationRealm realm =new TextConfigurationRealm();// 设置用户和角色 realm.setUserDefinitions(\"lc=123,user \\n admin=123,admin\");// 设置角色权限 realm.setRoleDefinitions(\"admin=read,write \\n user=read\"); return realm; } @Bean ShiroFilterChainDefinition shiroFilterChainDefinition() { DefaultShiroFilterChainDefinition definition=new DefaultShiroFilterChainDefinition(); definition.addPathDefinition(\"/doLogin\", \"anon\"); definition.addPathDefinition(\"/**\", \"authc\"); return definition; }} 4、controller123456789101112131415161718192021222324252627@RestControllerpublic class LoginController { @GetMapping(\"/hello\") public String hello() { return \"hello shiro\"; } @GetMapping(\"/login\") public String login() { return \"please login!\"; } @PostMapping(\"/doLogin\") public void doLogin(String username,String password) { Subject subject = SecurityUtils.getSubject(); try { subject.login(new UsernamePasswordToken(username, password)); System.out.println(\"登录成功！\"); } catch (AuthenticationException e) { System.out.println(); System.out.println(\"登录失败！\"+e.getMessage()); } }} 二、spring-boot-starter 整合shrio1、pom.xmlshiro-spring-boot-web-starter 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;springbootstarter-shiro&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;springbootstarter-shiro&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt; &lt;artifactId&gt;shiro-spring-boot-web-starter&lt;/artifactId&gt; &lt;version&gt;1.4.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、yaml配置1234567891011121314shiro: enabled: true unauthorizedUrl: /unauthorizedUrl web: enabled: true successUrl: /success loginUrl: /login # 就是每次请求是否支持把sessionid放在cookie中或者通过url携带sessionid# sessionManager:# 是否允许通过url实现会话跟踪# sessionIdUrlRewritingEnabled: true# 是否允许放在cookie中# sessionIdCookieEnabled: true 3、shiro配置123456789101112131415161718192021@Configurationpublic class ShrioConfig { @Bean Realm realm() { TextConfigurationRealm realm =new TextConfigurationRealm();// 设置用户和角色 realm.setUserDefinitions(\"lc=123,user \\n admin=123,admin\");// 设置角色权限 realm.setRoleDefinitions(\"admin=read,write \\n user=read\"); return realm; } @Bean ShiroFilterChainDefinition shiroFilterChainDefinition() { DefaultShiroFilterChainDefinition definition=new DefaultShiroFilterChainDefinition(); definition.addPathDefinition(\"/doLogin\", \"anon\"); definition.addPathDefinition(\"/**\", \"authc\"); return definition; }} 4、controller配置1234567891011121314151617181920212223242526@RestControllerpublic class LoginController { @GetMapping(\"/hello\") public String hello() { return \"hello shiro\"; } @GetMapping(\"/login\") public String login() { return \"please login!\"; } @PostMapping(\"/doLogin\") public void doLogin(String username,String password) { Subject subject = SecurityUtils.getSubject(); try { subject.login(new UsernamePasswordToken(username, password)); System.out.println(\"登录成功！\"); } catch (AuthenticationException e) { System.out.println(); System.out.println(\"登录失败！\"+e.getMessage()); } }}","link":"/2020/04/17/springsecurity/SpringBoot%E6%95%B4%E5%90%88Shiro/"},{"title":"WebSocket和Socket初识","text":"一、WebSocket和Socket的区别​ 由计算机网络知识我们可以知道，软件通信有七层结构，下三层结构偏向与数据通信，上三层更偏向于数据处理，中间的传输层则是连接上三层与下三层之间的桥梁，每一层都做不同的工作，上层协议依赖与下层协议。基于这个通信结构的概念。 1、Socket 其实并不是一个协议，是应用层与 TCP/IP 协议族通信的中间软件抽象层，它是一组接口。当两台主机通信时，让 Socket 去组织数据，以符合指定的协议。TCP 连接则更依靠于底层的 IP 协议，IP 协议的连接则依赖于链路层等更低层次。 2、WebSocket 则是一个典型的应用层协议。 总的来说：Socket 是传输控制层协议，WebSocket 是应用层协议。 二、什么是WebSocket​ WebSocket是一种在单个TCP连接上进行全双工通信的协议。WebSocket通信协议于2011年被IETF定为标准RFC 6455，并由RFC7936补充规范。WebSocket API也被W3C定为标准。 ​ WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。—-百度百科 WebSocket 是独立的、创建在 TCP 上的协议。 Websocket 通过HTTP/1.1 协议的101状态码进行握手。 为了创建Websocket连接，需要通过浏览器发出请求，之后服务器进行回应，这个过程通常称为“握手” 1、什么是全双工通信和半双工通信？①单工通信 ​ 单工通信，是指消息只能单方向传输的工作方式，只能有一个方向的通信而没有反方向的交互； ​ 在单工通信中，通信的信道是单向的，发送端与接收端也是固定的，即发送端只能发送信息，不能接收信息；接收端只能接收信息，不能发送信息，基于这种情况，数据信号从一端传送到另外一端，信号流是单方向的；举例：电视、广播 ②半双工通信 ​ 半双工通信是指数据可以沿两个方向传送，但同一时刻一个半双工总线结构信道只允许单方向传送，因此又被称为双向交替通信 ​ 半双工通信可以实现双向的通信，但不能在两个方向上同时进行，必须轮流交替地进行， ​ 在这种工作方式下，发送端可以转变为接收端；相应地，接收端也可以转变为发送端。但是在同一个时刻，信息只能在一个方向上传输，因此也可以将半双工通信理解为一种切换方向的单工通信；举例：对讲机 ③全双工通信 ​ 全双工通信称为双向同时通信，即通信的双方可以同时发送和接收信息的信息交互方式； ​ 全双工通信是指在通信的任意时刻，线路上存在A到B和B到A的双向信号传输，全双工通信允许数据同时在两个方向上传输，又称为双向同时通信，即通信的双方可以同时发送和接收数据， ​ 在全双工方式下，通信系统的每一端都设置了发送器和接收器，因此，能控制数据同时在两个方向上传送；举例：电话通讯 三、为什么需要WebSocket？​ 初次接触 WebSocket 的人，都会问同样的问题：我们已经有了 HTTP 协议，为什么还需要另一个协议？它能带来什么好处？ ​ 答案很简单，因为 HTTP 协议有一个缺陷：通信只能由客户端发起。 举例来说，我们想了解今天的天气，只能是客户端向服务器发出请求，服务器返回查询结果。HTTP 协议做不到服务器主动向客户端推送信息。 ​ 这种单向请求的特点，注定了如果服务器有连续的状态变化，客户端要获知就非常麻烦。我们只能使用”轮询”：每隔一段时候，就发出一个询问，了解服务器有没有新的信息。最典型的场景就是聊天室。 ​ 现在，很多网站为了实现推送技术，所用的技术都是 Ajax 轮询。轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。 ​ 轮询的效率低，非常浪费资源（因为必须不停连接，或者 HTTP 连接始终打开）。因此，工程师们一直在思考，有没有更好的方法。WebSocket 就是这样发明的。 ​ HTML5 定义的 WebSocket 协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。 ​ WebSocket 协议在2008年诞生，2011年成为国际标准。所有浏览器都已经支持了。 它的最大特点就是，服务器可以主动向客户端推送信息，客户端也可以主动向服务器发送信息，是真正的双向平等对话，属于服务器推送技术的一种。 其他特点包括： （1）建立在 TCP 协议之上，服务器端的实现比较容易。 （2）与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。 （3）数据格式比较轻量，性能开销小，通信高效。 （4）可以发送文本，也可以发送二进制数据。 （5）没有同源限制，客户端可以与任意服务器通信。 （6）协议标识符是ws（如果加密，则为wss），服务器网址就是 URL。 1ws://example.com:80/some/path 四、webSocket实例​ 为了建立一个 WebSocket 连接，客户端浏览器首先要向服务器发起一个 HTTP 请求，这个请求和通常的 HTTP 请求不同，包含了一些附加头信息，其中附加头信息”Upgrade: WebSocket”表明这是一个申请协议升级的 HTTP 请求，服务器端解析这些附加的头信息然后产生应答信息返回给客户端，客户端和服务器端的 WebSocket 连接就建立起来了，双方就可以通过这个连接通道自由的传递信息，并且这个连接会持续存在直到客户端或者服务器端的某一方主动的关闭连接。","link":"/2020/04/17/websocket/WebSocket%E7%AE%80%E4%BB%8B/"},{"title":"nginx极简入门","text":"一、基本介绍Nginx 是一个高性能的 HTTP 和反向代理 web 服务器，同时也提供了 IMAP/POP3/SMTP 服务。 Nginx 是由伊戈尔·赛索耶夫为俄罗斯访问量第二的 Rambler.ru 站点开发的，第一个公开版本 0.1.0 发布于 2004 年 10 月 4 日。 Nginx 特点是占有内存少，并发能力强。 事实上 nginx 的并发能力确实在同类型的网页服务器中表现较好，一般来说，如果我们在项目中引入了 Nginx ，我们的项目架构可能是这样： 在这样的架构中 ， Nginx 所代表的角色叫做负载均衡服务器或者反向代理服务器，所有请求首先到达 Nginx 上，再由 Nginx 根据提前配置好的转发规则，将客户端发来的请求转发到某一个 Tomcat 上去。那么这里涉及到两个概念： 负载均衡服务器 就是进行请求转发，降低某一个服务器的压力。负载均衡策略很多，也有很多层，对于一些大型网站基本上从 DNS 就开始负载均衡，负载均衡有硬件和软件之分，各自代表分别是 F5 和 Nginx （目前 Nginx 已经被 F5 收购），早些年，也可以使用 Apache 来做负载均衡，但是效率不如 Nginx ，所以现在主流方案是 Nginx 。 反向代理服务器： 另一个概念是反向代理服务器，要说反向代理，得先说正向代理，看下面一张图： 在这个过程中，Google 并不知道真正访问它的客户端是谁，它只知道这个中间服务器在访问它。因此，这里的代理，实际上是中间服务器代理了客户端，这种代理叫做正向代理。 那么什么是反向代理呢？反向代理有点类似于大家打 10086 客服，看下面一张图： 在这个过程中，10086 这个号码相当于是一个代理，真正提供服务的，是话务员，但是对于客户来说，他不关心到底是哪一个话务员提供的服务，他只需要记得 10086 这个号码就行了。 所有的请求打到 10086 上，再由 10086 将请求转发给某一个话务员去处理。因此，在这里，10086 就相当于是一个代理，只不过它代理的是话务员而不是客户端，这种代理称之为反向代理。 二、Nginx 的优势在 Java 开发中，Nginx 有着非常广泛的使用，随便举几点： 使用 Nginx 做静态资源服务器：Java 中的资源可以分为动态和静态，动态需要经过 Tomcat 解析之后，才能返回给浏览器，例如 JSP 页面、Freemarker 页面、控制器返回的 JSON 数据等，都算作动态资源，动态资源经过了 Tomcat 处理，速度必然降低。对于静态资源，例如图片、HTML、JS、CSS 等资源，这种资源可以不必经过 Tomcat 解析，当客户端请求这些资源时，之间将资源返回给客户端就行了。此时，可以使用 Nginx 搭建静态资源服务器，将静态资源直接返回给客户端。 使用 Nginx 做负载均衡服务器，无论是使用 Dubbo 还是 Spirng Cloud ，除了使用各自自带的负载均衡策略之外，也都可以使用 Nginx 做负载均衡服务器。 支持高并发、内存消耗少、成本低廉、配置简单、运行稳定等。 三、Nginx 安装：由于基本上都是在 Linux 上使用 Nginx，因此松哥这里主要向大家展示 CentOS 7 安装 Nginx： 首先下载 Nginx 1wget http://nginx.org/download/nginx-1.17.0.tar.gz 然后解压下载的目录，进入解压目录中，在编译安装之前，需要安装两个依赖： 1yum -y install pcre-develyum -y install openssl openssl-devel 然后开始编译安装： 1./configuremakemake install 装好之后，默认安装位置在 ： 1/usr/local/nginx/sbin/nginx 四、基本命令https://www.jianshu.com/p/03d17156616d 进入到该目录的 sbin 目录下，执行 nginx 即可启动 Nginx 进入到/sbin目录下 1./nginx 如果修改了 Nginx 配置，则可以通过如下命令重新加载 Nginx 配置文件： 1./nginx -s reload 启动服务 1/usr/local/nginx/sbin/nginx 查看配置 1vi /usr/local/nginx/conf/nginx.conf 重启服务 1/usr/local/nginx/sbin/nginx -s reopen 查看服务 1ps -ef | grep nginx 查看配置：vi /usr/local/nginx/conf/nginx.conf 编辑配置：vim /usr/local/nginx/conf/nginx.conf 重启配置：/usr/local/nginx/sbin/nginx -s reload 重启服务：/usr/local/nginx/sbin/nginx -s reopen 查看Nginx的版本 在/usr/local/nginx/sbin目录下 1./nginx -v 查看Nginx的编译模块 1./nginx -V nginx添加环境变量 123ln -s /usr/local/nginx/sbin/nginx /usr/local/bin/nginx(做软链，添加到环境变量)nginx -t (检测配置文件)nginx -s reload (平滑重启) 停止服务 1nginx -s stop 1systemctl stop nginx 查看当前操作的文件夹 1pwd 五、Nginx添加新的模块有时候我们安装模块后，查看Nginx已经安装的模块： /usr/local/nginx/sbin/nginx -V 12built by gcc 4.8.5 20150623 (Red Hat 4.8.5-39) (GCC) configure arguments: --prefix=/usr/local/nginx --add-module=/usr/local/fastdfs-nginx-module-1.22/src 这里我们添加新的模块 --with-http_gzip_static_module 进入nginx的源文件按安装目录 /root/nginx-1.8.1/ 1cd /root/nginx-1.8.1/ 添加编译新的模块 注意：这里要携带已经安装的模块参数 1./configure --prefix=/usr/local/nginx --add-module=/usr/local/fastdfs-nginx-module-1.22/src --with-http_gzip_static_module 编译 1make 注意：在这之后千万不要make install否则会覆盖之前安装好的模块 关闭nginx服务 1systemctl stop nginx 或者 nginx -s stop 备份原有nginx二进制文件 1cp /usr/local/nginx/sbin/nginx /usr/local/nginx/sbin/nginx.bak 复制新编译好的nginx二进制文件。此目录为 /root/nginx-1.8.1/ 1cp ./objs/nginx /usr/local/nginx/sbin/nginx 启动nginx 1systemctl start nginx 或者 /usr/local/nginx/sbin/nginx 重新查看nginx模块信息 123nginx version: nginx/1.8.1built by gcc 4.8.5 20150623 (Red Hat 4.8.5-39) (GCC) configure arguments: --prefix=/usr/local/nginx --add-module=/usr/local/fastdfs-nginx-module-1.22/src --with-http_gzip_static_module","link":"/2020/04/17/nginx/Nginx/"},{"title":"SpringBoot整合Redis","text":"一、docker中安装redis1、镜像安装与容器创建12docker pull redis //拉取镜像docker run -d -p 6379:6379 --restart=always --name myredis 镜像名 //创建容器 2、查看redis版本docker exec -it 9a7d1cf2c234 redis-cli -v //查看版本 3、修改redis密码（临时，重启失效）①进入redis管理页面不带密码进入（进入后需验证）==&gt; docker exec -it 9a7d1cf2c234 redis-cli //进入redis管理界面 带密码进入（进入后无需验证）==&gt; docker exec -it 9a7d1cf2c234 redis-cli -a '密码' //带密码进入管理界面 ②查询密码config get requirepass //查看密码(初始为空) ③设置密码config set reuqirepass 密码 //设置密码 ④验证密码auth 密码 //验证密码才能够进行查询密码和设置密码等操作 4、永久设置密码（需要修改配置文件）二、springboot整合Redis注意：①在Springboot 2.1.5及之后使用redis必须引入springSecurity ②redis5及之后远程访问连接必须要设置密码 ③使用jedis和lettuce客户端连接redis服务器的区别：使用jedis：当多线程使用同一个连接时，是线程不安全的。所以要使用连接池，为每个jedis实例分配一个连接。 Jedis在实现上是直接连接的redis server，如果在多线程环境下是非线程安全的，这个时候只有使用连接池，为每个Jedis实例增加物理连接 使用Lettuce：当多线程使用同一连接实例时，是线程安全的 Lettuce的连接是基于Netty的，连接实例（StatefulRedisConnection）可以在多个线程间并发访问，应为StatefulRedisConnection是线程安全的，所以一个连接实例（StatefulRedisConnection）就可以满足多线程环境下的并发访问，当然这个也是可伸缩的设计，一个连接实例不够的情况也可以按需增加连接实例。 1、基于lettuce底层的redis配置引入SpringSecurity后，SpringSecurity帮我们生成一个密码 在我们第一个请求redis会要求输入账号密码 用户名为:uers 密码为：Using generated security password: 648dcfaa-ce97-459d-a6d4-b02f73532f89 pom.xmlspring-boot-starter-data-redis spring-boot-starter-security 123456789101112131415161718192021222324252627282930&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; yaml配置123456789spring: redis:# 主机 host: 47.96.141.44# 默认使用的数据库（第一个） database: 0 port: 6379 password: 你的密码# 配置lettuce连接池的相关属性 controller1234567891011121314151617181920@RestControllerpublic class HelloController { @Autowired StringRedisTemplate stringRedisTemplate; @GetMapping(\"/set\") public void set(){ ValueOperations&lt;String, String&gt; ops = stringRedisTemplate.opsForValue(); ops.set(\"lc\", \"louchen.top\"); } @GetMapping(\"/get\") public void get() { ValueOperations&lt;String, String&gt; ops = stringRedisTemplate.opsForValue(); System.out.println(ops.get(\"lc\")); }} 自动配置详解org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration=&gt; 123456789101112131415161718192021222324252627282930@Configuration( proxyBeanMethods = false)@ConditionalOnClass({RedisOperations.class})@EnableConfigurationProperties({RedisProperties.class})@Import({LettuceConnectionConfiguration.class, JedisConnectionConfiguration.class})public class RedisAutoConfiguration { public RedisAutoConfiguration() { } @Bean @ConditionalOnMissingBean( name = {\"redisTemplate\"} ) //操作健值为对象的redistemplate public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException { RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate(); template.setConnectionFactory(redisConnectionFactory); return template; } @Bean @ConditionalOnMissingBean //主要操作健值为字符串的对象 public StringRedisTemplate stringRedisTemplate(RedisConnectionFactory redisConnectionFactory) throws UnknownHostException { StringRedisTemplate template = new StringRedisTemplate(); template.setConnectionFactory(redisConnectionFactory); return template; }}","link":"/2020/04/17/nosql/springboot%E6%95%B4%E5%90%88redis/"},{"title":"springboot整合Jpa及多数据源","text":"springboot整合Jpa1、基本配置：①pom.xml配置： 123456789101112131415161718192021222324252627282930313233343536373839&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.18&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;version&gt;5.1.27&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; ②yaml配置：1234567891011121314151617181920212223spring: datasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=UTF-8 username: root password: 123456 jpa:# 显示sql语句 show-sql: true# 数据库 database: mysql # 数据库平台 database-platform: mysql# 设置表的结构的生成类型 hibernate:# 每次启动更新表结构 ddl-auto: update properties: hibernate:# 设置方言 mysql57 dialect: org.hibernate.dialect.MySQL57Dialect ③实体配置：1234567891011121314151617181920212223242526272829303132/** * 指定表的名称 若不存在 则自动为你创建此表 */@Entity(name = \"t_book\")@Getter@Setter@ToStringpublic class Book { /** *在jpa中一个表必须设置主键，否则创建会失败 * @Id标注的属性为主键 * @GeneratedValue指定生成策略为自增长 * @column中可设置字段的约束操作（长度为10） */ @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(length = 10) private Integer id; /** * 设置自动不能为空，长度为50,设置数据库中和属性的对应名称 */ @Column(nullable = false,length = 50,name = \"name\") private String name; /** * 设置自动不能为空，长度为20,设置数据库中和属性的对应名称 */ @Column(nullable = false,length = 20,name = \"author\") private String author;} ④jpa接口配置：123456789/** * 这里要实现 JpaRepository 接口 * JpaRepository已经帮我们实现了很多操作直接使用即可 * 第一个参数为 操作的实体的类型 * 第二个参数为 主键的类型 */public interface BookDao extends JpaRepository&lt;Book,Integer&gt; {} ⑤测试：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475@SpringBootTestclass JpaApplicationTests { @Autowired private BookDao bookDao; /** * 增加 */ @Test void addBokk() { Book book=new Book(); book.setName(\"西游记\"); book.setAuthor(\"施耐庵\"); bookDao.save(book); } /** * 有则更新 无则添加 */ @Test void updateBook() { Book book=new Book(); book.setName(\"xiyouji\"); book.setAuthor(\"shinaian\"); book.setId(1); bookDao.saveAndFlush(book); } /** * 通过id删除 */ @Test void deleteBook() { bookDao.deleteById(1); } /** * 通过id查询 查询所有 */ @Test void findBook() { Optional&lt;Book&gt; byId = bookDao.findById(2); System.out.println(byId.get()); List&lt;Book&gt; all = bookDao.findAll(); System.out.println(all); } /** * 按照id 降序排序 */ @Test void findBookSort() { List&lt;Book&gt; all = bookDao.findAll(Sort.by(Sort.Direction.DESC, \"id\")); System.out.println(all); } /** * 分页查询 */ @Test void findBookPage() { //从第一页开始查询（起始为0），每页大小为2 Pageable pageable = PageRequest.of(2, 2); Page&lt;Book&gt; all = bookDao.findAll(pageable); System.out.println(\"总记录数:\"+all.getTotalElements()); System.out.println(\"当前页记录数:\"+all.getNumberOfElements()); System.out.println(\"每页记录数:\" + all.getSize()); System.out.println(\"总页数:\" + all.getTotalPages()); System.out.println(\"查询结果数据:\" + all.getContent()); System.out.println(\"当前页数(从0开始):\" + all.getNumber()); System.out.println(\"是否为首页:\" + all.isFirst()); System.out.println(\"是否为尾页:\" + all.isLast()); }} 2、jpa使用关键字进行查询：关键字查询参考表： Keyword Sample JPQL snippet And findByLastnameAndFirstname … where x.lastname = ?1 and x.firstname = ?2 Or findByLastnameOrFirstname … where x.lastname = ?1 or x.firstname = ?2 Is,Equals findByFirstname,findByFirstnameIs … where x.firstname = ?1 Between findByStartDateBetween … where x.startDate between ?1 and ?2 LessThan findByAgeLessThan … where x.age &lt; ?1 LessThanEqual findByAgeLessThanEqual … where x.age &lt;= ?1 GreaterThan findByAgeGreaterThan … where x.age &gt; ?1 GreaterThanEqual findByAgeGreaterThanEqual … where x.age &gt;= ?1 After findByStartDateAfter … where x.startDate &gt; ?1 Before findByStartDateBefore … where x.startDate &lt; ?1 IsNull findByAgeIsNull … where x.age is null IsNotNull,NotNull findByAge(Is)NotNull … where x.age not null Like findByFirstnameLike … where x.firstname like ?1 NotLike findByFirstnameNotLike … where x.firstname not like ?1 StartingWith findByFirstnameStartingWith … where x.firstname like ?1(parameter bound with appended %) EndingWith findByFirstnameEndingWith … where x.firstname like ?1(parameter bound with prepended %) Containing findByFirstnameContaining … where x.firstname like ?1(parameter bound wrapped in %) OrderBy findByAgeOrderByLastnameDesc … where x.age = ?1 order by x.lastname desc Not findByLastnameNot … where x.lastname &lt;&gt; ?1 In findByAgeIn(Collection ages) … where x.age in ?1 NotIn findByAgeNotIn(Collection ages) … where x.age not in ?1 True findByActiveTrue() … where x.active = true False findByActiveFalse() … where x.active = false IgnoreCase findByFirstnameIgnoreCase … where UPPER(x.firstame) = UPPER(?1) ①接口配置1234567891011121314151617181920212223242526272829303132/** * 这里要实现 JpaRepository 接口 * JpaRepository已经帮我们实现了很多操作直接使用即可 * 第一个参数为 操作的实体的类型 * 第二个参数为 主键的类型 */public interface BookDao extends JpaRepository&lt;Book,Integer&gt; { /** * 根据id查找 * @param id * @return */ Book findBookById(Integer id); /** * 查询比id小的 * @param integer * @return */ List&lt;Book&gt; findBookByIdLessThan(Integer integer); /** * 查询比id大的或者包含此名称的 * @param id * @param name * @return */ List&lt;Book&gt; findBookByIdGreaterThanOrNameContaining(Integer id, String name);} ②测试123456789 @Testvoid customeFind(){ Book bookById = bookDao.findBookById(4); System.out.println(bookById); List&lt;Book&gt; bookByIdLessThan = bookDao.findBookByIdLessThan(3); System.out.println(bookByIdLessThan); List&lt;Book&gt; finc = bookDao.findBookByIdGreaterThanOrNameContaining(6, \"马\"); System.out.println(finc);} 3、jpa自定义sql查询@Query标记为自定义的sql查询，nativeQuery=true，使用原生的sql操作 @Modifying标记为更新删除或新增的方法 @Transactional当方法为更新删除或者新增的时候，需要在自定义的方法上加上事务，或者在方法所在的dao或者service上加上事务@Transactional 两种传参形式：① 冒号形式 12Query(value = \"insert into t_book(name,author) values(:name,:author)\",nativeQuery = true)Integer addBook(@Param(\"name\")String name,@Param(\"author\")String author); ② ?形式 1234@Modifying@Transactional @Query(value = \"insert into t_book(name,author) values(?1,?2)\",nativeQuery = true) Integer addBook1(String name,String author); 12345678910111213141516171819202122/** * 这里要实现 JpaRepository 接口 * JpaRepository已经帮我们实现了很多操作直接使用即可 * 第一个参数为 操作的实体的类型 * 第二个参数为 主键的类型 */public interface BookDao extends JpaRepository&lt;Book,Integer&gt; { @Query(value = \"select * from t_book where id=(select max(id) from t_book)\",nativeQuery = true) Book getMaxIdBook(); @Modifying @Transactional @Query(value = \"insert into t_book(name,author) values(:name,:author)\",nativeQuery = true) Integer addBook(@Param(\"name\")String name,@Param(\"author\")String author); @Modifying @Transactional @Query(value = \"insert into t_book(name,author) values(?1,?2)\",nativeQuery = true) Integer addBook1(String name,String author);} 4、多数据源配置①pom.xml配置一致②yaml配置12345678910111213141516171819202122232425262728293031spring: datasourceone: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=UTF-8 username: root password: 123456 datasourcetwo: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://47.96.141.44:3306/test?useUnicode=true&amp;characterEncoding=UTF-8 username: root password: 你的密码 jpa: # 显示sql语句 show-sql: true # 数据库 database: mysql # 数据库平台 database-platform: mysql # 设置表的结构的生成类型 hibernate: # 每次启动更新表结构 ddl-auto: create properties: hibernate:# 搜索mysql57即可 找到类路径 # 设置方言 mysql57 dialect: org.hibernate.dialect.MySQL57Dialect ③实体bean1234567891011121314151617181920212223242526272829303132/** * 指定表的名称 若不存在 则自动为你创建此表 */@Entity(name = \"t_book\")@Getter@Setter@ToStringpublic class Book { /** *在jpa中一个表必须设置主键，否则创建会失败 * @Id标注的属性为主键 * @GeneratedValue指定生成策略为自增长 * @column中可设置字段的约束操作（长度为10） */ @Id @GeneratedValue(strategy = GenerationType.IDENTITY) @Column(length = 10) private Integer id; /** * 设置自动不能为空，长度为50,设置数据库中和属性的对应名称 */ @Column(nullable = false,length = 50,name = \"name\") private String name; /** * 设置自动不能为空，长度为20,设置数据库中和属性的对应名称 */ @Column(nullable = false,length = 20,name = \"author\") private String author;} ④数据源注入1234567891011121314151617@Configurationpublic class DataSourceConfig { @Primary @Bean @ConfigurationProperties(\"spring.datasourceone\") DataSource dataSourceOne(){ return DruidDataSourceBuilder.create().build(); } @Bean @ConfigurationProperties(\"spring.datasourcetwo\") DataSource dataSourceTwo() { return DruidDataSourceBuilder.create().build(); }} ⑤事务及LocalContainerEntityManagerFactoryBean配置1234567891011121314151617181920212223242526272829303132333435363738394041/** * basePackages 扫描所在接口的包 * entityManagerFactoryRef 引用配置的localContainerEntityManagerFactoryBeanOne * transactionManagerRef 引用配置的 事务platformTransactionManagerOne */@EnableJpaRepositories(basePackages = \"org.lc.jpa.dao.dao1\",entityManagerFactoryRef = \"localContainerEntityManagerFactoryBeanOne\",transactionManagerRef = \"platformTransactionManagerOne\")@Configurationpublic class JpaConfigOne { @Autowired @Qualifier(\"dataSourceOne\") DataSource dataSourceOne; //注入yaml中的其他属性配置 @Autowired JpaProperties jpaProperties; @Bean LocalContainerEntityManagerFactoryBean localContainerEntityManagerFactoryBeanOne(EntityManagerFactoryBuilder builder) { //注入数据源 return builder.dataSource(dataSourceOne)// 配置操作的实体bean .packages(\"org.lc.jpa.bean\")// 注入配置属性文件 .properties(jpaProperties.getProperties())// 初始化单元 不同即可 .persistenceUnit(\"pu1\") .build(); } /** * 事务的配置 * @param builder * @return */ @Bean PlatformTransactionManager platformTransactionManagerOne(EntityManagerFactoryBuilder builder) { return new JpaTransactionManager(localContainerEntityManagerFactoryBeanOne(builder).getObject()); }} 123456789101112131415161718192021222324252627282930313233343536373839404142/** * basePackages 扫描所在接口的包 * entityManagerFactoryRef 引用配置的localContainerEntityManagerFactoryBeanOne * transactionManagerRef 引用配置的 事务platformTransactionManagerOne */@EnableJpaRepositories(basePackages = \"org.lc.jpa.dao.dao2\",entityManagerFactoryRef = \"localContainerEntityManagerFactoryBeanTwo\",transactionManagerRef = \"platformTransactionManagerTwo\")@Configurationpublic class JpaConfigTwo { @Autowired @Qualifier(\"dataSourceTwo\") DataSource dataSourceTwo; //注入yaml中的其他属性配置 @Autowired JpaProperties jpaProperties; @Primary @Bean LocalContainerEntityManagerFactoryBean localContainerEntityManagerFactoryBeanTwo(EntityManagerFactoryBuilder builder) { //注入数据源 return builder.dataSource(dataSourceTwo)// 配置操作的实体bean .packages(\"org.lc.jpa.bean\")// 注入配置属性文件 .properties(jpaProperties.getProperties())// 初始化单元 不同即可 .persistenceUnit(\"pu1\") .build(); } /** * 事务的配置 * @param builder * @return */ @Primary @Bean PlatformTransactionManager platformTransactionManagerTwo(EntityManagerFactoryBuilder builder) { return new JpaTransactionManager(localContainerEntityManagerFactoryBeanTwo(builder).getObject()); }} ⑥两个不同包及名称的接口123public interface BookDaoOne extends JpaRepository&lt;Book,Integer&gt; { } 123public interface BookDaoTwo extends JpaRepository&lt;Book,Integer&gt; { } ⑦测试注入不同的dao进行测试 123456789101112@Autowiredprivate BookDaoOne bookDaoOne; @Autowiredprivate BookDaoTwo bookDaoTwo;@Testvoid multipleFind() { List&lt;Book&gt; all = bookDaoOne.findAll(); System.out.println(all); List&lt;Book&gt; all1 = bookDaoTwo.findAll(); System.out.println(all1);}","link":"/2020/04/17/multipledatasource/%E6%95%B4%E5%90%88Jpa%E5%8F%8A%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90/"},{"title":"springboot整合Mybatis及多数据源","text":"springboot整合Mybatis注意：1、mapper映射文件存放位置：①存放在java文件夹中当mapper映射文件存放的位置在src/mian/java中，即和mapper接口文件位置一致时。由于maven编译时会忽略配置xml文件，所以我们需要手动配置过滤其java文件夹下的xml文件即resource下的xml 12345678910111213&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; ②存放在resources下放在同一目录结构==&gt; 放在resources下的文件夹要和接口中的文件夹目录结构一致。 注意：这里新建包名要一个一个建，不要想java目录中的结果一样，直接把所有的包名写在一起。 例如：接口目录 src/main/org/lc/mybatis/mapper/xxxx.java mappes映射文件目录 resources/org/lc/mybatis/mapper/xxxx.mapper 放在不同目录结构==&gt; 例如：resources/mapper/mybatis01/xxxx.mapper 则需要在yaml中重新指定mappe映射位置： 1234567891011spring: datasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=UTF-8 username: root password: 123456mybatis: #映射resources资源目录下的mapper文件夹下的任意目录下的xml文件 mapper-locations: classpath:/mapper/**/*.xml 2、@Mapper @MapperScan(s）@Mapper 扫描单个mapper接口 @MapperScans({ ​ @MapperScan(), ​ @MapperScan() }) @MapperScan() 扫描指定包下的所有mapper接口，多数据源时，则需要指定对应的sqlSessionFactoryRef，sqlSessionTemplateRef 1234 @MapperScan(basePackages = \"org.lc.mybatis.mapper.mapper1\",sqlSessionFactoryRef = \"sqlSessionFactoryOne\",sqlSessionTemplateRef = \"sqlSessionTemplateOne\")@Configurationpublic class MybatisConfig {} 单数据源配置:pom.xml 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;mybatis&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.18&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;version&gt;5.1.27&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt;&lt;/project&gt; 1234567spring: datasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=UTF-8 username: root password: 123456 Lombok插件的使用:==&gt; 生成getter setter及 tostring 12345678@Getter@Setter@ToStringpublic class User { private Integer id; private String username; private String address;} *@Mapper *扫描mapper注入容器中 1234@Mapperpublic interface UserMapper { List&lt;User&gt; getAllUser();} 1234567&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" &gt;&lt;mapper namespace=\"org.lc.mybatis.mapper.UserMapper\"&gt; &lt;select id=\"getAllUser\" resultType=\"org.lc.mybatis.bean.User\"&gt; select * from user &lt;/select&gt;&lt;/mapper&gt; 使用==&gt; 123456789101112@SpringBootTestclass MybatisApplicationTests { @Autowired private UserMapper userMapper; @Test void contextLoads() { List&lt;User&gt; allUser = userMapper.getAllUser(); System.out.println(allUser); }} 多数据源配置:1234567891011121314spring: datasourceone: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=UTF-8 username: root password: 123456 datasourcetwo: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://47.96.141.44:3306/test?useUnicode=true&amp;characterEncoding=UTF-8 username: root password: xxxx 数据源属性注入==&gt; 12345678910111213141516@Configurationpublic class DataSourceConfig { @ConfigurationProperties(\"spring.datasourceone\") @Bean public DataSource dataSourceOne(){ return DruidDataSourceBuilder.create().build(); } @ConfigurationProperties(\"spring.datasourcetwo\") @Bean public DataSource dataSourceTwo(){ return DruidDataSourceBuilder.create().build(); }} SqlSessionFactory与SqlSessionTemplate配置==&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768@MapperScans({ //数据源一的对应的mapper接口位置 @MapperScan(basePackages = \"org.lc.mybatis.mapper.mapper1\",sqlSessionFactoryRef = \"sqlSessionFactoryOne\",sqlSessionTemplateRef = \"sqlSessionTemplateOne\"), //数据源二的对应的mapper接口位置 @MapperScan(basePackages = \"org.lc.mybatis.mapper.mapper2\",sqlSessionFactoryRef =\"sqlSessionFactoryTwo\",sqlSessionTemplateRef = \"sqlSessionTemplatelTwo\")})@Configurationpublic class MybatisConfig { /** * 数据源一注入 */ @Qualifier(\"dataSourceOne\") @Autowired DataSource dataSourceOne; /** * 数据源二注入 */ @Resource(name = \"dataSourceTwo\") DataSource dataSourceTwo; /** * SqlSessionFactory 属性配置 * @return */ @Bean public SqlSessionFactory sqlSessionFactoryOne(){ SqlSessionFactoryBean sqlSessionFactoryBean=new SqlSessionFactoryBean(); sqlSessionFactoryBean.setDataSource(dataSourceOne); try { //配置在resources下的自定义mapper文件位置 sqlSessionFactoryBean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(\"classpath:mapper/mybatis01/**/*.xml\")); return sqlSessionFactoryBean.getObject(); } catch (Exception e) { e.printStackTrace(); } return null; } /** * SqlSessionTemplate 一模板操作配置 * @return */ @Bean public SqlSessionTemplate sqlSessionTemplateOne(){ return new SqlSessionTemplate(sqlSessionFactoryOne()); } @Bean public SqlSessionFactory sqlSessionFactoryTwo(){ SqlSessionFactoryBean sqlSessionFactoryBean=new SqlSessionFactoryBean(); sqlSessionFactoryBean.setDataSource(dataSourceTwo); try { //配置在resources下的自定义mapper文件位置 sqlSessionFactoryBean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(\"classpath:mapper/mybatis02/**/*.xml\")); return sqlSessionFactoryBean.getObject(); } catch (Exception e) { e.printStackTrace(); } return null; } @Bean public SqlSessionTemplate sqlSessionTemplatelTwo(){ return new SqlSessionTemplate(sqlSessionFactoryTwo()); }} 同理=&gt; ①当mapper.xml在java文件夹下，则不需要配置mapper.xml的位置 ②当mapper.xml在resources自定义的文件夹下，则需要配置mapper.xml的位置 12//配置在resources下的自定义mapper文件位置 sqlSessionFactoryBean.setMapperLocations(new PathMatchingResourcePatternResolver().getResources(\"classpath:mapper/mybatis02/**/*.xml\") 因为多数据源的关系，所以所有在yaml的基本mybatis的配置失效，需要重新在SqlSessionFactory配置","link":"/2020/04/17/multipledatasource/%E6%95%B4%E5%90%88MyBatis%E5%8F%8A%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90/"},{"title":"JAR包和WAR包","text":"JAR包和WAR包一、JAR包1、简介JAR（Java Archive，Java 归档文件）是与平台无关的文件格式，它允许将许多文件组合成一个压缩文件。JavaSE程序可以打包成Jar包(J其实可以理解为Java了)。 JAR 文件格式以流行的 ZIP 文件格式为基础。与 ZIP 文件不同的是，JAR 文件不仅用于压缩和发布，而且还用于部署和封装库、组件和插件程序，并可被像编译器和 JVM 这样的工具直接使用。在 JAR 中包含特殊的文件，如 manifests 和部署描述符，用来指示工具如何处理特定的 JAR。 简单来说，jar包就是别人已经写好的一些类，然后对这些类进行打包。可以将这些jar包引入到你的项目中，可以直接使用这些jar包中的类和属性，这些jar包一般放在lib目录下。 2、Spring Boot 可执行 jarSpring Boot 中默认打包成的 jar 叫做 可执行 jar，这种 jar 不同于普通的 jar，普通的 jar 不可以通过 java -jar xxx.jar 命令执行，普通的 jar 主要是被其他应用依赖，Spring Boot 打成的 jar 可以执行，但是不可以被其他的应用所依赖，即使强制依赖，也无法获取里边的类。但是可执行 jar 并不是 Spring Boot 独有的，Java 工程本身就可以打包成可执行 jar 。 我们在springboot项目中可以看到一个默认的插件配置 spring-boot-maven-plugin这个打包插件存在 5 个方面的功能，从插件命令就可以看出： 五个功能分别是： build-info：生成项目的构建信息文件 build-info.properties repackage：这个是默认 goal，在 mvn package 执行之后，这个命令再次打包生成可执行的 jar，同时将 mvn package 生成的 jar 重命名为 *.origin run：这个可以用来运行 Spring Boot 应用 start：这个在 mvn integration-test 阶段，进行 Spring Boot 应用生命周期的管理 stop：这个在 mvn integration-test 阶段，进行 Spring Boot 应用生命周期的管理 这里功能，默认情况下使用就是 repackage 功能，其他功能要使用，则需要开发者显式配置。 3、打包repackage 功能的 作用，就是在打包的时候，多做一点额外的事情： 首先 mvn package 命令 对项目进行打包，打成一个 jar，这个 jar 就是一个普通的 jar，可以被其他项目依赖，但是不可以被执行 repackage命令，对第一步 打包成的jar进行再次打包，将之打成一个 可执行jar，通过将第一步打成的jar重命名为*.original` 文件 可执行jar(不能作为依赖):代码是存在 于 BOOT-INF/classes/ 目录下，另外，还有一个 META-INF 的目录，该目录下有一个 MANIFEST.MF 文件，打开该文件，内容如下： 12345678910Manifest-Version: 1.0Implementation-Title: adminImplementation-Version: 0.0.1-SNAPSHOTStart-Class: org.lc.admin.AdminApplicationSpring-Boot-Classes: BOOT-INF/classes/Spring-Boot-Lib: BOOT-INF/lib/Build-Jdk-Spec: 1.8Spring-Boot-Version: 2.2.5.RELEASECreated-By: Maven Archiver 3.4.0Main-Class: org.springframework.boot.loader.JarLauncher 可以看到，这里定义了一个 Start-Class，这就是可执行 jar 的入口类，Spring-Boot-Classes 表示我们自己代码编译后的位置，Spring-Boot-Lib 则表示项目依赖的 jar 的位置。 换句话说，如果自己要打一个可执行 jar 包的话，除了添加相关依赖之外，还需要配置 META-INF/MANIFEST.MF 文件。 不可执行jar(只能作为依赖)：这是可执行 jar 的结构，那么不可执行 jar 的结构呢？ 我们首先将默认的后缀 .original 除去，然后给文件重命名，重命名完成，进行解压： 解压后可以看到，不可执行 jar 根目录就相当于我们的 classpath，解压之后，直接就能看到我们的代码，它也有 META-INF/MANIFEST.MF 文件，但是文件中没有定义启动类等。 12345Manifest-Version: 1.0Implementation-Title: adminImplementation-Version: 0.0.1-SNAPSHOTBuild-Jdk-Spec: 1.8Created-By: Maven Archiver 3.4.0 注意这个不可以执行 jar 也没有将项目的依赖打包进来。 从这里我们就可以看出，两个 jar ，虽然都是 jar 包，但是内部结构是完全不同的，因此一个可以直接执行，另一个则可以被其他项目依赖。 4、一次打包两个 jar（自定义可执行jar名称）一般来说，Spring Boot 直接打包成可执行 jar 就可以了，不建议将 Spring Boot 作为普通的 jar 被其他的项目所依赖。如果有这种需求，建议将被依赖的部分，单独抽出来做一个普通的 Maven 项目，然后在 Spring Boot 中引用这个 Maven 项目。 如果非要将 Spring Boot 打包成一个普通 jar 被其他项目依赖，技术上来说，也是可以的，给 spring-boot-maven-plugin 插件添加如下配置： 1234567891011&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;configuration&gt; &lt;classifier&gt;exec&lt;/classifier&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 配置的 classifier 表示可执行 jar 的名字，配置了这个之后，在插件执行 repackage 命令时，就不会给 mvn package 所打成的 jar 重命名了，所以，打包后的 jar 如下： ![](F:\\桌面内容\\springboot2\\项目构建与部署与Maven使用\\images\\批注 2020-04-08 231513.png) 第一个jar可被其他项目依赖的jar 第二个jar则表示是一个可执行jar(自定义可执行jar名) 二、WAR包1、简介war是一个可以直接运行的web模块，通常用于网站，打成包部署到容器中。以Tomcat来说，将war包放置在其\\webapps\\目录下，然后启动Tomcat，这个包就会自动解压，就相当于发布了。 war包是Sun提出的一种web应用程序格式，与jar类似，是很多文件的压缩包。war包中的文件按照一定目录结构来组织。根据其根目录下包含有html和jsp文件，或者包含有这两种文件的目录，另外还有WEB-INF目录。通常在WEB-INF目录下含有一个web.xml文件和一个classes目录，web.xml是这个应用的配置文件，而classes目录下则包含编译好的servlet类和jsp，或者servlet所依赖的其他类（如JavaBean）。通常这些所依赖的类也可以打包成jar包放在WEB-INF下的lib目录下。 简单来说，war包是JavaWeb程序打的包，war包里面包括写的代码编译成的class文件，依赖的包，配置文件，所有的网站页面，包括html，jsp等等。一个war包可以理解为是一个web项目，里面是项目的所有东西。 区别：WAR文件代表了一个Web应用程序，JAR是类的归档文件 2、部署war包到Tomcat1）. 我这里工作中一般是开发打war包给测试，比如说现在测试拿到一个war包，名字叫test.war。 2）. 打开Tomcat的安装路径 ，假设是“D:\\Tomcat\\apache-tomcat-7.0.68”，然后进入到 webapps文件夹中，把 test.war放到 webapps文件夹。 3）. 启动Tomcat。 如果不需要更改配置文件：到这一步就可以了。 在浏览器输入“http:localhost:tomcat_port/test即可打开test项目的 index.jsp页面（port是自己的端口号）。如果test项目没有index.jsp页面，那就需要打开其他相应的页面。 如果需要更改配置文件： 4）. 关闭 Tomcat。 5）. 删除 test.war文件（如果在tomcat启动的状态下删去war包，解压好的文件夹也会被一并删除，所以需要在解压后停止tomcat， 然后删掉war包，这时再启动。这时项目文件夹就会被认为不是war解压而来。）。 6）. 由于刚刚启动过Tomcat，Tomcat会自动解压缩test.war为 test文件夹。所以我们在webapps下面可以看到test文件夹。打开test文件夹更改配置文件即可。 7）. 更新完配置之后，启动Tomcat。 8）. 浏览器打开即可。","link":"/2020/04/17/projectBuildAndDev/Jar%E5%8C%85%E4%B8%8EWar%E5%8C%85/"},{"title":"SpringBoot和Nginx实现gzip压缩","text":"SpringBoot和Nginx实现gzip压缩前后端分离项目如果做成 SPA（单页面）的形式，就必然面临一个首屏加载的问题，因为默认情况下首页文件比较大，可能超过 1 MB，进而带来首页加载很慢的问题。所以我们要通过优化，来提高首页的加载速度。 问题的解决，一般来说有这样几种思路： UI 组件按需加载 路由懒加载 组件重复打包 gzip 这些加载方式中，UI 组件按需加载和 gzip 是两种比较常用的方案，另外两种优化方式则要结合具体的项目，看看是否具备相关条件。 一、ElementUI按需加载1.1 问题不做任何优化，我们一般是在 main.js 中按照如下方式来引入 ElementUI 的： 即一次加载全部组件 123import ElementUI from 'element-ui';import 'element-ui/lib/theme-chalk/index.css';Vue.use(ElementUI,{size:'small'}); 这样做，没有用上的组件必然会造成资源的浪费 通过如下命令对项目生成 report.html 用来帮助我们分析包内容： 1vue-cli-service build --report 访问 report.html即可查看个文件的占用情况 ![](F:\\桌面内容\\springboot2\\项目构建与部署与Maven使用\\images\\批注 2020-04-12 193314.png) 1.2解决办法只在开发环境使用 -D 1npm install babel-plugin-component -D 这时会生成一个babel.config.js文件，修改其内容： 1234567891011121314151617181920module.exports = { presets: [ '@vue/cli-plugin-babel/preset', [ '@babel/preset-env', { modules: false } ] ], plugins: [ [ \"component\", { \"libraryName\": \"element-ui\", \"styleLibraryName\": \"theme-chalk\" } ] ]} 然后修改main.js，将elementUI组件按需导入 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596import { Button, Input, Table, TableColumn, Dialog, Card, Container, Footer, Icon, Select, Form, Tag, Tree, Pagination, Badge, Loading, Message, MessageBox, Menu, Tabs, TabPane, Breadcrumb, BreadcrumbItem, Dropdown, Steps, Tooltip, Popover, Collapse, FormItem, Checkbox, Header, DropdownMenu, DropdownItem, Aside, Main, MenuItem, Submenu, Option, Col, Row, Upload, Radio, DatePicker, RadioGroup, CollapseItem, Switch} from 'element-ui';//注册组件Vue.prototype.$ELEMENT = {size: 'small', zIndex: 3000};Vue.use(Switch);Vue.use(CollapseItem);Vue.use(Radio);Vue.use(RadioGroup);Vue.use(DatePicker);Vue.use(Upload);Vue.use(Row);Vue.use(Col);Vue.use(Option);Vue.use(Submenu);Vue.use(MenuItem);Vue.use(Header);Vue.use(DropdownMenu);Vue.use(DropdownItem);Vue.use(Aside);Vue.use(Main);Vue.use(Checkbox);Vue.use(FormItem);Vue.use(Collapse);Vue.use(Popover);Vue.use(Menu);Vue.use(Tabs);Vue.use(TabPane);Vue.use(Breadcrumb);Vue.use(BreadcrumbItem);Vue.use(Dropdown);Vue.use(Steps);Vue.use(Tooltip);Vue.use(Tree);Vue.use(Pagination);Vue.use(Badge);Vue.use(Loading);Vue.use(Button);Vue.use(Input);Vue.use(Table);Vue.use(Footer);Vue.use(TableColumn);Vue.use(Dialog);Vue.use(Card);Vue.use(Container);Vue.use(Icon);Vue.use(Select);Vue.use(Form);Vue.use(Tag);Vue.prototype.$alert = MessageBox.alertVue.prototype.$confirm = MessageBox.confirm 这里的代码倒是不难，有两个需要注意的地方： MessageBox 的引入方式和其他组件不太一样，需要注意。 给组件统一定制 size 和 zIndex 的方式有所变化。 其他具体不同的引入和注册方式查看 ElementUI官网：https://element.faas.ele.me/#/zh-CN/component/quickstart 再次执行 vue-cli-service build --report ，查看打包结果，发现相比上次文件大小减少不小 二、gzip我们可以下上面的基础上，使用gzip继续压缩 2.1服务端配置压缩前端编译打包后拷贝到后端，直接部署后端项目即可 这里我们在springboot的application.yaml中 1234server:# 当前端项目在static目录下 则开启压缩 compression: enabled: true 配置完成后，重启后端项目，访问项目首页，如下，可以看到文件基本上都被压缩了： 我们任意点开一个js文件： ![](F:\\桌面内容\\springboot2\\项目构建与部署与Maven使用\\images\\批注 2020-04-12 194559.png) 我们发现响应头已经有gzip的信息，即该文件已被压缩。 2.2 Nginx的动态压缩和静态压缩 Nginx 动态压缩，静态文件还是普通文件，前端在Nginx部署上的文件时普通文件，当请求来了Nginx再压缩，然后将压缩文件返回给前端，交由前端再解压回显。 Nginx 静态压缩，前端提前把文件压缩成 .gz 格式，然后部署在Nginx，此时Nginx是压缩文件，请求来了，Nginx直接将该文件返回即可。 2.2.1 Nginx动态压缩动态压缩 Vue 还是使用普通的打包编译后的文件，将前端编译打包后的文件拷贝到 Nginx 的 html 目录下，然后访问 nginx： 确保 nginx 运行成功后，接下来对 nginx 进行配置： 1234gzip on; # 开启 gzipgzip_min_length 2k;# 超过 2kb 进行压缩gzip_disable msie6; # ie6 不适用 gzipgzip_types text/css application/javascript text/javascript image/jpeg image/png image/gif; # 需要处理的文件 配置完成后，重启 Nginx： 1/usr/lcoal/nginx/sbin/nginx -s reload 启动成功后，再去访问前端页面，就可以看到压缩效果了。 直接访问ip 2.2.2 Nginx静态压缩上面的动态压缩有一个问题，就是每次请求响应的时候都要压缩，其实都是相同的文件，总是压缩有点浪费资源。 我们可以提前将文件压缩好，就保存在服务端，需要用的时候直接返回，就会方便很多。 这需要我们首先在前端安装压缩插件： 1npm install compression-webpack-plugin -D 安装成功之后，接下来在 vue.config.js 中进行配置： 1234567891011121314151617181920212223242526//插件导入const CompressionPlugin = require(\"compression-webpack-plugin\");module.exports={ // 前端服务器的地址信息 devServer:{ host:'localhost', //前端地址 port:8080, //前端端口 proxy:proxyObj }, //静态压缩配置 configureWebpack: config =&gt; { if (process.env.NODE_ENV === 'production') { return { plugins: [ new CompressionPlugin({ test: /\\.js$|\\.html$|\\.css/, //超过1kb即压缩 threshold: 1024, //压缩后是否删除源文件 deleteOriginalAssets: false }) ] } } }} 配置完成后，再次执行打包命令 vue-cli-service build。这次打包完成后，我们可以在 js 目录下看到 .gz 文件，如下：我们发现超过1kb的文件即被压缩 ![](F:\\桌面内容\\springboot2\\项目构建与部署与Maven使用\\images\\批注 2020-04-12 201221.png) 接下来将文件上传到 Nginx 服务器，然后对 Nginx 重新进行编译打包。想让 Nginx 返回已经压缩好的文件，需要用到 Nginx 中的 http_gzip_static_module 模块，这个模块可以发送以 .gz 作为文件扩展名的预压缩文件，所以我们要对 Nginx 重新进行编译打包： 123./configure --with-http_gzip_static_module 或者 /root/nginx-1.8.1/configure --with-http_gzip_static_modulemakemake install 然后在 Nginx 配置文件中开启 gzip_static，如下： 12gzip_static on;#动态压缩的其他配置注释 注意，开启了 gzip_static 后，gzip_types 就失效了，所以也没必要配置这个属性了。 配置完成后，重启 Nginx，再去访问，查看浏览器日志，就会发现 gzip 已经生效了。 注意： 静态压缩返回的 gzip 压缩文件都是提前准备好的，没有 .gz 格式的文件就会自动返回原文件。这是一种和动态压缩不同的响应策略。动态压缩是根据 Nginx 中的配置，超过配置的大小就会自动进行压缩。 好了，这一波操作下来，首屏加载速度提高了 5 倍左右。","link":"/2020/04/17/projectBuildAndDev/Springboot%E5%92%8CNginx%E5%AE%9E%E7%8E%B0gzip%E5%8E%8B%E7%BC%A9/"},{"title":"Redis做消息队列","text":"Redis做消息队列​ 我们平时说到消息队列，一般都是指 RabbitMQ、RocketMQ(阿里)、ActiveMQ 以及大数据里边的 Kafka，这些是我们比较常见的消息中间件，也是非常专业的消息中间件，作为专业的中间件，它里边提供了许多功能。 但是，当我们需要使用消息中间件的时候，并非每次都需要非常专业的消息中间件，假如我们只有一个消息队列，只有一个消费者，那就没有必要去使用上面这些专业的消息中间件，这种情况我们可以直接使用 Redis 来做消息队列。 Redis 的消息队列不是特别专业，他没有很多高级特性，适用简单的场景，如果对于消息可靠性有着极高的追求，那么不适合使用 Redis 做消息队列。 一、Redis 做消息队列​ 使用它里边的 List 数据结构就可以实现，我们可以使用 lpush/rpush 操作来实现入队，然后使用 lpop/rpop 来实现出队。 ​ 在客户端（例如 Java 端），我们会维护一个死循环来不停的从队列中读取消息，并处理，如果队列中有消息，则直接获取到，如果没有消息，就会陷入死循环，直到下一次有消息进入，这种死循环会造成大量的资源浪费，这个时候，我们可以使用之前讲的 blpop/brpop(阻塞式的弹出) 二、延迟消息队列延迟队列可以通过 zset 来实现，因为 zset 中有一个 score，我们可以把时间作为 score，将 value 存到 redis 中，然后通过轮询的方式，去不断的读取消息出来。 首先，如果消息是一个字符串，直接发送即可，如果是一个对象，则需要对对象进行序列化，这里我们使用 JSON 来实现序列化和反序列化。 1、pom.xml123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;distributed_lock&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;!--序列化我们需要使用到的jackson--&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.10.3&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 2、jedis和jedis连接池工具 CallWithJedis 1234public interface CallWithJedis { void call(Jedis jedis);} Redis 12345678910111213141516171819202122232425262728293031public class Redis { private JedisPool jedisPool; public Redis() {// 连接池配置对象 GenericObjectPoolConfig config=new GenericObjectPoolConfig();// 连接池最大空闲数 config.setMaxIdle(300);// 最大连接数 config.setMaxTotal(1000);// 连接最大等待时间（毫秒）。-1表示无限制 config.setMaxWaitMillis(30000);// 在空闲时检查有效性 config.setTestOnBorrow(true); /** * 1、连接池配置 * 2、redis地址 * 3、端口 * 4、超时时间 * 5、密码 */ jedisPool = new JedisPool(config, \"47.96.141.44\",6379,30000,\"你的密码\"); } public void execute(CallWithJedis callWithJedis) { try (Jedis jedis=jedisPool.getResource()) { callWithJedis.call(jedis); } }} 3、消息对象 LcMessgae 123456789101112131415161718192021222324252627282930public class LcMessgae implements Serializable { private String id; private Object data; public String getId() { return id; } public LcMessgae setId(String id) { this.id = id; return this; } public Object getData() { return data; } public LcMessgae setData(Object data) { this.data = data; return this; } @Override public String toString() { return \"LcMessgae{\" + \"id='\" + id + '\\'' + \", data=\" + data + '}'; }} 4、延迟消息队列对象1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071/** * 延迟消息队列 */public class DelayMsgQueue { private Jedis jedis; private String queue; public DelayMsgQueue(Jedis jedis, String queue) { this.jedis = jedis; this.queue = queue; } /** * 消息入队 * @param data 要发送的数据 */ public void queue(Object data) {// 构造一个消息对象 LcMessgae msg=new LcMessgae(); msg.setId(UUID.randomUUID().toString()); msg.setData(data);// 序列化对象 try {// 序列化对象为字符串 String s = new ObjectMapper().writeValueAsString(msg); System.out.println(\"msg publish:\"+new Date());// 队列的名称; 延迟五秒发送; 发送的消息 jedis.zadd(queue, System.currentTimeMillis() + 5000, s); } catch (JsonProcessingException e) { e.printStackTrace(); } } /** * 消息消费 */ public void loop() {// 如果当前线程没有被打断 则一直循环查找消息 while (!Thread.interrupted()){// 读取的队列; 从0开始; 到当前时间戳结束; 偏移量; 读取的个数 Set&lt;String&gt; zrange= jedis.zrangeByScore(queue, 0, System.currentTimeMillis(), 0, 1);// 如果读到的为空 if (zrange.isEmpty()) { try {// 休息0.5秒 Thread.sleep(500); } catch (InterruptedException e) {// 抛出异常直接。直接跳出循环 break; }// 否则 直接进行下一次循环 continue; }// 如果有消息 直接加载消息 String next = zrange.iterator().next();// 如果成功弹出指定消息 if(jedis.zrem(queue, next)&gt;0){// 处理业务// 消费该队列即可 try {// 将该字符串member反序列化为对象 LcMessgae lcMessgae = new ObjectMapper().readValue(next, LcMessgae.class); System.out.println(\"receive msg:\"+new Date()+\"&gt;&gt;&gt;&gt;&gt;&gt;&gt;\"+lcMessgae); } catch (JsonProcessingException e) { e.printStackTrace(); } } } }} 5、测试123456789101112131415161718192021222324252627282930313233343536373839404142package org.lc.distributed_lock;import javax.annotation.Resource;/** * @BelongsProject: distributed_lock * @BelongsPackage: org.lc.distributed_lock * @Author: lc * @CreateTime: 2020-04-23 22:17 * @Description: */public class DelayMsgTest { public static void main(String[] args) { Redis redis=new Redis(); redis.execute(jedis-&gt;{// 构造一个消息队列 DelayMsgQueue queue = new DelayMsgQueue(jedis, \"lc-queue\"); Thread producer= new Thread(() -&gt; { for (int i = 0; i &lt; 5; i++) {// 生产者 queue.queue(\"louchen.top&gt;&gt;&gt;&gt;\"+i); } });// 消费者 Thread consumer = new Thread(() -&gt; queue.loop());// 启动 producer.start(); consumer.start();// 休息7s，停止程序 try { Thread.sleep(7000); //中断消费 consumer.interrupt(); } catch (InterruptedException e) { e.printStackTrace(); } }); }} 12345678910msg publish:Thu Apr 23 22:44:55 GMT+08:00 2020msg publish:Thu Apr 23 22:44:55 GMT+08:00 2020msg publish:Thu Apr 23 22:44:55 GMT+08:00 2020msg publish:Thu Apr 23 22:44:55 GMT+08:00 2020msg publish:Thu Apr 23 22:44:55 GMT+08:00 2020receive msg:Thu Apr 23 22:45:00 GMT+08:00 2020&gt;&gt;&gt;&gt;&gt;&gt;&gt;LcMessgae{id='d366029d-0a62-49f5-96fb-20f87c51db4e', data=louchen.top&gt;&gt;&gt;&gt;0}receive msg:Thu Apr 23 22:45:01 GMT+08:00 2020&gt;&gt;&gt;&gt;&gt;&gt;&gt;LcMessgae{id='e9c730f6-aebc-4244-982c-28063f2ad439', data=louchen.top&gt;&gt;&gt;&gt;1}receive msg:Thu Apr 23 22:45:01 GMT+08:00 2020&gt;&gt;&gt;&gt;&gt;&gt;&gt;LcMessgae{id='ef6129d3-b62b-4222-9c89-dffce6a3ed7c', data=louchen.top&gt;&gt;&gt;&gt;2}receive msg:Thu Apr 23 22:45:01 GMT+08:00 2020&gt;&gt;&gt;&gt;&gt;&gt;&gt;LcMessgae{id='7077679f-f968-4261-a688-cd8f637874d9', data=louchen.top&gt;&gt;&gt;&gt;3}receive msg:Thu Apr 23 22:45:01 GMT+08:00 2020&gt;&gt;&gt;&gt;&gt;&gt;&gt;LcMessgae{id='1089b3e5-bea4-47a0-886f-b020091fe01a', data=louchen.top&gt;&gt;&gt;&gt;4}","link":"/2020/04/25/redis/Redis%E5%81%9A%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"},{"title":"Redis实现分布式锁的方式","text":"Redis实现分布式锁的方式问题场景：​ 例如一个简单的用户操作，一个线城去修改用户的状态，首先从数据库中读出用户的状态，然后在内存中进行修改，修改完成后，再存回去。在单线程中，这个操作没有问题，但是在多线程中，由于读取、修改、存 这是三个操作，不是原子操作，所以在多线程中，这样会出问题。 对于这种问题，我们可以使用分布式锁来限制程序的并发执行。 一、基本用法这里我们提前封装jedis连接池，拿到jedis对象 pom.xml 1234567&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt; CallWithJedis 123public interface CallWithJedis { void call(Jedis jedis);} Redis 1234567891011121314151617181920212223242526272829303132public class Redis { private JedisPool jedisPool; public Redis() {// 连接池配置对象 GenericObjectPoolConfig config=new GenericObjectPoolConfig();// 连接池最大空闲数 config.setMaxIdle(300);// 最大连接数 config.setMaxTotal(1000);// 连接最大等待时间（毫秒）。-1表示无限制 config.setMaxWaitMillis(30000);// 在空闲时检查有效性 config.setTestOnBorrow(true); /** * 1、连接池配置 * 2、redis地址 * 3、端口 * 4、超时时间 * 5、密码 */ jedisPool = new JedisPool(config, \"47.96.141.44\",6379,30000,\"你的密码\"); } public void execute(CallWithJedis callWithJedis) { try (Jedis jedis=jedisPool.getResource()) { callWithJedis.call(jedis); } }} 1、基本实现方式：123456789101112131415161718192021public class LockTest { public static void main(String[] args) { Redis redis = new Redis(); redis.execute(jedis -&gt; {// 获得锁，只有获得了锁才能进行数据的操作// 这里我们只是测试作用，作为占坑检验操作 Long setnx = jedis.setnx(\"k1\", \"v1\"); if (set != null &amp;&amp; set.equals(\"OK\")) {// 获得了锁 即没人占位 插入真正的key jedis.set(\"name\", \"lc\"); String s = jedis.get(\"name\"); System.out.println(s);// 释放占用的资源 jedis.del(\"k1\"); } else {// 修改失败 有人占位 System.out.println(\"有人占坑\"); } }); }} 上述代码问题：程序异常无法释放锁​ 如果我们的业务代码在执行的过程中抛出异常或者挂了，这样会导致del指令没有被调用(没有释放锁)，那么后面的请求全部堵塞在这，锁永远得不到释放 ​ 这里我们的解决方式就是在获得锁后，给锁添加过期时间，确保锁在一定的时间之后，能够得到释放。 2、给锁添加过期时间jedis.expire(&quot;k1&quot;, 5); 1234567891011121314151617181920212223public class LockTest { public static void main(String[] args) { Redis redis = new Redis(); redis.execute(jedis -&gt; {// 获得锁，只有获得了锁才能进行数据的操作// 这里我们只是测试作用，作为占坑检验操作 Long setnx = jedis.setnx(\"k1\", \"v1\"); if (set != null &amp;&amp; set.equals(\"OK\")) { //给锁添加一个过期时间，防止应用在运行过程中抛出异常导致锁无法及时得到释放 jedis.expire(\"k1\", 5);// 获得了锁 即没人占位 插入真正的key jedis.set(\"name\", \"lc\"); String s = jedis.get(\"name\"); System.out.println(s);// 释放占用的资源 jedis.del(\"k1\"); } else {// 修改失败 有人占位 System.out.println(\"有人占坑\"); } }); }} 上述代码的问题：获得锁和设置过期时间不能保证原子性​ 我们在获得锁和设置锁的过期时间如果服务器挂掉，这个时候锁被占用，过期时间也没有设置，那么也会发生死锁，因为获取锁和设置过期时间为两个操作，不具备原子性 ​ 解决方式：让setnx和exprie同时执行，即在获得锁的同时，同时设置锁的过期时间，保证原子性 3、获得锁同时设置锁过期时间为了解决这个问题，从 Redis2.8 开始，setnx 和 expire 可以通过一个命令一起来执行了 String set = jedis.set(&quot;k1&quot;, &quot;v1&quot;, new SetParams().nx().ex(5)); 1234567891011121314151617181920212223public class LockTest { public static void main(String[] args) { Redis redis = new Redis(); redis.execute(jedis -&gt; {// 这里我们可以在set操作的同时，同时加入其他参数：nx不存在时操作，ex设置过期时间// 这样我们可以防止在获得锁和设置过期时间，如果服务器挂掉，则这个时候锁被占用，无法及时得到释放，从而造成死锁。因为获得锁和设置过期时间是两个操作，不具备原子性。 String set = jedis.set(\"k1\", \"v1\", new SetParams().nx().ex(5)); if (set != null &amp;&amp; set.equals(\"OK\")) {// 给锁添加一个过期时间，防止应用在运行过程中抛出异常导致锁无法及时得到释放 jedis.expire(\"k1\", 5);// 修改成功 即没人占位 插入真正的key jedis.set(\"name\", \"lc\"); String s = jedis.get(\"name\"); System.out.println(s);// 释放占用的资源 jedis.del(\"k1\"); } else {// 修改失败 有人占位 System.out.println(\"有人占坑\"); } }); }} 二、解决超时问题​ 通过以上业务代码我们可以发现，为了防止业务在执行的时候抛出异常，我们给每一个锁添加一个超时时间，超时之后，锁自动释放。当业务时间过长，那么会出现线程紊乱。 ​ 案例：第一个线程首先获得锁，然后开始执行业务代码，这是执行业务代码的时间超过了锁设定的过期时间，那么该线程还未执行完业务代码该锁就被释放了。此时第二个线程获取到锁开始执行，此时该线程执行了几秒之后，第一个线程也执行完了，那么该第一个线程就会释放锁(del)，但是注意，它释放的这个锁是第二个线程的锁，第三个第四个线程也如此，那么就会造成线程紊乱，修改紊乱。 解决方式： ①尽量避免在获取锁的时候，执行耗时操作 ②我么可以在锁上考虑，将锁的value设置为一个随机字符串，每次释放锁的时候，都去比较随机字符串是否一致，如果一致，再去释放锁，否则，不释放。 对于第二种方案，由于释放锁的时候，要去查看锁的 value，第二个比较 value 的值是否正确，第三步释放锁，有三个步骤，很明显三个步骤不具备原子性，为了解决这个问题，我们得引入Lua脚本 Lua 脚本的优势： 使用方便，Redis 中内置了对 Lua 脚本的支持。 Lua 脚本可以在 Redis 服务端原子的执行多个 Redis 命令。 由于网络在很大程度上会影响到 Redis 性能，而使用 Lua 脚本可以让多个命令一次执行，可以有效解决网络给 Redis 带来的性能问题。 在 Redis 中，使用 Lua 脚本，大致上两种思路： 提前在 Redis 服务端写好 Lua 脚本，然后在 Java 客户端去调用脚本（推荐）。 可以直接在 Java 端去写 Lua 脚本，写好之后，需要执行时，每次将脚本发送到 Redis 上去执行。 在Redis服务器中创建Lua脚本基本步骤①、切换到redis安装目录，创建存储lua的文件夹 ②、创建vi releasewherevalueequal.lua文件 ③、编写内容,保存退出 12345if redis.call(\"get\",KEYS[1])==ARGV[1] then return redis.call(\"del\",KEYS[1])else return 0end reids.call 表示调用get操作方式，KEYS[1]表示传过来要操作的key(可以有多个key，索引从1开始)，ARGV表示传过来的其他参数。 ④、给Lua脚本求一个SHA1和(相当于给该lua文件算出一个标识符) redis-cli script load &quot;$(cat lua/releasewherevalueequal.lua)&quot; 返回的标识符： 19d0abd0b3b3bfd1b5294f957dcab483e58b97c84 script load相当于这个命令会在 Redis 服务器中缓存 Lua 脚本，并返回脚本内容的 SHA1 校验和，然后在 Java 端调用时，传入 SHA1 校验和作为参数，这样 Redis 服务端就知道执行哪个脚本了。 接下来，在 Java 端调用这个脚本。 1234567891011121314151617181920212223242526272829303132public class LuaTest { public static void main(String[] args) { Redis redis=new Redis(); redis.execute(jedis -&gt; {// 1、获取一个随机字符串 String s = UUID.randomUUID().toString();// 2、获取锁 String k1 = jedis.set(\"k1\", s, new SetParams().nx().ex(50));// 3、判断是否拿到锁 if (k1 != null &amp;&amp; k1.equals(\"OK\")) {// 4、业务操作 jedis.set(\"lc\", \"louchen.top\"); System.out.println(jedis.get(\"lc\"));// 5、释放锁// 校验和; keys; 其他的参数// 使用redis中加载的lua// jedis.evalsha(\"9d0abd0b3b3bfd1b5294f957dcab483e58b97c84\", Arrays.asList(\"k1\"),Arrays.asList(s));// 直接在java客户端中写lua String script = \"if redis.call('get',KEYS[1]) == ARGV[1] then\" + \" return redis.call('del',KEYS[1]) \" + \"else\" + \" return 0 \" + \"end\"; jedis.eval(script, Arrays.asList(\"k1\"), Arrays.asList(s)); }else{ System.out.println(\"没有拿到锁\"); } }); }} 三、基本命令介绍​ 使用jedis的2.7.x及以上版本。 ​ 命令：SET key value [NX|XX] [EX|PX] seconds ​ NX – 只有键key不存在的时候才会设置key的值 ​ XX – 只有键key存在的时候才会设置key的值 ​ EX seconds – 设置键key的过期时间，单位时秒 ​ PX milliseconds – 设置键key的过期时间，单位时毫秒","link":"/2020/04/23/redis/Redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/"},{"title":"Redis","text":"Redis之布隆过滤器 (Bloom Filter)一、布隆过滤器的应用场景场景1：推送不同消息我们用 HyperLogLog 来估计一个数，有偏差但是也够用。HyperLogLog 主要提供两个方法： pfadd pfcount ​ 但是 HyperLogLog 没有判断是否包含的方法，例如 pfexists 、pfcontains 等。没有这样的方法存在，但是我们有这样的业务需求。 ​ 例如刷今日头条，推送的内容有相似的，但是没有重复的。这就涉及到如何在推送的时候去重？ ​ 解决方案很多，例如将用户的浏览历史记录下来，然后每次推送时去比较该条消息是否已经给用户推送了。但是这种方式效率极低，不推荐。 所以这里我们使用布隆过滤器以今日头条为例，假设我们将用户的浏览记录用 B 表示，A 表示用户没有浏览的新闻，现在要给用户推送消息，先去 B 里边判断这条消息是否已经推送过，如果判断结果说没推送过（B 里边没有这条记录），那就一定没有推送过。如果判断结果说有推送过（B 里边也有可能没有这条消息），这个时候该条消息就不会推送给用户，导致用户错过该条消息，当然这是概率极低的。 场景2：缓存穿透(查不存在的数据)描述：缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。 ​ 我们经常会把一部分数据放在Redis等缓存，比如产品详情。这样有查询请求进来，我们可以根据产品Id直接去缓存中取数据，而不用读取数据库，这是提升性能最简单，最普遍，也是最有效的做法。一般的查询请求流程是这样的：先查缓存，有缓存的话直接返回，如果缓存中没有，再去数据库查询，然后再把数据库取出来的数据放入缓存，一切看起来很美好。但是如果现在有大量请求进来，而且都在请求一个不存在的产品Id，会发生什么？既然产品Id都不存在，那么肯定没有缓存，没有缓存，那么大量的请求都怼到数据库，数据库的压力一下子就上来了，还有可能把数据库打死。虽然有很多办法都可以解决这问题，但是我们的主角是“布隆过滤器”，没错，“布隆过滤器”就可以解决（缓解）缓存穿透问题。 题外话：1、缓存击穿(并发查同一条数据)​ 缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力 2、缓存雪崩 缓存雪崩是指缓存中数据大批量到过期时间，而查询数据量巨大，引起数据库压力过大甚至down机。和缓存击穿不同的是，缓存击穿指并发查同一条数据，缓存雪崩是不同数据都过期了，很多数据都查不到从而查数据库。 二、什么是布隆过滤器？布隆过滤器是一个叫“布隆”的人提出的，它本身是一个很长的二进制向量，既然是二进制的向量，那么显而易见的，存放的不是0，就是1。 Bloom Filter 专门用来解决我们上面所说的去重问题的，使用 Bloom Filter 不会像使用缓存那么浪费空间。当然，他也存在一个小小问题，就是不太精确。 Bloom Filter 相当于是一个不太精确的 set 集合，我们可以利用它里边的 contains 方法去判断某一个对象是否存在，但是需要注意，这个判断不是特别精确。一般来说，通过 contains 判断某个值不存在，那就一定不存在，但是判断某个值存在的话，则他可能不存在。 三、Bloom Filter实现原理每一个布隆过滤器，在 Redis 中都对应了一个大型的bit位数组以及几(3)个不同的 hash 函数。 如果我们要映射一个值到布隆过滤器中，首先根据几个不同的hash函数给元素(存储对象)生成多个哈希值，拿到这些哈希值后分别对位数组长度进行取模(取余)运算得到一个位置，将位数组中对应的位置设置为1。这样就完成元素的添加操作。 取模：a= c%bit数组长度 就是取余的过程 ​ 例如针对值 “baidu” 和三个不同的哈希函数分别生成了哈希值 ：1、4、7，取模为：1，4, 7 ​ 例如针对值“zhihu”和三个不同的哈希函数分别生成了哈希值：1，4，9 ,取模为：1 ，4，9 则上图转换如下： 当判断元素是否存在时，依然先对元素进行 hash 运算，将运算的结果和位数组取模，然后去对应的位置查看是否有相应的数据，如果有，表示元素可能存在（因为这个有数据的地方也可能是其他元素存进来的），如果没有表示元素一定不存在。 可以看出，仅仅从布隆过滤器本身而言，根本没有存放完整的数据，只是运用一系列随机映射函数计算出位置，然后填充二进制向量。 这有什么用呢？比如现在再给你一个数据，你要判断这个数据是否重复，你怎么做？ 你只需利用上面的三种固定的计算方式，计算出这个数据占据哪些格子，然后看看这些格子里面放置的是否都是1，如果有一个格子不为1，那么就代表这个数字不在其中。这很好理解吧，比如现在又给你了刚才你添加进去的数据，你通过三种固定的计算方式，算出的结果肯定和上面的是一模一样的，也是占据了布隆过滤器“1”，“4”，“9”三个格子。 但是有一个问题需要注意，如果这些格子里面放置的都是1，不一定代表给定的数据一定重复，也许其他数据经过三种固定的计算方式算出来的结果也是相同的。这也很好理解吧，比如我们需要判断对象是否相等，是不可以仅仅判断他们的哈希值是否相等的。 也就是说布隆过滤器只能判断数据是否一定不存在，而无法判断数据是否一定存在。 Bloom Filter 中，误判的概率和位数组的大小有很大关系，位数组越大，误判概率越小，当然占用的存储空间越大；位数组越小，误判概率越大，当然占用的存储空间就小。 按理来说，介绍完了新增、查询的流程，就要介绍删除的流程了，但是很遗憾的是布隆过滤器是很难做到删除数据的，为什么？你想想，比如你要删除刚才给你的数据，你把“1”，“4”，“9”三个格子都改成了0，但是可能其他的数据也映射到了“1”，“4”，“9”三个格子啊，这不就乱套了吗？ 四、Bloom Filter的优缺点： 优点：由于存放的不是完整的数据，所以占用的内存很少，而且新增，查询速度够快； 缺点： 随着数据的增加，误判率随之增加；无法做到删除数据；只能判断数据是否一定不存在，而无法判断数据是否一定存在。 五、Bloom Filter的安装官网：https://oss.redislabs.com/redisbloom/Quick_Start/ 1、docker安装1docker run -p 6379:6379 --name redis-redisbloom redislabs/rebloom:latest 2、编译安装123456789cd redis-5.0.7git clone https://github.com/RedisBloom/RedisBloom.gitcd RedisBloom/##编译make##切换上级目录cd ..##运行redis-server --loadmodule ./RedisBloom/redisbloom.so 后台运行，加入配置文件： 1redis-server redis.conf --loadmodule ./RedisBloom/redisbloom.so 进入redis测试是否安装成功： 123redis-cli -a 密码## 插入值bf.add k1 v1 避免每次启动布隆过滤器都要redis-server redis.conf --loadmodule ./RedisBloom/redisbloom.so这样写，比较麻烦。 我们修改redis.conf文件： 12345678################################## MODULES ###################################### Load modules at startup. If the server is not able to load modules# it will abort. It is possible to use multiple loadmodule directives.## loadmodule /path/to/my_module.so# loadmodule /path/to/other_module.soloadmodule /root/redis-5.0.8/RedisBloom/redisbloom.so 保存退出。这是我们次正常启动即可 redis-server redis.conf 六、基本用法1、bf.add/bf.madd 添加成功返回1 ，否则返回0 添加： bf.add [key] [value] 批量添加： bf.madd [key] [value1] [value2] [ value3] 2、bf.exists/bf.mexists 存在返回1，不存在返回0 判断是否存在 bf.exists [key] [value] 批量判断是否存在 bf.mexists [key] [value1] [value2] [value3] 12bf.add k1 v1 #==&gt; 1bf.exists k1 v1 #==&gt; 1 1234bf.madd k1 v1 v2 v3 1) (integer) 0 #重复的添加失败2) (integer) 13) (integer) 1 12345BF.MEXISTS k1 v1 v2 v3 v41) (integer) 12) (integer) 13) (integer) 14) (integer) 0 #不存在返回0 七、jedis实现布隆过滤器1、pom.xml注意这里的jedis版本必须在3以上才能使用布隆过滤器 1234567891011121314&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;scope&gt;compile&lt;/scope&gt;&lt;/dependency&gt;&lt;!--布隆过滤器--&gt;&lt;dependency&gt; &lt;groupId&gt;com.redislabs&lt;/groupId&gt; &lt;artifactId&gt;jrebloom&lt;/artifactId&gt; &lt;version&gt;1.2.0&lt;/version&gt;&lt;/dependency&gt; 2、测试代码123456789101112131415161718192021public class BloomFilerTest { public static void main(String[] args) { GenericObjectPoolConfig config=new GenericObjectPoolConfig(); config.setMaxIdle(300); config.setMaxTotal(1000); config.setMaxWaitMillis(30000); config.setTestOnBorrow(true); JedisPool jedisPool = new JedisPool(config, \"47.96.141.44\", 6379, 30000, \"你的密码\"); Client client=new Client(jedisPool); for (int i = 0; i &lt; 1000; i++) {// 存入数据 client.add(\"k1\", \"lc:\"+i); }// 判断是否存在 //boolean exists= client.exists(\"k1\", \"lc:1001\"); //false //存在误判情况 boolean exists=client.exists(\"k1\",\"lc:1002\") //true System.out.println(exists); }} 八、设置布隆过滤器的错误率默认情况下，我们使用的布隆过滤器它的错误率是 0.01 ，默认的元素大小是 100。但是这两个参数也是可以配置的。 我们可以调用 bf.reserve 方法进行配置。 BF.RESERVE k1 0.0001 1000000 前提是该k1要存在，否则将设置为默认的值 第一个参数是 key，第二个参数是错误率，错误率越低，占用的空间越大，第三个参数预计存储的数量，当实际数量超出预计数量时，错误率会上升。 https://www.cnblogs.com/CodeBear/p/10911177.html","link":"/2020/04/27/redis/Redis%E4%B9%8B%E5%B8%83%E9%9A%86%E8%BF%87%E6%BB%A4%E5%99%A8/"},{"title":"Redis基本数据类型的操作","text":"Redis基本数据类型与key相关的基本操作1、删除keydel [key] 2、删除当前数据库中的所有key1flushdb 3、删除所有数据库的key1flushall 4、序列化给定的keydump [key] 5、判断指定的key是否存在0不存在；1存在 exists [key] 6、查看key的有效期（秒）-2已过期 -1永久有效 ttl [key] 7、设置key的有效期注意：如果key在过期时间被重新set了，那么过期时间会失效 1设置成功 0设置失败 expire [key] [seconds(秒)] 8、移除一个key的过期时间persist [key] 9、通配符查看所有的keykeys * 查看所有key keys k 查看以k开头的所有key keys [pattern] 10、查看key的有效期（毫秒）pttl [key] 注意：四种数据类型（list/set/zset/hash），在第一次使用时，如果容器不存在，就自动创建一个 四种数据类型（list/set/zset/hash），如果里边没有元素了，那么立即删除容器，释放内存。 一、StringString 是 Redis 里边最最简单的一种数据结构。在 Redis 中，所以的 key 都是字符串，但是，不同的 key 对应的 value 则具备不同的数据结构，我们所说的五种不同的数据类型，主要是指 value 的数据类型不同。 Redis 中的字符串是动态字符串，内部是可以修改的，像 Java 中的 StringBuffer，它采用分配冗余空间的方式来减少内存的频繁分配。在 Redis 内部结构中，一般实际分配的内存会大于需要的内存，当字符串小于 1M 的时候，扩容都是在现有的空间基础上加倍，扩容每次扩 1M 空间，最大 512M。 1、append追加操作append [key] [value] 12345append k1 lcappend k1 .hello#获取键值get k1 #==&gt; 'lc.hello' 2、set给key赋值set [key] [value] 12set k2 33get k2 # ==&gt; '33' 3、decr可以实现对 value 的减 1 操作（前提是 value 是一个数字），如果 value 不是数字，会报错，如果 value 不存在，则会给一个默认的值为 0，在默认值的基础上减一。 decr [key] 1decr k3 # ==&gt; '-1' 12set k2 33decr k2 #==&gt; '32' 4、decrby设置减的步长decrby [key] [decrement] 12set k2 100decrby k2 10 #==&gt; '90' 5、get获取key的valueget [key] 6、getrange截取指定范围的字符串，相当于java中的substringstart 表示开始的位置(包含此位置) end 表示结束的位置 -1 表示截取到最后一个(包含) getrange [key] [start] [end] 1234set lou www.louchen.topget lou #==&gt; \"www.louchen.top\"getrange lou 4 -1 #==&gt; \"louchen.top\"getrange lou 4 -5 #==&gt; \"louchen\" 7、getset获取并更新某一个keygetset [key] [value] 123set k2 90getset k2 100get k2 #==&gt; \"100\" 8、incr给某一个key的value自增incr [key] 9、incrby给某一个key的value自增，并设置步长incrby [key] 10、incrbyfloat和incrby类似，步长可以设置为浮点数incrbyfloat [key] [increment] 123set k2 100incrbyfloat k2 0.22get k2 #==&gt; 100.22 11、mget 和 mset批量获取与批量设置mget [key1] [key2] [key3] [key...] mset [key1] [value1] [key2] [value2] [key...] [value..] 12mset k1 11 k2 22 k3 33mget k1 k2 k3 #===&gt; \"11\" \"22\" \"33\" 12、setex给key设置value并同时设置过期时间(秒)set [key] [seconds] [value] 123set k1 10 woshi#十秒后再获取get k1 #==&gt; \"nil(表示不存在)\" 13、ttl查看key的过期时间 -1表示不会过期 -2表示已过期ttl [key] 14、psetex给key设置value并同时设置过期时间(毫秒)set [key] [millseconds] [value] 15、setnx默认情况下set命令会覆盖已存在的key, setnx不会修改已存在的key0表示修改失败 setnx [key] [value] 15、msetnx批量设置，只要有一个已存在的key都不会修改msetnx [key1] [value1] [key2] [value2] [key...] [value..] 16、setrange覆盖一个已经存在的key的value，指定范围覆盖offset为偏移量,若偏移量超过本身字符的长度，则超过的位置用0补齐 setrange [key] [offset] [value] 123456set k1 louchensetrange k1 0 222get k1 #==&gt; \"222chen\"setrange k1 10 333get k1 #==&gt; \"222chen\\x00\\x00\\x00333\" 17、strlen查看字符串总长度strlen [key] 二、String的BIT操作在 Redis 中，字符串都是以二进制的方式来存储的。例如 set k1 a，a 对应的 ASCII 码是 97，97 转为二进制是 01100001，BIT 相关的命令就是对二进制进行操作的。 getbit key 对应的 value 在 offset 处的 bit 值。 getbit [key] [offset] setbit 修改 key 对应的 value 在 offset 处的 bit 值 setbit [key] [offset] [value] bitcount 统计二进制数据中 1 的个数。 bitcount [key] 三、List集合(可重复)1、lpush 和 lrangelpush将所有指定的值插入到存于 key 的列表的头部(相当于栈,先进后出)。如果 key 不存在，那么在进行 push 操作前会创建一个空列表。 如果 key 对应的值不是一个 list 的话，那么会返回一个错误。 lpush [key] [value1] [value2] [value...] lrange返回列表指定区间内的元素 返回列表所有元素 lrange [key] 0 -1 lrange [key] [start] [stop] 12lpush lc louchen.top lc.vhrlrange lc 0 1 #==&gt; 1) \"lc.vhr\" 2) \"louchen.top\" 2、rpush从右往左插入，先进先出rpush [key] [value1] [value2] [value...] 3、rpop移除并返回列表的尾元素rpop [key] 4、lpop移除并返回列表的头元素lpop [key] 5、lindex返回列表中下标为index的元素，只是查询索引从0开始 lindex [key] [index] 6、ltrim对列表进行修剪从指定start索引位置(包含此位置)到stop位置截取(包含此位置) ltrim [key] [start] [stop] 7、blpop阻塞式的弹出，相当于lpop的阻塞版即当弹出所有元素时，再次弹出会阻塞此操作，等待下一次插入再弹出，阻塞时间设置为秒 blpop [key] [timeout秒] 四、set集合(不可重复)1、sadd添加元素到集合若有重复的value，则只会添加一个 sadd [key] [value1] [value2] [value...] 2、smembers获取该key的所有元素smembers [key] 3、srem移除指定的元素,可以同时移除多个srem [key] [member1] [member2] 4、sismember返回某一个元素是否在集合中0 代表不存在，1代表存在 sismember [key] [member] 5、scard返回集合的数量scard [key] 6、srandmember随机返回一个或多个元素count表示随机返回元素的个数。没有count则返回一个 srandmember [key] [count] 7、spop随机返回并出栈一个元素spop [key] 8、smove把一个元素从一个集合移动到另一个集合source:源集合 destination：目标集合 member：元素 smove [source] [destination] [member] 123sadd k1 a b c#将k1中的a元素移动到k2中smove k1 k2 a 9、sdiff返回两个集合的差集这里注意 是key1-key2集合。除去key2在key1中的元素。反之类似 sidff [key1] [key2] 10、sinter返回两个集合的交集sinter [key1] [key2] 11、sdiffstore类似于sdiff,只不过，计算出来的结果会保存在一个新的集合中destination:保存的新集合的key key1-key2的差集 sdiffstore [destination] [key1] [key2] 12、sinterstore类似于sinter,只不过，计算出来的交集会保存在一个新的集合中destination:保存的新集合的key key1，key2的交集 sinterstore [destination] [key1] [key2] 13、sunion求并集14、sunionstore求并集保存到新的集合中五、Hash在 hash 结构中，key 是一个字符串，value 则是一个 key/value 键值对 1、hset添加值hset [key] [field] [value] 123hset k1 name lchset k1 age 18hset k1 gender male 2、hget获取值hget [key] [field] 1hget k1 name #==&gt; \"lc\" 3、hmset批量设置hmset [key] [field1] [value1] [field2] [value2].. 1hmset k2 name lcc age 18 gender femle 4、hmget批量获取hmget [key] [field1] [field2]... 12345hmget k2 name age gender------1) \"lcc\"2) \"18\"3) \"femle\" 5、hdel删除一个指定的fieldhdel [key] [field1] [field2] 6、hsetnx默认情况下，如果field存在则会覆盖已有的value。但是hsetn不能覆盖已有的field值hsetnx [key] [field] [value] 7、hvals获取所有的valuehvals [key] 8、hkeys获取所有的keyhkeys [key] 9、hgetall同时获取所有的key和valuehgetall [key] 10、hexists返回指定field是否存在不存在返回0 存在返回1 hexists [key] [field] 11、hincrby给指定的value自增1或指定步长increment:步长 hincrby [key] [field] [increment] 12、hincrbyfloat给指定的value自增指定浮点数hincrby [key] [field] [increment] 13、hlen返回某一个key中value的数量hlen [key] 14、hstrlen返回某一个key中的某一个field的字符串长度hstrlen [key] [filed] 六、ZSet有序set集合 1、zadd将指定的元素添加到有序集合中score：分数 作为值 member1： 作为键 zadd [key] [score1] [member1] [score2] [member2]... 1zadd k1 20 v1 k1 30 v2 40 v3 50 v4 2、zscore返回member的score值zscore [key] [member] 1zscore k1 v1 # ==&gt; \"20\" 3、zrange返回指定集合范围中的一组元素withsocres: 返回score值(可选) 返回k1集合中的所有member和score zcore k1 0 -1 withsocres zcore [key] [start] [stop] withsocres 123456789101112131415161718zrange k1 0 -1 withscores---------1) \"v1\"2) \"20\"3) \"v2\"4) \"30\"5) \"v3\"6) \"40\"7) \"v4\"8) \"50\"zrange k1 0 3--------------1) \"v1\"2) \"v2\"3) \"v3\"4) \"v4\" 4、zrevrange逆序返回指定集合范围中的一组元素zrevrange [key] [start] [stop] withscores 5、zcard返回元素个数member键的个数 zcard [key] 6、zcount返回score在某一个区间内的元素的个数默认是闭区间 即包含min和max zcount [key] [min] [max] 1234#包含20，50ZCOUNT k1 20 50 #==&gt; 4#在20到50之间 不包含20，50zocunt k1 (20 (50 #==&gt; 2 7、zrangebyscore按照score的范围返回元素withscores: 是否携带score(可选) zrangebyscore [key] [min] [max] withscores 8、zrank返回元素的排名(从小到大，从0开始)zrank [key] [member] 1zrank k1 v1 #==&gt; 0 9、zrevrank返回元素排名(从大到小)zrevrank [key] [memeber] 1zrevrank k1 v1 #==&gt; 3 10、zincrby按照指定步长自增increment: 步长 zincrby [key] [increment] [member] 11、zinterstore求两个集合的交集并存入新的集合destination：新的目标集合 numkeys：相同member的个数 把key1和key2中的members相同的元素把其score累加得到新的score zinterstore [destination] [numkeys] [key1] [key2].. 12、zrem弹出指定member元素zrem [key] [member1] [member2] 13、zlexcount计算有序集合中成员数量ZLEXCOUNT k1 - + 返回最小的到最大的成员数量(即全部) zlexcount [key] [min] [max] 12#统计v2到v3之间的成功数 包括v2和v3zlexcount k1 [v2 [v3 #==&gt; 2 14、zrangebylex返回指定区间内的成员zrangebylex [key] [min] [max] 12345ZRANGEBYLEX k1 - +------------------1) \"v2\"2) \"v3\"3) \"v4\"","link":"/2020/04/20/redis/Redis%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"title":"SpringBoot整合Swagger2","text":"SpringBoot整合Swagger2一、swagger简介Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。总体目标是使客户端和文件系统作为服务器以同样的速度来更新。 作用： 接口的文档在线自动生成。 功能测试。 二、基本配置1、pom.xmlspringfox-swagger2 springfox-swagger-ui 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;swagger2&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;swagger2&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger2&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.springfox&lt;/groupId&gt; &lt;artifactId&gt;springfox-swagger-ui&lt;/artifactId&gt; &lt;version&gt;2.9.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、swagger配置文件1234567891011121314151617181920212223242526272829303132333435@Configuration@EnableSwagger2//是否开启swagger，正式环境一般是需要关闭的（避免不必要的漏洞暴露！），可根据springboot的多环境配置进行设置//这里properties中的配置的swagger.enable和havingValue相等这个配置文件才会生效@ConditionalOnProperty(name = \"swagger.enable\", havingValue = \"true\")public class Swagger2Config { /** *构建swagger摘要 * @return */ @Bean Docket docket() {// 选择文本类型为SWAGGER_2 return new Docket(DocumentationType.SWAGGER_2) .select()// 指定controller所在的包 .apis(RequestHandlerSelectors.basePackage(\"org.lc.swagger2.controller\"))// 指定包下的所有路径生成文档 .paths(PathSelectors.any()) .build().apiInfo(new ApiInfoBuilder()// 文档描述信息 .description(\"这是接口文档描述信息\")// 标题 .title(\"这是项目标题\")// 联系信息 .contact(new Contact(\"lc\", \"www.louchen.top\", \"421192425@qq.com\"))// 版本 .version(\"v0.0.1\")// 许可证 .license(\"apache2.0\") .build()); }} 3、是否开启swagger配置1swagger.enable=true 4、实体描述123456789101112@Getter@Setter@ToString@ApiModel(value = \"用户实体类\",description = \"用户信息描述\")public class User { @ApiModelProperty(value = \"用户id\") private Integer id; @ApiModelProperty(value = \"用户名\") private String name; @ApiModelProperty(value = \"用户地址\") private String address;} ![](F:\\桌面内容\\springboot2\\springboot整合定时任务及swagger2\\images\\批注 2020-04-07 211747.png) 5、接口描述1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859@RestController//接口上的描述@Api(tags = \"用户数据接口\")public class UserController { /** * 这里需要指定的请求方式 否则swagger会启用所有方法类型调用 * @param id * @return */// 接口方法上的描述 @ApiOperation(value = \"查询用户\",notes = \"根据用户id查询用户\")// 接口参数上的描述// 这里的name为参数名，value为对该参数的解释，required只是对swagger的约束表示必填，默认值为11 @ApiImplicitParam(name = \"id\",value = \"用户id\",required = true,defaultValue = \"11\") @GetMapping(\"/user\") public User getUserById(Integer id) { User user=new User(); user.setId(id); return user; } @ApiOperation(value = \"删除用户\",notes = \"根据用户id删除用户\") @ApiImplicitParam(name = \"id\",value = \"用户id\",required = true,defaultValue = \"22\")// 设置响应的状态码的描述信息 @ApiResponses({ @ApiResponse(code = 200, message = \"删除成功\"), @ApiResponse(code = 500, message = \"删除失败\") }) @DeleteMapping(\"/user/{id}\") public void deleteById(@PathVariable(\"id\")Integer id){ System.out.println(\"deleteById:\"+id); } @ApiOperation(value = \"更新用户\",notes = \"根据用户id更新用户\") @ApiImplicitParams({ @ApiImplicitParam(name = \"username\",value = \"用户名\",required = true,defaultValue = \"lc\"), @ApiImplicitParam(name = \"id\",value = \"用户id\",required = true,defaultValue = \"1\") }) // 表示忽略此接口生成在swagger中// @ApiIgnore @PutMapping(\"/user\") public User updateUserById(String username,Integer id){ User user=new User(); user.setId(id); user.setName(username); return user; } @ApiOperation(value = \"添加用户\",notes = \"添加用户信息\") @PostMapping(\"/user\") public User addUser(@RequestBody User user){ return user; }} ![](F:\\桌面内容\\springboot2\\springboot整合定时任务及swagger2\\images\\批注 2020-04-07 211922.png) ![](F:\\桌面内容\\springboot2\\springboot整合定时任务及swagger2\\images\\批注 2020-04-07 211949.png) ![](F:\\桌面内容\\springboot2\\springboot整合定时任务及swagger2\\images\\批注 2020-04-07 212014.png) 6、swagger注解介绍 @Api：可设置对控制器的描述- @ApiOperation：: 可设置对接口方法的描述 @ApiIgnore: Swagger 文档不会显示拥有该注解的接口。 @ApiImplicitParams: 用于描述接口的非对象参数集。 @ApiImplicitParam: 用于描述接口的非对象参数，一般与 @ApiImplicitParams 组合使用。 @ApiImplicitParam 注解用来描述一个参数，可以配置参数的中文含义，也可以给参数设置默认值，这样在接口测试的时候可以避免手动输入。 如果有多个参数，则需要使用多个 @ApiImplicitParam 注解来描述，多个 @ApiImplicitParam 注解需要放在一个 @ApiImplicitParams 注解中。 需要注意的是，@ApiImplicitParam 注解中虽然可以指定参数是必填的，但是却不能代替 @RequestParam(required = true) ，前者的必填只是在 Swagger2 框架内必填，抛弃了 Swagger2 ，这个限制就没用了，所以假如开发者需要指定一个参数必填， @RequestParam(required = true) 注解还是不能省略。 @ApiModel:可设置接口相关实体的描述 @ApiModelProperty: 可设置实体属性的相关描述。 7、在 Security 中的配置​ 如果我们的 Spring Boot 项目中集成了 Spring Security，那么如果不做额外配置，Swagger2 文档可能会被拦截，此时只需要在 Spring Security 的配置类中重写 configure 方法，添加如下过滤即可： 1234567@Overridepublic void configure(WebSecurity web) throws Exception { web.ignoring() .antMatchers(\"/swagger-ui.html\") .antMatchers(\"/v2/**\") .antMatchers(\"/swagger-resources/**\");} 如此之后，Swagger2 文件就不需要认证就能访问了","link":"/2020/04/17/springboot/SpringBoot%E6%95%B4%E5%90%88Swagger2/"},{"title":"SpringBoot国际化","text":"SpringBoot国际化​ 国际化，也叫 i18n，为啥叫这个名字呢？因为国际化英文是 internationalization ，在 i 和 n 之间有 18 个字母，所以叫 i18n。我们的应用如果做了国际化就可以在不同的语言环境下，方便的进行切换，最常见的就是中文和英文之间的切换，国际化这个功能也是相当的常见。在 Spring 中，就通过 AcceptHeaderLocaleResolver 对国际化提供了支持，开发者通过简单配置，就可以在项目中直接使用国际化功能了。 一、基本使用Spring Boot 和 Spring 一脉相承，对于国际化的支持，默认是通过 AcceptHeaderLocaleResolver 解析器来完成的，这个解析器，默认是通过请求头的 Accept-Language 字段来判断当前请求所属的环境的，进而给出合适的响应。 首先创建一个普通的 Spring Boot 项目，添加 web 依赖即可。项目创建成功后，默认的国际化配置文件放在 resources 目录下，所以我们直接在该目录下创建四个测试文件，如下： 我们的 message 文件是直接创建在 resources 目录下的，IDEA 在展示的时候，会多出一个 Resource Bundle，这个大家不用管，千万别手动去创建这个目录。 messages.properties 这个是默认的配置，其他的则是不同语言环境下的配置，en_US 是英语(美国)，zh_CN 是中文简体，zh_TW 是中文繁体（文末附录里边有一个完整的语言简称表格）。 ![](F:\\桌面内容\\springboot2\\springboot系列\\images\\批注 2020-04-12 110435.png) 四个文件创建好之后，第一个默认的我们可以先空着，另外三个分别填入以下内容： messages.properties 1user.name=default messages_zh_CN.properties 1user.name=张三 messages_zh_TW.properties 1user.name=張三 messages_en_US.properties 1user.name=lc 配置完成后，我们就可以直接开始使用了。在需要使用值的地方，直接注入 MessageSource 实例即可。 在 Spring 中需要配置的 MessageSource 现在不用配置了，Spring Boot 会通过 org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration 自动帮我们配置一个 MessageSource 实例。 引用web依赖即可使用 spring-boot-starter-web 直接创建一个controller使用即可 1234567891011@RestControllerpublic class HelloController { @Autowired MessageSource messageSource; @GetMapping(\"/hello\") public String hello() { return messageSource.getMessage(\"user.name\", null, LocaleContextHolder.getLocale()); }} 在 HelloController 中我们可以直接注入 MessageSource 实例，然后调用该实例中的 getMessage 方法去获取变量的值，第一个参数是要获取变量的 key，第二个参数是如果 value 中有占位符，可以从这里传递参数进去，第三个参数传递一个 Locale 实例即可，这相当于当前的语言环境。 接下来我们就可以直接去调用这个接口了。 默认情况下，在接口调用时，通过请求头的 Accept-Language 来配置当前的环境，我这里通过 POSTMAN 来进行测试，结果如下： 直接在请求头中设置Accept-Language即可 直接切换：Accept-Language的value值即可 输出不同的语言 注意：这种方式只能将参数放在请求头中，不能放在url即params中 二、自定义切换将参数放在请求参数中，即url上 localeResolver的名字必须为这个 12345678910111213141516171819@Configurationpublic class WebConfig implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { LocaleChangeInterceptor interceptor=new LocaleChangeInterceptor();// 设置参数名 interceptor.setParamName(\"lang\"); registry.addInterceptor(interceptor); } //注意 这里的localeResolver只能叫这个名，不能叫其他名 @Bean LocaleResolver localeResolver() { SessionLocaleResolver localeResolver=new SessionLocaleResolver();// 默认语言中文 localeResolver.setDefaultLocale(Locale.SIMPLIFIED_CHINESE); return localeResolver; }} 在这段配置中，我们首先提供了一个 SessionLocaleResolver 实例，这个实例会替换掉默认的 AcceptHeaderLocaleResolver，不同于 AcceptHeaderLocaleResolver 通过请求头来判断当前的环境信息，SessionLocaleResolver 将客户端的 Locale 保存到 HttpSession 对象中，并且可以进行修改（这意味着当前环境信息，前端给浏览器发送一次即可记住，只要 session 有效，浏览器就不必再次告诉服务端当前的环境信息）。 另外我们还配置了一个拦截器，这个拦截器会拦截请求中 key 为 lang 的参数（不配置的话是 locale），这个参数则指定了当前的环境信息。 这个指定只需要一次即可，也就是说，在 session 不变的情况下，下次请求可以不必带上 lang 参数，服务端已经知道当前的环境信息了。 ![](F:\\桌面内容\\springboot2\\springboot系列\\images\\批注 2020-04-12 114357.png) 三、自定义位置默认情况下，我们的配置文件放在 resources 目录下，如果大家想自定义，也是可以的，例如定义在 resources/i18n 目录下： ![](F:\\桌面内容\\springboot2\\springboot系列\\images\\批注 2020-04-12 114632.png) 但是这种定义方式系统就不知道去哪里加载配置文件了，此时还需要 application.properties 中进行额外配置(注意这是一个相对路径)： ![](F:\\桌面内容\\springboot2\\springboot系列\\images\\批注 2020-04-12 115638.png) 四、语言简称表 语言 简称 简体中文(中国) zh_CN 繁体中文(中国台湾) zh_TW 繁体中文(中国香港) zh_HK 英语(中国香港) en_HK 英语(美国) en_US 英语(英国) en_GB 英语(全球) en_WW 英语(加拿大) en_CA 英语(澳大利亚) en_AU 英语(爱尔兰) en_IE 英语(芬兰) en_FI 芬兰语(芬兰) fi_FI 英语(丹麦) en_DK 丹麦语(丹麦) da_DK 英语(以色列) en_IL 希伯来语(以色列) he_IL 英语(南非) en_ZA 英语(印度) en_IN 英语(挪威) en_NO 英语(新加坡) en_SG 英语(新西兰) en_NZ 英语(印度尼西亚) en_ID 英语(菲律宾) en_PH 英语(泰国) en_TH 英语(马来西亚) en_MY 英语(阿拉伯) en_XA 韩文(韩国) ko_KR 日语(日本) ja_JP 荷兰语(荷兰) nl_NL 荷兰语(比利时) nl_BE 葡萄牙语(葡萄牙) pt_PT 葡萄牙语(巴西) pt_BR 法语(法国) fr_FR 法语(卢森堡) fr_LU 法语(瑞士) fr_CH 法语(比利时) fr_BE 法语(加拿大) fr_CA 西班牙语(拉丁美洲) es_LA 西班牙语(西班牙) es_ES 西班牙语(阿根廷) es_AR 西班牙语(美国) es_US 西班牙语(墨西哥) es_MX 西班牙语(哥伦比亚) es_CO 西班牙语(波多黎各) es_PR 德语(德国) de_DE 德语(奥地利) de_AT 德语(瑞士) de_CH 俄语(俄罗斯) ru_RU 意大利语(意大利) it_IT 希腊语(希腊) el_GR 挪威语(挪威) no_NO 匈牙利语(匈牙利) hu_HU 土耳其语(土耳其) tr_TR 捷克语(捷克共和国) cs_CZ 斯洛文尼亚语 sl_SL 波兰语(波兰) pl_PL 瑞典语(瑞典) sv_SE 西班牙语(智利) es_CL","link":"/2020/04/17/springboot/springboot%E5%9B%BD%E9%99%85%E5%8C%96/"},{"title":"springboot与jpa构建restful风格","text":"springboot与jpa构建restful风格一、基本配置1、pom.xmlspring-boot-starter-data-rest 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;jpa-rest&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;jpa-rest&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-rest&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.18&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;version&gt;5.1.27&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、实体bean1234567891011@Getter@Setter@ToString@Entity(name = \"t_book\")public class Book { @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id; private String name; private String author;} 3、yaml配置1234567891011121314151617181920212223spring: datasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://127.0.0.1:3306/test?useUnicode=true&amp;characterEncoding=UTF-8 username: root password: 123456 jpa: # 显示sql语句 show-sql: true # 数据库 database: mysql # 数据库平台 database-platform: mysql # 设置表的结构的生成类型 hibernate: # 每次启动更新表结构 ddl-auto: update properties: hibernate: # 设置方言 mysql57 dialect: org.hibernate.dialect.MySQL57Dialect 4、dao接口配置12public interface BookDao extends JpaRepository&lt;Book,Integer&gt; {} 二、基本的restful风格的增删改查1、查询所有数据要查询的实体的类名首字母小写，然后在后面加s get: http://localhost:8080/books 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384{ \"_embedded\": { \"books\": [ { \"name\": \"三国演义\", \"author\": \"罗贯中\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/books/1\" }, \"book\": { \"href\": \"http://localhost:8080/books/1\" } } }, { \"name\": \"水浒传\", \"author\": \"施耐庵\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/books/2\" }, \"book\": { \"href\": \"http://localhost:8080/books/2\" } } }, { \"name\": \"红楼梦\", \"author\": \"曹雪芹\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/books/3\" }, \"book\": { \"href\": \"http://localhost:8080/books/3\" } } }, { \"name\": \"西游记\", \"author\": \"吴承恩\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/books/4\" }, \"book\": { \"href\": \"http://localhost:8080/books/4\" } } }, { \"name\": \"童年\", \"author\": \"鲁迅\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/books/5\" }, \"book\": { \"href\": \"http://localhost:8080/books/5\" } } } ] }, \"_links\": { \"self\": { //可对分页进行排序操作 \"href\": \"http://localhost:8080/books{?page,size,sort}\", \"templated\": true }, \"profile\": { \"href\": \"http://localhost:8080/profile/books\" } }, //分页信息 //页的大小20 ；总记录数为5 ，总页数为1 ， 当前页为1（jpa中页面从0开始） \"page\": { \"size\": 20, \"totalElements\": 5, \"totalPages\": 1, \"number\": 0 }} 2、分页查询查询第二页，每页大小为2 get: http://localhost:8080/books?page=1&amp;size=2 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162{ \"_embedded\": { \"books\": [ { \"name\": \"红楼梦\", \"author\": \"曹雪芹\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/books/3\" }, \"book\": { \"href\": \"http://localhost:8080/books/3\" } } }, { \"name\": \"西游记\", \"author\": \"吴承恩\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/books/4\" }, \"book\": { \"href\": \"http://localhost:8080/books/4\" } } } ] }, \"_links\": { //首页地址 \"first\": { \"href\": \"http://localhost:8080/books?page=0&amp;size=2\" }, //上一页地址 \"prev\": { \"href\": \"http://localhost:8080/books?page=0&amp;size=2\" }, //排序 \"self\": { \"href\": \"http://localhost:8080/books{&amp;sort}\", \"templated\": true }, //下一页地址 \"next\": { \"href\": \"http://localhost:8080/books?page=2&amp;size=2\" }, //最后一页地址 \"last\": { \"href\": \"http://localhost:8080/books?page=2&amp;size=2\" }, \"profile\": { \"href\": \"http://localhost:8080/profile/books\" } }, \"page\": { \"size\": 2, \"totalElements\": 5, \"totalPages\": 3, \"number\": 1 }} 3、分页排序查询先按照id降序排列，然后查询出第二页的数据 get : http://localhost:8080/books?page=1&amp;size=2&amp;sort=id,desc 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556{ \"_embedded\": { \"books\": [ { \"name\": \"红楼梦\", \"author\": \"曹雪芹\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/books/3\" }, \"book\": { \"href\": \"http://localhost:8080/books/3\" } } }, { \"name\": \"水浒传\", \"author\": \"施耐庵\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/books/2\" }, \"book\": { \"href\": \"http://localhost:8080/books/2\" } } } ] }, \"_links\": { \"first\": { \"href\": \"http://localhost:8080/books?page=0&amp;size=2&amp;sort=id,desc\" }, \"prev\": { \"href\": \"http://localhost:8080/books?page=0&amp;size=2&amp;sort=id,desc\" }, \"self\": { \"href\": \"http://localhost:8080/books\" }, \"next\": { \"href\": \"http://localhost:8080/books?page=2&amp;size=2&amp;sort=id,desc\" }, \"last\": { \"href\": \"http://localhost:8080/books?page=2&amp;size=2&amp;sort=id,desc\" }, \"profile\": { \"href\": \"http://localhost:8080/profile/books\" } }, \"page\": { \"size\": 2, \"totalElements\": 5, \"totalPages\": 3, \"number\": 1 }} 4、查询指定id数据查询id为3的数据 get: http://localhost:8080/books/3 123456789101112{ \"name\": \"红楼梦\", \"author\": \"曹雪芹\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/books/3\" }, \"book\": { \"href\": \"http://localhost:8080/books/3\" } }} 5、添加数据post: http://localhost:8080/books application-type: json 1234{ \"name\":\"史记\", \"author\":\"司马迁\"} 123456789101112{ \"name\": \"史记\", \"author\": \"司马迁\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/books/6\" }, \"book\": { \"href\": \"http://localhost:8080/books/6\" } }} 6、根据id修改put: http://localhost:8080/books/6 application-type: json 这里的修改必须要传所有字段，否则没有传的字段会赋值为null 1234{ \"name\":\"《史记》\", \"author\":\"司马老贼\"} 123456789101112{ \"name\": \"《史记》\", \"author\": \"司马老贼\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/books/6\" }, \"book\": { \"href\": \"http://localhost:8080/books/6\" } }} 7、根据id删除delete: http://localhost:8080/books/6 三、自定义查询方法接口1、dao接口123456789public interface BookDao extends JpaRepository&lt;Book,Integer&gt; { /** * 查询包含的名称的数据 * @param name * @return */ List&lt;Book&gt; findBooksByNameContaining(@Param(\"name\") String name);} 2、postman测试①查询所有可使用的接口get： http://localhost:8080/books/search 1234567891011{ \"_links\": { \"findBooksByNameContaining\": { \"href\": \"http://localhost:8080/books/search/findBooksByNameContaining{?name}\", \"templated\": true }, \"self\": { \"href\": \"http://localhost:8080/books/search\" } }} ②使用自定义的接口查询名称包含红的集合 get: http://localhost:8080/books/search/findBooksByNameContaining?name=红 1234567891011121314151617181920212223{ \"_embedded\": { \"books\": [ { \"name\": \"红楼梦\", \"author\": \"曹雪芹\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/books/3\" }, \"book\": { \"href\": \"http://localhost:8080/books/3\" } } } ] }, \"_links\": { \"self\": { \"href\": \"http://localhost:8080/books/search/findBooksByNameContaining?name=%E7%BA%A2\" } }} ③修改请求路径及集合路径@RepositoryRestResource(path = “bs”,collectionResourceRel = “bs1”,itemResourceRel = “b”) path： 请求的一级路径 collectionResourceRel ： 集合名称 itemResourceRel： 集合中的路径herf元素名称 @RestResource(exported = true,path = “byname”,rel = “findByName”) exported : 是否暴露此接口（默认为true） path: 请求的二级路径 rel : 查询所有接口时的该方法的对象名称 修改dao接口==&gt; 123456789101112@RepositoryRestResource(path = \"bs\",collectionResourceRel = \"bs1\",itemResourceRel = \"b\")public interface BookDao extends JpaRepository&lt;Book,Integer&gt; { /** * 查询包含的名称的数据 * @param name * @return */ @RestResource(exported = true,path = \"byname\",rel = \"findByName\") List&lt;Book&gt; findBooksByNameContaining(@Param(\"name\") String name); } 查询所有接口==&gt; get: http://localhost:8080/bs/search 1234567891011{ \"_links\": { \"findByName\": { \"href\": \"http://localhost:8080/bs/search/byname{?name}\", \"templated\": true }, \"self\": { \"href\": \"http://localhost:8080/bs/search\" } }} 使用该findByName接口==&gt; get : http://localhost:8080/bs/search/byname?name=红 1234567891011121314151617181920212223{ \"_embedded\": { \"bs1\": [ { \"name\": \"红楼梦\", \"author\": \"曹雪芹\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/bs/3\" }, \"b\": { \"href\": \"http://localhost:8080/bs/3\" } } } ] }, \"_links\": { \"self\": { \"href\": \"http://localhost:8080/bs/search/byname?name=%E7%BA%A2\" } }} 四、实现跨域@CrossOrigin 默认为允许所有请求 @CrossOrigin(“*”) 12345678910111213@CrossOrigin@RepositoryRestResource(path = \"bs\",collectionResourceRel = \"bs1\",itemResourceRel = \"b\")public interface BookDao extends JpaRepository&lt;Book,Integer&gt; { /** * 查询包含的名称的数据 * @param name * @return */ @RestResource(exported = true,path = \"byname\",rel = \"findByName\") List&lt;Book&gt; findBooksByNameContaining(@Param(\"name\") String name);} 五、更改spring中对restful的自动配置org.springframework.boot.autoconfigure.data.rest.RepositoryRestProperties==&gt; 12345678910111213141516171819202122232425@ConfigurationProperties( prefix = \"spring.data.rest\")public class RepositoryRestProperties { //基础路径 private String basePath; //默认页 private Integer defaultPageSize; //每页的最大尺寸 private Integer maxPageSize; //页码的参数名称 private String pageParamName; private String limitParamName; //排序的参数名称 private String sortParamName; private RepositoryDetectionStrategies detectionStrategy; private MediaType defaultMediaType; //创建后并返回 private Boolean returnBodyOnCreate; //更新后并返回 private Boolean returnBodyOnUpdate; private Boolean enableEnumTranslation; //**** //****} 1、yaml的配置12345spring: data: rest:# 加前缀 base-path: /api 2、配置文件配置1234567891011121314/** * 此类的优先级配置 高于 yaml中的配置 */@Configurationpublic class RestConfig implements RepositoryRestConfigurer { @Override public void configureRepositoryRestConfiguration(RepositoryRestConfiguration config) { //设置默认路径 config.setBasePath(\"/lc\") //设置默认页大小 .setDefaultPageSize(2); }} 请求测试：==&gt; get: http://localhost:8080/lc/bs/search/byname?name=红 1234567891011121314151617181920212223{ \"_embedded\": { \"bs1\": [ { \"name\": \"红楼梦\", \"author\": \"曹雪芹\", \"_links\": { \"self\": { \"href\": \"http://localhost:8080/lc/bs/3\" }, \"b\": { \"href\": \"http://localhost:8080/lc/bs/3\" } } } ] }, \"_links\": { \"self\": { \"href\": \"http://localhost:8080/lc/bs/search/byname?name=%E7%BA%A2\" } }}","link":"/2020/04/17/restful/jpa%E6%9E%84%E5%BB%BArestful%E9%A3%8E%E6%A0%BC/"},{"title":"springsecurity&#x2F;Spring-Security整合OAuth2","text":"Spring-Security整合OAuth2基本配置1、pom.xmlspring-security-oauth2 spring-boot-starter-security spring-boot-starter-data-redis 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lx&lt;/groupId&gt; &lt;artifactId&gt;security-oauth&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;security-oauth&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security.oauth&lt;/groupId&gt; &lt;artifactId&gt;spring-security-oauth2&lt;/artifactId&gt; &lt;version&gt;2.3.6.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--redis 存储token--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、yaml配置1234567spring:# redis配置 redis: port: 6379 password: xxxxxx host: 47.96.141.44 database: 0 3、controller123456789101112131415161718192021222324252627282930@RestControllerpublic class controller { /** * 模拟admin用户 * @return */ @GetMapping(\"/admin/hello\") public String admin() { return \"hello admin\"; } /** * 模拟user用户 * @return */ @GetMapping(\"/user/hello\") public String user() { return \"user hello\"; } /** * 普通用户（登录即可访问） * @return */ @GetMapping(\"/hello\") public String hello() { return \"hello\"; }} 4、核心配置①授权服务器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677/** * 授权服务器 */@Configuration//开启授权服务器@EnableAuthorizationServerpublic class AuthorizationServerConfig extends AuthorizationServerConfigurerAdapter { /** * 注入认证管理器 来支持password的认证模式 * * 在oauth2模式中，有四种不同的认证模式. * 第三方登录一般使用授权码模式 * 前后端分离一般使用password模式 */ @Autowired private AuthenticationManager authenticationManager; @Autowired private RedisConnectionFactory redisConnectionFactory; @Autowired private UserDetailsService userDetailsService; @Bean PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); } /** * 配置password模式 * 配置用户 * @param clients * @throws Exception */ @Override public void configure(ClientDetailsServiceConfigurer clients) throws Exception {// 配置在内存中 clients.inMemory()// 设置认证模式 设置客户端id .withClient(\"password\")// 配置授权模式 标准的oauth并不包含refresh_token。但是在springsecurity实现下refresh_token归为其中一种// 获取token 和 刷新token的 .authorizedGrantTypes(\"password\", \"refresh_token\")// 设置过期时间 1800s .accessTokenValiditySeconds(1800)// 设置资源id .resourceIds(\"rid\") .scopes(\"all\")// 需要的密码（加密之后）密码 123 .secret(\"$2a$10$vMu/taZjUE/JPUUi8Aep/epAjQjT5XqJj1/fOKqH/n1k9x8DOnkW6\"); } /** * 令牌的存储 * @param endpoints * @throws Exception */ @Override public void configure(AuthorizationServerEndpointsConfigurer endpoints) throws Exception { endpoints.tokenStore(new RedisTokenStore(redisConnectionFactory)) .authenticationManager(authenticationManager) .userDetailsService(userDetailsService); } /** *支持client id和 client secret 作登录认证 * @param security * @throws Exception */ @Override public void configure(AuthorizationServerSecurityConfigurer security) throws Exception { security.allowFormAuthenticationForClients(); }} ②资源服务器（提供资源，即访问的路径，引用的令牌）123456789101112131415161718192021222324252627282930/** * 资源服务器 提供资源 */@Configuration//开启资源服务器@EnableResourceServerpublic class ResourceServerConfig extends ResourceServerConfigurerAdapter{ @Override public void configure(ResourceServerSecurityConfigurer resources) throws Exception {// 指定资源id resources.resourceId(\"rid\")// 这些资源基于令牌进行认证 .stateless(true); } /** * 先去授权服务器获取token，再去访问资源 * 在这里我们提供访问资源的路径 * @param http * @throws Exception */ @Override public void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers(\"/admin/**\").hasRole(\"admin\") .antMatchers(\"/user/**\").hasRole(\"user\") .anyRequest().authenticated(); }} ③security配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter { @Bean @Override public AuthenticationManager authenticationManagerBean() throws Exception { return super.authenticationManagerBean(); } @Bean @Override protected UserDetailsService userDetailsService() { return super.userDetailsService(); } /** * 配置模拟用户 * @param auth * @throws Exception */ @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.inMemoryAuthentication() //密码123 .withUser(\"lc\").password(\"$2a$10$vMu/taZjUE/JPUUi8Aep/epAjQjT5XqJj1/fOKqH/n1k9x8DOnkW6\") .roles(\"admin\") .and() //密码123 .withUser(\"zs\").password(\"$2a$10$vMu/taZjUE/JPUUi8Aep/epAjQjT5XqJj1/fOKqH/n1k9x8DOnkW6\") .roles(\"user\"); } /** * 拦截指定的请求 * @param http * @throws Exception */ @Override protected void configure(HttpSecurity http) throws Exception { http.antMatcher(\"/oauth/**\")// 拦截像/oauth/**的请求 .authorizeRequests()// 符合/oauth/** .antMatchers(\"/oauth/**\")// 全部放行 .permitAll() .and() .csrf().disable(); }} 5、请求过程详解① 获取令牌PUT: http://localhost:8080/oauth/token content-type : x-www-form-urlencoded 请求参数==&gt; username 和 password 为登录的用户名和密码 123456\"key\":\"username\",\"value\":\"lc\"\"key\":\"password\",\"value\":\"123\"\"key\":\"grant_type\",\"value\":\"password\"\"key\":\"client_id\",\"value\":\"password\"\"key\":\"scope\",\"value\":\"all\"\"key\":\"client_secret\",\"value\":\"123\" 结果: ==&gt; 123456789{ \"access_token\": \"d274cd88-1c84-4d6a-9da4-11ed734aed6f\", \"token_type\": \"bearer\", //用户请求获得新的token的验证 \"refresh_token\": \"0a454a83-9bf5-4331-bf12-35d4ac519f30\", //过期时间 \"expires_in\": 1064, \"scope\": \"all\"} ②请求资源接口访问普通接口==&gt; GET: http://localhost:8080/hello?access_token=d274cd88-1c84-4d6a-9da4-11ed734aed6f admin接口==&gt; GET: http://localhost:8080/admin/hello?access_token=d274cd88-1c84-4d6a-9da4-11ed734aed6f user接口==&gt; GET: http://localhost:8080/user/hello?access_token=d274cd88-1c84-4d6a-9da4-11ed734aed6f ③获取新的token，旧token失效POST: http://localhost:8080/oauth/token 请求参数==&gt; refresh_token 是之前用户登录 refresh_token的的值 1234\"key\":\"grant_type\",\"value\":\"refresh_token\"\"key\":\"refresh_token\",\"value\":\"0a454a83-9bf5-4331-bf12-35d4ac519f30\"\"key\":\"client_id\",\"value\":\"password\"\"key\":\"client_secret\",\"value\":\"123\" 请求结果==&gt; 1234567{ \"access_token\": \"8b03dd6a-18c7-49c0-b2ab-e0962627608c\", \"token_type\": \"bearer\", \"refresh_token\": \"0a454a83-9bf5-4331-bf12-35d4ac519f30\", \"expires_in\": 1799, \"scope\": \"all\"}","link":"/2020/04/17/springsecurity/Spring-Security%E6%95%B4%E5%90%88OAuth2/"},{"title":"Spring-Security整合jwt","text":"Spring-Security整合jwt一、有状态登录和无状态登录有状态：有状态服务，即服务端需要记录每次会话的客户端信息，从而识别客户端身份，根据用户身份进行请求的处理，典型的设计如Tomcat中的Session。例如登录：用户登录后，我们把用户的信息保存在服务端session中，并且给用户一个cookie值，记录对应的session，然后下次请求，用户携带cookie值来（这一步有浏览器自动完成），我们就能识别到对应session，从而找到用户的信息。这种方式目前来看最方便，但是也有一些缺陷，如下： 服务端保存大量数据，增加服务端压力 服务端保存用户状态，不支持集群化部署 无状态：微服务集群中的每个服务，对外提供的都使用RESTful风格的接口。而RESTful风格的一个最重要的规范就是：服务的无状态性，即： 服务端不保存任何客户端请求者信息 客户端的每次请求必须具备自描述信息，通过这些信息识别客户端身份 那么这种无状态性有哪些好处呢？ 客户端请求不依赖服务端的信息，多次请求不需要必须访问到同一台服务器 服务端的集群和状态对客户端透明 服务端可以任意的迁移和伸缩（可以方便的进行集群化部署） 减小服务端存储压力 二、如何实现无状态登录无状态登录的流程： 首先客户端发送账户名/密码到服务端进行认证 认证通过后，服务端将用户信息加密并且编码成一个token，返回给客户端 以后客户端每次发送请求，都需要携带认证的token 服务端对客户端发送来的token进行解密，判断是否有效，并且获取用户登录信息 三、JWT简介JWT包含三部分数据： Header：头部，通常头部有两部分信息： 声明类型，这里是JWT 加密算法，自定义 我们会对头部进行Base64Url编码（可解码），得到第一部分数据。 Payload：载荷，就是有效数据，在官方文档中(RFC7519)，这里给了7个示例信息： iss (issuer)：表示签发人 exp (expiration time)：表示token过期时间 sub (subject)：主题 aud (audience)：受众 nbf (Not Before)：生效时间 iat (Issued At)：签发时间 jti (JWT ID)：编号 这部分也会采用Base64Url编码，得到第二部分数据。 Signature：签名，是整个数据的认证信息。一般根据前两步的数据，再加上服务的的密钥secret（密钥保存在服务端，不能泄露给客户端），通过Header中配置的加密算法生成。用于验证整个数据完整和可靠性。 生成的数据格式如下： eyJhbGciOiJIUzUxMiJ9. ==&gt; 1{\"alg\":\"HS512\"} eyJhdXRob3JpdGllcyI6IlJPTEVfdXNlciwiLCJzdWIiOiJ6cyIsImV4cCI6MTU4NTY2ODQyM30. ==&gt; 1{\"authorities\":\"ROLE_user,\",\"sub\":\"zs\",\"exp\":1585668423} 5IgsesOWhkVPpyLbIHWbgeNNQFZvIRik2FlZHWCIoD7jH1b2BOgYHqWKb7LehZ_lyK53ZggXIdLVQJ_cqnVPtQ 最后一段无法解密 jwt交互流程： 应用程序或客户端向授权服务器请求授权 获取到授权后，授权服务器会向应用程序返回访问令牌 应用程序使用访问令牌来访问受保护资源（如API） 因为JWT签发的token中已经包含了用户的身份信息，并且每次请求都会携带，这样服务的就无需保存用户信息，甚至无需去数据库查询，这样就完全符合了RESTful的无状态规范。 四、基本配置1、pom.xmljjwt 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;springsecurity-jwt&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;springsecurity-jwt&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;io.jsonwebtoken&lt;/groupId&gt; &lt;artifactId&gt;jjwt&lt;/artifactId&gt; &lt;version&gt;0.9.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、实体1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374package org.lc.springsecurityjwt.bean;import org.springframework.security.core.GrantedAuthority;import org.springframework.security.core.userdetails.UserDetails;import java.util.Collection;/** * @BelongsProject: springsecurity-jwt * @BelongsPackage: org.lc.springsecurityjwt.bean * @Author: lc * @CreateTime: 2020-03-31 16:53 * @Description: */public class User implements UserDetails { private Integer id; private String username; private String password; public User setId(Integer id) { this.id = id; return this; } public Integer getId() { return id; } public User setUsername(String username) { this.username = username; return this; } public User setPassword(String password) { this.password = password; return this; } @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() { return null; } @Override public String getPassword() { return password; } @Override public String getUsername() { return username; } @Override public boolean isAccountNonExpired() { return true; } @Override public boolean isAccountNonLocked() { return true; } @Override public boolean isCredentialsNonExpired() { return true; } @Override public boolean isEnabled() { return true; }} 3、jwt登录的过滤器123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960public class JwtLoginFilter extends AbstractAuthenticationProcessingFilter { public JwtLoginFilter(String defaultFilterProcessesUrl, AuthenticationManager authenticationManager) { super(defaultFilterProcessesUrl); setAuthenticationManager(authenticationManager); } @Override public Authentication attemptAuthentication(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse) throws AuthenticationException, IOException, ServletException {// 从过滤的请求中 ，获得流。获取登录的用户对象// 以json形式登录 User user=new ObjectMapper().readValue(httpServletRequest.getInputStream(), User.class); return getAuthenticationManager().authenticate(new UsernamePasswordAuthenticationToken(user.getUsername(), user.getPassword())); } //登录成功的回调 @Override protected void successfulAuthentication(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult) throws IOException, ServletException {// 获取登录用户的角色 Collection&lt;? extends GrantedAuthority&gt; authorities=authResult.getAuthorities(); StringBuffer sb=new StringBuffer(); for (GrantedAuthority authority : authorities) {// 将角色所有角色加到一个以逗号隔开的字符串中 sb.append(authority.getAuthority()).append(\",\"); }// 构建jwt String jwt = Jwts.builder()// 构建角色 .claim(\"authorities\", sb)// 构建的主题 一般为用户名 .setSubject(authResult.getName())// 设置过期时间为 当前时间加上一个小时，即一个小时的过期时间 .setExpiration(new Date(System.currentTimeMillis() + 60 * 60 * 1000))// 签名 .signWith(SignatureAlgorithm.HS512, \"louchen\") .compact(); Map&lt;String,String&gt; map=new HashMap&lt;&gt;(); map.put(\"token\", jwt); map.put(\"msg\", \"登录成功！\"); response.setContentType(\"application/json;charset=utf-8\"); PrintWriter printWriter=response.getWriter(); printWriter.write(new ObjectMapper().writeValueAsString(map)); printWriter.flush(); printWriter.close(); }// 登录失败的回调 @Override protected void unsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed) throws IOException, ServletException { Map&lt;String,String&gt; map=new HashMap&lt;&gt;(); map.put(\"msg\", \"登录失败！\"); response.setContentType(\"application/json;charset=utf-8\"); PrintWriter printWriter=response.getWriter(); printWriter.write(new ObjectMapper().writeValueAsString(map)); printWriter.flush(); printWriter.close(); }} 4、jwt的Token验证过滤器12345678910111213141516public class JwtFilter extends GenericFilterBean { @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { HttpServletRequest req = (HttpServletRequest)servletRequest; String jwtToken = req.getHeader(\"authorization\"); Jws&lt;Claims&gt; jws= Jwts.parser().setSigningKey(\"louchen\") .parseClaimsJws(jwtToken.replace(\"Bearer\", \"\")); Claims claims=jws.getBody(); String username = claims.getSubject(); List&lt;GrantedAuthority&gt; authorities= AuthorityUtils.commaSeparatedStringToAuthorityList((String) claims.get(\"authorities\")); UsernamePasswordAuthenticationToken token = new UsernamePasswordAuthenticationToken(username, null, authorities); SecurityContextHolder.getContext().setAuthentication(token); filterChain.doFilter(servletRequest, servletResponse); }} 5、security配置123456789101112131415161718192021222324252627282930313233343536373839@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter { @Bean PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); } @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.inMemoryAuthentication() .withUser(\"lc\") .password(\"$2a$10$qrWxqVUCyOc.C5/uTx.9cO8cu89ast7g.mGhSms8yfj/4VPGRLab2\") .roles(\"admin\") .and() .withUser(\"zs\") .password(\"$2a$10$qrWxqVUCyOc.C5/uTx.9cO8cu89ast7g.mGhSms8yfj/4VPGRLab2\") .roles(\"user\"); } @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers(\"/hello\") .hasRole(\"user\") .antMatchers(\"/admin\") .hasRole(\"admin\") .antMatchers(HttpMethod.POST,\"/login\")// 允许登录的接口 .permitAll() .anyRequest().authenticated() .and()// 传入JwtLoginFilter中第一个参数 。作为过滤之前的请求 .addFilterBefore(new JwtLoginFilter(\"/login\", authenticationManager()), UsernamePasswordAuthenticationFilter.class) .addFilterBefore(new JwtFilter(),UsernamePasswordAuthenticationFilter.class) .csrf().disable(); }} 6、controller1234567891011121314@RestControllerpublic class HelloController { @GetMapping(\"/hello\") public String hello() { return \"hello everyone\"; } @GetMapping(\"/admin\") public String admin() { return \"hello admin\"; }} 7、请求测试请求登录：POST: http://localhost:8080/logincontent-type: application/json ==&gt; 请求参数 1234{ \"username\":\"zs\", \"password\":\"123\"} 结果==&gt; 1234{ \"msg\": \"登录成功！\", \"token\": \"eyJhbGciOiJIUzUxMiJ9.eyJhdXRob3JpdGllcyI6IlJPTEVfdXNlciwiLCJzdWIiOiJ6cyIsImV4cCI6MTU4NTY2ODQyM30.5IgsesOWhkVPpyLbIHWbgeNNQFZvIRik2FlZHWCIoD7jH1b2BOgYHqWKb7LehZ_lyK53ZggXIdLVQJ_cqnVPtQ\"} 请求接口：GET: http://localhost:8080/hello 选择Authorization的type为Bearer Token ，将Token输入。每次请求携带此token","link":"/2020/04/17/springsecurity/Spring-Security%E6%95%B4%E5%90%88jwt/"},{"title":"Springboot整合Quartz","text":"Springboot整合Quartz一、什么是Quartz在Quartz官网上是这么写的 1、Quartz 是一个完全由 Java 编写的开源作业调度框架，为在 Java 应用程序中进行作业调度提供了简单却强大的机制。2、Quartz 可以与 J2EE 与 J2SE 应用程序相结合也可以单独使用。 3、Quartz 允许程序开发人员根据时间的间隔来调度作业。4、Quartz 实现了作业和触发器的多对多的关系，还能把多个作业与不同的触发器关联。 二、Quartz核心概念1、Job 表示一个工作，要执行的具体内容。2、JobDetail 表示一个具体的可执行的调度程序，Job 是这个可执行程调度程序所要执行的内容，另外 JobDetail 还包含了这个任务调度的方案和策略。3、Trigger 代表一个调度参数的配置，什么时候去调。4、Scheduler 代表一个调度容器，一个调度容器中可以注册多个 JobDetail 和 Trigger。当 Trigger 与 JobDetail 组合，就可以被 Scheduler 容器调度了。 三、基本配置使用1、pom.xmlspring-boot-starter-quartz 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;quartz&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;quartz&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-quartz&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、启用定时任务12345678910@SpringBootApplication//启动定时任务@EnableSchedulingpublic class QuartzApplication { public static void main(String[] args) { SpringApplication.run(QuartzApplication.class, args); }} 3、job任务配置①直接定义一个Bean作为任务 首先将这个 Job 注册到 Spring 容器中。 这种定义方式有一个缺陷，就是无法传参。 123456789@Componentpublic class MyFirstJob { /** * 这种方式配置的任务不支持传参 */ public void sayHello() { System.out.println(\"first job say hello:\"+new Date()); }} ②继承 QuartzJobBean 并实现默认的方法这种方式支持传参，任务启动时，executeInternal 方法将会被执行。 12345678910111213141516171819202122public class MySecondJob extends QuartzJobBean { /** * 给当前job传入参数 */ private String name; public MySecondJob setName(String name) { this.name = name; return this; } /** * 这种形式的job支持传参 * @param jobExecutionContext * @throws JobExecutionException */ @Override protected void executeInternal(JobExecutionContext jobExecutionContext) throws JobExecutionException { System.out.println(\"second job say hello:\"+name+\":\"+new Date()); }} 4、JobDetail和Trigger配置JobDetail（要做的事情），另一个是触发器（什么时候做） 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384@Configurationpublic class QuartzConfig { /** * 配置job实例 * MethodInvokingJobDetailFactoryBean配置的任务不能传输参数 * @return */ @Bean MethodInvokingJobDetailFactoryBean methodInvokingJobDetailFactoryBean() { MethodInvokingJobDetailFactoryBean bean=new MethodInvokingJobDetailFactoryBean();// 设置job所在的类名 （类名开头小写） bean.setTargetBeanName(\"myFirstJob\");// 设置指定job方法名 bean.setTargetMethod(\"sayHello\"); return bean; } /** * 配置job实例 *JobDetailFactoryBean 可以设置job参数 * @return */ @Bean JobDetailFactoryBean jobDetailFactoryBean() { JobDetailFactoryBean bean=new JobDetailFactoryBean();// 向job传入参数 JobDataMap dataMap=new JobDataMap(); dataMap.put(\"name\", \"lccc\"); bean.setJobDataMap(dataMap);// 设置该job所在的class对象// 此job因为实现QuartzJobBean类所以自动实现内部的执行executeInternal方法完成任务 bean.setJobClass(MySecondJob.class); return bean; } /** * 配置简单的触发器(执行时间规则) * @return */ @Bean SimpleTriggerFactoryBean simpleTriggerFactoryBean() { SimpleTriggerFactoryBean bean=new SimpleTriggerFactoryBean();// 将job对象和触发器绑定 bean.setJobDetail(methodInvokingJobDetailFactoryBean().getObject());// job开启的时间 --当前时间 bean.setStartTime(new Date());// job重复间隔 bean.setRepeatInterval(2000);// job执行次数 bean.setRepeatCount(3); return bean; } /** *配置cron表达式 * @return */ @Bean CronTriggerFactoryBean cronTriggerFactoryBean() { CronTriggerFactoryBean bean=new CronTriggerFactoryBean();// 绑定job任务和触发器对象 bean.setJobDetail(jobDetailFactoryBean().getObject());// 设置cron表达式// 每秒执行一次 bean.setCronExpression(\"* * * * * ?\"); return bean; } /** * 配置调度任务 * @return */ @Bean SchedulerFactoryBean schedulerFactoryBean() { SchedulerFactoryBean bean=new SchedulerFactoryBean();// 向调度任务中加入配置好的触发器和job对象 bean.setTriggers(simpleTriggerFactoryBean().getObject(),cronTriggerFactoryBean().getObject()); return bean; }} 5、配置解释关于这个配置说如下几点： JobDetail 的配置有两种方式：MethodInvokingJobDetailFactoryBean 和 JobDetailFactoryBean 。 使用 MethodInvokingJobDetailFactoryBean 可以配置目标 Bean 的名字和目标方法的名字，这种方式不支持传参。 使用 JobDetailFactoryBean 可以配置 JobDetail ，任务类继承自 QuartzJobBean ，这种方式支持传参，将参数封装在 JobDataMap 中进行传递。 Trigger 是指触发器，Quartz 中定义了多个触发器，这里向大家展示其中两种的用法，SimpleTrigger 和 CronTrigger 。 SimpleTrigger 有点类似于前面说的 @Scheduled 的基本用法。 CronTrigger 则有点类似于 @Scheduled 中 cron 表达式的用法。","link":"/2020/04/17/task/SpringBoot%E6%95%B4%E5%90%88Quartz/"},{"title":"SpringCache 整合Ehcache","text":"SpringCache 整合Ehcache一 、介绍​ EhCache 是一个纯Java的进程内缓存框架，具有快速、精干等特点，是Hibernate中默认CacheProvider。Ehcache是一种广泛使用的开源Java分布式缓存。主要面向通用缓存,Java EE和轻量级容器。它具有内存和磁盘存储，缓存加载器,缓存扩展,缓存异常处理程序,一个gzip缓存servlet过滤器,支持REST和SOAP api等特点。 特性 快速、简单 多种缓存策略 缓存数据有两级：内存和磁盘，因此无需担心容量问题 缓存数据会在虚拟机重启的过程中写入磁盘 可以通过RMI、可插入API等方式进行分布式缓存 具有缓存和缓存管理器的侦听接口 支持多缓存管理器实例，以及一个实例的多个缓存区域 提供Hibernate的缓存实现 集成​ 可以单独使用，一般在第三方库中被用到的比较多（如mybatis、shiro等）ehcache 对分布式支持不够好，多个节点不能同步，通常和redis一块使用 灵活性​ ehcache具备对象api接口和可序列化api接口 不能序列化的对象可以使用出磁盘存储外ehcache的所有功能 支持基于Cache和基于Element的过期策略，每个Cache的存活时间都是可以设置和控制的。 提供了LRU、LFU和FIFO缓存淘汰算法，Ehcache 1.2引入了最少使用和先进先出缓存淘汰算法，构成了完整的缓存淘汰算法。 提供内存和磁盘存储，Ehcache和大多数缓存解决方案一样，提供高性能的内存和磁盘存储。 动态、运行时缓存配置，存活时间、空闲时间、内存和磁盘存放缓存的最大数目都是可以在运行时修改的。 应用持久化​ 在vm重启后，持久化到磁盘的存储可以复原数据 Ehache是第一个引入缓存数据持久化存储的开源java缓存框架，缓存的数据可以在机器重启后从磁盘上重新获得​ 根据需要将缓存刷到磁盘。将缓存条目刷到磁盘的操作可以通过cache.fiush方法执行,这大大方便了ehcache的使用 二、ehcache 和 redis 比较ehcache直接在jvm虚拟机中缓存，速度快，效率高；但是缓存共享麻烦，集群分布式应用不方便。 redis是通过socket访问到缓存服务，效率比ecache低，比数据库要快很多， 处理集群和分布式缓存方便，有成熟的方案。如果是单个应用或者对缓存访问要求很高的应用，用ehcache。如果是大型系统，存在缓存共享、分布式部署、缓存内容很大的，建议用redis。 三、基本配置所有的存储操作还是SpringCache的那一套，只是存储采取的载体不同 1、pom.xmlehcache spring-boot-starter-cache 1234567891011121314151617181920212223242526272829&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--ehcache依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt; &lt;artifactId&gt;ehcache&lt;/artifactId&gt; &lt;version&gt;2.10.6&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2、yaml配置若缓存配置文件名为ehcache.xml则无需配置此项 配置ehcache文件的存放位置 ==&gt; 1234spring: cache: ehcache: config: classpath:ehcache/ehcache1.xml 3、ehcache配置文件配置文件说明==&gt; diskStore path ：指定磁盘存储的位置 defaultCache 默认的缓存 cache 自定的缓存，当自定的配置不满足实际情况时可以通过自定义（可以包含多个cache节点） name : 缓存的名称，可以通过指定名称获取指定的某个Cache对象 maxElementsInMemory ：内存中允许存储的最大的元素个数，0代表无限个 clearOnFlush：内存数量最大时是否清除。 eternal ：设置缓存中对象是否为永久的，如果是，超时设置将被忽略，对象从不过期。根据存储数据的不同，例如一些静态不变的数据如省市区等可以设置为永不过时 timeToIdleSeconds ： 设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。 timeToLiveSeconds ：缓存数据的 生存时间（TTL），也就是一个元素从构建到消亡的最大时间间隔值，这只能在元素不是永久驻留时有效，如果该值是0就意味着元素可以停顿无穷长的时间。(和上面的两者取最小值) overflowToDisk：内存不足时，是否启用磁盘缓存。 maxEntriesLocalDisk：当内存中对象数量达到maxElementsInMemory时，Ehcache将会对象写到磁盘中。 maxElementsOnDisk：硬盘最大缓存个数。 diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。 diskPersistent：是否在VM重启时存储硬盘的缓存数据。默认值是false。 diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。 memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。这里比较遗憾，Ehcache并没有提供一个用户定制策略的接口，仅仅支持三种指定策略，感觉做的不够理想。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;ehcache&gt; &lt;!-- 磁盘缓存位置 --&gt; &lt;!-- diskStore:为缓存路径，ehcache分为内存和磁盘 2级，此属性定义磁盘的缓存位置 user.home - 用户主目录 user.dir - 用户当前工作目录 java.io.tmpdir - 默认临时文件路径--&gt; &lt;diskStore path=\"java.io.tmpdir/ehcache\"/&gt; &lt;!-- name:缓存名称。 maxElementsInMemory:缓存最大数目 maxElementsOnDisk：硬盘最大缓存个数。 eternal:对象是否永久有效，一但设置了，timeout将不起作用。 overflowToDisk:是否保存到磁盘，当系统宕机时 timeToIdleSeconds:设置对象在失效前的允许闲置时间（单位：秒）。仅当eternal=false对象不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大。 timeToLiveSeconds:设置对象在失效前允许存活时间（单位：秒）。最大时间介于创建时间和失效时间之间。仅当eternal=false对象不是永久有效时使用，默认是0.，也就是对象存活时间无穷大。 diskPersistent：是否缓存虚拟机重启期数据 Whether the disk store persists between restarts of the Virtual Machine. The default value is false. diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区。 diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒。 memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用）。 clearOnFlush：内存数量最大时是否清除。 memoryStoreEvictionPolicy:可选策略有：LRU（最近最少使用，默认策略）、FIFO（先进先出）、LFU（最少访问次数）。 FIFO，first in first out，这个是大家最熟的，先进先出。 LFU， Less Frequently Used，就是上面例子中使用的策略，直白一点就是讲一直以来最少被使用的。如上面所讲，缓存的元素有一个hit属性，hit值最小的将会被清出缓存。 LRU，Least Recently Used，最近最少使用的，缓存的元素有一个时间戳，当缓存容量满了，而又需要腾出地方来缓存新的元素的时候，那么现有缓存元素中时间戳离当前时间最远的元素将被清出缓存。--&gt; &lt;!-- 默认缓存 --&gt; &lt;defaultCache maxEntriesLocalHeap=\"10000\" eternal=\"false\" timeToIdleSeconds=\"120\" timeToLiveSeconds=\"120\" maxEntriesLocalDisk=\"10000000\" diskExpiryThreadIntervalSeconds=\"120\" memoryStoreEvictionPolicy=\"LRU\"&gt; &lt;persistence strategy=\"localTempSwap\"/&gt; &lt;/defaultCache&gt; &lt;!-- 自定义缓存 --&gt; &lt;!--name 为缓存名称--&gt; &lt;cache name=\"mycache\" maxElementsInMemory=\"1000\" eternal=\"false\" timeToIdleSeconds=\"600\" timeToLiveSeconds=\"600\" overflowToDisk=\"true\" memoryStoreEvictionPolicy=\"LRU\"/&gt;&lt;/ehcache&gt; 4、实体bean(实现serializable)12345678@Getter@Setter@ToStringpublic class User implements Serializable { private Integer id; private String username; private String address;} 5、开启缓存12345678910@SpringBootApplication//启用缓存@EnableCachingpublic class JpaRestApplication { public static void main(String[] args) { SpringApplication.run(JpaRestApplication.class, args); }} 6、service层123456789101112@Servicepublic class UserService { @Cacheable(cacheNames = \"mycache\",key = \"#id\") public User getUserById(Integer id){ User user=new User(); user.setId(id); System.out.println(\"id=====&gt;\"+id); return user; }} 测试==&gt; 12345678910111213@SpringBootTestclass JpaRestApplicationTests { @Autowired private UserService userService; @Test void contextLoads() { User userById = userService.getUserById(1); User userById1 = userService.getUserById(1); System.out.println(userById); System.out.println(userById1); }}","link":"/2020/04/17/springcache/Spring%20Cache%E6%95%B4%E5%90%88Ehcache/"},{"title":"SpringBoot整合@Scheduled定时任务","text":"SpringBoot整合@Scheduled定时任务一、JAVA常见的几种定时任务比较1、Timer： ​ jdk自带的java.util.Timer类，这个类允许你调度一个java.util.TimerTask任务。使用这种方式可以让程序按照某一个频度执行，但不能在指定时间运行，一般很少使用，主要用于非Spring项目简单的任务调度。 2、Spring Task： ​ Spring3.0以后自带的Task，可以将它看成一个轻量级的Quartz，使用起来比Quartz简单很多，在Spring应用中，直接使用@Scheduled注解即可，但对于集群项目比较麻烦，需要避免集群环境下任务被多次调用的情况，而且不能动态维护，任务启动以后不能修改、暂停等。 3、Quartz： ​ 好用的第三方任务调度工具，可谓是企业级应用系统任务调度工具的老大。可以方便的在集群下使用、可以动态增加、删除、暂停等维护任务，动态定时任务更加灵活。而且，和Spring Boot集成非常方便。 基本配置1、pom.xmlspring3之后自带定时任务 spring-boot-starter-web 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;sechdule&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;sechdule&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、开启定时任务123456789@SpringBootApplication//开启定时任务@EnableSchedulingpublic class SechduleApplication { public static void main(String[] args) { SpringApplication.run(SechduleApplication.class, args); }} 3、任务123456789101112131415161718192021222324252627282930313233343536373839404142@Servicepublic class HelloService { /** * rate速率 * 第一次任务和第二次任务开始的时间间隔(可能第一次任务还没结束，第二次就接着执行) * 毫秒为单位(这里为2s) */ @Scheduled(fixedRate = 2000) public void fixedRate() { System.out.println(\"fixedRate&gt;&gt;&gt;&gt;\"+new Date()); } /** * delay延期 * 第一次任务的结束时间和第二次任务开始的时间间隔(即第一次任务已经执行完毕后再执行第二次任务的间隔) * 毫秒为单位(这里为3s) */ @Scheduled(fixedDelay = 3000) public void fixedDelay() { System.out.println(\"fixedDelay&gt;&gt;&gt;&gt;\"+new Date()); } /** * initialDelay 表示首次任务启动的延迟时间 */ @Scheduled(initialDelay = 2000,fixedDelay = 2000) public void initialDelay() { System.out.println(\"initialDelay&gt;&gt;&gt;\"+new Date()); } /** * cron表达式 * [秒] [分] [小时] [日] [月] [周] [年](可省略) * 在这里 / 用于递增触发，如在秒上面设置”0/5” 表示从0秒开始，每增5秒触发(0,5,10,15……) */ @Scheduled(cron = \"0/5 * * * * *\") public void cron() { System.out.println(\"cron&gt;&gt;&gt;&gt;&gt;\"+new Date()); }} 配置详解1、@Scheduled常用属性： 首先使用 @Scheduled 注解开启一个定时任务。 fixedRate 表示任务执行之间的时间间隔，具体是指两次任务的开始时间间隔，即第二次任务开始时，第一次任务可能还没结束。 fixedDelay 表示任务执行之间的时间间隔，具体是指本次任务结束到下次任务开始之间的时间间隔。 initialDelay 表示首次任务启动的延迟时间。 所有时间的单位都是毫秒。 其他属性： fixedDelayString：与fixedDelay含义一样，只是参数类型变为String； fixedRateString: 与fixedRate的含义一样，只是将参数类型变为String； initialDelayString：与initialDelay的含义一样，只是将参数类型变为String； #####2、cron表达式 [秒] [分] [小时] [日] [月] [周] [年](可省略) 具体取值 序号 说明 是否必填 允许填写的值 允许的通配符 1 秒 是 0-59 - * / 2 分 是 0-59 - * / 3 时 是 0-23 - * / 4 日 是 1-31 - * ? / L W 5 月 是 1-12 or JAN-DEC - * / 6 周 是 1-7 or SUN-SAT - * ? / L # 7 年 否 1970-2099 - * / 这一块需要大家注意的是，月份中的日期和星期可能会起冲突，因此在配置时这两个得有一个是 ? 在线Cron表达式生成器 示例： 0 0 10 ？ * WED 每个星期三的10:00:00 @Scheduled(cron = &quot;0/5 * * * * *&quot;) 每隔5秒触发一次 通配符含义： ? 表示不指定值，即不关心某个字段的取值时使用。需要注意的是，月份中的日期和星期可能会起冲突，因此在配置时这两个得有一个是 ? * 表示所有值，例如:在秒的字段上设置 *,表示每一秒都会触发 , 用来分开多个值，例如在周字段上设置 “MON,WED,FRI” 表示周一，周三和周五触发 - 表示区间，例如在秒上设置 “10-12”,表示 10,11,12秒都会触发 / 用于递增触发，如在秒上面设置”5/15” 表示从5秒开始，每增15秒触发(5,20,35,50) # 序号(表示每月的第几个周几)，例如在周字段上设置”6#3”表示在每月的第三个周六，(用 在母亲节和父亲节再合适不过了) 周字段的设置，若使用英文字母是不区分大小写的 ，即 MON 与mon相同 L 表示最后的意思。在日字段设置上，表示当月的最后一天(依据当前月份，如果是二月还会自动判断是否是润年), 在周字段上表示星期六，相当于”7”或”SAT”（注意周日算是第一天）。如果在”L”前加上数字，则表示该数据的最后一个。例如在周字段上设置”6L”这样的格式,则表示”本月最后一个星期五” W 表示离指定日期的最近工作日(周一至周五)，例如在日字段上设置”15W”，表示离每月15号最近的那个工作日触发。如果15号正好是周六，则找最近的周五(14号)触发, 如果15号是周未，则找最近的下周一(16号)触发，如果15号正好在工作日(周一至周五)，则就在该天触发。如果指定格式为 “1W”,它则表示每月1号往后最近的工作日触发。如果1号正是周六，则将在3号下周一触发。(注，”W”前只能设置具体的数字,不允许区间”-“) L 和 W 可以一组合使用。如果在日字段上设置”LW”,则表示在本月的最后一个工作日触发(一般指发工资 )","link":"/2020/04/17/task/SpringBoot%E6%95%B4%E5%90%88@Scheduled%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"},{"title":"Linux常用命令","text":"简单命令：ip addr 查看ip地址 uname -r 查看系统内核版本 service network restart 重启虚拟机网络 clear 清屏 各发行版本命令123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199ctrl + alt 脱离控制ctrl+alt+t 开启多个终端 命令 选项 参数command [-options] [parameter] //选项和参数与顺序无关/ 代表根目录./ 代表当前路径sudo 获取权限ctrl+c 不执行 换行一次tab补全信息两次tab显示所有文件内容sudo apt-get install 文件名 //安装新的软件//安装 sudo apt-get install net-toolsifconfig [-a] //查看网络配置 sudo ifconfig ens33 192.168.183.111 为ens33设置ip地址ps [-aux] //查看所有进程信息 只显示kill 端口号 //关闭指定进程kill -9 端口号 //强制关闭指定进程//安装 sudo apt-get install treetree //以树状的形式显示所有文件信息 ls [目录] //显示当前目录的文件信息(list)ls -ah 等于 llls -a //显示所有文件（包括以点开头的文件即为隐藏文件）ls -l //以列表的方式显示ls -l -h //以列表显示文件并显示文件大小或者 ls -alh //此方式为简写 与顺序无关ls -alh &gt; xxx.txt //将此目录下的显示内容 覆盖xxx.txt文件中ls &gt;&gt; xxx.txt //将此目录下的显示内容 追加到xxx.txt中ls -alh /bin | more //将bin下的文件以分页的方式显示 （此方式为管道） pwd //显示当前操作目录cd [目录] //切换目录（change directory）cd / //跳转到根目录cd ./xx //跳转到当前文件夹的指定目录cd .. //跳转到上一层路径cd ../.. //跳转到上上层路径 （利用相对路径） cd - //跳转到上一次文件目录cd ~ //跳转回原始根目录 touch //创建文件 mkdir //创建文件夹(make directory) mkdir [] -p //创建文件夹 自动创建不存在文件夹clear //清屏命令 --help //查看命令信息man 命名 //查看命令信息man [2,3..] 函数 //查看使用（manual手册） 可以查看底层cat //查看文件内容 （一次加载全部）car 1.txt 2.txt &gt; xxx.txt //将1.txt和2.txt的内容合并并且覆盖到xxx.txt中 more //查看文件内容 （可翻页 b上一页 f下一页 ）vi //编辑文件gedit //打开编辑器history //查看历史命令记录!行号 //执行历史记录命令rm //删除文件（仅能删除文件）rm [] -r //递归删除 能够删除文件和文件夹rmdir //删除文件夹 （此文件夹必须为空）mv [原] [旧] //更新文件或文件夹名称mv [原文件] [目录] //剪切文件或文件夹并粘贴到目录cp [原文件] [目录] //拷贝文件到目录cp [文件夹] [目录] -r //recursion递归拷贝文件夹到目录ln -s [原] [快捷] //为文件创建快捷方式 软链接（soft links 删除原文件则快捷方式会失效）ln [原] [快键] //为文件创建快捷方式 硬链接（删除源文件快捷方式不会失效） 数字代表链接数-rw-r--r-- 1 mybuntu mybuntu 0 2月 21 19:26 12das.txt-rw-r--r-- 1 mybuntu mybuntu 0 2月 21 19:26 312.txtdrwxr-xr-x 3 mybuntu mybuntu 4.0K 2月 21 20:08 a-rw-r--r-- 1 mybuntu mybuntu 17 2月 21 21:50 hardlink.txtdrwxr-xr-x 2 mybuntu mybuntu 4.0K 2月 21 18:16 myq-rw-r--r-- 1 mybuntu mybuntu 557 2月 21 19:38 xx.txt正则：* 匹配所有？ 匹配显示一个位置[1-5] 匹配选项的条件[12345]grep [-n] \"\" xxx.txt //查询包含的指定的内容 -n //带行号grep \"^xx\" xxx.txt //查询以xx开头的指定的内容grep \"xx$\" xxx.txt //查询以xx结尾的指定的内容sudo find / -name \"*na*\" //以根路径下查找 包含文件名为na的文件 （sudo获取所有权限）tar -cvf xxx.tar *.py //将当前所有为.py的文件打包为xxx.tar格式（基本不用）tar -xvf xxx.tar //解压 （基本不用）//常用两中压缩和解压方式：tar -zcvf xxx.tar.gz *.py //将当前所有为.py的文件打包并且压缩为xxx.tar.gz的格式 （此文件大小更小）tar -zxvf xxx.tar.gz [-C] [d/s]/ //解压到指定路径tar -jcvf xxx.tar.bz2 *.py ////将当前所有为.py的文件打包并且压缩为xxx.tar.bz2的格式tar -jxvf xxx.tar.bz2 //解压zip zzz.zip *.py //压缩unzip zzz.zip //解压which 命令 //查看命令所在的目录cal [-y] //查看日历date //查看时间date \"+%Y-%m-%d\" //以xxxx-xx-xx显示reboot 重启shutdown -h now [20:25] 立刻关机 或者在20:25的时候关机df //查看硬盘信息du [-h] [-a] //(disk usage)查看当前目录大小情况//安装sshsudo apt-get install openssh-serverssh 用户名@ip地址 //连接指定的ip地址服务器// sudo为获取权限sudo useradd louchen -m //添加用户（-m为该用户创建目录）su louchen //切换登录用户（默认无密码）sudo passwd louchen //为用户设置密码 sudo passwd louchen //为用户设置新密码whoami //查看当前用户who //查看登录的用户信息exit //退出并且切换到原来用户sudo userdel louchen [-r] //删除用户（-r删除该用户的目录）su - louchen //登录并且切换到该用户的目录sudu -s //切换到超级管理员用户$ 为普通用户# 为超级管理员 用户 组drwxr-xr-x 17 mybuntu mybuntu 4096 2月 22 00:30 ./drwxr-xr-x 4 root root 4096 2月 22 00:57 ../drwxr-xr-x 2 mybuntu mybuntu 4096 2月 21 18:21 桌面/-rw------- 1 mybuntu mybuntu 2878 2月 22 01:01 .bash_history-rw-r--r-- 1 mybuntu mybuntu 220 2月 21 01:07 .bash_logout//你创建一个用户的时候 也为该用户创建了一个组//新创建的用户默认不能设置为超级管理员权限 （sudo -s）sudo groupadd lou1 //创建一个新的组cat /etc/group //查看组groupmod tal键2次 //查看组sudo groupdel lou1 //删除一个组①sudo usermod -a -G adm lou1 //为新创建的用户添加能够为超级管理员的权限 ①②同时满足②sudo usermod -a -G sudo lou1chgrp 组名 文件名 //将指定的文件 改为相应的组名权限信息chown 组名 文件名 //将指定的文件 改为相应的用户所属信息权限：第一组：-为文件 ，d 为文件夹第二组：文件拥有者的权限第三组：同组者的权限 第四组：其他人的权限r:可读 w:可写 x(execute):可执行① ② ③ ④ 拥有者 所属组d rwx r-x r-x 17 mybuntu mybuntu 4096 2月 22 00:30 ./drwxr-xr-x 4 root root 4096 2月 22 00:57 ../drwxr-xr-x 2 mybuntu mybuntu 4096 2月 21 18:21 桌面/-rw------- 1 mybuntu mybuntu 2878 2月 22 01:01 .bash_history修改权限：x r w1、修改拥有者权限：chmod u=xrw 文件名 //修改该文件名的拥有者权限为可读可写可执行2、修改同组者权限：chmod g=xrw 文件名3、修改其他人权限：chmod o=xrw 文件名4、一起修改chmod u=x,g=w,o=r 文件名 //分别为所属者拥有者其他人设置为可执行可写可读5、修改为无权限chmod u=,g=,o= 文件名 //设置为无任何权限6、数字法修改权限x:1 w:2 r:4相加做出判断chmod 137 文件名 //设置为 用户可执行 ，所属组可执行可写，其他组可读可写可执行 vi编辑操作1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283//安装sudo apt install vimvi（vim）命令：vim 文件 //新建或者打开一个新文件ESC退出当前模式： 切换行末模式vi命令①插入模式②命令模式: i 在当前光标之前插入 I 在当前光标行首插入 a 在当前光标之后插入 A 在当前光标行末插入 x 删除当前光标内容 o 在光标下方插入 O 在光标上方插入 yy:复制 光标所在的这一行 4yy:复制 光标所在行开始向下的4行 p: 粘贴 dd:剪切 光标所在的这一行 2dd:剪切 光标所在行 向下 2行 D:从当前的光标开始剪切，一直到行末 d0:从当前的光标开始剪切，一直到行首 x:删除当前的光标，每次只会删除一个 X:删除当前光标前面的那个，每次只会删除一个 h左 j下 k上 l右 H:当前屏幕的上方 M:当前屏幕的中间 L:当前屏幕的下方 ctrl+f---&gt;向下翻一页代码 ctrl+b---&gt;向上翻一页代码 ctrl+d---&gt;向下翻半页代码 ctrl+u---&gt;向上翻半页代码 20G:快速的定位到第2行代码 G:快速的回到 整个代码的最后一行 gg:快速回到 整个代码的第1行 w:向后跳一个单词的长度，即调到下一个单词的开始出 b:向前跳一个单词的长度，即调到上一个单词的开始出 u:撤销刚刚的操作 ctrl+r:反撤销 选中一片代码 v: V: &gt;&gt;:向右移动代码 &lt;&lt;:向左移动代码 .:重复执行上一次的命令 r:替换一个字符 R:替换光标以及后面的字符 shift+zz:相当于wq③末行模式: w:保存 q:退出 wq:保存并且退出出 :w - 保存文件，不退出 vim:w file -将修改另外保存到 file 中，不退出 vim:w! -强制保存，不退出 vim:wq -保存文件，退出 vim:wq! -强制保存文件，退出 vim:q -不保存文件，退出 vim:q! -不保存文件，强制退出 vim:e! -放弃所有修改，从上次保存文件开始再编辑","link":"/2020/04/17/shell/Linux/"},{"title":"Springboot整合RabbitMQ","text":"Springboot整合RabbitMQ一、安装RabbitMQ这里我们使用docker 通信端口 : 5672 管理界面端口 :15672 默认账户密码都是 guest 1、拉取镜像docker pull rabbitmq:3-management //下载带管理界面的消息队列 2、初始化容器docker run -d -p 5672:5672 -p 15672:15672 --restart=always --name myrabbitmq 镜像id 3、修改rabbitmq密码123docker exec -it fd4f81cdd3e7 bash //进入容器rabbitmqctl list_users //查看所有用户 rabbitmqctl change_password guest 'Newpassword' //修改指定用户密码 4、常见命令12345新建用户：rabbitmqctl add_user username passwd删除用户：rabbitmqctl delete_user username改密码: rabbimqctl change_password {username} {newpassword}设置用户角色：rabbitmqctl set_user_tags {username} {tag ...}rabbitmqctl set_permissions -p / username \".*\" \".*\" \".*\" //添加权限 二、springboot整合RabbitMQ1、什么是RabbitMQ？​ RabbitMQ是一个基于AMQP(Advanced Message Queuing Protocol)协议的高级消息中间件，是应用层协议的一个开放标准。基于Erlang语言，可跨平台。它主要的技术特点是可用性，安全性，集群，多协议支持，可视化的客户端，活跃的社区。 ​ AMQP为面向消息的中间件设计。消息中间件主要用于组件之间的解耦，消息的发送者无需知道消息使用者的存在，反之亦然。 AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全。 RabbitMQ是一个开源的AMQP实现，服务器端用Erlang语言编写，支持多种客户端，如：Python、Ruby、.NET、Java、JMS、C、PHP、ActionScript、XMPP、STOMP等，支持AJAX。用于在分布式系统中存储转发消息，在易用性、扩展性、高可用性等方面表现不俗。 2、基本配置pom.xml配置spring-boot-starter-amqp 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;rabbitmq&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;rabbitmq&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.amqp&lt;/groupId&gt; &lt;artifactId&gt;spring-rabbit-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; properties配置12345678#配置主机地址spring.rabbitmq.host=47.96.141.44#通信端口spring.rabbitmq.port=5672#用户名spring.rabbitmq.username=guest#密码spring.rabbitmq.password=guest ①直连交换机(Direct)直连型交换机，根据消息携带的路由键将消息投递给对应队列。 大致流程，有一个队列绑定到一个直连交换机上，同时赋予一个路由键 routing key 。然后当一个消息携带着路由值为X，这个消息通过生产者发送给交换机时，交换机就会根据这个路由值X去寻找绑定值也是X的队列。 队列交换机配置： 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Direct策略 直接指定到发送的队列名称。 */@Configurationpublic class RabbitDirectConfig { /** * 定义directExchange的名称 */ public final static String DIRECTNAME = \"javaMr-direct\"; /** * 注意导的包 org.springframework.amqp.core.Queue; * 定义队列 * @return */ @Bean Queue queue() { return new Queue(\"hello.lc\"); } /** * 定义Direct交换机 * @return */ @Bean DirectExchange directExchange() { //定义的DirectExchange名称; durable(持久性)重启后是否依然有效; autodelete长期未使用是否自动删除 return new DirectExchange(DIRECTNAME,true,false); } /** * 绑定指定的队列到交换机上并指定策略 * @return */ @Bean Binding binding() {// 绑定队列到交换机上 并指定路由匹配规则 return BindingBuilder.bind(queue()).to(directExchange()).with(\"direct\"); }} 消费者： 12345678910111213141516/** * direct消费者 */@Componentpublic class DirectReceiver { /** * 监听指定队列(hello.lc) * @param msg */ @RabbitListener(queues = \"hello.lc\") public void handler(String msg) { System.out.println(\"&gt;&gt;&gt;&gt;&gt;&gt;&gt;:\"+msg); }} 生产者： 1234567891011121314151617@SpringBootTestclass RabbitmqApplicationTests { @Autowired private RabbitTemplate rabbitTemplate; /** * direct模式 发送到指定队列 */ @Test void directTest() {// 发送到指定路由规则(默认为队列名)队列; 发送的消息 rabbitTemplate.convertAndSend(RabbitDirectConfig.DIRECTNAME,\"direct\", \"你好呀 direct!!!\");// 如果不指定发送的交换机名称则直接匹配的routingkey到队列名// rabbitTemplate.convertAndSend(\"hello.lc\", \"你好呀 direct!!!\"); }} ②主题交换机(Topic)前面讲到direct类型的Exchange路由规则是完全匹配binding key与routing key，但这种严格的匹配方式在很多情况下不能满足实际业务需求。topic类型的Exchange在匹配规则上进行了扩展，它与direct类型的Exchage相似，也是将消息路由到binding key与routing key相匹配的Queue中，但这里的匹配规则有些不同，它约定： routing key为一个句点号“. ”分隔的字符串（我们将被句点号“. ”分隔开的每一段独立的字符串称为一个单词），如“stock.usd.nyse”、“nyse.vmw”、“quick.orange.rabbit” binding key与routing key一样也是句点号“. ”分隔的字符串 binding key中可以存在两种特殊字符“ * ”与“#”，用于做模糊匹配，其中“*”用于匹配一个单词，“#”用于匹配多个单词（可以是零个） 队列交换机配置： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** *topic策略 根据指定路径匹配符转发到指定队列 */@Configurationpublic class RabbitTopicCofig { public static final String TOPICNAME = \"javaMr-topic\"; @Bean Queue xiaomi() { return new Queue(\"xiaomi\"); } @Bean Queue huawei() { return new Queue(\"huawei\"); } @Bean Queue iphone() { return new Queue(\"iphone\"); } @Bean TopicExchange topicExchange() { return new TopicExchange(TOPICNAME, true, false); } @Bean Binding xiaomiBinding() {// 绑定xiaomi队列到topic交换机，并指定队列访问规则// 发送匹配的路由规格 以 xiao. 开头的路径 return BindingBuilder.bind(xiaomi()).to(topicExchange()).with(\"xiaomi.#\"); } @Bean Binding huaweiBinding() {// 绑定huawei队列到topic交换机，并指定队列访问规则// 发送匹配的路由规格 以 huawei. 开头的路径 return BindingBuilder.bind(huawei()).to(topicExchange()).with(\"huawei.#\"); } @Bean Binding iphoneBinding() {// 绑定iphone队列到topic交换机，并指定队列访问规则// 发送匹配的路由规格 以 .phone. 规则的路径 return BindingBuilder.bind(iphone()).to(topicExchange()).with(\"#.iphone.#\"); }} 消费者配置： 1234567891011121314151617@Componentpublic class TopicReceiver { @RabbitListener(queues = \"xiaomi\") public void handlerXiaomi(String msg) { System.out.println(\"TopicReceiver:handlerXiaomi&gt;&gt;&gt;&gt;&gt;\"+msg); } @RabbitListener(queues = \"huawei\") public void handlerHuawei(String msg) { System.out.println(\"TopicReceiver:handlerHuawei&gt;&gt;&gt;&gt;&gt;\"+msg); } @RabbitListener(queues = \"iphone\") public void handlerIphone(String msg) { System.out.println(\"TopicReceiver:handlerIphone&gt;&gt;&gt;&gt;&gt;\"+msg); }} 生成者配置： 12345678910111213141516171819@SpringBootTestclass RabbitmqApplicationTests { @Autowired private RabbitTemplate rabbitTemplate; /** * topic模式 发送到指定交换机下的路径匹配的队列 */ @Test void topicTest() {// 发送到指定交换机; 匹配路由为 xiaomi.# 的路径--&gt;指定到xiaomi队列; 发送的消息 rabbitTemplate.convertAndSend(RabbitTopicCofig.TOPICNAME, \"xiaomi.news\", \"小米手机\");// 发送到指定交换机; 匹配路由为 #.iphone.# 的路径--&gt;指定到iphone队列; 发送的消息 rabbitTemplate.convertAndSend(RabbitTopicCofig.TOPICNAME, \"iphoneXR.iphone\", \"iphone手机\");// 发送到指定交换机; 匹配路由为 huawei.# 和 #.iphone.# 的路径--&gt;指定到huawei和iphone队列; 发送的消息 rabbitTemplate.convertAndSend(RabbitTopicCofig.TOPICNAME, \"huawei.iphone\", \"A12系列和麒麟系列芯片\"); }} ③扇形交换机(Fanout)扇型交换机，这个交换机没有路由键概念，就算你绑了路由键也是无视的。 这个交换机在接收到消息后，会直接转发到绑定到它上面的所有队列。 队列交换机配置： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * fanout策略 转发到该交换机下的所有队列（跟路由规则（routingkey）无关） */@Configurationpublic class RabbitFanoutConfig { /** * 定义交换机名称 */ public static final String FANOUTNAME = \"javaMr-fanout\"; /** * 定义第一个队列 * @return */ @Bean Queue queueOne() { return new Queue(\"queue-one\"); } /** * 定义第二个队列 * @return */ @Bean Queue queueTwo() { return new Queue(\"queue-two\"); } /** * 定义Fanout交换机 * @return */ @Bean FanoutExchange fanoutExchange() { return new FanoutExchange(FANOUTNAME,true,false); } /** * 绑定第一个队列到交换机 * @return */ @Bean Binding bindingOne() { return BindingBuilder.bind(queueOne()).to(fanoutExchange()); } /** * 绑定到第二个交换机 * @return */ @Bean Binding bindingTwo() { return BindingBuilder.bind(queueTwo()).to(fanoutExchange()); }} 消费者配置： 1234567891011121314151617/** * 定义消费者 */@Componentpublic class FanoutReceiver { @RabbitListener(queues = \"queue-one\") public void handlerOne(String msg) { System.out.println(\"queue-one&gt;&gt;&gt;&gt;&gt;:\"+msg); } @RabbitListener(queues = \"queue-two\") public void handlerTwo(String msg) { System.out.println(\"queue-two&gt;&gt;&gt;&gt;&gt;:\"+msg); }} 生产者配置： 123456789101112131415@SpringBootTestclass RabbitmqApplicationTests { @Autowired private RabbitTemplate rabbitTemplate; /** * fanout模式 发送到所有该交换机下的队列 */ @Test void fanoutTest(){ //发送到指定交换机; 这里的routingkey队列关键词会无效; 发送的消息 rabbitTemplate.convertAndSend(RabbitFanoutConfig.FANOUTNAME, null, \"java fanout np!!!!\"); }} ④头部交换机(Headers)headers类型的Exchange不依赖于routing key与binding key的匹配规则来路由消息，而是根据发送的消息内容中的headers属性进行匹配。 在绑定Queue与Exchange时指定一组键值对；当消息发送到Exchange时，RabbitMQ会取到该消息的headers（也是一个键值对的形式），对比其中的键值对是否完全匹配Queue与Exchange绑定时指定的键值对；如果完全匹配则消息会路由到该Queue，否则不会路由到该Queue。 队列交换机配置： 1234567891011121314151617181920212223242526272829303132333435363738394041/** * headers策略 根据指定头部转发到指定队列(跟路由规则routingkey无关) */@Configurationpublic class RabbitHeadersConfig { public static final String HEADERNAME = \"javaMr-header\"; @Bean Queue queueName() { return new Queue(\"name-queue\"); } @Bean Queue queueAge() { return new Queue(\"age-queue\"); } @Bean HeadersExchange headersExchange() { return new HeadersExchange(HEADERNAME, true, false); } @Bean Binding bindingName() { Map&lt;String,Object&gt; map=new HashMap&lt;&gt;(); map.put(\"name\", \"lcc\");// 需要满足发送的消息 携带头部 name为lcc才匹配到该队列// 只需要匹配该map中的任意一个即可 return BindingBuilder.bind(queueName()).to(headersExchange()).whereAny(map).match();// 当有多个键值对时，必须必须匹配所有。// return BindingBuilder.bind(queueName()).to(headersExchange()).whereAll(map).match(); } @Bean Binding bindingAge() {// 满足只要有age属性存在 即可匹配到该队列 return BindingBuilder.bind(queueAge()).to(headersExchange()).where(\"age\").exists(); }} 消费者配置： 123456789101112131415@Componentpublic class HeadersReceiver { @RabbitListener(queues = \"name-queue\") public void handlerName(byte[] msg) {// 将字节数组解码为字符串对象 System.out.println(\"HeaderReceiver:handlerName&gt;&gt;&gt;&gt;&gt;&gt;\"+new String(msg,0,msg.length)); } @RabbitListener(queues = \"age-queue\") public void handlerAge(byte[] msg) {// 将字节数组解码为字符串对象 System.out.println(\"HeaderReceiver:handlerAge&gt;&gt;&gt;&gt;&gt;&gt;\"+new String(msg,0,msg.length)); }} 生产者配置： 1234567891011121314151617181920212223@SpringBootTestclass RabbitmqApplicationTests { @Autowired private RabbitTemplate rabbitTemplate; /** * header模式 发送消息时携带指定的头部信息 满足条件时即转发到指定队列 */ @Test void headerTest() {// 构建消息对象// 传入消息体转为字节数组; 设置匹配到路由的规则（map形式）; Message nameMsg= MessageBuilder.withBody(\"hello lcccccccc\".getBytes()).setHeader(\"name\", \"lcc\").build();// 发送到指定交换机; 此时路由无效; 传入消息 rabbitTemplate.send(RabbitHeadersConfig.HEADERNAME, null, nameMsg);// 构建消息对象// 传入消息体转为字节数组; 设置匹配到路由的规则（map形式）; Message ageMsg=MessageBuilder.withBody(\"i am 20\".getBytes()).setHeader(\"age\", \"22\").build();// 发送到指定交换机; 此时路由无效; 传入消息 rabbitTemplate.send(RabbitHeadersConfig.HEADERNAME, null, ageMsg); }} 三、RabbitMQ 选型和对比1.从社区活跃度按照目前网络上的资料，RabbitMQ 、activeM 、ZeroMQ 三者中，综合来看，RabbitMQ 是首选。 2.持久化消息比较ZeroMq 不支持，ActiveMq 和RabbitMq 都支持。持久化消息主要是指我们机器在不可抗力因素等情况下挂掉了，消息不会丢失的机制。 3.综合技术实现可靠性、灵活的路由、集群、事务、高可用的队列、消息排序、问题追踪、可视化管理工具、插件系统等等。 RabbitMq / Kafka 最好，ActiveMq 次之，ZeroMq 最差。当然ZeroMq 也可以做到，不过自己必须手动写代码实现，代码量不小。尤其是可靠性中的：持久性、投递确认、发布者证实和高可用性。 4.高并发毋庸置疑，RabbitMQ 最高，原因是它的实现语言是天生具备高并发高可用的erlang 语言。 5.比较关注的比较， RabbitMQ 和 KafkaRabbitMq 比Kafka 成熟，在可用性上，稳定性上，可靠性上， RabbitMq 胜于 Kafka （理论上）。 另外，Kafka 的定位主要在日志等方面， 因为Kafka 设计的初衷就是处理日志的，可以看做是一个日志（消息）系统一个重要组件，针对性很强，所以 如果业务方面还是建议选择 RabbitMq 。 还有就是，Kafka 的性能（吞吐量、TPS ）比RabbitMq 要高出来很多。","link":"/2020/04/17/mq/SpringBoot%E6%95%B4%E5%90%88RabbitMQ/"},{"title":"Springboot应用监控","text":"Springboot应用监控使用Actuator实现监控应用端点信息介绍 /info 应用基本信息 /health 健康度信息 /metrics 运行指标 /env 环境变量信息 /loggers 日志相关 /dump 线程相关信息 /trace 请求调用轨迹 ID 描述 是否需要鉴权 actuator 为其他端点提供“发现页面”。要求Spring HATEOAS在classpath路径上。 需要 auditevents 陈列当前应用程序的审计事件信息。 需要 autoconfig 展示自动配置信息并且显示所有自动配置候选人以及他们“被不被”应用的原因。 需要 beans 显示应用程序中所有Spring bean的完整列表。 需要 configprops 显示所有配置信息。 需要 dump dump所有线程。 需要 env 陈列所有的环境变量。 需要 flyway Shows any Flyway database migrations that have been applied. 需要 health 显示应用程序运行状况信息 不需要 info 显示应用信息。 不需要 loggers 显示和修改应用程序中的loggers配置。 需要 liquibase 显示已经应用的任何Liquibase数据库迁移。 需要 metrics 显示当前应用程序的“指标”信息。 需要 mappings 显示所有@RequestMapping的url整理列表。 需要 shutdown 关闭应用（默认情况下不启用）。 需要 trace 显示跟踪信息（默认最后100个HTTP请求）。 需要 一、应用端点1、pom.xmlspring-boot-starter-actuator spring-boot-starter-security 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;actuator&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;actuator&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、security安全配置httpBasic: 使用httpBasic认证 12345678910111213141516@Configurationpublic class SecurtyConfig extends WebSecurityConfigurerAdapter { @Override protected void configure(HttpSecurity http) throws Exception {// 请求匹配其他所有端点的请求 http.requestMatcher(EndpointRequest.toAnyEndpoint())// 开启所有请求授权 .authorizeRequests()// 其他请求必须要有admin角色 .anyRequest().hasRole(\"admin\") .and()// 使用httpBasic认证 .httpBasic(); }} 3、properties配置123456789101112131415161718192021222324252627282930#关闭默认的配置（即 关闭所有默认开启的端口），一般没有必要配置#management.endpoints.enabled-by-default=false#是否开启远程应用关闭功能 （默认一般只有这个是关闭的）#post：http://localhost:8080/actuator/shutdown 即可关闭应用#但是这样不够安全 需要进行配置securitymanagement.endpoint.shutdown.enabled=true#虽然默认开启了很多端点 但是都没有暴露#暴露所有端点management.endpoints.web.exposure.include=*#配置用户名密码角色spring.security.user.name=lcspring.security.user.password=123spring.security.user.roles=admin#配置访问的基础路径#默认为/actuatormanagement.endpoints.web.base-path=/lc#默认为/actuator/helath#health路径的重新配置management.endpoints.web.path-mapping.health=/lc-health#允许的域（默认* 所有）#自定义运行请求的地址http://localhost:8081management.endpoints.web.cors.allowed-origins=http://localhost:8081#允许的请求方法类型#默认为* 所有management.endpoints.web.cors.allowed-methods=GET,POST 4、访问测试①访问health默认：GET http://localhost:8080/actuaotr/health GET http://localhost:8080/lc/lc-health 选择：Authorization-&gt;Basic Auth Username:lc password:123 ②访问beans默认：GET http://localhost:8080/actuaotr/beans GET http://localhost:8080/lc/beans 选择：Authorization-&gt;Basic Auth Username:lc password:123 二、 health端点123456789101112131415161718192021222324252627282930313233#关闭默认的配置（即 关闭所有默认开启的端口），一般没有必要配置#management.endpoints.enabled-by-default=false#是否开启远程应用关闭功能 （默认一般只有这个是关闭的）#post：http://localhost:8080/actuator/shutdown 即可关闭应用#但是这样不够安全 需要进行配置securitymanagement.endpoint.shutdown.enabled=true#虽然默认开启了很多端点 但是都没有暴露#暴露所有端点management.endpoints.web.exposure.include=*#配置用户名密码角色spring.security.user.name=lcspring.security.user.password=123spring.security.user.roles=admin#配置访问的基础路径#默认为/actuator#management.endpoints.web.base-path=/lc#默认为/actuator/helath#health路径的重新配置#management.endpoints.web.path-mapping.health=/lc-health#允许的域（默认* 所有）#自定义运行请求的地址http://localhost:8081management.endpoints.web.cors.allowed-origins=http://localhost:8081#允许的请求方法类型#默认为* 所有management.endpoints.web.cors.allowed-methods=GET,POST#验证后展示健康信息management.endpoint.health.show-details=when_authorized 当配置其他应用时，如redis,mongo,mysql等都会有健康信息 GET http://localhost:8080/actuaotr/health 12345678910111213141516{ \"status\": \"UP\", \"components\": { \"diskSpace\": { \"status\": \"UP\", \"details\": { \"total\": 492657700864, \"free\": 265716948992, \"threshold\": 10485760 } }, \"ping\": { \"status\": \"UP\" } }} 三、info端点1、自定义信息①通过配置文件配置12345678910111213141516171819202122232425262728293031323334353637383940#关闭默认的配置（即 关闭所有默认开启的端口），一般没有必要配置#management.endpoints.enabled-by-default=false#是否开启远程应用关闭功能 （默认一般只有这个是关闭的）#post：http://localhost:8080/actuator/shutdown 即可关闭应用#但是这样不够安全 需要进行配置securitymanagement.endpoint.shutdown.enabled=true#虽然默认开启了很多端点 但是都没有暴露#暴露所有端点management.endpoints.web.exposure.include=*#配置用户名密码角色spring.security.user.name=lcspring.security.user.password=123spring.security.user.roles=admin#配置访问的基础路径#默认为/actuator#management.endpoints.web.base-path=/lc#默认为/actuator/helath#health路径的重新配置#management.endpoints.web.path-mapping.health=/lc-health#允许的域（默认* 所有）#自定义运行请求的地址http://localhost:8081management.endpoints.web.cors.allowed-origins=http://localhost:8081#允许的请求方法类型#默认为* 所有management.endpoints.web.cors.allowed-methods=GET,POST#验证后展示健康信息management.endpoint.health.show-details=when_authorized#配置应用信息info.app.encoding=@project.build.sourceEncoding@info.app.java.source=@java.version@info.app.java.target=@java.version@info.author.name=lcinfo.author.address=www.louchen.top GET:http://localhost:8080/actuator/info 12345678910111213{ \"app\": { \"encoding\": \"UTF-8\", \"java\": { \"source\": \"1.8.0_191\", \"target\": \"1.8.0_191\" } }, \"author\": { \"name\": \"lc\", \"address\": \"www.louchen.top\" }} ②通过代码配置会覆盖在properties的配置 123456789@Componentpublic class LcInfo implements InfoContributor { @Override public void contribute(Info.Builder builder) { Map&lt;String,Object&gt; info=new HashMap&lt;&gt;(); info.put(\"email\", \"421192425@qq.com\"); builder.withDetail(\"author\", info); }} GET http://localhost:8080/actuaotr/health 123456789101112{ \"app\": { \"encoding\": \"UTF-8\", \"java\": { \"source\": \"1.8.0_191\", \"target\": \"1.8.0_191\" } }, \"author\": { \"email\": \"421192425@qq.com\" }} 2、git信息①创建该项目所在的版本库git init–&gt;git add . –&gt;git commit -m ‘信息’ ②安装git信息插件12345678910111213&lt;build&gt; &lt;plugins&gt; &lt;!--添加git插件 获取git版本信息--&gt; &lt;plugin&gt; &lt;groupId&gt;pl.project13.maven&lt;/groupId&gt; &lt;artifactId&gt;git-commit-id-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; ③生成git.propertiesmaven-&gt;plugins-&gt;git-commit-id 点击：git-commit-id:revision 在target-&gt;classes下生成：git.properties 12345678910111213141516171819202122232425#Generated by Git-Commit-Id-Plugin#Wed Apr 08 16:33:41 GMT+08:00 2020git.branch=mastergit.build.host=LAPTOP-LJJM9R29git.build.time=2020-04-08T16\\:33\\:41+0800git.build.user.email=421192425@qq.comgit.build.user.name=louchen97git.build.version=0.0.1-SNAPSHOTgit.closest.tag.commit.count=git.closest.tag.name=git.commit.id=5a55c763ecfb66fff1986fce9880663a72ab7e88git.commit.id.abbrev=5a55c76git.commit.id.describe=5a55c76-dirtygit.commit.id.describe-short=5a55c76-dirtygit.commit.message.full=创建git.commit.message.short=创建git.commit.time=2020-04-08T16\\:30\\:36+0800git.commit.user.email=421192425@qq.comgit.commit.user.name=louchen97git.dirty=truegit.local.branch.ahead=NO_REMOTEgit.local.branch.behind=NO_REMOTEgit.remote.origin.url=Unknowngit.tags=git.total.commit.count=1 ④主配置文件123456789101112131415161718192021222324252627282930313233343536373839404142434445#关闭默认的配置（即 关闭所有默认开启的端口），一般没有必要配置#management.endpoints.enabled-by-default=false#是否开启远程应用关闭功能 （默认一般只有这个是关闭的）#post：http://localhost:8080/actuator/shutdown 即可关闭应用#但是这样不够安全 需要进行配置securitymanagement.endpoint.shutdown.enabled=true#虽然默认开启了很多端点 但是都没有暴露#暴露所有端点management.endpoints.web.exposure.include=*#配置用户名密码角色spring.security.user.name=lcspring.security.user.password=123spring.security.user.roles=admin#配置访问的基础路径#默认为/actuator#management.endpoints.web.base-path=/lc#默认为/actuator/helath#health路径的重新配置#management.endpoints.web.path-mapping.health=/lc-health#允许的域（默认* 所有）#自定义运行请求的地址http://localhost:8081management.endpoints.web.cors.allowed-origins=http://localhost:8081#允许的请求方法类型#默认为* 所有management.endpoints.web.cors.allowed-methods=GET,POST#验证后展示健康信息management.endpoint.health.show-details=when_authorized#配置应用信息info.app.encoding=@project.build.sourceEncoding@info.app.java.source=@java.version@info.app.java.target=@java.version@info.author.name=lcinfo.author.address=www.louchen.top#git信息配置#simple(默认)展示一些简单信息#full展示所有git信息management.info.git.mode=full GET: http://localhost:8080/actuator/info 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667{ \"app\": { \"encoding\": \"UTF-8\", \"java\": { \"source\": \"1.8.0_191\", \"target\": \"1.8.0_191\" } }, \"author\": { \"email\": \"421192425@qq.com\" }, \"git\": { \"build\": { \"host\": \"LAPTOP-LJJM9R29\", \"version\": \"0.0.1-SNAPSHOT\", \"time\": \"2020-04-08T08:33:41Z\", \"user\": { \"name\": \"louchen97\", \"email\": \"421192425@qq.com\" } }, \"branch\": \"master\", \"commit\": { \"message\": { \"short\": \"创建\", \"full\": \"创建\" }, \"id\": { \"describe\": \"5a55c76-dirty\", \"abbrev\": \"5a55c76\", \"describe-short\": \"5a55c76-dirty\", \"full\": \"5a55c763ecfb66fff1986fce9880663a72ab7e88\" }, \"time\": \"2020-04-08T08:30:36Z\", \"user\": { \"email\": \"421192425@qq.com\", \"name\": \"louchen97\" } }, \"closest\": { \"tag\": { \"name\": \"\", \"commit\": { \"count\": \"\" } } }, \"local\": { \"branch\": { \"ahead\": \"NO_REMOTE\", \"behind\": \"NO_REMOTE\" } }, \"dirty\": \"true\", \"remote\": { \"origin\": { \"url\": \"Unknown\" } }, \"tags\": \"\", \"total\": { \"commit\": { \"count\": \"1\" } } }} 3、项目构建信息maven--&gt;Plugins--&gt;spring-boot 点击：spring-boot:build-info 在classes下的META-INF下生成build-info.properties 12345build.artifact=actuatorbuild.group=org.lcbuild.name=actuatorbuild.time=2020-04-08T09\\:33\\:21.830Zbuild.version=0.0.1-SNAPSHOT GET http://localhost:8080/actuator/info 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374{ \"app\": { \"encoding\": \"UTF-8\", \"java\": { \"source\": \"1.8.0_191\", \"target\": \"1.8.0_191\" } }, \"author\": { \"email\": \"421192425@qq.com\" }, \"git\": { \"build\": { \"host\": \"LAPTOP-LJJM9R29\", \"version\": \"0.0.1-SNAPSHOT\", \"time\": \"2020-04-08T08:33:41Z\", \"user\": { \"name\": \"louchen97\", \"email\": \"421192425@qq.com\" } }, \"branch\": \"master\", \"commit\": { \"message\": { \"short\": \"创建\", \"full\": \"创建\" }, \"id\": { \"describe\": \"5a55c76-dirty\", \"abbrev\": \"5a55c76\", \"describe-short\": \"5a55c76-dirty\", \"full\": \"5a55c763ecfb66fff1986fce9880663a72ab7e88\" }, \"time\": \"2020-04-08T08:30:36Z\", \"user\": { \"email\": \"421192425@qq.com\", \"name\": \"louchen97\" } }, \"closest\": { \"tag\": { \"name\": \"\", \"commit\": { \"count\": \"\" } } }, \"local\": { \"branch\": { \"ahead\": \"NO_REMOTE\", \"behind\": \"NO_REMOTE\" } }, \"dirty\": \"true\", \"remote\": { \"origin\": { \"url\": \"Unknown\" } }, \"tags\": \"\", \"total\": { \"commit\": { \"count\": \"1\" } } }, \"build\": { \"version\": \"0.0.1-SNAPSHOT\", \"artifact\": \"actuator\", \"name\": \"actuator\", \"group\": \"org.lc\", \"time\": \"2020-04-08T09:33:21.830Z\" }}","link":"/2020/04/17/projectcontrol/SpringBoot%E5%BA%94%E7%94%A8%E7%9B%91%E6%8E%A7/"},{"title":"FastDFS构建分布式文件管理系统","text":"FastDFS构建分布式文件管理系统​ 说起分布式文件管理系统，大家可能很容易想到 HDFS、GFS 等系统，前者是 Hadoop 的一部分，后者则是 Google 提供的分布式文件管理系统。除了这些之外，国内淘宝和腾讯也有自己的分布式文件管理系统，都叫 TFS（Taobao File System 和 Tencent File System）。 ​ 相对于上面提到的这些分布式文件管理系统而言，FastDFS 可能离我们 Java 工程师更近一些，因为文件上传这个功能太常见了，而想要搭建独立的分布式文件管理系统，FastDFS+Nginx 组合无疑是最佳方案。 一、FastDFS简介 fastDFS 是以C语言开发的一项开源轻量级分布式文件系统，他对文件进行管理，主要功能有：文件存储，文件同步，文件访问（文件上传/下载）,特别适合以文件为载体的在线服务，如图片网站，视频网站等 分布式文件系统：基于客户端/服务器的文件存储系统 对等特性允许一些系统扮演客户端和服务器的双重角色，可供多个用户访问的服务器，比如，用户可以“发表”一个允许其他客户机访问的目录，一旦被访问，这个目录对客户机来说就像使用本地驱动器一样 FastDFS 由淘宝的余庆大佬在 2008 年开源的一款轻量级分布式文件管理系统，FastDFS 用 C 语言实现，支持 Linux、FreeBSD、MacOS 等类 UNIX 系统。FastDFS 类似 google FS，属于应用级文件系统，不是通用的文件系统，只能通过专有 API 访问，目前提供了 C 和 Java SDK ，以及 PHP 扩展 SDK。 这款开源软件从发布至今，历经数十年，这款开源软件的生命力依然旺盛，在业界依然备受推崇，当然这也得益于作者一直在不断完善该软件。 FastDFS 专为互联网应用量身定做，解决大容量文件存储问题，追求高性能和高扩展性，它可以看做是基于文件的 key/value 存储系统，key 为文件 ID，value 为文件内容，因此称作分布式文件存储服务更为合适。 1.1为什么需要FastDFS？传统的企业级开发对于高并发要求不是很高，而且数据量可能也不大，在这样的环境下文件管理可能非常 Easy。 但是互联网应用访问量大、数据量大，在互联网应用中，我们必须考虑解决文件大容量存储和高性能访问的问题，而 FastDFS 就特别适合干这件事情，常见的图片存储、视频存储、文档存储等等我们都可以采用 FastDFS 来做。 1.2FastDFS 架构作为一款分布式文件管理系统，FastDFS 主要包括四个方面的功能： 文件存储 文件同步 文件上传 文件下载 这个方面的功能，基本上就能搞定我们常见的文件管理需求了。 下面这是一张来自 FastDFS 官网的系统架构图： 从上面这张图中我们可以看到，FastDFS 架构包括 Tracker 和 Storage 两部分，看名字大概就能知道，Tracker 用来追踪文件，相当于是文件的一个索引，而 Storage 则用来保存文件。 我们上传文件的文件最终保存在 Storage 上，文件的元数据信息保存在 Tracker 上，通过 Tracker 可以实现对 Storage 的负载均衡。 Storage 一般会搭建成集群，一个 Storage Cluster 可以由多个组构成，不同的组之间不进行通信，一个组又相当于一个小的集群，组由多个 Storage Server 组成，组内的 Storage Server 会通过连接进行文件同步来保证高可用。 二、安装FastDFS介绍完 FastDFS 之后，相信小伙伴已经摩拳擦掌跃跃欲试了，接下来我们就来看下 FastDFS 的安装。 我这里为了测试方便，就不开启多台虚拟机了，Tracker 和 Storage 我将安装在同一台服务器上。 图片上传我们一般使用 FastDFS，图片上传成功之后，接下来的图片访问我们一般采用 Nginx，所以这里的安装将从三个方面来介绍： Tracker(追踪器) 安装 Storage(存储) 安装 Nginx 安装 2.1 Tracker 安装安装，我们首先需要准备一个环境,两个库以及一个安装包。 2.1.1一个环境先来看一个环境，由于 FastDFS 采用 C 语言开发，所以在安装之前，如果没有 gcc 环境，需要先安装，安装命令如下： 1yum install gcc-c++ 2.1.2两个库再来看两个库，由于 FastDFS 依赖 libevent 库，安装命令如下： 1yum -y install libevent 另一个库是 libfastcommon，这是 FastDFS 官方提供的，它包含了 FastDFS 运行所需要的一些基础库。 libfastcommon 下载地址：https://github.com/happyfish100/libfastcommon/archive/V1.0.43.tar.gz 1wget https://github.com/happyfish100/libfastcommon/archive/V1.0.43.tar.gz 将下载好的 libfastcommon 拷贝至 /usr/local/ 目录下， 1mv V1.0.43.tar.gz /usr/local/ 然后依次执行如下命令： 12345cd /usr/localtar -zxvf V1.0.43.tar.gzcd libfastcommon-1.0.43/./make.sh./make.sh install 2.1.3一个安装包接下来我们下载 Tracker，注意，由于 Tracker 和 Storage 是相同的安装包，所以下载一次即可（2.2 小节中不用再次下载）。 安装文件可以从 FastDFS 的 GitHub 仓库上下载，下载地址：https://github.com/happyfish100/fastdfs/archive/V6.06.tar.gz 1wget https://github.com/happyfish100/fastdfs/archive/V6.06.tar.gz 下载成功后，将下载文件拷贝到 /usr/local 目录下， 1mv V6.06.tar.gz /usr/local 然后依次执行如下命令安装： 12345cd /usr/localtar -zxvf V6.06.tar.gzcd fastdfs-6.06/./make.sh./make.sh install 安装成功后，执行如下命令，将安装目录内 conf 目录下的配置文件拷贝到 /etc/fdfs 目录下： 12cd conf/cp ./* /etc/fdfs/ 2.1.4配置接下来进入 /etc/fdfs/ 目录下进行配置： 打开 tracker.conf 文件： 1vi tracker.conf 修改如下配置： 默认端口是 22122，可以根据实际需求修改，我这里就不改了。然后下面配置一下元数据的保存目录（注意目录要存在）。 设置存储是否需要限额的百分比： 若硬盘的剩余空间不足20%,则会储存失败！ 若不存在home和sang文件夹，则需要创建 12mkdir homemkdir sang 2.1.5启动接下来执行如下命令启动 Tracker： 1/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf start 2.2 Storage 安装简单起见，这里我们搭建一个 Storage 实例即可。Storage 安装也需要 libevent 和 libfastcommon，这两个库的安装参考上文，这里无需再次安装。 Storage 本身的安装，也和 Tracker 一致，执行命令也都一样，因为我这里将 Tracker 和 Storage 安装在同一台服务器上，所以不用再执行安装命令了（相当于安装 Tracker 时已经安装了 Storage 了）。 唯一要做的，就是进入到 /etc/fdfs 目录下，配置 Storage： 1vi storage.conf ![](images\\批注 2020-04-10 152254.png) 这里一共配置三个地方，分别是 base_path、store_path0 以及 tracker_server ，tracker_server 模板有两个地址，我们这里只有一个，配置完成后，记得注释掉另外一个不用的。 配置完成后，执行如下命令启动 Storage： 1/usr/bin/fdfs_storaged /etc/fdfs/storage.conf start 这两个启动完成后，现在就可以做文件的上传了 注意：这里我们的服务器需要暴露 22122(tracker) 和 23000(storage) 端口 2.3 实现文件上传这里我们使用Springboot来整合 1、pom.xmlfastdfs-client-java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;fastdfs&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;fastdfs&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--fastdfs 客户端--&gt; &lt;dependency&gt; &lt;groupId&gt;net.oschina.zcx7878&lt;/groupId&gt; &lt;artifactId&gt;fastdfs-client-java&lt;/artifactId&gt; &lt;version&gt;1.27.0.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、fastdfs客户端配置修改tracker公网地址即可 12345678910111213141516171819202122232425## fastdfs-client.propertiesfastdfs.connect_timeout_in_seconds = 5fastdfs.network_timeout_in_seconds = 30fastdfs.charset = UTF-8fastdfs.http_anti_steal_token = falsefastdfs.http_secret_key = FastDFS1234567890fastdfs.http_tracker_http_port = 80#修改tracker公网地址fastdfs.tracker_servers = 47.96.141.44:22122## Whether to open the connection pool, if not, create a new connection every timefastdfs.connection_pool.enabled = true## max_count_per_entry: max connection count per host:port , 0 is not limitfastdfs.connection_pool.max_count_per_entry = 500## connections whose the idle time exceeds this time will be closed, unit: second, default value is 3600fastdfs.connection_pool.max_idle_time = 3600## Maximum waiting time when the maximum number of connections is reached, unit: millisecond, default value is 1000fastdfs.connection_pool.max_wait_time_in_ms = 1000 3、测试123456789101112131415161718@SpringBootTestclass FastdfsApplicationTests { @Test void contextLoads() throws IOException, MyException {// 加载配置文件 ClientGlobal.initByProperties(\"fastdfs-client.properties\"); TrackerClient trackerClient = new TrackerClient(); TrackerServer trackerServer= trackerClient.getConnection(); StorageServer storageServer= null; StorageClient1 storageClient1 = new StorageClient1(trackerServer, storageServer); NameValuePair pairs[]=null; String[] fileId= storageClient1.upload_file(\"F:\\\\桌面内容\\\\i\\\\1.jpg\", \"jpg\", pairs); System.out.println(Arrays.toString(fileId)); }} ==&gt;输出 1[group1, M00/00/00/L2CNLF6QAt6AejqEAADgTCtaXcs207.jpg] 这里，首先加载配置文件，然后构造一个 TrackerClient 对象，接着再根据这个对象获取到一个 TrackerServer，然后创建一个 StorageClient1 实例。NameValuePair 中保存的是文件的元数据信息，如果有的话，就以 key/value 的方式来设置，如果没有的话，直接给一个 null 即可。 最后，调用 client 的 upload_file1 方法上传文件，第一个参数是文件路径，第二个参数是文件的扩展名，第三个参数就是文件的元数据信息. group1 表示我们的一个个storage组 M00，M01, M02, 表示我们的storage中的每一台storage服务器 00/00/L2CNLF6QAt6AejqEAADgTCtaXcs207.jpg 才是真真正的路径地址 查看文件的存储位置 1cd /home/sang/fastdfs/data 1cd 00/00/ ![](F:\\桌面内容\\springboot2\\vhr项目\\images\\批注 2020-04-10 154344.png) 即可查看到文件的存储位置 2.4 Nginx的安装实现文件访问Nginx 可以算是 FastDFS 的重要搭档。 Nginx 的安装分为两个步骤： 安装 Nginx 首先在 Storage 下安装 fastdfs-nginx-module 首先下载 fastdfs-nginx-module，下载地址：https://github.com/happyfish100/fastdfs-nginx-module/archive/V1.22.tar.gz 1wget https://github.com/happyfish100/fastdfs-nginx-module/archive/V1.22.tar.gz 下载完成后，将下载的文件拷贝到 /usr/local 目录下。 1mv V1.22.tar.gz /usr/local 然后进入 /usr/local 目录，分别执行如下命令： 12cd /usr/localtar -zxvf V1.22.tar.gz 然后将 /usr/local/fastdfs-nginx-module-1.22/src/mod_fastdfs.conf 文件拷贝到 /etc/fdfs/ 目录下 1cp /usr/local/fastdfs-nginx-module-1.22/src/mod_fastdfs.conf /etc/fdfs/ 并修改该文件的内容： 1vi /etc/fdfs/mod_fastdfs.conf ![](images\\批注 2020-04-10 155554.png) 接下来，回到第一步下载的 nginx 安装文件的解压目录中，执行如下命令，重新配置编译安装： 在/root/nginx-1.8.1/下 123./configure --add-module=/usr/local/fastdfs-nginx-module-1.22/srcmakemake install 安装完成后，修改 nginx 的配置文件，如下： 1vi /usr/local/nginx/conf/nginx.conf ![](images\\批注 2020-04-10 155945.png) 在这里配置 nginx 请求转发。 配置完成后，启动 nginx，看到如下日志，表示 nginx 启动成功： ngx_http_fastdfs_set pid=9908 疑问：fastdfs-nginx-module 有啥用 看了整个安装过程之后，到头来还是 nginx 本身直接找到了图片文件目录，fastdfs-nginx-module 到底有啥用？ 前面我们说过，Storage 由很多组构成，每个组又是一个小的集群，在每一个组里边，数据会进行同步，但是如果数据还没同步，这个时候就有请求发来了，该怎么办？此时fastdfs-nginx-module 会帮助我们直接从源 Storage 上获取文件。 安装成功了。 文件访问测试：1http://47.96.141.44/group1/M00/00/00/L2CNLF6QAt6AejqEAADgTCtaXcs207.jpg 实现文件下载 其他配置和文件上传一致 1234567891011121314 @Test public void downloadTest() throws IOException, MyException { // 加载配置文件 ClientGlobal.initByProperties(\"fastdfs-client.properties\"); TrackerClient trackerClient = new TrackerClient(); TrackerServer trackerServer= trackerClient.getConnection(); StorageServer storageServer= null; StorageClient1 storageClient1 = new StorageClient1(trackerServer, storageServer); byte[] bytes = storageClient1.download_file1(\"group1/M00/00/00/L2CNLF6QAt6AejqEAADgTCtaXcs207.jpg\");// 写入新的路径 FileOutputStream outputStream=new FileOutputStream(new File(\"F:\\\\桌面内容\\\\i\\\\2.jpg\")); outputStream.write(bytes); outputStream.close(); } 2.5添加访问令牌，防止盗链现在，任何人都可以访问我们服务器上传文件，这肯定是不行的，这个问题好解决，加一个上传时候的令牌即可。 首先我们在服务端开启令牌校验： 1vi /etc/fdfs/http.conf ![](images\\批注 2020-04-10 164343.png) 配置完成后，记得重启nginx服务端： 123cd /usr/local/nginx/sbin./nginx -s stop./nginx 配置token有效期修改vi /etc/fdfs/http.conf 默认为10分钟 1234# token TTL (time to live), seconds# default value is 600#设置为1800s 即30分钟http.anti_steal.token_ttl = 1800 获取令牌访问12345678910111213141516@Test public void tokenTest() throws UnsupportedEncodingException, NoSuchAlgorithmException, MyException {// 获取时间戳 int ts = (int)Instant.now().getEpochSecond();// 获取token// 注意第一个参数不需要加group1; 时间戳; 令牌 String token = ProtoCommon.getToken(\"M00/00/00/L2CNLF6QLYqAPtyOAADgTCtaXcs276.jpg\", ts, \"FastDFS421192425\"); StringBuffer sb= new StringBuffer(); sb.append(\"http://47.96.141.44\") .append(\"/group1/M00/00/00/L2CNLF6QLYqAPtyOAADgTCtaXcs276.jpg\") .append(\"?token=\") .append(token) .append(\"&amp;ts=\") .append(ts); System.out.println(sb.toString()); } 得到如下地址 http://47.96.141.44/group1/M00/00/00/L2CNLF6QLYqAPtyOAADgTCtaXcs276.jpg?token=18247d981993d006085a519c4fcb668e&amp;ts=1586507960 这里，我们主要是根据 ProtoCommon.getToken 方法来获取令牌，注意这个方法的第一个参数是你要访问的文件 id，注意，这个地址里边不包含 group，千万别搞错了；第二个参数是时间戳，第三个参数是密钥，密钥要和服务端的配置一致。 将生成的字符串拼接，追加到访问路径后面，如：http://192.168.91.128/group1/M00/00/00/wKhbgF5aMteAWy0gAAJkI7-2yGk361.png?token=7e329cc50307000283a3ad3592bb6d32&amp;ts=1582975854。此时访问路径里边如果没有令牌，会访问失败。","link":"/2020/04/17/springboot/FastDFS%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"},{"title":"SpringBoot整合邮件服务","text":"SpringBoot整合邮件服务一、邮件服务简介SMTP(发送邮件) 协议SMTP 的全称是“Simple Mail Transfer Protocol”，即简单邮件传输协议。它是一组用于从源地址到目的地址传输邮件的规范，通过它来控制邮件的中转方式。SMTP 协议属于 TCP/IP 协议簇，它帮助每台计算机在发送或中转信件时找到下一个目的地。SMTP 服务器就是遵循 SMTP 协议的发送邮件服务器。SMTP 认证，简单地说就是要求必须在提供了账户名和密码之后才可以登录 SMTP 服务器，这就使得那些垃圾邮件的散播者无可乘之机。增加 SMTP 认证的目的是为了使用户避免受到垃圾邮件的侵扰。 POP3(接收邮件)协议​ POP3是Post Office Protocol 3的简称，即邮局协议的第3个版本,它规定怎样将个人计算机连接到Internet的邮件服务器和下载电子邮件的电子协议。它是因特网电子邮件的第一个离线协议标准,POP3允许用户从服务器上把邮件存储到本地主机（即自己的计算机）上,同时删除保存在邮件服务器上的邮件，而POP3服务器则是遵循POP3协议的接收邮件服务器，用来接收电子邮件的。但目前的 POP3 邮件服务器大都可以“只下载邮件，服务器端并不删除”，也就是改进的 POP3 协议。 SMTP 和 POP3 是最初的两个协议，随着邮件的不断发展后来又增加了两个协议： IMAP 协议IMAP全称是Internet Mail Access Protocol，即交互式邮件存取协议，它是跟POP3类似邮件访问标准协议之一。不同的是，开启了IMAP后，您在电子邮件客户端收取的邮件仍然保留在服务器上，同时在客户端上的操作都会反馈到服务器上，如：删除邮件，标记已读等，服务器上的邮件也会做相应的动作。所以无论从浏览器登录邮箱或者客户端软件登录邮箱，看到的邮件以及状态都是一致的。 Mime 协议MIME的英文全称是”Multipurpose Internet Mail Extensions” 多功能Internet 邮件扩充服务，它是一种多用途网际邮件扩充协议，在1992年最早应用于电子邮件系统，但后来也应用到浏览器。MIME意为多目Internet邮件扩展，它设计的最初目的是为了在发送电子邮件时附加多媒体数据，让邮件客户程序能根据其类型进行处理。然而当它被HTTP协议支持之后，它的意义就更为显著了。它使得HTTP传输的不仅是普通的文本，而变得丰富多彩。 二、发送邮件的准备工作申请授权码：以qq邮箱为例 登录qq邮箱–&gt;设置–&gt;账户–&gt;开启POP3/SMTP服务–&gt;验证–&gt;获取授权码 三、发送简单邮件1、pom.xmlspring-boot-starter-mail 123456789101112131415161718192021&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2、properties配置1234567891011121314#指定邮件服务器的地址 这里我们使用qq的smtp服务器发送邮件spring.mail.host=smtp.qq.com# 服务器的端口号修改成465或587；spring.mail.port=587# 邮件发送者的邮件spring.mail.username=421192425@qq.com# 这里使用的为授权码（不能使用邮箱密码）spring.mail.password=eqsdqizwdnenbgif#设置默认编码spring.mail.default-encoding=UTF-8#设置ssl协议spring.mail.properties.mail.smtp.socketFactory.class=javax.net.ssl.SSLSocketFactory#打印发送邮件的日志spring.mail.properties.mail.debug=true 3、发送邮件123456789101112131415161718192021222324252627@SpringBootTestclass MailApplicationTests { @Autowired private JavaMailSender javaMailSender; /** * 发送简单文本邮件 */ @Test void contextLoads() { SimpleMailMessage smm=new SimpleMailMessage();// 谁发的 这里需要和配置文件中的一致 smm.setFrom(\"421192425@qq.com\");// 发给谁 smm.setTo(\"421192425@qq.com\");// 定义主题 smm.setSubject(\"这是一份测试主题\");// 定义发送的日期 smm.setSentDate(new Date());// 发送的内容 smm.setText(\"测试lclcllclcl\");// 发送 javaMailSender.send(smm); }} 四、发送附件1、pom.xml123456789101112131415161718192021&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2、properties配置1234567891011121314#指定邮件服务器的地址 这里我们使用qq的smtp服务器发送邮件spring.mail.host=smtp.qq.com# 服务器的端口号修改成465或587；spring.mail.port=587# 邮件发送者的邮件spring.mail.username=421192425@qq.com# 这里使用的为授权码（不能使用邮箱密码）spring.mail.password=eqsdqizwdnenbgif#设置默认编码spring.mail.default-encoding=UTF-8#设置ssl协议spring.mail.properties.mail.smtp.socketFactory.class=javax.net.ssl.SSLSocketFactory#打印发送邮件的日志spring.mail.properties.mail.debug=true 3、发送邮件12345678910111213141516171819202122232425262728293031@SpringBootTestclass MailApplicationTests { @Autowired private JavaMailSender javaMailSender; /** * 发送附件 * @throws MessagingException */ @Test public void attachmentTest() throws MessagingException {// 创建模拟消息对象 MimeMessage msg = javaMailSender.createMimeMessage();// 传入模拟消息对象; 文件上传类型为true MimeMessageHelper helper = new MimeMessageHelper(msg, true);// 谁发的 这里需要和配置文件中的一致 helper.setFrom(\"421192425@qq.com\");// 发给谁 helper.setTo(\"421192425@qq.com\");// 定义主题 helper.setSubject(\"附件主题\");// 定义发送的日期 helper.setSentDate(new Date());// 发送的内容 helper.setText(\"附件内容哈哈哈---\");// 发送附件// 附件的名称(需要携带扩展名); 附件的地址 helper.addAttachment(\"lc.png\", new File(\"F:\\\\桌面内容\\\\i\\\\1.jpg\")); javaMailSender.send(msg); }} 五、发送图片资源文件1、pom.xml123456789101112131415161718192021&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2、properties配置1234567891011121314#指定邮件服务器的地址 这里我们使用qq的smtp服务器发送邮件spring.mail.host=smtp.qq.com# 服务器的端口号修改成465或587；spring.mail.port=587# 邮件发送者的邮件spring.mail.username=421192425@qq.com# 这里使用的为授权码（不能使用邮箱密码）spring.mail.password=eqsdqizwdnenbgif#设置默认编码spring.mail.default-encoding=UTF-8#设置ssl协议spring.mail.properties.mail.smtp.socketFactory.class=javax.net.ssl.SSLSocketFactory#打印发送邮件的日志spring.mail.properties.mail.debug=true 3、发送邮件12345678910111213141516171819202122232425262728293031323334@SpringBootTestclass MailApplicationTests { @Autowired private JavaMailSender javaMailSender; /** * 发送图片资源邮件 * @throws MessagingException */ @Test public void resourcesImgTest() throws MessagingException { // 创建模拟消息对象 MimeMessage msg = javaMailSender.createMimeMessage();// 传入模拟消息对象; multipalt(多部分)类型为true MimeMessageHelper helper = new MimeMessageHelper(msg, true);// 谁发的 这里需要和配置文件中的一致 helper.setFrom(\"421192425@qq.com\");// 发给谁 helper.setTo(\"421192425@qq.com\");// 定义主题 helper.setSubject(\"图片资源\");// 定义发送的日期 helper.setSentDate(new Date());// 发送的内容 ； cid定义文本id ; 设置发送的内容为html为true helper.setText(\"图片资源---》》这是第一张图片：&lt;img src='cid:p01'/&gt;，这是第二张图片：&lt;img src='cid:p02'/&gt;\",true);// 设置文本id helper.addInline(\"p01\", new FileSystemResource((new File(\"F:\\\\桌面内容\\\\i\\\\1.jpg\"))));// 设置文本id helper.addInline(\"p02\", new FileSystemResource((new File(\"F:\\\\桌面内容\\\\i\\\\2.png\")))); javaMailSender.send(msg); }} 六、使用thymeleaf发送邮件1、pom.xmlspring-boot-starter-thymeleaf spring-boot-starter-mail 12345678910111213141516171819202122232425&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2、properties1234567891011121314#指定邮件服务器的地址 这里我们使用qq的smtp服务器发送邮件spring.mail.host=smtp.qq.com# 服务器的端口号修改成465或587；spring.mail.port=587# 邮件发送者的邮件spring.mail.username=421192425@qq.com# 这里使用的为授权码（不能使用邮箱密码）spring.mail.password=eqsdqizwdnenbgif#设置默认编码spring.mail.default-encoding=UTF-8#设置ssl协议spring.mail.properties.mail.smtp.socketFactory.class=javax.net.ssl.SSLSocketFactory#打印发送邮件的日志spring.mail.properties.mail.debug=true 3、mail.html1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;hello &lt;span th:text=\"${username}\"&gt;&lt;/span&gt;,欢迎加入大家庭！！&lt;table border=\"1\" cellspacing=\"0\" cellpadding=\"0\"&gt; &lt;tr&gt; &lt;td&gt;职位&lt;/td&gt; &lt;td th:text=\"${position}\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;职称&lt;/td&gt; &lt;td th:text=\"${jobLevel}\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;薪水&lt;/td&gt; &lt;td th:text=\"${salary}\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;部门&lt;/td&gt; &lt;td th:text=\"${dep}\"&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;div style=\"color: red;font-size: 30px\"&gt;希望在未来的日子携手共进&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 4、发送邮件12345678910111213141516171819202122232425262728293031323334353637@SpringBootTestclass MailApplicationTests { @Autowired private JavaMailSender javaMailSender; //注入模板引擎 将thymeleaf的一些指令渲染成html @Autowired private TemplateEngine templateEngine; @Test public void thymeleafTemplateTest() throws MessagingException { // 创建模拟消息对象 MimeMessage msg = javaMailSender.createMimeMessage();// 传入模拟消息对象; multipalt(多部分)类型为true MimeMessageHelper helper = new MimeMessageHelper(msg, true);// 谁发的 这里需要和配置文件中的一致 helper.setFrom(\"421192425@qq.com\");// 发给谁 helper.setTo(\"421192425@qq.com\");// 定义主题 helper.setSubject(\"thymeleaf主题\");// 定义发送的日期 helper.setSentDate(new Date());// thymeleaf内容 Context context = new Context(); context.setVariable(\"username\", \"lc\"); context.setVariable(\"position\", \"总经理\"); context.setVariable(\"jobLevel\", \"架构师\"); context.setVariable(\"salary\",\"2000\"); context.setVariable(\"dep\", \"研发部\");// 将thymeleaf和context解析为字符串 String process = templateEngine.process(\"mail.html\", context);// 发送的内容 ； 设置发送的内容为html为true helper.setText(process,true); javaMailSender.send(msg); }} 七、使用freemarker发送邮件1、pom.xmlspring-boot-starter-mail spring-boot-starter-freemarker 12345678910111213141516171819202122232425&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-mail&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.junit.vintage&lt;/groupId&gt; &lt;artifactId&gt;junit-vintage-engine&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2、properties配置1234567891011121314#指定邮件服务器的地址 这里我们使用qq的smtp服务器发送邮件spring.mail.host=smtp.qq.com# 服务器的端口号修改成465或587；spring.mail.port=587# 邮件发送者的邮件spring.mail.username=421192425@qq.com# 这里使用的为授权码（不能使用邮箱密码）spring.mail.password=eqsdqizwdnenbgif#设置默认编码spring.mail.default-encoding=UTF-8#设置ssl协议spring.mail.properties.mail.smtp.socketFactory.class=javax.net.ssl.SSLSocketFactory#打印发送邮件的日志spring.mail.properties.mail.debug=true 3、mail.ftlh123456789101112131415161718192021222324252627282930&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;freemarker&lt;/h1&gt;hello &lt;span&gt;${username}&lt;/span&gt;,欢迎加入大家庭！！&lt;table border=\"1\" cellspacing=\"0\" cellpadding=\"0\"&gt; &lt;tr&gt; &lt;td&gt;职位&lt;/td&gt; &lt;td &gt;${position}&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;职称&lt;/td&gt; &lt;td&gt;${jobLevel}&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;薪水&lt;/td&gt; &lt;td&gt;${salary}&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;部门&lt;/td&gt; &lt;td&gt;${dep}&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;div style=\"color: red;font-size: 30px\"&gt;希望在未来的日子携手共进&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 4、发送邮件12345678910111213141516171819202122232425262728293031323334353637@SpringBootTestclass MailApplicationTests { @Autowired private JavaMailSender javaMailSender; @Test public void freemakerTest() throws MessagingException, IOException, TemplateException { // 创建模拟消息对象 MimeMessage msg = javaMailSender.createMimeMessage();// 传入模拟消息对象; multipalt(多部分)类型为true MimeMessageHelper helper = new MimeMessageHelper(msg, true);// 谁发的 这里需要和配置文件中的一致 helper.setFrom(\"421192425@qq.com\");// 发给谁 helper.setTo(\"421192425@qq.com\");// 定义主题 helper.setSubject(\"freeMaiker主题\");// 定义发送的日期 helper.setSentDate(new Date());// 设置freemarker配置版本 Configuration configuration=new Configuration(Configuration.VERSION_2_3_29);// 传入当前对象的类加载器; 所在的基础包路径 configuration.setClassLoaderForTemplateLoading(this.getClass().getClassLoader(), \"templates\"); Template template=configuration.getTemplate(\"mail.ftlh\"); Map&lt;String,Object&gt; map= new HashMap&lt;&gt;(); map.put(\"username\", \"lcccc\"); map.put(\"position\", \"总经理\"); map.put(\"jobLevel\", \"架构师\"); map.put(\"salary\",\"2000\"); map.put(\"dep\", \"研发部\"); StringWriter out=new StringWriter(); template.process(map, out);// 发送的内容 ； 设置发送的内容为html为true helper.setText(out.toString(),true); javaMailSender.send(msg); }}","link":"/2020/04/17/springboot/SpringBoot%E6%95%B4%E5%90%88%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1/"},{"title":"SpringBoot整合WebSocket","text":"SpringBoot整合WebSocket一、springboot实现在线群聊1、pom.xml主要的后端依赖 spring-boot-starter-websocket 前端依赖 sockjs-client jquery stomp-websocket webjars-locator-core 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;websocket1&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;websocket1&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--前端websocket客户端依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;sockjs-client&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--jquery--&gt; &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;stomp-websocket&lt;/artifactId&gt; &lt;version&gt;2.3.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;webjars-locator-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、消息bean123456@Getter@Setterpublic class Message { private String name; private String content;} 3、websocket代理服务器123456789101112131415161718192021222324/** * 实现websocket消息代理人配置器 */@Configuration//开启消息代理@EnableWebSocketMessageBrokerpublic class WebSocketConfig implements WebSocketMessageBrokerConfigurer { @Override public void configureMessageBroker(MessageBrokerRegistry registry) {// 消息代理的前缀 registry.enableSimpleBroker(\"/topic\"); registry.setApplicationDestinationPrefixes(\"/app\"); } /** * 建立连接点 * @param registry */ @Override public void registerStompEndpoints(StompEndpointRegistry registry) { registry.addEndpoint(\"/chat\").withSockJS(); }} 4、消息请求处理controller1234567891011121314@Controllerpublic class GreetingController {// 处理客户端请求消息的路径 //客户端发送消息的路径 /app/hello @MessageMapping(\"/hello\") // 服务器广播的路径(/topic/greetings) 由配置的topic前缀的服务去处理 //客户端订阅消息的路径 /topic/greeting @SendTo(\"/topic/greetings\") public Message greeting(Message message) { return message; }} 5、聊天页面123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;群聊&lt;/title&gt; &lt;script src=\"/webjars/jquery/jquery.min.js\"&gt;&lt;/script&gt; &lt;script src=\"/webjars/sockjs-client/sockjs.min.js\"&gt;&lt;/script&gt; &lt;script src=\"/webjars/stomp-websocket/stomp.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;请输入用户名&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" id=\"name\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=\"button\" id=\"connect\" value=\"连接\"/&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=\"button\" id=\"disconnect\" value=\"断开连接\" disabled=\"disabled\"/&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;!--display:none 此块不会显示--&gt; &lt;div id=\"chat\" style=\"display: none;\"&gt; &lt;table&gt; &lt;tr&gt;请输入聊天内容&lt;/tr&gt; &lt;td&gt;&lt;input type=\"text\" id=\"content\"/&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=\"button\" id=\"send\" value=\"发送\"&gt;&lt;/td&gt; &lt;/table&gt; &lt;div id=\"conversation\"&gt;群聊进行中....&lt;/div&gt; &lt;/div&gt;&lt;script&gt; $(function () { //点击连接 $(\"#connect\").click(function () { connect() }); // 断开连接 $(\"#disconnect\").click(function () { if(stompClient!=null){ //直接断开连接 stompClient.disconnect(); } setConnect(false); }); $(\"#send\").click(function () { stompClient.send('/app/hello',{},JSON.stringify({'name':$(\"#name\").val(),'content':$(\"#content\").val()})) }) }) var stompClient=null; //尝试连接 function connect() { //如果没有输入用户名 直接返回 if(!$(\"#name\").val()){ alert(\"请输入用户名\") return; } //建立连接点 var socket=new SockJS('/chat'); stompClient=Stomp.over(socket); stompClient.connect({},function (success) { //连接成功的回调 //建立连接 （界面的处理） setConnect(true); // 订阅服务器的消息（后端服务服务器广播消息的路径） stompClient.subscribe('/topic/greetings',function (msg) { //服务端的msg的具体消息 在body属性中 //将字符串消息转为json对象 showGreeting(JSON.parse(msg.body)) }) },function () { // 连接失败的回调 }) } //展示消息 function showGreeting(msg) { //向聊天div中追加内容 $(\"#conversation\").append('&lt;div&gt;'+msg.name+\":\"+msg.content+'&lt;/div&gt;') } //建立连接 function setConnect(flag) { //prop() 方法设置或返回被选元素的属性和值。 //如果连接成功 则设置 '连接' 按钮不可用 $(\"#connect\").prop(\"disabled\",flag); //断开连接按钮 可用 $(\"#disconnect\").prop(\"disabled\",!flag); if (flag) { //显示 聊天界面 $(\"#chat\").show(); }else{ $(\"#chat\").hide(); } }&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 二、 springboot实现在线单聊1、pom.xml主要的后端依赖 spring-boot-starter-websocket spring-boot-starter-security 前端依赖 sockjs-client jquery stomp-websocket webjars-locator-core 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;websocket1&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;websocket1&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-websocket&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--前端websocket客户端依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;sockjs-client&lt;/artifactId&gt; &lt;version&gt;1.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--jquery--&gt; &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;jquery&lt;/artifactId&gt; &lt;version&gt;3.4.1&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;stomp-websocket&lt;/artifactId&gt; &lt;version&gt;2.3.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.webjars&lt;/groupId&gt; &lt;artifactId&gt;webjars-locator-core&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、消息bean12345678910111213141516@Getter@Setterpublic class Chat { /** * 消息从哪来 */ private String from; /** * 消息内容 */ private String content; /** * 消息发给谁 */ private String to;} 3、websocket代理服务器1234567891011121314151617181920212223242526/** * 实现websocket消息代理人配置器 */@Configuration//开启消息代理@EnableWebSocketMessageBrokerpublic class WebSocketConfig implements WebSocketMessageBrokerConfigurer { @Override public void configureMessageBroker(MessageBrokerRegistry registry) {// 消息代理的前缀// 在这里我们定义 /topic为群聊消息 /queue为单聊消息 registry.enableSimpleBroker(\"/topic\",\"/queue\");// 定义程序的发送目标前缀 registry.setApplicationDestinationPrefixes(\"/app\"); } /** * 建立连接点 * @param registry */ @Override public void registerStompEndpoints(StompEndpointRegistry registry) { registry.addEndpoint(\"/chat\").withSockJS(); }} 4、security配置12345678910111213141516171819202122232425262728293031@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter { @Bean public PasswordEncoder passwordEncoder() { return NoOpPasswordEncoder.getInstance(); } @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.inMemoryAuthentication() .withUser(\"lc\") .password(\"123\") .roles(\"admin\") .and() .withUser(\"zs\") .password(\"123\") .roles(\"user\"); } @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests(). anyRequest().authenticated() .and() .formLogin()// 允许所有登录请求 .permitAll(); }} 5、消息请求处理controller12345678910111213141516171819202122232425262728293031323334353637@Controllerpublic class GreetingController {// // 处理客户端请求消息的路径// @MessageMapping(\"/hello\")//// 服务器广播的路径(/topic/greetings) 由配置的topic前缀的服务去处理// @SendTo(\"/topic/greetings\")// public Message greeting(Message message) {// return message;// } /** * 使用消息发送模板 */ @Autowired private SimpMessagingTemplate simpMessagingTemplate; @MessageMapping(\"/hello\") public void greeting(Message message) {// 直接指定发送的路径和消息 simpMessagingTemplate.convertAndSend(\"/topic/greetings\",message); } /** * 单聊 * @param principal 当前登录的用户信息 * @param chat */ @MessageMapping(\"/chat\") public void chat(Principal principal, Chat chat) { //谁发的消息 （指定发送人） chat.setFrom(principal.getName());// 指定发送人 ，发送的路径 ，发送的消息 simpMessagingTemplate.convertAndSendToUser(chat.getTo(), \"/queue/chat\", chat); }} 6、聊天页面注意： 123456// 注意在单聊是 发送给指定用户，那么websocket服务端自动帮我们加 /user 所以这里我们也要加 /user stompClient.subscribe('/user/queue/chat', function (msg) { //服务端的msg的具体消息 在body属性中 //将字符串消息转为json对象 showGreeting(JSON.parse(msg.body)) }) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;单聊&lt;/title&gt; &lt;script src=\"/webjars/jquery/jquery.min.js\"&gt;&lt;/script&gt; &lt;script src=\"/webjars/sockjs-client/sockjs.min.js\"&gt;&lt;/script&gt; &lt;script src=\"/webjars/stomp-websocket/stomp.min.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type=\"button\" id=\"connect\" value=\"连接\"/&gt;&lt;input type=\"button\" id=\"disconnect\" value=\"断开连接\" disabled=\"disabled\"/&gt;&lt;hr&gt;&lt;table&gt; &lt;tr&gt; &lt;td&gt;消息内容:&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" id=\"content\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;目标用户:&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" id=\"to\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;&lt;input type=\"button\" value=\"发送\" id=\"send\"&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;div id=\"chat\" style=\"display: none\"&gt; &lt;div id=\"conversation\"&gt;连接进行中...&lt;/div&gt;&lt;/div&gt;&lt;script&gt; $(function () { //点击连接 $(\"#connect\").click(function () { connect() }); // 断开连接 $(\"#disconnect\").click(function () { if (stompClient != null) { //直接断开连接 stompClient.disconnect(); } setConnect(false); }); //点击发送 $(\"#send\").click(function () { stompClient.send('/app/chat', {}, JSON.stringify({ 'to': $(\"#to\").val(), 'content': $(\"#content\").val() })) }) }) var stompClient = null; //尝试连接 function connect() { // 创建连接点 var socket = new SockJS('/chat'); stompClient = Stomp.over(socket); stompClient.connect({}, function (success) { //连接成功的回调 //建立连接 （界面的处理） setConnect(true); // 订阅服务器的消息 // 注意在单聊是 发送给指定用户，那么websocket服务端自动帮我们加 /user 所以这里我们也要加 /user stompClient.subscribe('/user/queue/chat', function (msg) { //服务端的msg的具体消息 在body属性中 //将字符串消息转为json对象 showGreeting(JSON.parse(msg.body)) }) }, function () { // 连接失败的回调 }) } //展示消息 function showGreeting(msg) { //向聊天div中追加内容 $(\"#conversation\").append('&lt;div&gt;' + msg.from + \":\" + msg.content + '&lt;/div&gt;') } //建立连接 function setConnect(flag) { //prop() 方法设置或返回被选元素的属性和值。 //如果连接成功 则设置 '连接' 按钮不可用 $(\"#connect\").prop(\"disabled\", flag); //断开连接按钮 可用 $(\"#disconnect\").prop(\"disabled\", !flag); if (flag) { //显示 聊天界面 $(\"#chat\").show(); } else { $(\"#chat\").hide(); } }&lt;/script&gt;&lt;/body&gt;&lt;/html&gt;","link":"/2020/04/17/websocket/SpringBoot%E6%95%B4%E5%90%88WebSocket/"},{"title":"Docker的基本操作Linux常用命令","text":"Centos 软件包管理工具 一、RPM：是Red-Hat Package Manager(RPM软件包管理器) 二、Yum（全称为 Yellow dog Updater, Modified）是一个在Fedora和RedHat以及CentOS中的Shell前端软件包管理器。 0、修改docker镜像源 编辑 /etc/docker/daemon.json 12345vi /etc/docker/daemon.json#添加如下网易镜像源{\"registry-mirrors\": [\"http://hub-mirror.c.163.com\"]} 1、docker操作123456yum install docker //安装dockeryum update //更新软件包工具systemctl enable docker //配置开机自启dockersudo systemctl start docker //启动systemctl stop docker //停止dockeryum -y install vim* //安装vim 2、镜像操作1234567docker search tag //从docker hub官网上检索tag指定镜像docker pull tag //下载镜像 tag为安装的软件名称 默认安装latest版本 即最近的docker pull tag:版本号 //安装指定版本号的软件docker images //查看本机安装的镜像docker rmi 镜像Image id //根据镜像id删除指定的镜像rm -rf //递归删除sudo rm -rf /var/lib/docker //删除所有镜像 3、防火墙操作123456systemctl start firewalld //启动防火墙systemctl stop firewalld //关闭防火墙systemctl status firewalld //查看防火墙状态systemctl start firewalld //启动防火墙systemctl disable firewalld //开机禁用防火墙systemctl enable firewalld //开机启用防火墙 4、容器操作123456docker ps //查看运行的容器docker stop id //根据id停止容器docker ps -a //查看所有容器,包括运行和退出的docker rm id/name //s根据id或者名称删除容器docker start id/name //根据id或名称开启容器docker logs name/id //根据容器id或容器名查看日志 5、常见容器安装1、mysql容器 (注意启动版本)123docker pull mysql:3.7 //下载指版本镜像docker run -d -p 3306:3306 --restart=always --name mysql01 -e MYSQL_ROOT_PASSWORD=123456 mysql:5.7// -d在后台启动 , -p端口映射 主机端口:映射端口 , --name 容器名称 ，-e 参数 若密码错误： 1234567&lt;1&gt; docker start mysql 进入MySql&lt;2&gt; docker ps -a 查出自己创建的container（容器）的ID&lt;3&gt; docker exec -it 63c9e29aelef bash （每个人创建的container ID都不一样） 执行对应的mysql程序&lt;4&gt; mysql --user=root --password 进入mysql进行登录&lt;5&gt; ALTER USER 'root' IDENTIFIED WITH mysql_native_password BY '1234567'; 设置新的密码quit 退出当前mysql命令行模式exit 退出容器 123456docker run --name mysql03 -v /conf/mysql:/etc/mysql/conf.d -e MYSQL_ROOT_PASSWORD=my-secret-pw -d mysql:tag把主机的/conf/mysql文件夹挂载到 mysqldocker容器的/etc/mysql/conf.d文件夹里面改mysql的配置文件就只需要把mysql配置文件放在自定义的文件夹下（/conf/mysql）docker run -p 3307:3306 --name mysql02 -e MYSQL_ROOT_PASSWORD=123456 -d mysql --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci指定mysql的一些配置参数 2、Rabbitmq安装rabbitmq端口 ：5672 管理界面端口 ：15672 默认账户密码都是 guest 12docker pull rabbitmq:3-management //下载带管理界面的消息队列docker run -d -p 5672:5672 -p 15672:15672 --restart=always --name myrabbitmq 镜像id 修改rabbitmq密码 123docker exec -it fd4f81cdd3e7 bash //进入容器rabbitmqctl list_users //查看所有用户 rabbitmqctl change_password guest 'Newpassword' //修改指定用户密码 常见命令 12345新建用户：rabbitmqctl add_user username passwd删除用户：rabbitmqctl delete_user username改密码: rabbimqctl change_password {username} {newpassword}设置用户角色：rabbitmqctl set_user_tags {username} {tag ...}rabbitmqctl set_permissions -p / username \".*\" \".*\" \".*\" //添加权限 3、redis安装123456789docker pull redis //拉取镜像docker run -d -p 6379:6379 --restart=always --name myredis 镜像名 //创建容器docker exec -it 9a7d1cf2c234 redis-cli -v //查看版本①设置密码 此方法是临时设置的密码 重启服务后失效docker exec -it 9a7d1cf2c234 redis-cli //进入redis管理界面config get requirepass //查看密码config set requirepass 密码 //设置密码docker exec -it 9a7d1cf2c234 redis-cli -a '密码' //带密码进入管理界面 4、jdk安装12345678910111213141516171819202122下载jdk1.8和tomcat8.5 利用sftp传到远程服务器tar -zxvf jdk-8u221-linux-x64.tar.gz //解压jdkmv jdk1.8.0_221 /opt/jdk //移动rm jdk-8u221-linux-x64.tar.gz //安装包vi /etc/profile //进入文件##### 在文件末尾加上环境变量配置JAVA_HOME=/opt/jdk/JAVA_BIN=/opt/jdk/binJRE_HOME=/opt/jdk/jreCLASSPATH=/opt/jdk/jre/lib:/opt/jdk/lib:/opt/jdk/jre/lib/charsets.jarexport JAVA_HOME JAVA_BIN JRE_HOME PATH CLASSPATH#####source /etc/profile //使配置生效vi ~/.bashrc //进入文件##### 在文件默认加上配置export JAVA_HOME=/opt/jdkexport PATH=$JAVA_HOME/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar######source ~/.bashrc //使配置生效java -version //查看是否成功 5、tomcat安装①docker常规方法（成功）123docker pull tomcat //拉取镜像docker run -d -p 8080:8080 --name tomcat01 -v /usr/local/dev/docker-tomcat:/usr/local/tomcat/webapps --restart=always tomcat //路径挂载 ，将.war的包放在宿主机/usr/local/dev/docker-tomcat下即可 访问 1http://47.96.141.44:8080/Test1_war/ ②容器打包镜像方法 （失败）123456789101112131415161718192021222324252627282930docker pull centos:7.2.1511 //拉取镜像docker run -i -t -v /root/software/:/mnt/software/ 9aec5c5fe4ba /bin/bash //创建目录并挂载容器## -i：表示以“交互模式”运行容器## -t：表示容器启动后会进入其命令行## -v：表示需要将本地哪个目录挂载到容器中，格式：-v &lt;宿主机目录&gt;:&lt;容器目录&gt;## /bin/bash：一旦容器启动，需要执行的命令，当前使用 \"/bin/bash\", 表示启动后直接进bash shellctrl+d 或者 exit //退出容器docker start thirsty_jepsen //开启容器tar -zxvf apache-tomcat-8.5.46.tar.gz //解压tomcatmv apache-tomcat-8.5.46 /opt/tomcat //移动rm apache-tomcat-8.5.46.tar.gz //删除安装包######编写tomcat启动脚本vi /root/run.sh###### 加入命令#!/bin/bashsource ~/.bashrcsh /opt/tomcat/bin/catalina.sh run######chmod u+x /root/run.sh //设置run.sh 权限###将配置好的容器重新打包为镜像 docker commit 2bd3cf9f4b33 tomcat_jdk_01 //docker commit [容器id] [命名]docker run -d -p 8080:8080 -v /root/webapps/:/opt/tomcat/webapps/ --name tomcat01 tomcat_jdk_01 /root/run.sh 6、nginx安装12341、docker pull nginx2、docker run -d -p 80:80 --restart=always --name nginx01 f949e7d76d63docker run -d -p 3000:80 --name longdbvuejs -v /usr/local/dev/vuelist:/usr/share/nginx/html/ 6617a398219c 7、mongodb安装docker run 命令参数123456789101112131415161718192021222324252627282930313233343536-a, --attach=[] 登录容器（必须是以docker run -d启动的容器） -w, --workdir=\"\" 指定容器的工作目录 -c, --cpu-shares=0 设置容器CPU权重，在CPU共享场景使用 -e, --env=[] 指定环境变量，容器中可以使用该环境变量 -m, --memory=\"\" 指定容器的内存上限 -P, --publish-all=false 指定容器暴露的端口 -p, --publish=[] 指定容器暴露的端口 主机端口:容器端口 -h, --hostname=\"\" 指定容器的主机名 -v, --volume=[] 给容器挂载存储卷，挂载到容器的某个目录 --volumes-from=[] 给容器挂载其他容器上的卷，挂载到容器的某个目录 --cap-add=[] 添加权限，权限清单详见：http://linux.die.net/man/7/capabilities --cap-drop=[] 删除权限，权限清单详见：http://linux.die.net/man/7/capabilities --cidfile=\"\" 运行容器后，在指定文件中写入容器PID值，一种典型的监控系统用法 --cpuset=\"\" 设置容器可以使用哪些CPU，此参数可以用来容器独占CPU --device=[] 添加主机设备给容器，相当于设备直通 --dns=[] 指定容器的dns服务器 --dns-search=[] 指定容器的dns搜索域名，写入到容器的/etc/resolv.conf文件 --entrypoint=\"\" 覆盖image的入口点 --env-file=[] 指定环境变量文件，文件格式为每行一个环境变量 --expose=[] 指定容器暴露的端口，即修改镜像的暴露端口 --link=[] 指定容器间的关联，使用其他容器的IP、env等信息 --lxc-conf=[] 指定容器的配置文件，只有在指定--exec-driver=lxc时使用 --name=\"\" 指定容器名字，后续可以通过名字进行容器管理，links特性需要使用名字 --net=\"bridge\" 容器网络设置: bridge 使用docker daemon指定的网桥 host //容器使用主机的网络 container:NAME_or_ID &gt;//使用其他容器的网路，共享IP和PORT等网络资源 none 容器使用自己的网络（类似--net=bridge),但是不进行配置--privileged=false 指定容器是否为特权容器，特权容器拥有所有的capabilities --restart=\"no\" 指定容器停止后的重启策略: no：容器退出时不重启 on-failure：容器故障退出（返回值非零）时重启 always：容器退出时总是重启 --rm=false 指定容器停止后自动删除容器(不支持以docker run -d启动的容器) --sig-proxy=true 设置由代理接受并处理信号，但是SIGCHLD、SIGSTOP和SIGKILL不能被代理 6、常见问题1、解决ctenOs中docker不能启动问题Job for docker.service failed because the control process exited with error code. Se e “systemctl st 1vi /etc/sysconfig/docker 将文件中的内容 改为 –selinux-enabled=false docker -v 查看版本号 (ctl==&gt;controller) 2、解决Error response from daemon: oci runtime error: container_linux.go:247: starting container processhttps://blog.csdn.net/liqun_super/article/details/88304094 3、查找所有docker 并强制删除https://www.cnblogs.com/OnlyDreams/p/8990350.html 4、sftp和ftp的区别1234567一、适用场景 我们平时习惯了使用ftp来上传下载文件，尤其是很多Linux环境下，我们一般都会通过第三方的SSH工具连接到Linux，但是当我们需要传输文件到Linux服务器当中，很多人习惯用ftp来传输，其实Linux默认是不提供ftp的，需要你额外安装FTP服务器。而且ftp服务器端会占用一定的VPS服务器资源。其实笔者更建议使用sftp代替ftp。 主要因为：一、可以不用额外安装任何服务器端程序(我比较中意这个，哈哈~~，很多公司为了安全性Linux没有外网环境，只有SSH的时候，想传输文件是很悲催的问题)。二、会更省系统资源。三、SFTP使用加密传输认证信息和传输数据，相对来说会更安全。四、也不需要单独配置，对新手来说比较简单(开启SSH默认就开启了SFTP)。二、主要区别 FTP是一种文件传输协议，一般是为了方便数据共享的。包括一个FTP服务器和多个FTP客户端。FTP客户端通过FTP协议在服务器上下载资源。而SFTP协议是在FTP的基础上对数据进行加密，使得传输的数据相对来说更安全。但是这种安全是以牺牲效率为代价的，也就是说SFTP的传输效率比FTP要低(不过现实使用当中，没有发现多大差别)。个人肤浅的认为就是：一；FTP要安装，SFTP不要安装。二；SFTP更安全，但更安全带来副作用就是的效率比FTP要低些。 6、docker官方手册https://docs.docker.com/engine/reference/commandline/docker/可以参考每一个镜像的文档 7、vi 命令12345678:w 保存文件但不退出vi:w file 将修改另外保存到file中，不退出vi:w! 强制保存，不推出vi:wq 保存文件并退出vi:wq! 强制保存文件，并退出viq: 不保存文件，退出vi:q! 不保存文件，强制退出vi:e! 放弃所有修改，从上次保存文件开始再编辑 8、linux中 ~ 和 / 的区别1234567891011~ 是当前用户的目录地址/ 是根目录的地址（一般称呼为root，/ 和 /root/ 是有区别的）/ 也指目录分隔符①当用户是root用户时~ 代表/root/，即根目录下的root目录/ 代表/ ，即根目录②当用户是jack用户时~ 代表/home/jack，即根目录下的home目录下的jack目录/ 代表/ ，即根目录 9、ps/top命令①查看所有用户进程信息1ps aux ②查看包含指定应用的进程12//查询包含apt的进程ps -ef|grep apt ps其他命令参数详解 1234567a：显示现行终端机下的所有进程，包括其他用户（所有用户）的进程； u：显示进程拥有者（当前用户下）、状态、资源占用等的详细信息（注意有“-”和无“-”的区别）； x：显示没有控制终端的进程。通常与 a 这个参数一起使用，可列出较完整信息； -e：显示所有进程； -f：完整输出显示进程之间的父子关系； -l：较长、较详细的将该 PID 的的信息列出； -o：自定义显示的字段； 进程参数详解 123456789101112131415161718192021222324USER 进程的属主；PID 进程的ID；PPID 父进程；%CPU 进程占用的CPU百分比；%MEM 占用内存的百分比；NI 进程的NICE值，数值大，表示较少占用CPU时间；VSZ 进程虚拟大小；RSS 驻留中页的数量；TTY 终端IDSTAT 进程状态（有以下几种） R 运行 S 可中断睡眠 Sleep D 不可中断睡眠 T 停止的进程 Z 僵尸进程 X 死掉的进程 Ss s进程的领导者，父进程 S&lt; &lt;优先级较高的进程 SN N优先级较低的进程 R+ +表示WCHAN 正在等待的进程资源；START 启动进程的时间；TIME 进程消耗CPU的时间；COMMAND 命令的名称和参数； ③根据端口找到指定进程12//根据端口找到该进程netstat -lnp|grep 8080 123456netstat子命令:-t (tcp) 仅显示tcp相关选项-u (udp) 仅显示udp相关选项-n 拒绝显示别名，能显示数字的全部转化为数字-l 仅列出在Listen(监听)的服务状态-p 显示建立相关链接的程序名 ④根据pid关闭进程12//根据PID强制关闭该进程kill -9 28937 ⑤top连续监控进程cpu使用情况top -c 其他用法 12345top //每隔5秒显式所有进程的资源占用情况top -d 2 //每隔2秒显式所有进程的资源占用情况top -c //每隔5秒显式进程的资源占用情况，并显示进程的命令行参数(默认只有进程名)top -p 12345 -p 6789//每隔5秒显示pid是12345和pid是6789的两个进程的资源占用情况top -d 2 -c -p 123456 //每隔2秒显示pid是12345的进程的资源使用情况，并显式该进程启动的命令行参数 11、查看文件内容①、一次加载全部1cat 1.txt ②、查看文件内容 （可翻页 b上一页 f下一页 ）1more 1.txt 12、jar包后台运行方式一：java -jar shareniu.jar特点：当前ssh窗口被锁定，可按CTRL + C打断程序运行，或直接关闭窗口，程序退出 那如何让窗口不锁定？ 方式二：java -jar shareniu.jar &amp;&amp;代表在后台运行。 特定：当前ssh窗口不被锁定，但是当窗口关闭时，程序中止运行。 继续改进，如何让窗口关闭时，程序仍然运行？ 方式三：nohup java -jar shareniu.jar &amp; nohup 意思是不挂断运行命令,当账户退出或终端关闭时,程序仍然运行 当用 nohup 命令执行作业时，缺省情况下该作业的所有输出被重定向到nohup.out的文件中，除非另外指定了输出文件。 结束后台！！！！！ 通过ps aux命令查看进程号PID，然后执行 kill -9 PID 如果是前台进程的话，直接执行 Ctrl+c 就可以终止了指定日志位置： 在vblog.log下 nohup java -jar vblog.jar &gt; vblog.log &amp; 在vhr.log下 nohup java -jar vhr.jar &gt; vhr.log &amp; 14、解决在linux中mysql中不区分大小写的情况问题：可能出现vim无法找到 一、apt-get update 二、apt-get install vim 在配置文件的[mysqld]后添加lower_case_table_names=1 ①.进入docke容器命令： docker exec -it f0b1c8ab3633 /bin/bash （f0b1c8ab3633为CONTAINER ID，请修改为你的CONTAINER ID ） ②.进入mysql目录命令： cd /etc/mysql/mysql.conf.d ③.查看mysql配置文件：命令： ls ④.修改配置文件命令：vim mysqld.cnf 按 i 进入编辑，加入lower_case_table_names=1 按Esc键，输入 :wq 保存退出 ⑤.exit退出容器⑥重启该容器docker stop mysql01 docker start mysql01 15、卸载某项软件或服务①查找包含程序运行的服务ps -ef | grep nginx ②停止服务kill -9 pid ③查询哪里包含nginxwhereis nginx find / -name nginx ④依次删除执行位置目录rm -rf 目录位置","link":"/2020/04/17/shell/Linux-CentOs/"},{"title":"SpringCache 整合redis缓存","text":"Spring Cache 整合redis缓存一、概述SpringCache本身是一个缓存体系的抽象实现，并没有具体的缓存能力，要使用SpringCache还需要配合具体的缓存实现来完成。 虽然如此，但是SpringCache是所有Spring支持的缓存结构的基础，而且所有的缓存的使用最后都要归结于SpringCache，那么一来，要想使用SpringCache，还是要仔细研究一下的。 SpringCache只是定义的一种规范，所有的实现均有redis实现，即我们需要使用其他的缓存只需要替换引用操作的缓存件即可。 二、缓存注解SpringCache缓存功能的实现是依靠下面的这几个注解完成的。 @EnableCaching：开启缓存功能 @Cacheable：定义缓存，用于触发缓存 @CachePut：定义更新缓存，触发缓存更新 @CacheEvict：定义清除缓存，触发缓存清除 @Caching：组合定义多种缓存功能 @CacheConfig：定义公共设置，位于class之上 2.1 @EnableCaching12345678910111213141516171819202122232425@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Import(CachingConfigurationSelector.class)public @interface EnableCaching { // 用于设置使用哪种代理方式，默认为基于接口的JDK动态代理（false）， // 设置为true，则使用基于继承的CGLIB动态代理 boolean proxyTargetClass() default false; // 用于设置切面织入方式(设置面向切面编程的实现方式)， // 默认为使用动态代理的方式织入，当然也可以设置为ASPECTJ的方式来实现AOP AdviceMode mode() default AdviceMode.PROXY; // 用于设置在一个切点存在多个通知的时候各个通知的执行顺序，默认为最低优先级， // 其中数字却大优先级越低，这里默认为最低优先级，int LOWEST_PRECEDENCE = // Integer.MAX_VALUE;，却是整数的最大值 int order() default Ordered.LOWEST_PRECEDENCE;}public enum AdviceMode { PROXY, ASPECTJ}public interface Ordered { int HIGHEST_PRECEDENCE = Integer.MIN_VALUE; int LOWEST_PRECEDENCE = Integer.MAX_VALUE; int getOrder();} 2.2 @Cacheable​ 该注解用于标注于方法之上用于标识该方法的返回结果需要被缓存起来，标注于类之上标识该类中所有方法均需要将结果缓存起来。 ​ 该注解标注的方法每次被调用前都会触发缓存校验，校验指定参数的缓存是否已存在（已发生过相同参数的调用），若存在，直接返回缓存结果，否则执行方法内容，最后将方法执行结果保存到缓存中。 12345678910111213141516171819202122232425262728293031323334353637383940@Target({ElementType.METHOD, ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface Cacheable { // 用于指定缓存名称，与cacheNames()方法效果一致 @AliasFor(\"cacheNames\") String[] value() default {}; // 用于指定缓存名称，与value()方法效果一致 @AliasFor(\"value\") String[] cacheNames() default {}; // 用于使用SPEL手动指定缓存键的组合方式，默认情况使用所有的参数来组合成键，除非自定义了keyGenerator。 // 使用SPEL表达式可以根据上下文环境来获取到指定的数据： // #root.method：用于获取当前方法的Method实例 // #root.target：用于获取当前方法的target实例 // #root.caches：用于获取当前方法关联的缓存 // #root.methodName：用于获取当前方法的名称 // #root.targetClass：用于获取目标类类型 // #root.args[1]：获取当前方法的第二个参数，等同于：#p1和#a1和#argumentName String key() default \"\"; // 自定义键生成器，定义了该方法之后，上面的key方法自动失效，这个键生成器是： // org.springframework.cache.interceptor.KeyGenerator，这是一个函数式接口， // 只有一个generate方法，我们可以通过自定义的逻辑来实现自定义的key生成策略。 String keyGenerator() default \"\"; // 用于设置自定义的cacheManager(缓存管理器),可以自动生成一个cacheResolver // （缓存解析器），这一下面的cacheResolver()方法设置互斥 String cacheManager() default \"\"; // 用于设置一个自定义的缓存解析器 String cacheResolver() default \"\"; // 用于设置执行缓存的条件，如果条件不满足，方法返回的结果就不会被缓存，默认无条件全部缓存。 // 同样使用SPEL来定义条件，可以使用的获取方式同key方法。 String condition() default \"\"; // 这个用于禁止缓存功能，如果设置的条件满足，就不执行缓存结果，与上面的condition不同之处在于， // 该方法执行在当前方法调用结束，结果出来之后，因此，它除了可以使用上面condition所能使用的SPEL // 表达式之外，还可以使用#result来获取方法的执行结果，亦即可以根据结果的不同来决定是否缓存。 String unless() default \"\"; // 设置是否对多个针对同一key执行缓存加载的操作的线程进行同步，默认不同步。这个功能需要明确确定所 // 使用的缓存工具支持该功能，否则不要滥用。 boolean sync() default false;} 2.3 @CachePut该注解用于更新缓存，无论结果是否已经缓存，都会在方法执行结束插入缓存，相当于更新缓存。一般用于更新方法之上。 123456789101112131415161718192021222324@Target({ElementType.METHOD, ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface CachePut { // 同上 @AliasFor(\"cacheNames\") String[] value() default {}; // 同上 @AliasFor(\"value\") String[] cacheNames() default {}; // 同上 String key() default \"\"; // 同上 String keyGenerator() default \"\"; // 同上 String cacheManager() default \"\"; // 同上 String cacheResolver() default \"\"; // 同上 String condition() default \"\"; // 同上 String unless() default \"\";} 2.4 @CacheEvict该注解主要用于删除缓存操作 1234567891011121314151617181920212223242526@Target({ElementType.METHOD, ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface CacheEvict { // 同上 @AliasFor(\"cacheNames\") String[] value() default {}; // 同上 @AliasFor(\"value\") String[] cacheNames() default {}; // 同上 String key() default \"\"; // 同上 String keyGenerator() default \"\"; // 同上 String cacheManager() default \"\"; // 同上 String cacheResolver() default \"\"; // 同上 String condition() default \"\"; // 这个设置用于指定当前缓存名称名下的所有缓存是否全部删除，默认false。 boolean allEntries() default false; // 这个用于指定删除缓存的操作是否在方法调用之前完成，默认为false，表示先调用方法，在执行缓存删除。 boolean beforeInvocation() default false;} 2.5 @Caching这个注解用于组个多个缓存操作，包括针对不用缓存名称的相同操作等，源码： 123456789101112@Target({ElementType.METHOD, ElementType.TYPE})@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface Caching { // 用于指定多个缓存设置操作 Cacheable[] cacheable() default {}; // 用于指定多个缓存更新操作 CachePut[] put() default {}; // 用于指定多个缓存失效操作 CacheEvict[] evict() default {};} 用法==&gt; 123456789101112131415161718192021222324@Service@Log4j2public class AnimalService { @Autowired private AnimalRepository animalRepository; //... @Caching( evict = { @CacheEvict(value = \"animalById\", key = \"#id\"), @CacheEvict(value = \"animals\", allEntries = true, beforeInvocation = true) } ) public ResponseEntity&lt;Integer&gt; deleteAnimalById(final int id){ return ResponseEntity.ok(animalRepository.deleteById(id)); } @Cacheable(\"animals\") public ResponseEntity&lt;Page&lt;Animal&gt;&gt; getAnimalPage(final Animal animal, final int pageId, final int pageSize){ Page&lt;Animal&gt; page = new Page&lt;&gt;(); page.setCurrent(pageId); page.setSize(pageSize); return ResponseEntity.ok((Page&lt;Animal&gt;) animalRepository.selectPage(page,packWrapper(animal, WrapperType.QUERY))); } //...} 2.6 @CacheConfig该注解标注于类之上，用于进行一些公共的缓存相关配置。源码为： 12345678910111213@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface CacheConfig { // 设置统一的缓存名，适用于整个类中的方法全部是针对同一缓存名操作的情况 String[] cacheNames() default {}; // 设置统一个键生成器，免去了每个缓存设置中单独设置 String keyGenerator() default \"\"; // 设置统一个自定义缓存管理器 String cacheManager() default \"\"; // 设置统一个自定义缓存解析器 String cacheResolver() default \"\";} 三、基本配置1、pom.xmlspring-boot-starter-security spring-boot-starter-cache spring-boot-starter-data-redis 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;jpa-rest&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;jpa-rest&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 2、yaml配置1234567891011spring:# redis配置 redis: host: 47.96.141.44 database: 0 password: 你的密码 port: 6379# 配置缓存名称 cache: cache-names: c1 3、实体Bean12345678@Getter@Setter@ToStringpublic class User implements Serializable { private Integer id; private String username; private String address;} 4、开启缓存12345678910@SpringBootApplication//启用缓存@EnableCachingpublic class JpaRestApplication { public static void main(String[] args) { SpringApplication.run(JpaRestApplication.class, args); }} 5、service层①缓存存储： key：指定一个或多个参数作为key12345678910111213141516171819@Servicepublic class UserService {/** * 方法的参数为key * 方法返回的结果为value * * cacheNames配置的缓存名称 * key 只指定某一个参数作为key,或者联合多个参数作为key * @param id * @return */ @Cacheable(cacheNames = \"c1\",key = \"#id+'-'+#name\") public User getUserById(Integer id,String name) { System.out.println(\"getUserId===&gt;&gt;&gt;&gt;\" + id); User u=new User(); u.setId(id); return u; }} 当参数即key相同时，直接从redis中取 测试==&gt; 1234567891011121314@SpringBootTestclass JpaRestApplicationTests { @Autowired private UserService userService; @Test void contextLoads() { User userById = userService.getUserById(1,\"bb\"); User userById1 = userService.getUserById(1,\"bb\"); System.out.println(userById); System.out.println(userById1); }} ②自定义key1234567891011121314@Componentpublic class RedisKeyGenerator implements KeyGenerator { /** * 自定义返回的key 当前定义的key形式为 \" 方法名:所有参数组成的字符串数组 \" * @param o * @param method 当前方法名 * @param objects 方法的参数 * @return */ @Override public Object generate(Object o, Method method, Object... objects) { return method.getName()+\":\"+ Arrays.toString(objects); }} 12345678910111213141516@Servicepublic class UserService { /** * keyGenerator 自定义生成的key 当前引用的配置类为开头字母小写的类名 * @param id * @param name * @return */ @Cacheable(cacheNames = \"c1\",keyGenerator = \"redisKeyGenerator\") public User getUserById1(Integer id,String name,String author) { System.out.println(\"getUserId===&gt;&gt;&gt;&gt;\" + id); User u=new User(); u.setId(id); return u; }} 测试==&gt; 1234567@Testvoid contextLoads1() { User userById = userService.getUserById1(1,\"bb\",\"张三\"); User userById1 = userService.getUserById1(1,\"bb\",\"张三\"); System.out.println(userById); System.out.println(userById1);} ③删除缓存1234567891011121314151617181920@Servicepublic class UserService { @Cacheable(cacheNames = \"c1\") public User getUserById2(Integer id) { System.out.println(\"getUserId===&gt;&gt;&gt;&gt;\" + id); User u=new User(); u.setId(id); return u; } /** * 删除缓存中的内容 * 默认根据方法的参数作为key进行删除 * @param id */ @CacheEvict(cacheNames = \"c1\") public void deleteUserById(Integer id) { System.out.println(\"deleteUserById==&gt;&gt;&gt;&gt;\"+id); }} 测试==&gt; 12345678@Test void contextLoads2() { User userById = userService.getUserById2(1); userService.deleteUserById(1); User userById1 = userService.getUserById2(1); System.out.println(userById); System.out.println(userById1); } ④更新缓存123456789101112@Servicepublic class UserService { /** * 更新缓存中的内容 key: 指定user对象中的id作为键 * @param user * @return */ @CachePut(cacheNames = \"c1\",key = \"#user.id\") public User updateUserById(User user){ return user; }} 测试==&gt; 123456789101112@Test void contextLoads3() { User userById = userService.getUserById2(2); User user = new User(); user.setId(1); user.setUsername(\"张三\"); user.setAddress(\"湖北武汉\"); userService.updateUserById(user); User userById1 = userService.getUserById2(2); System.out.println(userById); System.out.println(userById1); } ⑤定义全局缓存名称@CacheConfig(cacheNames = &quot;c1&quot;) 无需在每个方法上加cacheName 123456789101112131415161718192021@Service@CacheConfig(cacheNames = \"c1\")public class UserService { /** * 方法的参数为key * 方法返回的结果为value * * cacheNames配置的缓存名称 * key 只指定某一个参数作为key,或者联合多个参数作为key * @param id * @return */ @Cacheable(key = \"#id+'-'+#name\") public User getUserById(Integer id,String name) { System.out.println(\"getUserId===&gt;&gt;&gt;&gt;\" + id); User u=new User(); u.setId(id); return u; }}","link":"/2020/04/17/springcache/Spring%20Cache%E6%95%B4%E5%90%88redis/"},{"title":"Git详细使用","text":"一、什么是git？Git是目前世界上最先进的分布式版本控制系统。 工作原理 / 流程： Workspace：工作区Index / Stage：暂存区Repository：仓库区（或本地仓库）Remote：远程仓库 二、SVN与Git的最主要的区别？①SVN​ SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而干活的时候，用的都是自己的电脑，所以首先要从中央服务器哪里得到最新的版本，然后干活，干完后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，如果在局域网还可以，带宽够大，速度够快，如果在互联网下，如果网速慢的话，就纳闷了。 ②Git​ Git是分布式版本控制系统，那么它就没有中央服务器的，每个人的电脑就是一个完整的版本库，这样，工作的时候就不需要联网了，因为版本都是在自己的电脑上。既然每个人的电脑都有一个完整的版本库，那多个人如何协作呢？比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。 三、如何操作1、创建版本库​ 什么是版本库？版本库又名仓库，英文名repository,你可以简单的理解一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改，删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻还可以将文件”还原”。 ① 通过命令 git init 把这个目录变成git可以管理的仓库 ②使用 git add readme.txt 添加指定文件到暂存区里面去。 git add . 添加所有文件到暂存区 ③用命令 git commit 告诉Git，把文件提交到仓库。 git commit -m “描述” 添加修改的描述，以便辨别版本 ④git status 查看是否还有文件未提交 ⑤当修改或增加文件后 重新使用 git status 查看状态 12345678910111213On branch masterChanges not staged for commit: (use \"git add &lt;file&gt;...\" to update what will be committed) (use \"git checkout -- &lt;file&gt;...\" to discard changes in working directory) modified: \"guava\\347\\232\\204\\344\\275\\277\\347\\224\\250.md\" ------&gt;&gt;修改的Untracked files: (use \"git add &lt;file&gt;...\" to include in what will be committed) 1.txt ------&gt;&gt;增加的no changes added to commit (use \"git add\" and/or \"git commit -a\") ⑤git diff 文件名 查看修改的内容 ⑥ 当修改或增加其他文件时 重新添加所有 git add . 重新提交 git commit -m “描述” 2、版本回退例如： 在创建版本库的时候已经添加了1.txt 文件 多次修改1.txt 文件，并add和commit ① 查看历史记录 git log git log命令显示从最近到最远的显示日志 1234567891011121314151617181920212223commit 852772742844a1f7b2fca0211be71985431acc71 (HEAD -&gt; master)Author: louchen97 &lt;421192425@qq.com&gt;Date: Sun Dec 8 14:19:45 2019 +0800 修改1.txt gitcommit 132064dc8f0fc298794a555c5cc3e4c36931c37bAuthor: louchen97 &lt;421192425@qq.com&gt;Date: Sun Dec 8 14:18:57 2019 +0800 修改1.txt 天气commit 5b340f7c2ede9536c7ae42f4b65efde895e697c9Author: louchen97 &lt;421192425@qq.com&gt;Date: Sun Dec 8 14:15:31 2019 +0800 增加1.txt 修改guavacommit 05da67dce6737ccb2d6b526f27a91f43719e27cdAuthor: louchen97 &lt;421192425@qq.com&gt;Date: Sun Dec 8 11:30:22 2019 +0800 第一次 使用 git log –pretty=oneline 简化查看的界面 1234852772742844a1f7b2fca0211be71985431acc71 (HEAD -&gt; master) 修改1.txt git132064dc8f0fc298794a555c5cc3e4c36931c37b 修改1.txt 天气5b340f7c2ede9536c7ae42f4b65efde895e697c9 增加1.txt 修改guava05da67dce6737ccb2d6b526f27a91f43719e27cd 第一次 ②回退版本 回退到上一个版本： git reset –hard HEAD^ 回退到上上个版本：git reset –hard HEAD^^ 回退到前100个版本的话: git reset –hard HEAD~100 依次类推……… ③重新查看文件内容： cat 1.txt ④回退之后 重新 git log 发现回退之前的版本的log会消失 你想反悔了 又想回到回退之前的版本 查看所有的版本(包括已回退)： git reflog 12345132064d (HEAD -&gt; master) HEAD@{0}: reset: moving to HEAD^8527727 HEAD@{1}: commit: 修改1.txt git132064d (HEAD -&gt; master) HEAD@{2}: commit: 修改1.txt 天气5b340f7 HEAD@{3}: commit: 增加1.txt 修改guava05da67d HEAD@{4}: commit (initial): 第一次 根据版本号回退： git reset –hard 8527727 发现又恢复到回退之前的版本 三、理解工作区与暂存区的区别？​ 工作区：就是你在电脑上看到的目录，比如目录下里的文件(.git隐藏目录版本库除外)。或者以后需要再新建的目录文件等等都属于工作区范畴。​ 版本库(Repository)：工作区有一个隐藏目录.git,这个不属于工作区，这是版本库。其中版本库里面存了很多东西，其中最重要的就是stage(暂存区)，还有Git为我们自动创建了第一个分支master,以及指向master的一个指针HEAD。 我们前面说过使用Git提交文件到版本库有两步： 第一步：是使用 git add 把文件添加进去，实际上就是把文件添加到暂存区。 第二步：使用git commit提交更改，实际上就是把暂存区的所有内容提交到当前分支上。 四、Git撤销修改和删除文件操作1、撤销操作​ 之前我们提到当修改一个文件时 提交之后发现有问题需要回退 ①提交之后的做法： 第一步：如果我知道要删掉那些内容的话，直接手动更改去掉那些需要的文件，然后add添加到暂存区，最后commit掉。 第二步：我可以按以前的方法直接恢复到上一个版本。使用 git reset –hard HEAD^ ②未提交到暂存区的做法（未提交）： 在这里我们可以使用另一种方法： git checkout – 文件名 把该文件在工作区做的修改全部撤销 解释： 该文件自动修改后，还没有放到暂存区，使用 撤销修改就回到和版本库一模一样的状态。 ③提交到暂存器（未提交）的做法： 例如： 1、修改1.txt 2、add到暂存区 3、再修改1.txt 4、使用 git checkout – 文件名 5、结果会回退到 add到暂存区的版本 注意：git checkout – 1.txt 中的 – 很重要，如果没有 – 的话，那么命令变成创建分支了。2、删除操作①已提交状态 无法使用checkout 恢复 直接在工作区删除此文件 rm 1.txt 然后 git add . 然后 commit -m ‘描述’ ② 未add加到暂存区和未提交 可使用checkout恢复该文件 git checkout – 1.txt 五、远程仓库​ 在了解之前，先注册github账号，由于你的本地Git仓库和github仓库之间的传输是通过SSH加密的，所以需要一点设置：​ 第一步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有id_rsa和id_rsa.pub这两个文件，如果有的话，直接跳过此如下命令，如果没有的话，打开命令行，输入如下命令： ssh-keygen -t rsa –C “youremail@example.com” id_rsa是私钥，不能泄露出去，id_rsa.pub是公钥，可以放心地告诉任何人。 查看github添加 私钥和公钥的方法 https://blog.csdn.net/qq_36150631/article/details/81038485 1、如何添加远程库？​ 现在的情景是：我们已经在本地创建了一个Git仓库后，又想在github创建一个Git仓库，并且希望这两个仓库进行远程同步，这样github的仓库可以作为备份，又可以其他人通过该仓库来协作。 ①在指定的远端仓库添加本机的ssh rsa 公钥 ②新建远端仓库：获取远端的git仓库的路径 ③将工作区添加到远端分支 查看关联的远程仓库信息 git remote ===&gt;&gt; 一般为origin 若为空则首次创建需要创建远端的origin仓库名并关联本地的master分支 git remote add origin https://gitee.com/louchen97/gitttttttt.git git push --set-upstream origin master ​ 把本地库的内容推送到远程，使用 git push命令，实际上是把当前分支master推送到远程。 ​ 由于远程库是空的，我们第一次推送master分支时，加上了 –u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。推送成功后，可以立刻在github页面中看到远程库的内容已经和本地一模一样了 ④提交到远程仓库（master分支） git push origin master 或者 git push https://gitee.com/louchen97/gitttttttt.git master 把本地master分支的最新修改推送到github上了，现在你就拥有了真正的分布式版本库了。 2、如何远程克隆仓库？①新建文件夹 git clone https://gitee.com/louchen97/gitttttttt.git 3、远程仓库的其他操作①删除远程仓库的关联git remote remove ②修改远程仓库的关联第一种：使用 git remote set-url 命令，更新远程仓库的 url git remote set-url origin &lt;newurl&gt; 第二种：先删除之前关联的远程仓库，再来添加新的远程仓库关联 # 删除关联的远程仓库 git remote remove &lt;name&gt; # 添加新的远程仓库关联 git remote add &lt;name&gt; &lt;url&gt; 远程仓库的名称推荐使用默认的名称 origin 。 六、创建与合并分支​ 在 版本回填退里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即master分支。HEAD严格来说不是指向提交，而是指向master，master才是指向提交的，所以，HEAD指向的就是当前分支。 1、创建并切换dev分支git checkout -b dev 等价于==&gt;&gt; git branch dev 创建分支 git checkout dev 切换分支 2、查看（所有）分支git branch ===&gt;&gt; 12* dev ====&gt;&gt; 当前分支前面有*号 并且为绿色字样 master 3、在dev分支上添加文件add到暂存器并且commit提交 4、切换到master主分支git checkout master 发现在分支dev添加的文件并没有 5、在master分支下，将分支dev合并到master主分支git merge dev git merge命令用于合并指定分支到当前分支上 这是可以看到主分支中在dev分支下添加的内容 6、删除dev分支git branch -d dev 总结分支操作12345678910111213总结创建与合并分支命令如下：查看分支：git branch创建分支：git branch name切换分支：git checkout name创建+切换分支：git checkout –b name合并某分支到当前分支：git merge name删除分支：git branch –d name 七、如何解决分支冲突？1、发生冲突在master分支和dev分支下都使用同一版本的时候 例如 1.txt 内容： 1增加其他的 ①、在dev分支下 修改1.txt1增加其他的 dev add 并 commit ②、在master主分支下 修改1.txt1增加其他的 master add 并 commit ③、 在master分支下合并dev分支git status 1234567891011121314On branch masterYour branch is ahead of 'origin/master' by 2 commits. (use \"git push\" to publish your local commits)You have unmerged paths. (fix conflicts and run \"git commit\") (use \"git merge --abort\" to abort the merge)Unmerged paths: (use \"git add &lt;file&gt;...\" to mark resolution) both modified: 1.txtno changes added to commit (use \"git add\" and/or \"git commit -a\") 1.txt 结果： 12345&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD增加其他的 master=======增加其他的 dev&gt;&gt;&gt;&gt;&gt;&gt;&gt; dev &lt;&lt;&lt;HEAD是指主分支修改的内容 &gt;&gt;&gt;&gt;&gt;dev 是指dev上修改的内容 ⑤、还原master修改1.txt内容： 1增加其他的 master add 并 commit 因为dev和master合并后是 管理的同一版本的分支 所有文件内容都一致 2、分支策略管理 合并分支后删除分支 会丢掉分支信息​ 通常合并分支时，git一般使用”Fast forward”模式，在这种模式下，删除分支后，会丢掉分支信息，现在我们来使用带参数 –no-ff来禁用”Fast forward”模式。 合并dev分支，使用命令 git merge –no-ff -m “注释” dev ​ 分支策略：首先master主分支应该是非常稳定的，也就是用来发布新版本，一般情况下不允许在上面干活，干活一般情况下在新建的dev分支上干活，干完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。 八、bug分支​ 在开发中，会经常碰到bug问题，那么有了bug就需要修复，在Git中，分支是很强大的，每个bug都可以通过一个临时分支来修复，修复完成后，合并分支，然后将临时的分支删除掉。 ​ 比如我在开发中接到一个404 bug时候，我们可以创建一个404分支来修复它，但是，当前的fen分支上的工作还没有提交。比如下： 创建 git checkout -b fen 分支并切换到此分支 修改2.txt文件 但此时因为其他原因不能提交此文件 12345678On branch fenChanges not staged for commit: (use \"git add &lt;file&gt;...\" to update what will be committed) (use \"git checkout -- &lt;file&gt;...\" to discard changes in working directory) modified: 2.txtno changes added to commit (use \"git add\" and/or \"git commit -a\") ​ 并不是我不想提交，而是工作进行到一半时候，我们还无法提交，比如我这个分支bug要2天完成，但是我issue-404 bug需要5个小时内完成。怎么办呢？还好，Git还提供了一个stash功能，可以把当前工作现场 ”隐藏起来”，等以后恢复现场后继续工作。如下： ①、隐藏当前不能提交的分支git stash ②、创建其他分支修复此buggit checkout -b issue-404 修复此文件2.txt add 并 commit ③、master主分支合并issue-404git merge --no-ff -m 'merge修复404' issue-404 ④、删除此修复作用的分支git branch -d issue-404 ⑤、重新切换到dev分支git stash apply 恢复dev工作区 git stash list 查看恢复区 git stash drop 删除恢复区 九、多人协作​ 当你从远程库克隆时候，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且远程库的默认名称是origin。 要查看远程库的信息 使用 git remote 1origin 要查看远程库的详细信息 使用 git remote –v 12origin https://gitee.com/louchen97/gitttttttt.git (fetch) ====&gt;&gt; 抓取origin https://gitee.com/louchen97/gitttttttt.git (push) ====&gt;&gt; 推送 二、推送分支 (项目t1)1、推送master主分支到远端​ 推送分支就是把该分支上所有本地提交到远程库中，推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上 git push origin master 2、推送fen分支到远端git push origin fen 此时远端分支有两个 主分支 master 和 fen 分支 分别对应不同的版本库 master分支是主分支，因此要时刻与远程同步。一些修复bug分支不需要推送到远程去，可以先合并到主分支上，然后把主分支master推送到远程去。 二、抓取分支（新建项目t2）​ 多人协作时，大家都会往master分支上推送各自的修改。现在我们可以模拟另外一个同事，可以在另一台电脑上（注意要把SSH key添加到github上）或者同一台电脑上另外一个目录克隆，新建一个目录名字叫t2 ①、抓取主分支mastergit clone https://gitee.com/louchen97/gitttttttt.git ②、抓取后在master中创建fen把远程的origin的dev分支到本地来，于是可以使用命令创建本地dev分支： git checkout –b fen origin/fen 现在小伙伴们就可以在dev分支上做开发了，开发完成后把dev分支推送到远程库时 此时 本地的 master 对应远端的 master ​ 本地的 fen 对应远端的 fen 在fen分支中修改 后 add 和 commit 推送当前fen分支到远端的fen分支 git push origin fen ③、切换到t1 的fen分支下修改同样文件的内容 add 和 commit git push origin fen 发现： 12345678To https://gitee.com/louchen97/gitttttttt.git ! [rejected] fen -&gt; fen (fetch first)error: failed to push some refs to 'https://gitee.com/louchen97/gitttttttt.git'hint: Updates were rejected because the remote contains work that you dohint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: (e.g., 'git pull ...') before pushing again.hint: See the 'Note about fast-forwards' in 'git push --help' for details. ​ 由上面可知：推送失败，因为我的小伙伴最新提交的和我试图推送的有冲突，解决的办法也很简单，上面已经提示我们，先用git pull把最新的提交从origin/dev抓下来，然后在本地合并，解决冲突，再推送。 ④、拉取远端的fen分支，设置本地的fen分支和远端的origin/fen分支链接​ git pull也失败了，原因是没有指定本地fen分支与远程origin/fen分支的链接，根据提示，设置fen和origin/fen的链接：如下： git branch --set-upstream-to=origin/fen fen 这条命名会自动merge 本地和远端的fen分支 但是有冲突： 12345&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEADt1添加的内容=======t2添加的内容&gt;&gt;&gt;&gt;&gt;&gt;&gt; d58f1f34d63f02333174f6e4dad45f4ba330b941 修改后重新push 1t1添加的内容 ⑤、切换到t2项目重新 git pull 得到t2和t2在fen分支下的同样内容 总结​ 首先，可以试图用git push origin branch-name推送自己的修改.如果推送失败，则因为远程分支比你的本地更新早，需要先用git pull试图合并。如果合并有冲突，则需要解决冲突，并在本地提交。再用git push origin branch-name推送。 总结一、新建代码库123# 在当前目录新建一个Git代码库$ git init # 新建一个目录，将其初始化为Git代码库$ git init [project-name] # 下载一个项目和它的整个代码历史$ git clone [url] 二、配置123# 显示当前的Git配置$ git config --list# 编辑Git配置文件$ git config -e [--global]# 设置提交代码时的用户信息$ git config [--global] user.name &quot;[name]&quot;$ git config [--global] user.email &quot;[email address]&quot; 三、增加/删除文件12345678# 添加指定文件到暂存区$ git add [file1] [file2] ... # 添加指定目录到暂存区，包括子目录$ git add [dir] # 添加当前目录的所有文件到暂存区$ git add . # 添加每个变化前，都会要求确认# 对于同一个文件的多处变化，可以实现分次提交$ git add -p # 删除工作区文件，并且将这次删除放入暂存区$ git rm [file1] [file2] ...# 停止追踪指定文件，但该文件会保留在工作区$ git rm --cached [file] # 改名文件，并且将这个改名放入暂存区$ git mv [file-original] [file-renamed] 四、代码提交1234567# 提交暂存区到仓库区$ git commit -m [message] # 提交暂存区的指定文件到仓库区$ git commit [file1] [file2] ... -m [message] # 提交工作区自上次commit之后的变化，直接到仓库区$ git commit -a # 提交时显示所有diff信息$ git commit -v # 使用一次新的commit，替代上一次提交# 如果代码没有任何新变化，则用来改写上一次commit的提交信息$ git commit --amend -m [message] # 重做上一次commit，并包括指定文件的新变化$ git commit --amend [file1] [file2] ... 五、分支1234567891011121314# 列出所有本地分支$ git branch # 列出所有远程分支$ git branch -r # 列出所有本地分支和远程分支$ git branch -a # 新建一个分支，但依然停留在当前分支$ git branch [branch-name] # 新建一个分支，并切换到该分支$ git checkout -b [branch] # 新建一个分支，指向指定commit$ git branch [branch] [commit] # 新建一个分支，与指定的远程分支建立追踪关系$ git branch --track [branch] [remote-branch] # 切换到指定分支，并更新工作区$ git checkout [branch-name] # 切换到上一个分支$ git checkout - # 建立追踪关系，在现有分支与指定的远程分支之间$ git branch --set-upstream [branch] [remote-branch] # 合并指定分支到当前分支$ git merge [branch] # 选择一个commit，合并进当前分支$ git cherry-pick [commit] # 删除分支$ git branch -d [branch-name] # 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch] 六、标签123456789# 列出所有tag$ git tag # 新建一个tag在当前commit$ git tag [tag] # 新建一个tag在指定commit$ git tag [tag] [commit] # 删除本地tag$ git tag -d [tag] # 删除远程tag$ git push origin :refs/tags/[tagName] # 查看tag信息$ git show [tag] # 提交指定tag$ git push [remote] [tag] # 提交所有tag$ git push [remote] --tags# 新建一个分支，指向某个tag$ git checkout -b [branch] [tag] 七、查看信息1234567891011121314151617181920# 显示有变更的文件$ git status # 显示当前分支的版本历史$ git log# 显示commit历史，以及每次commit发生变更的文件$ git log --stat # 搜索提交历史，根据关键词$ git log -S [keyword] # 显示某个commit之后的所有变动，每个commit占据一行$ git log [tag] HEAD --pretty=format:%s # 显示某个commit之后的所有变动，其&quot;提交说明&quot;必须符合搜索条件$ git log [tag] HEAD --grep feature # 显示某个文件的版本历史，包括文件改名$ git log --follow [file]$ git whatchanged [file] # 显示指定文件相关的每一次diff$ git log -p [file] # 显示过去5次提交$ git log -5 --pretty --oneline # 显示所有提交过的用户，按提交次数排序$ git shortlog -sn # 显示指定文件是什么人在什么时间修改过$ git blame [file] # 显示暂存区和工作区的差异$ git diff # 显示暂存区和上一个commit的差异$ git diff --cached [file] # 显示工作区与当前分支最新commit之间的差异$ git diff HEAD # 显示两次提交之间的差异$ git diff [first-branch]...[second-branch] # 显示今天你写了多少行代码$ git diff --shortstat &quot;@{0 day ago}&quot; # 显示某次提交的元数据和内容变化$ git show [commit]# 显示某次提交发生变化的文件$ git show --name-only [commit] # 显示某次提交时，某个文件的内容$ git show [commit]:[filename] # 显示当前分支的最近几次提交$ git reflog 八、远程同步12345678# 下载远程仓库的所有变动$ git fetch [remote] # 显示所有远程仓库$ git remote -v # 显示某个远程仓库的信息$ git remote show [remote] # 增加一个新的远程仓库，并命名$ git remote add [shortname] [url] # 取回远程仓库的变化，并与本地分支合并$ git pull [remote] [branch] # 上传本地指定分支到远程仓库$ git push [remote] [branch] # 强行推送当前分支到远程仓库，即使有冲突$ git push [remote] --force# 推送所有分支到远程仓库$ git push [remote] --all 九、撤销1234567891011# 恢复暂存区的指定文件到工作区$ git checkout [file] # 恢复某个commit的指定文件到暂存区和工作区$ git checkout [commit] [file] # 恢复暂存区的所有文件到工作区$ git checkout . # 重置暂存区的指定文件，与上一次commit保持一致，但工作区不变$ git reset [file] # 重置暂存区与工作区，与上一次commit保持一致$ git reset --hard # 重置当前分支的指针为指定commit，同时重置暂存区，但工作区不变$ git reset [commit] # 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致$ git reset --hard [commit] # 重置当前HEAD为指定commit，但保持暂存区和工作区不变$ git reset --keep [commit] # 新建一个commit，用来撤销指定commit# 后者的所有变化都将被前者抵消，并且应用到当前分支$ git revert [commit] # 暂时将未提交的变化移除，稍后再移入$ git stash$ git stash pop","link":"/2020/04/17/git/git%E4%BD%BF%E7%94%A8/"},{"title":"mysql基础知识","text":"一、查询操作查询语句执行顺序1234567891011(1)from (3)join (2)on (4)where (5)group by(开始使用select中的别名，后面的语句中都可以使用)(6)avg,sum.... (7)having (8)select (9)distinct (10)order by (10)limit 1、between…and… 用法SELECT * FROM sc where grade BETWEEN 10 and 20; not 用法 表示非 SELECT * FROM sc where not(grade &gt;=10 and grade &lt;=20) 等于号后面不能接查询语句 SELECT * from sc where grade=(SELECT …..) 错误的写法 SELECT * from sc where grade in (SELECT grade from sc) #in后面才能跟结果集 2、exists用法 和 not existsSELECT * FROM b WHERE not EXISTS(SELECT * from a where a.id=b.id); 每次执行一次外部查询 都会执行子查询（会引用外部查询的值）是否返回结果集 查询选修了 1006课程的学生SELECT sname from s where EXISTS(SELECT * from sc where s.sid=sc.sid and cid=’1006’) 查询选修了课程的学生SELECT sname from s where EXISTS(select * from sc WHERE s.sid=sc.sid)1 查询到 退出5 没查询到 查询选修了全部课程的学生SELECT sname from s where not EXISTS(select * from c where not exists(SELECT * from sc where s.sid=sc.sid and c.cid=sc.cid)) 相当于三个for循环嵌套，都匹配返回，不匹配往下循环查找1 1001 空1 1002 不为空1 1003 不为空….1 1006 空遍历完二层后结果集 整体有值则不会返回 1 4 1001 空4 1002 空4 1003 空4 1004 空4 1005 空4 1006 空遍历完二层后结果集 整体为空则会返回 1 3、时间处理 %a 缩写星期名 %b 缩写月名 %c 月，数值 %D 带有英文前缀的月中的天 %d 月的天，数值(00-31) %e 月的天，数值(0-31) %f 微秒 %H 小时 (00-23) %h 小时 (01-12) %I 小时 (01-12) %i 分钟，数值(00-59) %j 年的天 (001-366) %k 小时 (0-23) %l 小时 (1-12) %M 月名 %m 月，数值(00-12) %p AM 或 PM %r 时间，12-小时（hh:mm:ss AM 或 PM） %S 秒(00-59) %s 秒(00-59) %T 时间, 24-小时 (hh:mm:ss) %U 周 (00-53) 星期日是一周的第一天 %u 周 (00-53) 星期一是一周的第一天 %V 周 (01-53) 星期日是一周的第一天，与 %X 使用 %v 周 (01-53) 星期一是一周的第一天，与 %x 使用 %W 星期名 %w 周的天 （0=星期日, 6=星期六） %X 年，其中的星期日是周的第一天，4 位，与 %V 使用 %x 年，其中的星期一是周的第一天，4 位，与 %v 使用 %Y 年，4 位 %y 年，2 位 时间间隔单位 HOUR 小时 MINUTE 分 SECOND 秒 MICROSECOND 毫秒 YEAR 年 MONTH 月 DAY 日 WEEK 周 QUARTER 季 YEAR_MONTH 年和月 DAY_HOUR 日和小时 DAY_MINUTE 日和分钟 DAY_ SECOND 日和秒 HOUR_MINUTE 小时和分 HOUR_SECOND 小时和秒 MINUTE_SECOND 分钟和秒 查询当前日期 2019-05-28SELECT CURDATE() 查询当前时间 13:41:49SELECT CURTIME() 查询当前日期和时间 2019-05-28 13:42:29select sysdate() SELECT NOW();SELECT NOW()+0; #20190528141522 ######查询指定日期属于一年中的第几周 21SELECT week(“2019-05-28 13:42:29”) ######查询指定日期的 年份 2019SELECT YEAR(“2019-05-28 13:42:29”); ######查询指定日期的 月份 5SELECT MONTH(“2019-05-28 13:42:29”);SELECT MONTHNAME(“2019-05-28 13:42:29”); #月份 May ######查询指定日期的 号 28SELECT day(“2019-05-28 13:42:29”);SELECT HOUR(“2019-05-28 13:42:29”); #时 13SELECT minute(“2019-05-28 13:42:29”); #分 42SELECT SECOND(“2019-05-28 13:42:29”) #秒 29 ######格式化日期 2019/05/28 14:05:25SELECT DATE_FORMAT(now(),”%Y/%m/%d %H:%i:%s”) ######日期相隔的天数 第一个日期减第二个日期 (格式必须相同) 符合年月日规范SELECT DATEDIFF(“2019-08-01”,”1997-08-06”) #8030 ######时间相隔 第一个时间减第二个时间 (格式必须相同) 符合时分秒规范SELECT TIMEDIFF(“15:44:44”,”13:04:44”) ######给日期加上指定间隔 INTERVAL 10 YEAR 加十年######给日期减去指定间隔 INTERVAL -10 YEAR 减十年SELECT ADDDATE(“2019-05-28 13:42:29”,INTERVAL -10 SECOND)######给日期加上指定天数 只能加天数 负数表示减SELECT ADDDATE(“2019-05-28 13:42:29”,2); ######给指定日期时间SELECT ADDTIME(“2017-03-03 13:42:29”,”2 1:11:11”); #2017-03-05 14:53:40######加秒SELECT ADDTIME(‘23:59:59’, 55); ######直接对日期任何部分进行操作 加+10小时 -10表示减10小时SELECT “2019-05-28 13:42:29” + INTERVAL 10 SECOND######减10年SELECT “2019-05-28 13:42:29” + INTERVAL -10 year 4、case when ….then… end 用法SELECT stu.sid,stu.sname, max(case when cname=’语文’ then grade ELSE 0 END) as 语文, max(case when cname=’数学’ then grade else 0 END) as 数学, max(case when cname=’英语’ then grade else 0 END) as 英语, avg(grade) 平均分FROM stu LEFT JOIN cs on stu.sid=cs.sid GROUP BY stu.sid,stu.sname; sid sname 语文 数学 英语 平均分 1 张三 86 60 0 73.00002 李四 86 99 100 95.00003 王五 0 0 100 100.00004 赵六 0 96 0 96.00005 田七 0 0 0 查询每个学生的选课成绩 一个陷阱请注意： 在聚合函数中，只能为空或者为null或者只能为数字。 不能出现汉字和字符 否则会出错 select student.sno 学号, student.sname 姓名,max(case when cname=’数据库’ then grade else ‘’ end) as 数据库,max(case when cname=’数学’ then grade else ‘’ end) as 数学,max(case when cname=’信息系统’ then grade else ‘’ end) as 信息系统,max(case when cname=’操作系统’ then grade else ‘’ end) as 操作系统,max(case when cname=’数据结构’ then grade else ‘’ end) as 数据结构,max(case when cname=’数据处理’ then grade else ‘’ end) as 数据处理,max(case when cname=’PASCAL语言’ then grade else ‘’ end) as PASCAL语言from student LEFT JOIN(select * from sc NATURAL join course WHERE sc.cno=course.cno) s onstudent.sno=s.sno GROUP BY student.sno,student.sname; 5、limit和offset的用法1234语句1：select * from student limit 9,4语句2：slect * from student limit 4 offset 9// 语句1和2均返回表student的第10、11、12、13行//语句2中的4表示返回4行，9表示从表的第十行开始 6、ifnull的用法12ifnull(null,&quot;123&quot;); //第一个参数为null 输出123ifnull(&quot;456&quot;,&quot;789&quot;); //第一个参数不为null 输出456 7、mysql事务的使用 (定时执行) 批量插入例子： 123456789101112Begin start transaction; set @timenow=now(); #定义变量#批量插入 记得列之间要对应insert into 表1(column1,column2,……) select column1,column2,…… from 表2;update 表2.....delete 表3.....其他操作.... commit;end 8、some,all,any 的用法any/some:any 可以与=、&gt;、&gt;=、&lt;、&lt;=、&lt;&gt;结合起来使用，分别表示等于、大于、大于等于、小于、小于等于、不等于其中的任何一个数据即返回。 只要有sage小于其中sdept为IS条件的任何一个数据即返回 1select *from student where sage&lt; any(select sage from student where sdept='IS') and sdept&lt;&gt;'IS' all:all可以与=、&gt;、&gt;=、&lt;、&lt;=、&lt;&gt;结合是来使用，分别表示等于、大于、大于等于、小于、小于等于、不等于其中的所有数据。 只要sgae 小于select sage from student中的所有数据即返回 1select *from student where sage&lt;=all(select sage from student) 9、自然连接natural join去掉重复的列 course表： cno cname credit pcno sc表： sno cno grade 1select * from sc natural join course where .... cno sno grade cname credit pcno 10、upper(str) lower(str) ucase(str) lcase(str)12SELECT upper('chINese'), lower('chINese'); # CHINESE chineseSELECT ucase('chINese'), lcase('chINese'); # CHINESE chinese 11、datetime和timestamp区别1、占用空间 类型 占据字节 表示形式 datetime 8 字节 yyyy-mm-dd hh:mm:ss timestamp 4 字节 yyyy-mm-dd hh:mm:ss 2、表示范围 类型 表示范围 datetime ‘1000-01-01 00:00:00.000000’ to ‘9999-12-31 23:59:59.999999’ timestamp ‘1970-01-01 00:00:01.000000’ to ‘2038-01-19 03:14:07.999999’ 3、时区123timestamp 只占 4 个字节，而且是以utc的格式储存， 它会自动检索当前时区并进行转换。datetime以 8 个字节储存，不会进行时区的检索. 也就是说，对于timestamp来说，如果储存时的时区和检索时的时区不一样，那么拿出来的数据也不一样。对于datetime来说，存什么拿到的就是什么。 4、mysql自动处理的形式1234//下面都是 MySQL 允许的形式，MySQL 会自动处理2016-10-01 20:48:592016#10#01 20/48/5920161001204859 5、使用场景12345如果在时间上要超过Linux时间的，或者服务器时区不一样的就建议选择 datetime。如果是想要使用自动插入时间或者自动更新时间功能的，可以使用timestamp。如果只是想表示年、日期、时间的还可以使用 year、 date、 time，它们分别占据 1、3、3 字节，而datetime就是它们的集合。 6、根据当前时间戳更新当我们创建字段时，勾选根据当前时间戳更新 时，字段类型为datatime或者timestamp 类型时。 修改(只有更新)数据时会自动更新该字段为当前系统时间 12、is not null, is null , &lt;&gt; ,!=12345678910在mysql中，筛选非空的时候经常会用到is not null和!=null，这两种方法单从字面上来看感觉是差不多的，其实如果去运行一下试试的话差别会很大！为什么会出现这种情况呢？null 表示什么也不是， 不能=、&gt;、&lt; … 所有的判断，结果都是false，所有只能用 is null进行判断。默认情况下，推荐使用 IS NOT NULL去判断，因为SQL默认情况下对！= Null的判断会永远返回0行，但没有语法错误。如果你一定想要使用！= Null来判断，需要加上这个语句：set ANSI_NULLS off这时你会发现IS NOT NULL 和 != null 是等效的一个字段如果设为“NULL”，表示如果这个字段的值为空时，自动插入一个“NULL”值。一个字段如果设为“NOT NULL”，表示如果这个字段的值为空时，不自动插入“NULL”值（任其无值）。所以，设为“NULL”的意思反而是“不能无值”（由MYSQL自动赋“NULL”值），而设为“NOT NULL”是“可以无值” 13、decimal(P,D) P是表示有效数字数(从左边第一个非0开始)的精度。 P范围为1〜65。 D是表示小数点后的位数。 D的范围是0~30。MySQL要求D小于或等于(&lt;=)P。 12amount ``DECIMAL``(6,2); amount列最多可以存储6位数字，小数位数为2位; 因此，amount列的范围是从-9999.99到9999.99。 1column_name DECIMAL(P) 等于 column_name DECIMAL(P,0); 在这种情况下，列不包含小数部分或小数点。 1column_name DECIMAL; 在这种情况下，P的默认值为10。 注意：当数值在其取值范围之内，小数位多了，则四舍五入后直接截断多出的小数位。 若数值在其取值范围之外，则直接报Out of range value错误。 14、decimal与之java中对应的BigDecimal一、构造BigDecimal 对象常用方法 123BigDecimal BigDecimal(double d); //不允许使用BigDecimal BigDecimal(String s); //常用,推荐使用static BigDecimal valueOf(double d); //常用,推荐使用 二、常用方法该对象进行操作会生成新的对象 123BigDecimal decimal=new BigDecimal(\"23.23123\");BigDecimal add = decimal.add(new BigDecimal(\"23123.11\"));System.out.println(add); 注意 1. double 参数的构造方法,不允许使用!!!!因为它不能精确的得到相应的值，值会变大; 2. String 构造方法是完全可预知的: 写入 new BigDecimal(“0.1”) 将创建一个 BigDecimal,它正好等于预期的0.1; 因此,通常建议优先使用 String 构造方法; 3. 静态方法 valueOf(double val) 内部实现,仍是将 double 类型转为 String 类型; 这通常是将 double(或float)转化为 BigDecimal 的首选方法; 15、concat的使用连接多个字符串的作用 concat(str1,str2,str3…..) 1concat('%',\"张三\",'%') 一般得到模糊查询的作用 1%张三% 16、union和union all区别列名的要相同 123select * from Table1 union #去除重复select * from Table2 123select * from Table1 union all #不会去除重复select * from Table2 17、replace into 有则更新，无则新增replace into表示插入替换数据，需求表中有PrimaryKey，或者unique索引，如果数据库已经存在数据，则用新数据替换，如果没有数据效果则和insert into一样； 1.如果发现表中已经有此行数据（根据主键或者唯一索引判断）则先删除此行数据，然后插入新的数据。 2. 否则，直接插入新数据。 https://www.jb51.net/article/158125.htm 1replace into tbl_name(col_name, ...) values(...) 相当于： 1if not exists (select 1 from t where id = 1) insert into t(id, update_time) values(1, getdate()) else update t set update_time = getdate() where id = 1； 关于执行影响的行数： ①：假如表中的一个旧记录与一个用于PRIMARY KEY或一个UNIQUE索引的新记录具有相同的值，则在新记录被插入之前，旧记录被删除。 返回影响行数2 ②：假如不存在即没有与一个用于PRIMARY KEY或一个UNIQUE索引的新记录具有相同的值，即直接插入，此时相当于一个普通插入操作。 返回影响行数1 18、xml中大于小于号的表示 &amp;lt; &lt; 小于号 &amp;gt; &gt; 大于号 &amp;amp; &amp; 和 &amp;apos; ‘ 单引号 &amp;quot; “ 双引号 还有一种方法是将判断条件放到一个声明中，即 例如： AND = #{startTime,jdbcType=DATE} ]]> AND","link":"/2020/04/17/sql/Mysql/"},{"title":"SpringBoot整合SpringSecurity","text":"SpringBoot整合SpringSecurity一、SpringSecurity初体验Spring Security 是 Spring 家族中的一个安全管理框架，实际上，在 Spring Boot 出现之前，Spring Security 就已经发展了多年了，但是使用的并不多，安全管理这个领域，一直是 Shiro 的天下。 相对于 Shiro，在 SSM/SSH 中整合 Spring Security 都是比较麻烦的操作，所以，Spring Security 虽然功能比 Shiro 强大，但是使用反而没有 Shiro 多（Shiro 虽然功能没有 Spring Security 多，但是对于大部分项目而言，Shiro 也够用了）。 自从有了 Spring Boot 之后，Spring Boot 对于 Spring Security 提供了 自动化配置方案，可以零配置使用 Spring Security。 因此，一般来说，常见的安全管理技术栈的组合是这样的： SSM + Shiro Spring Boot/Spring Cloud + Spring Security 注意，这只是一个推荐的组合而已，如果单纯从技术上来说，无论怎么组合，都是可以运行的。 1、pom.xmlspring-boot-starter-security 12345678910111213141516171819202122&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2、controller12345678@RestControllerpublic class UserController { @GetMapping(\"/hello\") public String hello(){ return \"hello lc\"; }} 3、默认进入security登录页面在SpringSecurity中，已经对所有接口进行保护。所以首次请求时需要用户名和密码 ，密码由springSecurity动态生成。 用户名： user 密码： Using generated security password: 14404948-b30c-4cf3-8d02-cbb79779ffab 二、 手动配置用户名密码任选其一即可 在我们的yaml配置中，我们的面不需要加密 1、yaml配置用户名密码123456789spring: security: user:# 配置用户名 name: louchen# 配置密码 password: 你的密码# 配置角色 roles: admin 2、配置文件配置用户名密码123456789101112131415161718192021222324@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter {// spring5开始 security中使用配置文件的设置用户密码的必须要加密// 所有这里我们设置密码不加密// 配置密码编码器 @Bean PasswordEncoder passwordEncoder() {// 此方法已过期（这里我们只是测试实验） return NoOpPasswordEncoder.getInstance(); }// 认证管理 @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception {// 在内存中的认证 auth.inMemoryAuthentication()// 设置多个用户名,密码,角色 .withUser(\"lc\").password(\"123456\").roles(\"admin\") .and() .withUser(\"zs\").password(\"123\").roles(\"user\"); }} 三、配置HttpSecurity(拦截规则)1、基本配置①、controller12345678910111213141516171819@RestControllerpublic class UserController { @GetMapping(\"/hello\") public String hello(){ return \"hello lc\"; } @GetMapping(\"/admin/hello\") public String admin(){ return \"hello admin\"; } @GetMapping(\"/user/hello\") public String user(){ return \"hello user\"; }} ②、securityConfig12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter {// spring5开始 security中使用配置文件的设置用户密码的必须要加密// 所有这里我们设置密码不加密// 配置密码编码器 @Bean PasswordEncoder passwordEncoder() {// 此方法已过期（这里我们只是测试实验） return NoOpPasswordEncoder.getInstance(); }// 认证管理 @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception {// 在内存中的认证 auth.inMemoryAuthentication()// 设置多个用户名,密码,角色 .withUser(\"lc\").password(\"123456\").roles(\"admin\") .and() .withUser(\"zs\").password(\"123\").roles(\"user\"); } @Override protected void configure(HttpSecurity http) throws Exception {// 开启授权请求 http.authorizeRequests()// 路径匹配 满足/admin/**路径的 必须要有admin角色 .antMatchers(\"/admin/**\").hasRole(\"admin\")// 路径匹配 满足/user/**路径的 必须要有其中的一个角色即可访问// .antMatchers(\"/user/**\").hasAnyRole(\"admin\",\"user\")// 另一种写法==&gt; 必须要有其中的一个角色即可访问 .antMatchers(\"/user/**\").access(\"hasAnyRole('admin','user')\")// 路径匹配 满足/manager/**路径规则的 必须要同时拥有admin和manager角色 .antMatchers(\"/manager/**\").access(\"hasRole('admin') and hasRole('manager')\")// 其他的请求只要认证即可访问 .anyRequest().authenticated() .and()// 开启表单登录 .formLogin() //处理表单登录的路径 //通过该路径登录的用户名和密码再去请求接口就不会有登录页面的出现,若直接走其他接口则会进入登录页面 //注意这里为post请求 .loginProcessingUrl(\"/doLogin\")// 跟登录有关的接口 直接运行访问 .permitAll() .and()// 关闭crsf攻击（跨站请求伪造）,便于我们测试 .csrf().disable(); }} 2、登录表单的详细配置①、Usercontroller1234567891011121314151617181920212223@RestControllerpublic class UserController {// 登录即可访问 @GetMapping(\"/hello\") public String hello(){ return \"hello lc\"; }// 模拟admin接口 @GetMapping(\"/admin/hello\") public String admin(){ return \"hello admin\"; }// 模拟user接口 @GetMapping(\"/user/hello\") public String user(){ return \"hello user\"; } } ②、LoginController1234//若前后端不分离，设置默认登录成功的路径 我们只需要跳转到主页连接即可(注意:这里的请求只支持post)// .successForwardUrl(\"/index111\")// 若前后端不分离 设置默认登录成功的路径 我们只需要跳转到主页链接即可（注意：这里的请求只支持get）// .defaultSuccessUrl(\"/index111\",true) 123456789101112131415@Controllerpublic class LoginController { //模拟登录成功后跳转的页面 @GetMapping(\"/index111\") public String toIndex() { return \"index11\"; }// 模拟登录的页面 @GetMapping(\"/login\") public String logon() { return \"login\"; }} ③、登录页login.html12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;登录&lt;/h1&gt;&lt;form action=\"/doLogin\" method=\"post\"&gt; &lt;div&gt; 用户名:&lt;input type=\"text\" name=\"uname\" placeholder=\"请输入用户名\"&gt;&lt;/div&gt; &lt;div&gt; 密码:&lt;input type=\"text\" name=\"passwd\" placeholder=\"请输入密码\"&gt;&lt;/div&gt; &lt;div&gt;&lt;input type=\"submit\" value=\"登录\"&gt;&lt;/div&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; ④、主页index11.html12345678910&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;主页！！！！&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; ③、SecurityConfig123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter {// spring5开始 security中使用配置文件的设置用户密码的必须要加密// 所有这里我们设置密码不加密// 配置密码编码器 @Bean PasswordEncoder passwordEncoder() {// 此方法已过期（这里我们只是测试实验） return NoOpPasswordEncoder.getInstance(); }// 认证管理 @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception {// 在内存中的认证 auth.inMemoryAuthentication()// 设置多个用户名,密码,角色 .withUser(\"lc\").password(\"123456\").roles(\"admin\") .and() .withUser(\"zs\").password(\"123\").roles(\"user\"); } @Override protected void configure(HttpSecurity http) throws Exception {// 开启授权请求 http.authorizeRequests()// 路径匹配 满足/admin/**路径的 必须要有admin角色 .antMatchers(\"/admin/**\").hasRole(\"admin\")// 路径匹配 满足/user/**路径的 必须要有其中的一个角色即可访问// .antMatchers(\"/user/**\").hasAnyRole(\"admin\",\"user\")// 另一种写法==&gt; 必须要有其中的一个角色即可访问 .antMatchers(\"/user/**\").access(\"hasAnyRole('admin','user')\")// 路径匹配 满足/manager/**路径规则的 必须要同时拥有admin和manager角色 .antMatchers(\"/manager/**\").access(\"hasRole('admin') and hasRole('manager')\")// 其他的请求只要认证即可访问 .anyRequest().authenticated() .and()// 开启表单登录 .formLogin() //处理表单登录的路径 //通过该路径登录的用户名和密码再去请求接口就不会有登录页面的出现,若直接走其他接口则会进入登录页面 //注意这里为post请求 .loginProcessingUrl(\"/doLogin\")// 自定义跳转到的登录页的路径（默认登录页失效）// 在前后端分离的情况下 我们只需要返回json即可 .loginPage(\"/login\")// 设置自定义的登录的用户名的key的名称 .usernameParameter(\"uname\")// 设置自定义的登录的密码的key的名称 .passwordParameter(\"passwd\")// 若前后端不分离，设置默认登录成功的路径 我们只需要跳转到主页连接即可(注意:这里的请求只支持post)// .successForwardUrl(\"/index111\")// 若前后端不分离 设置默认登录成功的路径 我们只需要跳转到主页链接即可（注意：这里的请求只支持get）// .defaultSuccessUrl(\"/index111\",true)// 登录成功的的自定义处理// 若前后端分离 则我们只需要处理是否登录成功返回相应的json即可 .successHandler(new AuthenticationSuccessHandler() {// Authentication用户登录的信息 @Override public void onAuthenticationSuccess(HttpServletRequest req, HttpServletResponse res, Authentication authentication) throws IOException, ServletException {// 设置响应头类型 res.setContentType(\"application/json;charset=utf-8\");// 获取打印输出流 PrintWriter printWriter=res.getWriter();// 响应自定义的数据 Map&lt;String,Object&gt; map=new HashMap&lt;&gt;();// 自定义状态码 map.put(\"status\", 200);// 登录的信息// map.put(\"msg\", authentication.getPrincipal()); //\"msg\": { // \"password\": null, // \"username\": \"lc\", // \"authorities\": [ // { // \"authority\": \"ROLE_admin\" // } // ], // \"accountNonExpired\": true, // \"accountNonLocked\": true, // \"credentialsNonExpired\": true, // \"enabled\": true // },// map.put(\"msg1\", authentication.getDetails()); // \"msg1\": { // \"remoteAddress\": \"0:0:0:0:0:0:0:1\", // \"sessionId\": null // },// map.put(\"msg2\", authentication.getAuthorities()); // \"msg2\": [ // { // \"authority\": \"ROLE_admin\" // } // ],// map.put(\"msg3\", authentication.getCredentials()); //\"msg3\": null,// map.put(\"msg4\", authentication.isAuthenticated()); //\"msg4\": true,// 将map转为json字符串 printWriter.write(new ObjectMapper().writeValueAsString(map)); printWriter.flush(); printWriter.close(); } })// 同理，前后端不分离进入登录失败的处理路径（支持post）// .failureForwardUrl(\"/error\")// 前后端分离 进入登录失败的自定义处理 .failureHandler(new AuthenticationFailureHandler() {// AuthenticationException 验证异常的信息 @Override public void onAuthenticationFailure(HttpServletRequest req, HttpServletResponse res, AuthenticationException e) throws IOException, ServletException {// 设置响应头类型 res.setContentType(\"application/json;charset=utf-8\");// 获取打印输出流 PrintWriter printWriter=res.getWriter();// 响应自定义的数据 Map&lt;String,Object&gt; map=new HashMap&lt;&gt;();// 自定义状态码 map.put(\"status\", 401);// 找到错误的类型 设置错误信息// Credentials 证书 凭证 if(e instanceof LockedException){ map.put(\"msg\", \"账户被锁定，登录失败\"); }else if(e instanceof BadCredentialsException){ map.put(\"msg\", \"用户名或密码输入错误，登录失败！\"); }else if(e instanceof DisabledException){ map.put(\"msg\", \"账号被禁用，登录失败！\"); }else if(e instanceof AccountExpiredException){ map.put(\"msg\", \"账户过期，登录失败！\"); }else if(e instanceof CredentialsExpiredException){ map.put(\"msg\", \"密码过期，登录失败！\"); }else{ map.put(\"msg\", \"登录失败！\"); }// 将map转为json字符串 printWriter.write(new ObjectMapper().writeValueAsString(map)); printWriter.flush(); printWriter.close(); } })// 跟登录有关的接口 直接运行访问 .permitAll() .and()// 关闭crsf攻击（跨站请求伪造）,便于我们测试 .csrf().disable(); }} 3、注销登录配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter {// spring5开始 security中使用配置文件的设置用户密码的必须要加密// 所有这里我们设置密码不加密// 配置密码编码器 @Bean PasswordEncoder passwordEncoder() {// 此方法已过期（这里我们只是测试实验） return NoOpPasswordEncoder.getInstance(); }// 认证管理 @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception {// 在内存中的认证 auth.inMemoryAuthentication()// 设置多个用户名,密码,角色 .withUser(\"lc\").password(\"123456\").roles(\"admin\") .and() .withUser(\"zs\").password(\"123\").roles(\"user\"); } @Override protected void configure(HttpSecurity http) throws Exception {// 开启授权请求 http.authorizeRequests()// 路径匹配 满足/admin/**路径的 必须要有admin角色 .antMatchers(\"/admin/**\").hasRole(\"admin\")// 路径匹配 满足/user/**路径的 必须要有其中的一个角色即可访问// .antMatchers(\"/user/**\").hasAnyRole(\"admin\",\"user\")// 另一种写法==&gt; 必须要有其中的一个角色即可访问 .antMatchers(\"/user/**\").access(\"hasAnyRole('admin','user')\")// 路径匹配 满足/manager/**路径规则的 必须要同时拥有admin和manager角色 .antMatchers(\"/manager/**\").access(\"hasRole('admin') and hasRole('manager')\")// 其他的请求只要认证即可访问 .anyRequest().authenticated() .and()// 开启表单登录 .formLogin() //处理表单登录的路径 //通过该路径登录的用户名和密码再去请求接口就不会有登录页面的出现,若直接走其他接口则会进入登录页面 //注意这里为post请求 .loginProcessingUrl(\"/doLogin\")// 自定义跳转到的登录页的路径（默认登录页失效）// 在前后端分离的情况下 我们只需要返回json即可 .loginPage(\"/login\")// 设置自定义的登录的用户名的key的名称 .usernameParameter(\"uname\")// 设置自定义的登录的密码的key的名称 .passwordParameter(\"passwd\")// 若前后端不分离，设置默认登录成功的路径 我们只需要跳转到主页连接即可(注意:这里的请求只支持post)// .successForwardUrl(\"/index111\")// 若前后端不分离 设置默认登录成功的路径 我们只需要跳转到主页链接即可（注意：这里的请求只支持get）// .defaultSuccessUrl(\"/index111\",true)// 登录成功的的自定义处理// 若前后端分离 则我们只需要处理是否登录成功返回相应的json即可 .successHandler(new AuthenticationSuccessHandler() {// Authentication报错用户登录的信息 @Override public void onAuthenticationSuccess(HttpServletRequest req, HttpServletResponse res, Authentication authentication) throws IOException, ServletException {// 设置响应头类型 res.setContentType(\"application/json;charset=utf-8\");// 获取打印输出流 PrintWriter printWriter=res.getWriter();// 响应自定义的数据 Map&lt;String,Object&gt; map=new HashMap&lt;&gt;();// 自定义状态码 map.put(\"status\", 200);// 登录的信息 map.put(\"msg\", authentication.getPrincipal()); //\"msg\": { // \"password\": null, // \"username\": \"lc\", // \"authorities\": [ // { // \"authority\": \"ROLE_admin\" // } // ], // \"accountNonExpired\": true, // \"accountNonLocked\": true, // \"credentialsNonExpired\": true, // \"enabled\": true // },// map.put(\"msg1\", authentication.getDetails()); // \"msg1\": { // \"remoteAddress\": \"0:0:0:0:0:0:0:1\", // \"sessionId\": null // },// map.put(\"msg2\", authentication.getAuthorities()); // \"msg2\": [ // { // \"authority\": \"ROLE_admin\" // } // ],// map.put(\"msg3\", authentication.getCredentials()); //\"msg3\": null,// map.put(\"msg4\", authentication.isAuthenticated()); //\"msg4\": true,// 将map转为json字符串 printWriter.write(new ObjectMapper().writeValueAsString(map)); printWriter.flush(); printWriter.close(); } })// 同理，前后端不分离进入登录失败的处理路径（支持post）// .failureForwardUrl(\"/error\")// 前后端分离 进入登录失败的自定义处理 .failureHandler(new AuthenticationFailureHandler() {// AuthenticationException 验证异常的信息 @Override public void onAuthenticationFailure(HttpServletRequest req, HttpServletResponse res, AuthenticationException e) throws IOException, ServletException {// 设置响应头类型 res.setContentType(\"application/json;charset=utf-8\");// 获取打印输出流 PrintWriter printWriter=res.getWriter();// 响应自定义的数据 Map&lt;String,Object&gt; map=new HashMap&lt;&gt;();// 自定义状态码 map.put(\"status\", 401);// 找到错误的类型 设置错误信息// Credentials 证书 凭证 if(e instanceof LockedException){ map.put(\"msg\", \"账户被锁定，登录失败\"); }else if(e instanceof BadCredentialsException){ map.put(\"msg\", \"用户名或密码输入错误，登录失败！\"); }else if(e instanceof DisabledException){ map.put(\"msg\", \"账号被禁用，登录失败！\"); }else if(e instanceof AccountExpiredException){ map.put(\"msg\", \"账户过期，登录失败！\"); }else if(e instanceof CredentialsExpiredException){ map.put(\"msg\", \"密码过期，登录失败！\"); }else{ map.put(\"msg\", \"登录失败！\"); }// 将map转为json字符串 printWriter.write(new ObjectMapper().writeValueAsString(map)); printWriter.flush(); printWriter.close(); } })// 跟登录有关的接口 直接运行访问 .permitAll() .and() .logout()// 定义注销的路径 .logoutUrl(\"/logout\")// 自定义注销的处理 .logoutSuccessHandler(new LogoutSuccessHandler() {// authentication 登录用户的信息 @Override public void onLogoutSuccess(HttpServletRequest req, HttpServletResponse res, Authentication authentication) throws IOException, ServletException { // 设置响应头类型 res.setContentType(\"application/json;charset=utf-8\");// 获取打印输出流 PrintWriter printWriter=res.getWriter();// 响应自定义的数据 Map&lt;String,Object&gt; map=new HashMap&lt;&gt;();// 自定义状态码 map.put(\"status\", 200); map.put(\"msg\", \"注销登录成功！\");// 将map转为json字符串 printWriter.write(new ObjectMapper().writeValueAsString(map)); printWriter.flush(); printWriter.close(); } }) .and()// 关闭crsf攻击（跨站请求伪造）,便于我们测试 .csrf().disable(); }} 三、多个httpSecurity配置1、controller123456789101112131415161718192021@RestControllerpublic class UserController {// 登录即可访问 @GetMapping(\"/hello\") public String hello(){ return \"hello lc\"; }// 模拟admin接口 @GetMapping(\"/admin/hello\") public String admin(){ return \"hello admin\"; }// 模拟user接口 @GetMapping(\"/user/hello\") public String user(){ return \"hello user\"; }} 2、SecurityConfig注意： httpSecurity.antMatcher(&quot;/admin/**&quot;).authorizeRequests().anyRequest().hasRole(&quot;admin&quot;) 只是对/admin/\\的形式的路径进行拦截，而不是所有路径** 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Configurationpublic class MultipleHttpSecurity { @Bean PasswordEncoder passwordEncoder() { return NoOpPasswordEncoder.getInstance(); } /** * 认证管理 * @param auth 这里相当于注入 AuthenticationManagerBuilder对象 * @throws Exception */ @Autowired protected void configure(AuthenticationManagerBuilder auth) throws Exception {// 在内存中的认证 auth.inMemoryAuthentication()// 设置多个用户名,密码,角色 .withUser(\"lc\").password(\"111\").roles(\"admin\") .and() .withUser(\"zs\").password(\"222\").roles(\"user\"); } @Configuration// 数字越小优先级越高 @Order(1) public static class AdminSecurityConfig extends WebSecurityConfigurerAdapter{ @Override protected void configure(HttpSecurity httpSecurity) throws Exception {// 表示当前httpsecurity只拦截 /admin/** 路径，并且需要admin角色 httpSecurity.antMatcher(\"/admin/**\").authorizeRequests().anyRequest().hasRole(\"admin\"); } } @Configuration public static class OtherSecurityConfig extends WebSecurityConfigurerAdapter{ @Override protected void configure(HttpSecurity httpSecurity) throws Exception {// 开启授权请求，所有的请求都需要认证即可访问// 这里经过上面的admin的请求后 再拦截其他的所有请求 httpSecurity.authorizeRequests().anyRequest().authenticated() .and() .formLogin() .loginProcessingUrl(\"/doLogin\") .permitAll() .and() .csrf().disable(); } } } 四、BCryptPasswordEncoder密码加密​ spring security中的BCryptPasswordEncoder方法采用SHA-256 +随机盐+密钥对密码进行加密。SHA系列是Hash算法，不是加密算法，使用加密算法意味着可以解密（这个与编码/解码一样），但是采用Hash处理，其过程是不可逆的。 （1）加密(encode)：注册用户时，使用SHA-256+随机盐+密钥把用户输入的密码进行hash处理，得到密码的hash值，然后将其存入数据库中。 （2）密码匹配(matches)：用户登录时，密码匹配阶段并没有进行密码解密（因为密码经过Hash处理，是不可逆的），而是使用相同的算法把用户输入的密码进行hash处理，得到密码的hash值，然后将其与从数据库中查询到的密码hash值进行比较。如果两者相同，说明用户输入的密码正确。 这正是为什么处理密码时要用hash算法，而不用加密算法。因为这样处理即使数据库泄漏，黑客也很难破解密码（破解密码只能用彩虹表）。 12345678910111213141516171819202122232425262728293031@SpringBootTestclass JpaRestApplicationTests { @Test void Test1(){// 可定义循环迭代的强度（默认为10） BCryptPasswordEncoder bCryptPasswordEncoder=new BCryptPasswordEncoder(); String encode=\"\"; for (int i = 0; i &lt; 10; i++) { //加密 encode = bCryptPasswordEncoder.encode(\"111\"); System.out.println(encode); }// 解密// 验证加密的和原密码是否匹配 boolean matches = bCryptPasswordEncoder.matches(\"111\", encode); System.out.println(matches); // 我们可以看到每次加密的密码都不一致 //$2a$10$4f0bp6uBiLdt2mfZcL4ITuolV7C1wNSAvmC5DCkQQ/wIbf0N4aiYu //$2a$10$3J7jUw/4d5tIJc.36e/SMOf3g3SWjFwYnBnc5q90F9jsHkbbfrbWO //$2a$10$oDbDEQonfNF3VccU9rw2u.PCEYgPz7sdEA/Zk3vlhq7nnA6zFptUq //$2a$10$h5mGJ1JleyKqJ0cXThgiv.D6tXWtsJovWCGn3lRC2VKzyHWBrrnSS //$2a$10$005mvGASGZVRgNzm2upYsOXTCgwZPhxhHsJQM50DFE9PTW0GR3hY. //$2a$10$gVbxdtiMstQESB0/EBbZq.4rPWHpgq20AUK.Jlq4xUE.g3jPGa5Mq //$2a$10$HWUDxz8SZYorijp05yeJH.JdkF8Jm.y2/rVnAXEXObprxeBWZYRfa //$2a$10$rpslaqYmHY9VCXY6U94nNO69rzwU34vDDFudW/APYFgLb3oVeVNu6 //$2a$10$7o41f4IV/uNwPmDKd4Rl/ehdPY5FT5uCvt1aofXwqwWTdkOQK/9L. //$2a$10$6NfXSvvKtzpgdjskRhoiMeqq9xTaWsCS7FdDr/I1I3Iy4IeT0tuta } 修改securityconfig配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152@Configurationpublic class MultipleHttpSecurity {// 这里我们使用BCryptPasswordEncoder加密 @Bean PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); } /** * 认证管理 * @param auth 这里相当于注入 AuthenticationManagerBuilder对象 * @throws Exception */ @Autowired protected void configure(AuthenticationManagerBuilder auth) throws Exception {// 在内存中的认证 auth.inMemoryAuthentication()// 设置多个用户名,密码,角色 .withUser(\"lc\").password(\"111\").roles(\"admin\") .and() .withUser(\"zs\").password(\"$2a$10$4f0bp6uBiLdt2mfZcL4ITuolV7C1wNSAvmC5DCkQQ/wIbf0N4aiYu\").roles(\"user\"); } @Configuration// 数字越小优先级越高 @Order(1) public static class AdminSecurityConfig extends WebSecurityConfigurerAdapter{ @Override protected void configure(HttpSecurity httpSecurity) throws Exception {// 表示当前httpsecurity只拦截 /admin/** 路径，并且需要admin角色 httpSecurity.antMatcher(\"/admin/**\").authorizeRequests().anyRequest().hasRole(\"admin\"); } } @Configuration public static class OtherSecurityConfig extends WebSecurityConfigurerAdapter{ @Override protected void configure(HttpSecurity httpSecurity) throws Exception {// 开启授权请求，所有的请求都需要认证即可访问// 这里经过上面的admin的请求后 再拦截其他的所有请求 httpSecurity.authorizeRequests().anyRequest().authenticated() .and() .formLogin() .loginProcessingUrl(\"/doLogin\") .permitAll() .and() .csrf().disable(); } }} 五、方法安全管控1、注解详解​ spring security默认禁用注解，要想开启注解，需要在继承WebSecurityConfigurerAdapter的类上加@EnableGlobalMethodSecurity注解，并在该类中将AuthenticationManager定义为bean。 这里springSecurity默认禁用所有方法保护的注解@EnableGlobalMethodSecurity(prePostEnabled = true,securedEnabled = true) prePostEnabled开启 @PreAuthorize和@PostAuthorize 注解securedEnabled 开启@Secured注解 @EnableGlobalMethodSecurity启用注解1、@PreAuthorize在方法执行前判断，可以调用方法参数，主要利用Java8的参数名反射特性，如果没用Java8也可以使用spring security的@P标注参数，或者Spring Data的@Param标注参数。 123//判断用户是否为当前登录用户或拥有ROLE_ADMIN权限@PreAuthorize(\"#userId == authentication.principal.userId or hasAuthority(‘ADMIN’)\")public void changePassword(@P(\"userId\") long userId ){} 2、@PostAuthorize在方法执行后判断，可以调用参数。如果EL为false，虽然方法已经执行完了也可能会回滚，EL变量returnObject表示返回的对象。 3、@Secured只支持字符串形式,且必须要加上前缀ROLE_ 是否有权限访问 2、基本配置①、securityConfig1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556@Configuration//这里springSecurity默认禁用所有方法保护的注解//prePostEnabled开启 @PreAuthorize和@PostAuthorize 注解//securedEnabled 开启@Secured注解@EnableGlobalMethodSecurity(prePostEnabled = true,securedEnabled = true)public class MultipleHttpSecurity {// 这里我们使用BCryptPasswordEncoder加密 @Bean PasswordEncoder passwordEncoder() { return new BCryptPasswordEncoder(); } /** * 认证管理 * @param auth 这里相当于注入 AuthenticationManagerBuilder对象 * @throws Exception */ @Autowired protected void configure(AuthenticationManagerBuilder auth) throws Exception {// 在内存中的认证 auth.inMemoryAuthentication()// 设置多个用户名,密码,角色 .withUser(\"lc\").password(\"$2a$10$4f0bp6uBiLdt2mfZcL4ITuolV7C1wNSAvmC5DCkQQ/wIbf0N4aiYu\").roles(\"admin\") .and() .withUser(\"zs\").password(\"$2a$10$4f0bp6uBiLdt2mfZcL4ITuolV7C1wNSAvmC5DCkQQ/wIbf0N4aiYu\").roles(\"user\"); } @Configuration// 数字越小优先级越高 @Order(1) public static class AdminSecurityConfig extends WebSecurityConfigurerAdapter{ @Override protected void configure(HttpSecurity httpSecurity) throws Exception {// 表示当前httpsecurity只拦截 /admin/** 路径，并且需要admin角色 httpSecurity.antMatcher(\"/admin/**\").authorizeRequests().anyRequest().hasRole(\"admin\"); } } @Configuration public static class OtherSecurityConfig extends WebSecurityConfigurerAdapter{ @Override protected void configure(HttpSecurity httpSecurity) throws Exception {// 开启授权请求，所有的请求都需要认证即可访问// 这里经过上面的admin的请求后 再拦截其他的所有请求 httpSecurity.authorizeRequests().anyRequest().authenticated() .and() .formLogin() .loginProcessingUrl(\"/doLogin\") .permitAll() .and() .csrf().disable(); } }} ②、userService123456789101112131415161718192021222324252627282930313233@Servicepublic class UserService { /** * 方法进入前 验证是否有admin角色 * @return */ @PreAuthorize(\"hasRole('admin')\") //同时要有admin和user角色// @PreAuthorize(\"hasRole('admin') and hasRole('user')\") public String admin() { return \"hello admin\"; } /** * 是否有user角色 * @return */ @Secured(\"ROLE_user\") public String user() { return \"hello user\"; } /** * 方法进入前 验证是否有admin或者user角色 * @return */ @PreAuthorize(\"hasAnyRole('admin','user')\") public String hello(){ return \"hello evenyone\"; }} ③、controller123456789101112131415161718@RestControllerpublic class UserController {// 登录即可访问 @GetMapping(\"/hello\") public String hello(){ return \"hello lc\"; }// 模拟admin接口 @GetMapping(\"/admin/hello\") public String admin(){ return \"hello admin\"; }// 模拟user上接口 @GetMapping(\"/user/hello\") public String user(){ return \"hello user\"; }} 六、基于数据库的认证1、sql1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859SET FOREIGN_KEY_CHECKS=0;-- ------------------------------ Table structure for role-- ----------------------------DROP TABLE IF EXISTS `role`;CREATE TABLE `role` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(32) DEFAULT NULL, `nameZh` varchar(32) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;-- ------------------------------ Records of role-- ----------------------------INSERT INTO `role` VALUES ('1', 'dba', '数据库管理员');INSERT INTO `role` VALUES ('2', 'admin', '系统管理员');INSERT INTO `role` VALUES ('3', 'user', '用户');-- ------------------------------ Table structure for user-- ----------------------------DROP TABLE IF EXISTS `user`;CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(32) DEFAULT NULL, `password` varchar(255) DEFAULT NULL, `enabled` tinyint(1) DEFAULT NULL, `locked` tinyint(1) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;-- ------------------------------ Records of user 密码123-- ----------------------------INSERT INTO `user` VALUES ('1', 'root', '$2a$10$RMuFXGQ5AtH4wOvkUqyvuecpqUSeoxZYqilXzbz50dceRsga.WYiq', '1', '0');INSERT INTO `user` VALUES ('2', 'admin', '$2a$10$RMuFXGQ5AtH4wOvkUqyvuecpqUSeoxZYqilXzbz50dceRsga.WYiq', '1', '0');INSERT INTO `user` VALUES ('3', 'sang', '$2a$10$RMuFXGQ5AtH4wOvkUqyvuecpqUSeoxZYqilXzbz50dceRsga.WYiq', '1', '0');-- ------------------------------ Table structure for user_role-- ----------------------------DROP TABLE IF EXISTS `user_role`;CREATE TABLE `user_role` ( `id` int(11) NOT NULL AUTO_INCREMENT, `uid` int(11) DEFAULT NULL, `rid` int(11) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;-- ------------------------------ Records of user_role-- ----------------------------INSERT INTO `user_role` VALUES ('1', '1', '1');INSERT INTO `user_role` VALUES ('2', '1', '2');INSERT INTO `user_role` VALUES ('3', '2', '2');INSERT INTO `user_role` VALUES ('4', '3', '3');SET FOREIGN_KEY_CHECKS=1; 2、pom.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;com.lc&lt;/groupId&gt; &lt;artifactId&gt;security-db&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;security-db&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.18&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.27&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 3、实体这里提供的UserDetails只是一种规范 123456789101112131415public interface UserDetails extends Serializable { Collection&lt;? extends GrantedAuthority&gt; getAuthorities(); String getPassword(); String getUsername(); boolean isAccountNonExpired(); boolean isAccountNonLocked(); boolean isCredentialsNonExpired(); boolean isEnabled();} ①user 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118public class User implements UserDetails { private Integer id; private String username; private String password; /** * 是否启用 */ private Boolean enabled; /** * 是否锁定 */ private Boolean locked; /** * 一个用户可以包含多个角色 */ private List&lt;Role&gt; roles; public Integer getId() { return id; } public User setId(Integer id) { this.id = id; return this; } public User setUsername(String username) { this.username = username; return this; } public User setPassword(String password) { this.password = password; return this; } public User setEnabled(Boolean enabled) { this.enabled = enabled; return this; } public User setLocked(Boolean locked) { this.locked = locked; return this; } public List&lt;Role&gt; getRoles() { return roles; } public User setRoles(List&lt;Role&gt; roles) { this.roles = roles; return this; } @Override public String getPassword(){ return password; } @Override public String getUsername() { return username; } /** * 返回用户的所有角色 * @return */ @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() { List&lt;SimpleGrantedAuthority&gt; authorities=new ArrayList&lt;&gt;();// 将数据中查询的角色信息查出并传入springsecurity for (Role role : roles) {// 注意若数据中的角色名没有以ROLE_开头，则需要在这动态赋予。否则则不需要 authorities.add(new SimpleGrantedAuthority(\"ROLE_\" + role.getName())); } return authorities; } /** * 账户是否没有未过期 * @return */ @Override public boolean isAccountNonExpired() { return true; } /** * 账户是否未锁定 相当于locked的get方法 * @return */ @Override public boolean isAccountNonLocked() { //这里的数据库中为0，则这里的locked为false; 因为这里问是否未被锁定，所以这里要取反 return !locked; } /** * 凭证(密码)是否未过期 * @return */ @Override public boolean isCredentialsNonExpired() { return true; } /** * 是否可用 相当于enabled的get方法 * @return */ @Override public boolean isEnabled() { return enabled; }} ②role 12345678@Setter@Getter@ToStringpublic class Role { private Integer id; private String name; private String nameZh;} 5、mapper①接口 1234567public interface UserMapper { User loadUserByUsername(String username); //根据用户id查询所有该用户对应的角色 List&lt;Role&gt; getUserRolesById(Integer id);} ②xml 12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" &gt;&lt;mapper namespace=\"com.lc.securitydb.mapper.UserMapper\"&gt; &lt;select id=\"loadUserByUsername\" resultType=\"com.lc.securitydb.bean.User\"&gt; select * from user where username=#{username}; &lt;/select&gt; &lt;select id=\"getUserRolesById\" resultType=\"com.lc.securitydb.bean.Role\"&gt; select * from role where id in(select rid from user_role where uid=#{id}) &lt;/select&gt;&lt;/mapper&gt; 6、service同理，这里我们提供UserDetailsService是一种规范 123public interface UserDetailsService { UserDetails loadUserByUsername(String var1) throws UsernameNotFoundException;} 1234567891011121314151617181920212223@Servicepublic class UserService implements UserDetailsService { @Autowired private UserMapper userMapper; /** * 根据用户名查询用户 这里我们只需要根据用户名查出即可 后面的密码结果系统会去比对 * @param username 登录时的用户名 * @return * @throws UsernameNotFoundException */ @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException { User user=userMapper.loadUserByUsername(username); if (user == null) { throw new UsernameNotFoundException(\"用户不存在\"); }// 查询用户角色 user.setRoles(userMapper.getUserRolesById(user.getId())); return user; }} 7、config①mybatis配置1234@Configuration@MapperScan(basePackages = \"com.lc.securitydb.mapper\")public class MybatisConfig {} ②security配置123456789101112131415161718192021222324252627282930313233343536373839@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter { @Autowired private UserService userService; /** * 进行用户名和密码的配置管理 * @param auth * @throws Exception */ @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.userDetailsService(userService); } /** * 加密器 * @return */ @Bean public BCryptPasswordEncoder bCryptPasswordEncoder() { return new BCryptPasswordEncoder(); } @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers(\"/admin/**\").hasRole(\"admin\") .antMatchers(\"/dba/**\").hasRole(\"dba\") .antMatchers(\"/user/**\").hasRole(\"user\") .anyRequest().authenticated() .and() .formLogin() .permitAll() .and() .csrf().disable(); }} 8、yaml123456spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/securitytest?useUnicode=true&amp;characterEncoding=utf-8 username: root password: 123456 9、controller12345678910111213141516171819202122232425262728293031323334353637383940@RestControllerpublic class HelloController { /** * 登录即可 访问 * @return */ @GetMapping(\"/hello\") public String hello() { return \"hello security\"; } /** * 角色dba访问 * @return */ @GetMapping(\"/dba/hello\") public String dba() { return \"hello dba\"; } /** * 角色admin访问 * @return */ @GetMapping(\"/admin/hello\") public String admin() { return \"hello admin\"; } /** * 角色user访问 * @return */ @GetMapping(\"/user/hello\") public String user() { return \"hello user\"; }} 七、SpringSecurity中的继承关系1、版本化的配置差异①SpringBoot2.0.8(含)之前的写法角色之间的继承关系用 空格 分开 1234567@Bean RoleHierarchy roleHierarchy() { RoleHierarchyImpl roleHierarchy = new RoleHierarchyImpl(); String hierarchy = \"ROLE_dba &gt; ROLE_admin ROLE_admin &gt; ROLE_user\"; roleHierarchy.setHierarchy(hierarchy); return roleHierarchy; } ②SpringBoot2.0.8之后的版本角色之前的继承用 \\n 分开 1234567@Beanpublic RoleHierarchy roleHierarchy() { RoleHierarchyImpl roleHierarchy = new RoleHierarchyImpl(); String hierarchy = \"ROLE_dba &gt; ROLE_admin \\n ROLE_admin &gt; ROLE_user\"; roleHierarchy.setHierarchy(hierarchy); return roleHierarchy;} 拥有dba角色可以访问admin有关的接口，拥有admin角色可以访问user有关的接口，user只能访问自己有关的接口，所以dba可以访问admin和user有关的接口，admin可以访问user的有关接口 2、注意的几个地方：①注意角色前要加 ROLE_ 前缀 ②角色和角色之间的定义 &gt; 前后要加空格 , \\n 前后也要加空格 3、基本配置12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter { @Autowired private UserService userService; /** * 进行用户名和密码的配置管理 * * @param auth * @throws Exception */ @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.userDetailsService(userService); } /** * 加密器 * * @return */ @Bean public BCryptPasswordEncoder bCryptPasswordEncoder() { return new BCryptPasswordEncoder(); } @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .antMatchers(\"/admin/**\").hasRole(\"admin\") .antMatchers(\"/dba/**\").hasRole(\"dba\") .antMatchers(\"/user/**\").hasRole(\"user\") .anyRequest().authenticated() .and() .formLogin() .permitAll() .and() .csrf().disable(); } @Bean public RoleHierarchy roleHierarchy() { RoleHierarchyImpl roleHierarchy = new RoleHierarchyImpl(); String hierarchy = \"ROLE_dba &gt; ROLE_admin \\n ROLE_admin &gt; ROLE_user\"; roleHierarchy.setHierarchy(hierarchy); return roleHierarchy; }} 八、动态配置权限1、sql菜单表，菜单角色表，用户表，角色表，用户角色表 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980CREATE TABLE `menu` ( `id` int(11) NOT NULL AUTO_INCREMENT, `pattern` varchar(100) NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4;-- ------------------------------ Records of menu-- ----------------------------INSERT INTO `menu` VALUES ('1', '/dba/**');INSERT INTO `menu` VALUES ('2', '/admin/**');INSERT INTO `menu` VALUES ('3', '/user/**');CREATE TABLE `menu_role` ( `id` int(11) NOT NULL AUTO_INCREMENT, `mid` int(11) DEFAULT NULL, `rid` int(11) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8mb4;-- ------------------------------ Records of menu_role-- ----------------------------INSERT INTO `menu_role` VALUES ('1', '1', '1');INSERT INTO `menu_role` VALUES ('2', '2', '2');INSERT INTO `menu_role` VALUES ('3', '3', '3');CREATE TABLE `role` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(32) DEFAULT NULL, `nameZh` varchar(32) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;-- ------------------------------ Records of role-- ----------------------------INSERT INTO `role` VALUES ('1', 'dba', '数据库管理员');INSERT INTO `role` VALUES ('2', 'admin', '系统管理员');INSERT INTO `role` VALUES ('3', 'user', '用户');-- ------------------------------ Table structure for user-- ----------------------------DROP TABLE IF EXISTS `user`;CREATE TABLE `user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(32) DEFAULT NULL, `password` varchar(255) DEFAULT NULL, `enabled` tinyint(1) DEFAULT NULL, `locked` tinyint(1) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=4 DEFAULT CHARSET=utf8;-- ------------------------------ Records of user 密码123-- ----------------------------INSERT INTO `user` VALUES ('1', 'root', '$2a$10$RMuFXGQ5AtH4wOvkUqyvuecpqUSeoxZYqilXzbz50dceRsga.WYiq', '1', '0');INSERT INTO `user` VALUES ('2', 'admin', '$2a$10$RMuFXGQ5AtH4wOvkUqyvuecpqUSeoxZYqilXzbz50dceRsga.WYiq', '1', '0');INSERT INTO `user` VALUES ('3', 'sang', '$2a$10$RMuFXGQ5AtH4wOvkUqyvuecpqUSeoxZYqilXzbz50dceRsga.WYiq', '1', '0');-- ------------------------------ Table structure for user_role-- ----------------------------DROP TABLE IF EXISTS `user_role`;CREATE TABLE `user_role` ( `id` int(11) NOT NULL AUTO_INCREMENT, `uid` int(11) DEFAULT NULL, `rid` int(11) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;-- ------------------------------ Records of user_role-- ----------------------------INSERT INTO `user_role` VALUES ('1', '1', '1');INSERT INTO `user_role` VALUES ('2', '1', '2');INSERT INTO `user_role` VALUES ('3', '2', '2');INSERT INTO `user_role` VALUES ('4', '3', '3');SET FOREIGN_KEY_CHECKS=1; 2、pom.xml12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.5.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;groupId&gt;org.lc&lt;/groupId&gt; &lt;artifactId&gt;security-dynamic&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; &lt;name&gt;security-dynamic&lt;/name&gt; &lt;description&gt;Demo project for Spring Boot&lt;/description&gt; &lt;properties&gt; &lt;java.version&gt;1.8&lt;/java.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-security&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;2.1.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.1.18&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;version&gt;5.1.27&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.security&lt;/groupId&gt; &lt;artifactId&gt;spring-security-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 3、yaml配置123456spring: datasource: driver-class-name: com.mysql.jdbc.Driver url: jdbc:mysql://localhost:3306/securitydy?useUnicode=true&amp;characterEncoding=UTF-8 username: root password: 123456 4、实体配置menu==&gt; 12345678910111213141516@Getter@Setter@ToStringpublic class Menu { private Integer id; /** * 访问此菜单的路径 */ private String pattern; /** * 访问此此单需要的角色 */ private List&lt;Role&gt; roles;} role==&gt; 12345678@Getter@Setter@ToStringpublic class Role { private Integer id; private String name; private String nameZh;} user==&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public class User implements UserDetails { private Integer id; private String username; private String password; private Boolean enabled; private Boolean locked; private List&lt;Role&gt; roles; public List&lt;Role&gt; getRoles() { return roles; } public User setRoles(List&lt;Role&gt; roles) { this.roles = roles; return this; } public Integer getId() { return id; } public User setId(Integer id) { this.id = id; return this; } public User setUsername(String username) { this.username = username; return this; } public User setPassword(String password) { this.password = password; return this; } public User setEnabled(Boolean enabled) { this.enabled = enabled; return this; } public User setLocked(Boolean locked) { this.locked = locked; return this; } @Override public Collection&lt;? extends GrantedAuthority&gt; getAuthorities() { List&lt;SimpleGrantedAuthority&gt; authorities=new ArrayList&lt;&gt;(); for (Role role : roles) {// 此时这里我们不需要加ROLE_前缀 因为数据库中我们的角色名已经加好了前缀 authorities.add(new SimpleGrantedAuthority(role.getName())); } return authorities; } @Override public String getPassword() { return password; } @Override public String getUsername() { return username; } @Override public boolean isAccountNonExpired() { return true; } @Override public boolean isAccountNonLocked() { return !locked; } @Override public boolean isCredentialsNonExpired() { return true; } @Override public boolean isEnabled() { return enabled; }} 5、mapper123public interface MenuMapper { List&lt;Menu&gt; getAllMenus();} 1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" &gt;&lt;mapper namespace=\"org.lc.securitydynamic.mapper.MenuMapper\"&gt; &lt;resultMap id=\"BaseResultMap\" type=\"org.lc.securitydynamic.bean.Menu\"&gt; &lt;id property=\"id\" column=\"id\"/&gt; &lt;result property=\"pattern\" column=\"pattern\"/&gt; &lt;collection property=\"roles\" ofType=\"org.lc.securitydynamic.bean.Role\"&gt; &lt;id property=\"id\" column=\"rid\"/&gt; &lt;result property=\"name\" column=\"rname\"/&gt; &lt;result property=\"nameZh\" column=\"rnameZh\"/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=\"getAllMenus\" resultMap=\"BaseResultMap\"&gt; SELECT menu.*, role.id rid, role. NAME rname, role.nameZh rnameZh FROM menu LEFT JOIN menu_role mr ON menu.id = mr.mid LEFT JOIN role ON mr.rid = role.id &lt;/select&gt;&lt;/mapper&gt; 123456public interface UserMapper { User getUserByUsername(String username); List&lt;Role&gt; getRolesByUserId(Integer id);} 123456789101112&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\" &gt;&lt;mapper namespace=\"org.lc.securitydynamic.mapper.UserMapper\"&gt; &lt;select id=\"getUserByUsername\" resultType=\"org.lc.securitydynamic.bean.User\"&gt; select * from user where username=#{username} &lt;/select&gt; &lt;select id=\"getRolesByUserId\" resultType=\"org.lc.securitydynamic.bean.Role\"&gt; select * from role where id in(select rid from user_role where uid=#{id}) &lt;/select&gt;&lt;/mapper&gt; 6、service12345678910@Servicepublic class MenuService { @Autowired private MenuMapper menuMapper; public List&lt;Menu&gt; getAllMenus() { return menuMapper.getAllMenus(); }} 12345678910111213141516@Servicepublic class UserService implements UserDetailsService { @Autowired private UserMapper userMapper; @Override public UserDetails loadUserByUsername(String s) throws UsernameNotFoundException { User user= userMapper.getUserByUsername(s); if (user == null) { throw new UsernameNotFoundException(\"用户不存在\"); } user.setRoles(userMapper.getRolesByUserId(user.getId())); return user; }} 7、controller12345678910111213141516171819202122232425262728293031323334353637383940@RestControllerpublic class HelloController { /** * 登录即可访问 * @return */ @GetMapping(\"/hello\") public String hello() { return \"hello security\"; } /** * 模拟 dba角色 * @return */ @GetMapping(\"/dba/hello\") public String dba() { return \"hello dba\"; } /** * 模拟admin角色 * @return */ @GetMapping(\"/admin/hello\") public String admin() { return \"hello admin\"; } /** * 模拟user角色 * @return */ @GetMapping(\"/user/hello\") public String user() { return \"hello user\"; }} 8、核心配置①mybati配置1234@Configuration@MapperScan(basePackages = \"org.lc.securitydynamic.mapper\")public class MybatisConfig {} ②过滤回调配置(筛选请求需要的角色)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263@Componentpublic class MyFilterInvocation implements FilterInvocationSecurityMetadataSource { /** * 匹配ant风格的路径 使用AntPathMatcher类比较两个路径是否匹配 */ AntPathMatcher antPathMatcher=new AntPathMatcher(); @Autowired private MenuService menuService; /** * 这里每一次请求就会查询一遍表 和遍历一遍集合，我们可以放入redis缓存中 * * 根据请求的地址 分析 出需要的角色 * @param o 实际上是一个FilterInvocation对象 请求的相关信息 * @return 返回需要的角色 * @throws IllegalArgumentException */ @Override public Collection&lt;ConfigAttribute&gt; getAttributes(Object o) throws IllegalArgumentException {// 获取当前请求的url String requestUrl = ((FilterInvocation) o).getRequestUrl();// 获取数据库中每个菜单请求对应的访问路径即角色信息 List&lt;Menu&gt; allMenus = menuService.getAllMenus();// 遍历数据库中的菜单 for (Menu menu : allMenus) {// 判断数据库中的菜单路径 是否 和请求的路径匹配 if (antPathMatcher.match(menu.getPattern(), requestUrl)) {// 若匹配 获取该路径下的对应的所有角色信息 List&lt;Role&gt; roles = menu.getRoles();// 定义存放角色的字符串 并指定和list中相同的长度 String[] allRoleList=new String[roles.size()];// 遍历该角色集合 for (int i = 0; i &lt; roles.size(); i++) {// 存放到字符串数组中 allRoleList[i] = roles.get(i).getName(); }// 返回该匹配的请求路径下的所有角色信息 return SecurityConfig.createList(allRoleList); } }// 如果请求的路径没有和数据库中的路径匹配 则返回自定义的角色（这里，我们只作为一个标识，后期根据标识再去处理） return SecurityConfig.createList(\"ROLE_login\"); } @Override public Collection&lt;ConfigAttribute&gt; getAllConfigAttributes() { return null; } /** * 是否支持这种方式 返回true即可 * @param aClass * @return */ @Override public boolean supports(Class&lt;?&gt; aClass) { return true; }} ③存储决定管理器(比对登录用户的角色)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package org.lc.securitydynamic.config;import org.springframework.security.access.AccessDecisionManager;import org.springframework.security.access.AccessDeniedException;import org.springframework.security.access.ConfigAttribute;import org.springframework.security.authentication.AnonymousAuthenticationToken;import org.springframework.security.authentication.InsufficientAuthenticationException;import org.springframework.security.core.Authentication;import org.springframework.security.core.GrantedAuthority;import org.springframework.stereotype.Component;import java.util.Collection;/** * @BelongsProject: security-dynamic * @BelongsPackage: org.lc.securitydynamic.config * @Author: lc * @CreateTime: 2020-03-29 00:19 * @Description: */@Componentpublic class MyAccessDecisionManager implements AccessDecisionManager { /** * @param authentication 当前登录用户的信息 * @param o 当前的请求对象（相当于FilterInvocation对象） * @param collection 我们自定义的FilterInvocationSecurityMetadataSource的返回匹配路径需要的角色对象 * @throws AccessDeniedException * @throws InsufficientAuthenticationException */ @Override public void decide(Authentication authentication, Object o, Collection&lt;ConfigAttribute&gt; collection) throws AccessDeniedException, InsufficientAuthenticationException {// 这里考虑 未登录先直接抛出异常*************** if (authentication instanceof AnonymousAuthenticationToken) { throw new AccessDeniedException(\"未登录,非法请求\"); }// 遍历该请求路径下需要的角色对象 for (ConfigAttribute configAttribute : collection) {// 如果没有任何路径匹配（我们之前定义的没有任何路径能够匹配上，自定义返回的角色） if (\"ROLE_login\".equals(configAttribute.getAttribute())) {// 若登录状态为匿名用户（未登录） 直接抛异常 if (authentication instanceof AnonymousAuthenticationToken) { //RememberMeAuthenticationToken (org.springframework.security.authentication) //TestingAuthenticationToken (org.springframework.security.authentication)// 匿名用户的登录 //AnonymousAuthenticationToken (org.springframework.security.authentication) //RunAsUserToken (org.springframework.security.access.intercept)// 已经进行用户名和密码的登录 //UsernamePasswordAuthenticationToken (org.springframework.security.authentication) //PreAuthenticatedAuthenticationToken (org.springframework.security.web.authentication.preauth) throw new AccessDeniedException(\"非法请求\"); }else{// 已经登录 但是没有匹配数据库中的路径// 可能只要登录即可访问// 直接退出角色寻找 return; } }// 当前登录用户具备的角色 Collection&lt;? extends GrantedAuthority&gt; authorities = authentication.getAuthorities();// 遍历用户具备的角色 for (GrantedAuthority authority : authorities) {// 如果当前登录用户的角色和 该路径下的数据库的角色匹配 if (authority.getAuthority().equals(configAttribute.getAttribute())) {// 直接返回 return; } } }// 若路径匹配但是 没有找到相应的角色 抛出异常 throw new AccessDeniedException(\"权限不足，非法请求\"); } /** * 是否支持这种方式 true * @param configAttribute * @return */ @Override public boolean supports(ConfigAttribute configAttribute) { return true; } /** * 是否支持这种方式 true * @param aClass * @return */ @Override public boolean supports(Class&lt;?&gt; aClass) { return true; }} ④security配置1234567891011121314151617181920212223242526272829303132333435363738394041424344@Configurationpublic class SecurityConfig extends WebSecurityConfigurerAdapter { @Autowired private UserService userService; @Autowired private MyFilterInvocation myFilterInvocation; @Autowired private MyAccessDecisionManager myAccessDecisionManager; @Bean BCryptPasswordEncoder bCryptPasswordEncoder() { return new BCryptPasswordEncoder(); } @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.userDetailsService(userService); } @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests()// 定义请求之前的处理器 .withObjectPostProcessor(new ObjectPostProcessor&lt;FilterSecurityInterceptor&gt;() { @Override public &lt;O extends FilterSecurityInterceptor&gt; O postProcess(O o) {// 设置自定义拦截请求需要的角色 o.setSecurityMetadataSource(myFilterInvocation);// 设置自定义角色比对管理器 o.setAccessDecisionManager(myAccessDecisionManager); return o; } }) .and() .formLogin() .permitAll() .and() .csrf().disable(); }} 9 、执行流程分析①首先拦截所有请求通过过滤回调配置文件处理(MyFilterInvocation)，获得当前请求的路径（String requestUrl = ((FilterInvocation) o).getRequestUrl();） ②查找所有的请求路径所需的角色信息，遍历该路径信息，如果找到与请求向匹配的路径，则返回该路径所需要的全部角色信息。若没有匹配上，则返回一个标识角色代表没有匹配上（return SecurityConfig.createList(“ROLE_login”)） ③来到角色比对管理器（MyAccessDecisionManager），首先我们可以直接判断用户是否登录，若未登录，直接抛出非法请求异常（throw new AccessDeniedException(“未登录,请求非法”)）。若进入登录状态验证后，遍历返回的该路径下需要的角色信息，若匹配到我们自定义的标识角色，则代表未匹配路径，则直接返回（代表该路径不需要角色，登录即可访问）。否则代表匹配上指定的路径，那么遍历当前用户登录的角色信息，查看数据库路径下的角色信息是否和当前用户登录所有的角色信息匹配，若匹配到，直接返回。遍历完之后，还没有符合的条件，直接抛出异常。","link":"/2020/04/17/springsecurity/Spring-Security%E9%85%8D%E7%BD%AE/"},{"title":"springboot基本配置","text":"一、springboot基本配置1234567#设置端口server.port=8081#设置上下文路径 (即请求包含的前缀)server.servlet.context-path=/lc#配置内嵌的tomcat编码server.tomcat.uri-encoding=UTF-8#还可以配置其他jetty相关的属性 12345678910111213141516171819&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;!--排除内部的tomcat--&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;!--排除tomcat服务器后，使用jetty服务器--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 1、关于springboot启动类1234567@SpringBootApplicationpublic class TomcatApplication { public static void main(String[] args) { SpringApplication.run(TomcatApplication.class, args); }} @SpringBootApplication===&gt; 1234567891011@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan( excludeFilters = {@Filter( type = FilterType.CUSTOM, classes = {TypeExcludeFilter.class}), @Filter( type = FilterType.CUSTOM, classes = {AutoConfigurationExcludeFilter.class})}) ①@ComponentScan12@Service,@Repository,@Component,@Controller用来定义一个bean.@ComponentScan注解就是用来自动扫描被这些注解标识的类，最终生成ioc容器里的bean．可以通过设置@ComponentScan(basePackages，includeFilters，excludeFilters)属性来动态确定自动扫描范围，类型以及不扫描的类型． 默认情况下:它扫描所有类型，并且扫描范围是@ComponentScan注解所在配置类包及子包的类 ②@SpringBootConfiguration1这个注解的作用与@Configuration作用相同，都是用来声明当前类是一个配置类．可以通过＠Bean注解生成IOC容器管理的bean. ③@EnableAutoConfiguration12@EnableAutoConfiguration是springboot实现自动化配置的核心注解，通过这个注解把spring应用所需的bean注入容器中．@EnableAutoConfiguration源码通过@Import注入了一个ImportSelector的实现类AutoConfigurationImportSelector,这个ImportSelector最终实现根据我们的配置，动态加载所需的bean. 2、maven中的 parent1234567891011121314 &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.2.2.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt;&lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt;&lt;/build&gt; 这里查看源我们可以发现，它自动帮我们定义了一系列的引用的版本号。我们去引用其他依赖时，不需要定义额外的版本号（这里的依赖必须是org.springframework.boot中，否则还是要加版本号） 3、花里胡哨的banner在resources下添加banner.txt http://patorjk.com/software/taag http://www.network-science.de/ascii/ 123456789101112131415161718192021////////////////////////////////////////////////////////////////////// _ooOoo_ //// o8888888o //// 88&quot; . &quot;88 //// (| ^_^ |) //// O\\ = /O //// ____/`---'\\____ //// .' \\\\| |// `. //// / \\\\||| : |||// \\ //// / _||||| -:- |||||- \\ //// | | \\\\\\ - /// | | //// | \\_| ''\\---/'' | | //// \\ .-\\__ `-` ___/-. / //// ___`. .' /--.--\\ `. . ___ //// .&quot;&quot; '&lt; `.___\\_&lt;|&gt;_/___.' &gt;'&quot;&quot;. //// | | : `- \\`.;`\\ _ /`;.`/ - ` : | | //// \\ \\ `-. \\_ __\\ /__ _/ .-` / / //// ========`-.____`-.___\\_____/___.-`____.-'======== //// `=---=' //// ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ //// 佛祖保佑 永不宕机 永无BUG // 禁用banner 123456789@SpringBootApplicationpublic class TomcatApplication { public static void main(String[] args) { SpringApplicationBuilder builder = new SpringApplicationBuilder(TomcatApplication.class); SpringApplication build = builder.build(); build.setBannerMode(Banner.Mode.OFF); build.run(args); }} 4、单元测试添加123456&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;!--只会在测试时使用 不会被打包--&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt; test主文件： 12345678@RunWith(SpringRunner.class)//启动类@SpringBootTest(classes = JDBCTemplateApplication.class))public class PropertyApplicationTests { @Test public void contextLoads(){ }} 5、自定义属性配置及加载properties①@PropertySource(“classpath:person.properties”)导入properties文件 ②@ConfigurationProperties(prefix = “person”)定义前缀person ③@Value(“${name:xxx}”)属性上加@value可不用定义该属性的get,set方法，否则要加get,set方法 定义实体对应的properties文件中的属性 定义默认值：xxx 配置实体,定义为组件： 1234567891011121314@Component@PropertySource(\"classpath:person.properties\")@ConfigurationProperties(prefix = \"person\")public class Person { @Value(\"${name:xxx}\") private String name; private Integer age; private String gender; //getter... //setter... //toString...} properties文件==&gt; 123person.name=张三person.age=10person.gender=男 使用==&gt; 注入即用: 12345678910@RunWith(SpringRunner.class)@SpringBootTestpublic class PropertyApplicationTests { @Autowired private Person person; @Test public void contextLoads(){ System.out.println(person); }} 6、yaml/yml配置注意：在yaml中，最好不要写大写的属性名称，大写前面加字母前加 - 后转小写 1、yaml是配置是有序的，properties是无序的 2、自定义的yaml目前暂不支持使用注解的方式注入到springboot项目中 3、注意每个属性的冒号： 后需要加一个空格 注入集合字符串，注入集合对象123456789101112131415161718192021server: port: 8081 servlet: context-path: /lcredis: port: 6379# 注入集合字符串 hosts: - 192.169.22.33 - 192.169.22.34 - 192.169.22.35 - 192.169.22.36 - 192.169.22.37# 注入集合对象 redisList: #一个 -组 代表一个对象 - port: 6379 host: 192.168.22.38 - port: 6379 host: 192.168.22.39 1234567public class Redis { private Integer port; private String host; //getter... //setter... //toString...} 12345678910@Component@ConfigurationProperties(prefix = \"redis\")public class RedisCluster { private Integer port; private List&lt;String&gt; hosts; private List&lt;Redis&gt; redisList; //getter... //setter... //toString...} 7、多环境的yaml/properties配置我们可以定义诸如：application-xxx.yaml application-test.yaml application-dev.yaml application-prod.yaml 多种环境的配置，在application.yaml中激活即可: 1spring.profiles.active=prod 会覆盖application.yaml中本身内容 8、访问static下的所有资源(html)1234567891011121314151617&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/java&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/*.xml&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;filtering&gt;false&lt;/filtering&gt; &lt;includes&gt; &lt;include&gt;**/**&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt; &lt;/build&gt; 二、springboot整合视图层框架1、整合Freemarker依赖==&gt; 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-freemarker&lt;/artifactId&gt;&lt;/dependency&gt; 123456789public class User { private String id; private String username; private String password; private String address; //getter //setter //toString} 1234567891011121314151617@Controllerpublic class UserController { @GetMapping(\"/user\") public String user(Model model) { List&lt;User&gt; list = new ArrayList&lt;&gt;(); for (int i = 1; i &lt; 6; i++) { User user=new User(); user.setId(i+\"\"); user.setUsername(\"cl\"+i); user.setPassword(\"123456\"); user.setAddress(\"pengx\"); list.add(user); } model.addAttribute(\"users\", list); return \"user\"; }} 模板引擎==&gt; 注意：此文件的后缀为 .ftlh 1234567891011121314151617181920212223242526&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;用户信息&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table border=\"1\" cellspacing=\"0\"&gt; &lt;tr&gt; &lt;td&gt;编号&lt;/td&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;地址&lt;/td&gt; &lt;/tr&gt; &lt;#list users as u&gt; &lt;tr&gt; &lt;td&gt;${u.id}&lt;/td&gt; &lt;td&gt;${u.username}&lt;/td&gt; &lt;td&gt;${u.password}&lt;/td&gt; &lt;td&gt;${u.address}&lt;/td&gt; &lt;/tr&gt; &lt;/#list&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; yaml配置==&gt; 12345678spring: freemarker: #自定义模板文件的加载位置 template-loader-path: classpath:/templates #是否开启缓存 cache: false #上下文类型 content-type: text/html 更多属性的更改参考 FreeMarkerProperties中的默认配置 12345678910public class FreeMarkerProperties extends AbstractTemplateViewResolverProperties { public static final String DEFAULT_TEMPLATE_LOADER_PATH = \"classpath:/templates/\"; public static final String DEFAULT_PREFIX = \"\"; public static final String DEFAULT_SUFFIX = \".ftlh\"; private Map&lt;String, String&gt; settings = new HashMap(); private String[] templateLoaderPath = new String[]{\"classpath:/templates/\"}; private boolean preferFileSystemAccess = true; //..... //.....} 2、整合thymeleaf1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;&lt;/dependency&gt; 12345678910111213141516171819@Controllerpublic class UserController { @GetMapping(\"/user\") public String user(Model model) { List&lt;User&gt; list = new ArrayList&lt;&gt;(); for (int i = 1; i &lt; 6; i++) { User user=new User(); user.setId(i+\"\"); user.setUsername(\"cl\"+i); user.setPassword(\"123456\"); user.setAddress(\"pengx\"); list.add(user); } model.addAttribute(\"users\", list); return \"User\"; }} 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;用户信息&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table border=\"1\" cellspacing=\"0\"&gt; &lt;tr&gt; &lt;td&gt;编号&lt;/td&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;地址&lt;/td&gt; &lt;/tr&gt; &lt;tr th:each=\"user :${users}\"&gt; &lt;td th:text=\"${user.id}\"&gt;&lt;/td&gt; &lt;td th:text=\"${user.username}\"&gt;&lt;/td&gt; &lt;td th:text=\"${user.password}\"&gt;&lt;/td&gt; &lt;td th:text=\"${user.address}\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 更多配置请看源码 ThymeleafProperties: 1234567891011121314151617181920public class ThymeleafProperties { private static final Charset DEFAULT_ENCODING; public static final String DEFAULT_PREFIX = \"classpath:/templates/\"; public static final String DEFAULT_SUFFIX = \".html\"; private boolean checkTemplate = true; private boolean checkTemplateLocation = true; private String prefix = \"classpath:/templates/\"; private String suffix = \".html\"; private String mode = \"HTML\"; private Charset encoding; private boolean cache; private Integer templateResolverOrder; private String[] viewNames; private String[] excludedViewNames; private boolean enableSpringElCompiler; private boolean renderHiddenMarkersBeforeCheckboxes; private boolean enabled; private final ThymeleafProperties.Servlet servlet; private final ThymeleafProperties.Reactive reactive;} 3、整合jsp①pom.xml123456789&lt;dependency&gt; &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt; &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt; ②配置视图解析器 WebMvcConfigurer在src/main/webapp/page/...... 增加webapp文件夹，并指定存放jsp的位置 1234567@Configurationpublic class WebMvcConfig implements WebMvcConfigurer { @Override public void configureViewResolvers(ViewResolverRegistry registry) { registry.jsp(\"/page/\", \".jsp\"); }} ③控制器1234567891011121314151617@Controllerpublic class UserController { @GetMapping(\"/user\") public String user(Model model) { List&lt;User&gt; list = new ArrayList&lt;&gt;(); for (int i = 1; i &lt; 6; i++) { User user=new User(); user.setId(i+\"\"); user.setUsername(\"cl\"+i); user.setPassword(\"123456\"); user.setAddress(\"pengx\"); list.add(user); } model.addAttribute(\"users\", list); return \"User\"; }} ④视图12345678910111213141516171819202122232425&lt;%@ taglib prefix=\"c\" uri=\"http://java.sun.com/jsp/jstl/core\" %&gt;&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table border=\"1\" cellspacing=\"0\"&gt; &lt;tr&gt; &lt;td&gt;编号&lt;/td&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;地址&lt;/td&gt; &lt;/tr&gt; &lt;c:forEach var=\"user\" items=\"${users}\"&gt; &lt;tr&gt; &lt;td&gt;${user.id}&lt;/td&gt; &lt;td&gt;${user.username}&lt;/td&gt; &lt;td&gt;${user.password}&lt;/td&gt; &lt;td&gt;${user.address}&lt;/td&gt; &lt;/tr&gt; &lt;/c:forEach&gt; &lt;/table&gt;&lt;/body&gt;&lt;/html&gt; 三、springboot整合web开发1、HttpMessageConverter注：以下例子只是实体响应日期类型的格式转换 (1)功能①将服务端返回的对象序列化成JOSN字符串 ②将前端传来的JSON字符串反序列化成java对象 (2)Jackson和Gson自动化配置和手动配置所有的JSON生成都离不开HttpMessageConverter SpringMvc自动配置了Jackson和Gson的HttpMessageConverter, springboot对此做了自动化配置 ①Jacksonspring-boot-starter-web中默认使用的是jsckson 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;&lt;/dependency&gt; 方式一：自动配置==&gt; 如果我们没有配置MappingJackson2HttpMessageConverter，则springboot帮我们自动配置 org.springframework.boot.autoconfigure.http.JacksonHttpMessageConvertersConfiguration==&gt; 12345678@Bean @ConditionalOnMissingBean( value = {MappingJackson2HttpMessageConverter.class}, ignoredType = {\"org.springframework.hateoas.server.mvc.TypeConstrainedMappingJackson2HttpMessageConverter\", \"org.springframework.data.rest.webmvc.alps.AlpsJsonHttpMessageConverter\"} ) MappingJackson2HttpMessageConverter mappingJackson2HttpMessageConverter(ObjectMapper objectMapper) { return new MappingJackson2HttpMessageConverter(objectMapper); } 手动配置==&gt; 如果我们配置了MappingJackson2HttpMessageConverter类,则自动配置失效 WebMvcConfig.java: 1234567891011@Configurationpublic class WebMvcConfig { @Bean public MappingJackson2HttpMessageConverter mappingJackson2HttpMessageConverter() { MappingJackson2HttpMessageConverter converter=new MappingJackson2HttpMessageConverter(); ObjectMapper mapper=new ObjectMapper(); mapper.setDateFormat(new SimpleDateFormat(\"yyyy-MM-dd\")); converter.setObjectMapper(mapper); return converter;` }} 方式二：自动配置==&gt; org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration 123456@Bean @Primary @ConditionalOnMissingBean ObjectMapper jacksonObjectMapper(Jackson2ObjectMapperBuilder builder) { return builder.createXmlMapper(false).build(); } 手动配置==&gt; 配置ObjectMapper使其自动配置失效 WebMvcConfig.java: 123456789@Configurationpublic class WebMvcConfig { @Bean public ObjectMapper objectMapper(){ ObjectMapper mapper=new ObjectMapper(); mapper.setDateFormat(new SimpleDateFormat(\"yyyy-MM-dd\")); return mapper; }} ②Gson排除spring-boot-starter-web中原有的jackson。 新增gson依赖 方式一：123456789101112131415&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-json&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt;&lt;/dependency&gt; 自动配置：==&gt; 同理，如果我们没有配置HttpMessageConverter，则springboot帮我们自动配置 org.springframework.boot.autoconfigure.http.GsonHttpMessageConvertersConfiguration==&gt; 1234567@Bean @ConditionalOnMissingBean GsonHttpMessageConverter gsonHttpMessageConverter(Gson gson) { GsonHttpMessageConverter converter = new GsonHttpMessageConverter(); converter.setGson(gson); return converter; } 手动配置：==&gt; 123456789@Configurationpublic class WebMvcConfig { @Bean GsonHttpMessageConverter gsonHttpMessageConverter() { GsonHttpMessageConverter converter = new GsonHttpMessageConverter(); converter.setGson(new GsonBuilder().setDateFormat(\"yyyy-MM-dd\").create()); return converter; }} 方式二：自动配置==&gt; org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration==&gt; 12345@Bean @ConditionalOnMissingBean public Gson gson(GsonBuilder gsonBuilder) { return gsonBuilder.create(); } 手动配置==&gt; 1234567@Configurationpublic class WebMvcConfig { @Bean Gson gson() { return new GsonBuilder().setDateFormat(\"yyyy-MM-dd\").create(); }} (3)fastjson手动配置12345678910111213141516&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-json&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.58&lt;/version&gt; &lt;/dependency&gt; 1234567891011@Configurationpublic class WebMvcConfig { @Bean FastJsonHttpMessageConverter fastJsonHttpMessageConverter() { FastJsonHttpMessageConverter converter=new FastJsonHttpMessageConverter(); FastJsonConfig fastJsonConfig=new FastJsonConfig(); fastJsonConfig.setDateFormat(\"yyyy-MM-dd\"); converter.setFastJsonConfig(fastJsonConfig); return converter; }} 2、springboot静态资源管理(1)默认的自动配置在源码中，我们可以看出，springboot帮我们自动做了一些配置 org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfigurati==&gt; 12345678910111213141516public void addResourceHandlers(ResourceHandlerRegistry registry) { if (!this.resourceProperties.isAddMappings()) { logger.debug(\"Default resource handling disabled\"); } else { Duration cachePeriod = this.resourceProperties.getCache().getPeriod(); CacheControl cacheControl = this.resourceProperties.getCache().getCachecontrol().toHttpCacheControl(); if (!registry.hasMappingForPattern(\"/webjars/**\")) { this.customizeResourceHandlerRegistration(registry.addResourceHandler(new String[]{\"/webjars/**\"}).addResourceLocations(new String[]{\"classpath:/META-INF/resources/webjars/\"}).setCachePeriod(this.getSeconds(cachePeriod)).setCacheControl(cacheControl)); } String staticPathPattern = this.mvcProperties.getStaticPathPattern(); if (!registry.hasMappingForPattern(staticPathPattern)) { this.customizeResourceHandlerRegistration(registry.addResourceHandler(new String[]{staticPathPattern}).addResourceLocations(WebMvcAutoConfiguration.getResourceLocations(this.resourceProperties.getStaticLocations())).setCachePeriod(this.getSeconds(cachePeriod)).setCacheControl(cacheControl)); } } } org.springframework.boot.autoconfigure.web.ResourceProperties==&gt; 1private static final String[] CLASSPATH_RESOURCE_LOCATIONS = new String[]{\"classpath:/META-INF/resources/\", \"classpath:/resources/\", \"classpath:/static/\", \"classpath:/public/\"}; 我们可以发现，springboot帮我们配置了一些静态资源的处理路径，按照顺序依次在resources文件夹下查找静态资源文件 classpath:/META-INF/resources/“ classpath:/resources/ classpath:/static/ classpath:/public/ 注意：在请求的时候我们就可以省略定义的文件夹名了 (2)自定义访问目录①yaml配置12345678910spring: resources: #静态资源的位置 static-locations: classpath:/lc/ mvc: #静态资源的请求规则 #不配置规则（任意规则）# static-path-pattern: /** #请求静态资源时必须加 /hh/ 前缀再加文件夹或者文件路径 static-path-pattern: /hh/** ②配置文件配置addResourceHandler(&quot;/**&quot;) 静态资源请求规则 addResourceLocations(&quot;classpath:/lc/&quot;) 静态资源位置 1234567@Configurationpublic class WebMvcConfig implements WebMvcConfigurer { @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { registry.addResourceHandler(\"/**\").addResourceLocations(\"classpath:/lc/\"); }} 例如：–resources ​ –lc ​ –java ​ –hello.js 无访问规则：==&gt; 访问路径为 http://localhost:8080/java/hello.js 有访问规则（/hh/**）==&gt; 访问路径为 http://localhost:8080/hh/java/hello.js 3、springBoot实现文件上传（1）form形式在springboot中我们直接使用MultipartFile接口中的org.springframework.web.multipart.support.StandardMultipartHttpServletRequest.StandardMultipartFile实现类 自动配置==&gt; org.springframework.boot.autoconfigure.web.servlet.MultipartProperties==&gt; 12345678910111213141516171819@ConfigurationProperties( prefix = \"spring.servlet.multipart\", ignoreUnknownFields = false)public class MultipartProperties { //是否开启上传 private boolean enabled = true; //临时存储位置 private String location; //上传大小限制 private DataSize maxFileSize = DataSize.ofMegabytes(1L); //上传文件（多个）总大小 private DataSize maxRequestSize = DataSize.ofMegabytes(10L); //文件上传的阈值（上传多少文件时，不能往内存中写，需要转换处理） private DataSize fileSizeThreshold = DataSize.ofBytes(0L); private boolean resolveLazily = false; //...... //......} 12345spring: servlet: multipart:# 定义文件的上传大小限制 这里需要大写KB max-file-size: 1KB ①单文件123456789101112131415161718192021222324252627282930313233@RestControllerpublic class FileUploadController { SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"/yyyy/MM/dd/\"); @PostMapping(\"/upload\") public String hello(MultipartFile file, HttpServletRequest req) { String format = simpleDateFormat.format(new Date());// 自定义：获取上传的文件的真正路径/img/yyyy/MM/dd/ String realPath = req.getServletContext().getRealPath(\"/img\") + format; File folder = new File(realPath);// 若定义的文件夹不存在 if (!folder.exists()) {// 创建该文件夹 folder.mkdirs(); }// 获得上传的文件名称 String oldName = file.getOriginalFilename();// 截图文件的后缀，并加上生成的uuid作为文件名 String newName = UUID.randomUUID().toString() + oldName.substring(oldName.lastIndexOf(\".\")); try {// 文件转换 上传到内存中// 重新定义其文件路径 及 文件名 file.transferTo(new File(folder, newName));// 返回路径：协议://服务器名称:端口/img//yyyy/MM/dd/+新的文件名 String url = req.getScheme() + \"://\" + req.getServerName() + \":\" + req.getServerPort() + \"/img\" + format + newName;// 返回该url return url; } catch (IOException e) { } return \"error\"; }} 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"/upload\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"file\" name=\"file\"/&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; ②多文件注意：这里的files为一个数组，为前端的 的name名称。 若有多个input标签，则只需要在后端请求参数上多加个MultipartFile file1,MultipartFile file2即可 123456789101112131415161718192021222324252627282930 @PostMapping(\"/uploads\") public String uploads(MultipartFile[] files, HttpServletRequest req) { String format = simpleDateFormat.format(new Date());// 自定义：获取上传的文件的真正路径/img/yyyy/MM/dd/ String realPath = req.getServletContext().getRealPath(\"/img\") + format; File folder = new File(realPath);// 若定义的文件夹不存在 if (!folder.exists()) {// 创建该文件夹 folder.mkdirs(); } //循环遍历存储 for (MultipartFile file : files) {// 获得上传的文件名称 String oldName = file.getOriginalFilename();// 截图文件的后缀，并加上生成的uuid作为文件名 String newName = UUID.randomUUID().toString() + oldName.substring(oldName.lastIndexOf(\".\")); try {// 文件转换 上传到内存中 // 重新定义其文件路径 及 文件名 file.transferTo(new File(folder, newName));// 返回路径：协议://服务器名称:端口/img//yyyy/MM/dd/+新的文件名 String url = req.getScheme() + \"://\" + req.getServerName() + \":\" + req.getServerPort() + \"/img\" + format + newName;// 输出该url System.out.println(url); } catch (IOException e) { } } return \"success\"; } 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;form action=\"/uploads\" method=\"post\" enctype=\"multipart/form-data\"&gt; &lt;input type=\"file\" name=\"files\" multiple/&gt; &lt;input type=\"submit\" value=\"提交\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; （2）ajax形式①单文件后端和form单文件上传一致 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"jquery-3.4.1.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"result\"&gt;&lt;/div&gt; &lt;input type=\"file\" id=\"file\"/&gt; &lt;input type=\"button\" value=\"提交\" onclick=\"upload()\"&gt; &lt;script type=\"text/javascript\"&gt; function upload() { //获取第一个文件 （这是个数组，可以多文件上传） var file = $(\"#file\")[0].files[0]; var formData = new FormData(); formData.append(\"file\", file); $.ajax({ type: \"post\", url: \"/upload\", //使数据不做处理 processData:false, //不要设置Content-Type请求头 contentType:false, data:formData, success:function (msg) { $(\"#result\").text(msg) } }) } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; ②多文件后端和form 多文件上传一致 123456789101112131415161718192021222324252627282930313233343536&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src=\"jquery-3.4.1.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"result\"&gt;&lt;/div&gt; &lt;input type=\"file\" id=\"file1\"/&gt; &lt;input type=\"file\" id=\"file2\"/&gt; &lt;input type=\"button\" value=\"提交\" onclick=\"upload()\"&gt; &lt;script type=\"text/javascript\"&gt; function upload() { var formData = new FormData(); //获取第一个文件 （这是个数组，可以多文件上传） var file1 = $(\"#file1\")[0].files[0]; var file2 = $(\"#file2\")[0].files[0]; formData.append(\"files\", file1); formData.append(\"files\", file2); $.ajax({ type: \"post\", url: \"/uploads\", //使数据不做处理 processData:false, //不要设置Content-Type请求头 contentType:false, data:formData, success:function (msg) { $(\"#result\").text(msg) } }) } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 4、@ControllerAdvice的使用(1)全局异常处理@RestControllerAdvice ==&gt; 12@ControllerAdvice@ResponseBody @ExceptionHandler 指定拦截的异常类型 若有返回值，则直接返回定义的异常bean即可，加上@RestControllerAdvice ①无返回值12345678910111213@ControllerAdvicepublic class CustomExceptionHandler {// @ExceptionHandler拦截指定异常// 这里我们可以返回任意值，或者不返回。 @ExceptionHandler(MaxUploadSizeExceededException.class) public void uploadFileException(MaxUploadSizeExceededException e, HttpServletResponse res) throws IOException { res.setContentType(\"text/html;charset=utf-8\"); PrintWriter printWriter = res.getWriter(); printWriter.write(\"文件大小超出限制！\"); printWriter.flush(); printWriter.close(); }} ②返回视图这里我们用的thymeleaf 1234567891011@ControllerAdvicepublic class CustomExceptionHandler { // 定义返回的视图 @ExceptionHandler(MaxUploadSizeExceededException.class) public ModelAndView uploadFileException(MaxUploadSizeExceededException e){ //新建视图并设定名称 ModelAndView modelAndView =new ModelAndView(\"exception\"); modelAndView.addObject(\"error\", \"文件大小超出限制！\"); return modelAndView; }} ③常用形式 返回自定义bean123456789101112131415@RestControllerAdvicepublic class GlobalExceptionHandler { private static final Logger logger = LoggerFactory.getLogger(GlobalExceptionHandler.class);// 处理SQLException该异常的方法 @ExceptionHandler(SQLException.class) public ResponseBean sqlException(SQLException e){ //判断是否为其类和及其子类 if(e instanceof MySQLIntegrityConstraintViolationException){ return ResponseBean.error(\"该数据有关联的数据，操作失败！\"); } logger.error(e.getMessage()); return ResponseBean.error(\"数据库操作异常，操作失败！\"); }} (2)预设全局数据12345678910@ControllerAdvicepublic class GlobalData { @ModelAttribute(value = \"info\") public Map&lt;String, Object&gt; mydata() { Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(\"name\", \"louchen\"); map.put(\"address\", \"www.louchen.top\"); return map; }} 1234567891011121314@RestControllerpublic class UserController { @GetMapping(\"/hello\") public String hello(Model model) { //转为map集合 Map&lt;String,Object&gt; map = model.asMap();// 获取所有的key Set&lt;String&gt; keySet = map.keySet(); for (String key : keySet) { System.out.println(\"key:\"+map.get(key)); } return \"success\"; }} 这里的map集合中===&gt; key为 @ModelAttribute(value = “info”)中的value值 value为定义在map中的所有值 1key:{address=www.louchen.top, name=louchen} (3)请求参数预处理当遇到参数需要处理的时候，例如多个对象的重复属性等其他情况 12345678public class Cat { private String id; private String name; private Integer age; //getter //setter //toString} 12345public class Doctor { private String id; private String name; private Integer age;} 12345678910111213141516@ControllerAdvicepublic class InitData { @InitBinder(\"doctor\") public void initDoctor(WebDataBinder binder){ //参数请求的时候的需要加的前缀 binder.setFieldDefaultPrefix(\"doc.\"); } @InitBinder(\"cat\") public void initCat(WebDataBinder binder){ //参数请求的时候的需要加的前缀 binder.setFieldDefaultPrefix(\"cat.\"); }} 123456789@RestControllerpublic class InitDataController { @PostMapping(\"/add\") //这里的@ModelAttribute中为@InitBinder中绑定的值 public void addDocAndCat(@ModelAttribute(\"doctor\")Doctor doctor, @ModelAttribute(\"cat\")Cat cat){ System.out.println(doctor.toString()); System.out.println(cat.toString()); }} 请求参数：post： http://localhost:8080/add doc.id ==&gt; doc.name ==&gt; doc.age ==&gt; cat.id ==&gt; cat.name ==&gt; cat.age ==&gt; 5、自定义错误页面(1)错误页面模板加载顺序在springboot中，程序发生错误的时候会自动寻找自动配置的错误页面 –resources ​ –static ​ –error ===&gt;404.html,4xx.html,500.html,5xx.html ​ –templates ​ –error ===&gt;404.html,4xx.html,500.html,5xx.html 在此目录下: 按照全匹配的优先规则依次从动态页面templates/error下寻找，再从静态页面static/error下寻找 在按照模糊匹配的优先规则依次从动态页面templates/error下寻找，再从静态页面static/error下寻找 (2)自定义异常数据自动配置==&gt; org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration==&gt; 12345678@Bean @ConditionalOnMissingBean( value = {ErrorAttributes.class}, search = SearchStrategy.CURRENT ) public DefaultErrorAttributes errorAttributes() { return new DefaultErrorAttributes(this.serverProperties.getError().isIncludeException()); } 手动配置==&gt; 123456789@Componentpublic class MyErrorAttribute extends DefaultErrorAttributes { @Override public Map&lt;String, Object&gt; getErrorAttributes(WebRequest webRequest, boolean includeStackTrace) { Map&lt;String, Object&gt; errorAttributes = super.getErrorAttributes(webRequest, includeStackTrace); errorAttributes.put(\"myerror\", \"自定义的异常信息\"); return errorAttributes; }} 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=\"en\" xmlns:th=\"http://www.thymeleaf.org\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;table border=\"1\" cellspacing=\"0\"&gt; &lt;tr&gt; &lt;td&gt;path&lt;/td&gt; &lt;td th:text=\"${path}\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;timestamp&lt;/td&gt; &lt;td th:text=\"${timestamp}\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;message&lt;/td&gt; &lt;td th:text=\"${message}\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;error&lt;/td&gt; &lt;td th:text=\"${error}\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;path&lt;/td&gt; &lt;td th:text=\"${path}\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;status&lt;/td&gt; &lt;td th:text=\"${status}\"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;myerror&lt;/td&gt; &lt;td th:text=\"${myerror}\"&gt;&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt;&lt;/body&gt;&lt;/html&gt; path /111 timestamp Mon Mar 16 21:31:50 GMT+08:00 2020 message No message available error Not Found path /111 status 404 myerror 自定义的异常信息 (3)自定义异常视图自动配置==&gt; org.springframework.boot.autoconfigure.web.servlet.error.ErrorMvcAutoConfiguration==&gt; 123456@Bean @ConditionalOnBean({DispatcherServlet.class}) @ConditionalOnMissingBean({ErrorViewResolver.class}) DefaultErrorViewResolver conventionErrorViewResolver() { return new DefaultErrorViewResolver(this.applicationContext, this.resourceProperties); } 手动配置==&gt; 注意：这里的视图名称在templates文件夹下的任意目录即可 1234567891011121314151617@Componentpublic class MyErrorViewResolver extends DefaultErrorViewResolver { public MyErrorViewResolver(ApplicationContext applicationContext, ResourceProperties resourceProperties) { super(applicationContext, resourceProperties); } @Override public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model) { ModelAndView modelAndView = super.resolveErrorView(request, status, model); //视图的名称 modelAndView.setViewName(\"lc.html\"); modelAndView.addObject(model);// 该Map&lt;String, Object&gt; model不可修改。// 如果我们新增其他的属性 我们可以遍历此map数据取出，然后定义新的map放进ModelAndView中 return modelAndView; }} 视图模板内容和上面的一致 6、springboot跨域问题https://segmentfault.com/a/1190000019550329?utm_source=tag-newest (1)背景​ Same Origin Policy，译为“同源策略”。它是对于客户端脚本（尤其是JavaScript）的重要安全度量标准，其目的在于防止某个文档或者脚本从多个不同“origin”（源）装载。它认为自任何站点装载的信赖内容是不安全的。当被浏览器半信半疑的脚本运行在沙箱时，它们应该只被允许访问来自同一站点的资源，而不是那些来自其它站点可能怀有恶意的资源。​ 注：具有相同的Origin，也即是拥有相同的协议、主机地址以及端口。一旦这三项数据中有一项不同，那么该资源就将被认为是从不同的Origin得来的，进而不被允许访问。 (2)CORS简介​ CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨源(协议 + 域名 + 端口)服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。CORS需要浏览器和服务器同时支持。它的通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX/Fetch通信没有差别，代码完全一样。浏览器一旦发现请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。​ 因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。 浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。 简答请求（HEAD、GET、POST）：不需要试探请求 非简单请求（DELETE,PUT）：Request Method: OPTIONS 需要进行一次试探请求。在正式通信之前，增加一次OPTIONS查询请求，称为”预检”请求（preflight）。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。 详解响应头： Access-Control-Allow-Origin 该字段必填。它的值要么是请求时Origin字段的具体值，要么是一个*，表示接受任意域名的请求。 Access-Control-Allow-Methods该字段必填。它的值是逗号分隔的一个具体的字符串或者*，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次”预检”请求。 Access-Control-Expose-Headers该字段可选。CORS请求时，XMLHttpRequest对象的getResponseHeader()方法只能拿到6个基本字段：Cache-Control、Content-Language、Content-Type、Expires、Last-Modified、Pragma。如果想拿到其他字段，就必须在Access-Control-Expose-Headers里面指定。 Access-Control-Allow-Credentials该字段可选。它的值是一个布尔值，表示是否允许发送Cookie.默认情况下，不发生Cookie，即：false。对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json，这个值只能设为true。如果服务器不要浏览器发送Cookie，删除该字段即可。 Access-Control-Max-Age该字段可选，用来指定本次预检请求的有效期，单位为秒。在有效期间，不用发出另一条预检请求。 顺便提一下，如果在开发中，发现每次发起请求都是两条，一次OPTIONS，一次正常请求，注意是每次，那么就需要配置Access-Control-Max-Age，避免每次都发出预检请求。 (3)实现跨域的方法①最小粒度的cors控制，精确到单个请求级别。@CrossOrigin(&quot;*&quot;) 允许所有请求 @CrossOrigin(&quot;http:localhost:8080&quot;) 只允许http:localhost:8080 123456789@RestControllerpublic class CORSController { @CrossOrigin(\"*\") @GetMapping(\"/doget\") public String doGet(){ return \"doGet\"; }} 从@CrossOrigin注解中==&gt; 该注解可以用于方法上和类上，用于类上，所有该类下的请求都支持该跨域请求。用于方法上，只有该请求支持跨域 123456@Target({ElementType.TYPE, ElementType.METHOD})@Retention(RetentionPolicy.RUNTIME)@Documentedpublic @interface CrossOrigin { //....} ②全局配置1234567891011121314151617@Configurationpublic class WebMvcConfig implements WebMvcConfigurer { @Override public void addCorsMappings(CorsRegistry registry) {// 哪些请求能够跨域(所有) registry.addMapping(\"/**\")// 哪些域能够访问(所有) .allowedOrigins(\"*\")// 哪些请求头(所有) .allowedHeaders(\"*\")// 允许的请求方法类型(所有) .allowedMethods(\"*\")// 会首先发送一个探测请求(若探测许可,即发送真正的请求，否则返回请求失败)// 设定发送探测请求的时间间隔(30s，单位秒) .maxAge(30); }} 1234567891011@RestControllerpublic class CORSController { @GetMapping(\"/doget\") public String doGet(){ return \"doGet\"; } @PutMapping(\"/dopost\") public String doPut(){ return \"doPut\"; }} 另一个域的请求视图==&gt; 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;title&gt;CORS&lt;/title&gt; &lt;script src=\"jquery-3.4.1.js\"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=\"result\"&gt;&lt;/div&gt; &lt;input type=\"button\" value=\"GET\" onclick=\"getData()\"&gt; &lt;input type=\"button\" value=\"PUT\" onclick=\"putData()\"&gt; &lt;script&gt; function getData() { $.get('http://localhost:8081/doget',function (msg) { $(\"#result\").text(msg); }) } function putData() { $.ajax({ type:'PUT', url:'http://localhost:8081/dopost', success:function (msg) { $(\"#result\").text(msg); } }) } &lt;/script&gt;&lt;/body&gt;&lt;/html&gt;d ③过滤器形式配置1234567891011121314@WebFilter(filterName = \"CorsFilter \")@Configurationpublic class CorsFilter implements Filter { @Override public void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException { HttpServletResponse response = (HttpServletResponse) res; response.setHeader(\"Access-Control-Allow-Origin\",\"*\"); response.setHeader(\"Access-Control-Allow-Credentials\", \"true\"); response.setHeader(\"Access-Control-Allow-Methods\", \"POST, GET, PATCH, DELETE, PUT\"); response.setHeader(\"Access-Control-Max-Age\", \"3600\"); response.setHeader(\"Access-Control-Allow-Headers\", \"Origin, X-Requested-With, Content-Type, Accept\"); chain.doFilter(req, res); }} 7、springboot加载xml配置文件resources==&gt; 12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean class=\"org.lc.xml.controller.HelloController\" id=\"sayHello\"&gt;&lt;/bean&gt;&lt;/beans&gt; 12345@Configuration//加载bean.xml配置文件，注入到spring容器中@ImportResource(locations = \"classpath:beans.xml\")public class WebMvcConfig {} 12345public class HelloController { public String sayHello() { return \"say hello\"; }} Test==&gt; 1234567891011@RunWith(SpringRunner.class)@SpringBootTestpublic class XmlTest { @Autowired private HelloController helloController; @Test public void Test1() { String s = helloController.sayHello(); System.out.println(s); }} 9、springboot中使用拦截器定义拦截执行的方法（内容）==&gt; 1234567891011121314151617public class MyInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\"执行之前\"); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\"执行中\"); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(\"执行后\"); }} 注入容器中，并添加新的拦截器==&gt; 12345678910111213@Configurationpublic class WebMvcConfig implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { //添加拦截器，拦截所有请求 registry.addInterceptor(myInterceptor()).addPathPatterns(\"/**\"); } @Bean MyInterceptor myInterceptor(){ return new MyInterceptor(); }} 使用更多配置==&gt; org.springframework.web.servlet.config.annotation.InterceptorRegistration==&gt; 12345678910public class InterceptorRegistration { private final HandlerInterceptor interceptor; private final List&lt;String&gt; includePatterns = new ArrayList(); private final List&lt;String&gt; excludePatterns = new ArrayList(); @Nullable private PathMatcher pathMatcher; private int order = 0; //...... //......} 10、springboot实现系统启动任务注意：两种接口可混用，不冲突 (1)实现CommandLineRunner接口@order(100) 的使用： 默认为最大值2^31-1，即int的范围。 默认最大值表示优先级最低，即执行的顺序 值越大优先级越低，反之值越小优先级越高 1234567891011121314@Component@Order(100)public class MyCommondLineRunnerOne implements CommandLineRunner { /** * 获得启动程序的初始参数 * @param args * @throws Exception */ @Override public void run(String... args) throws Exception { System.out.println(\"MyCommondLineRunnerOne==&gt;&gt;\"+Arrays.toString(args)); }} 1234567891011121314@Component@Order(99)public class MyCommondLineRunnerTwo implements CommandLineRunner { /** * 获得启动程序的初始参数 * @param args * @throws Exception */ @Override public void run(String... args) throws Exception { System.out.println(\"MyCommondLineRunnerTwo==&gt;&gt;\"+Arrays.toString(args)); }} 添加启动参数：①在主程序中,写死即可 123456789@SpringBootApplicationpublic class XmlApplication { public static void main(String[] args) { args=new String[]{ \"org.lc\",\"louchen\" }; SpringApplication.run(XmlApplication.class,args); }} ==&gt; 12MyCommondLineRunnerTwo==&gt;&gt;[org.lc, louchen]MyCommondLineRunnerOne==&gt;&gt;[org.lc, louchen] ②在idea启动的时候配置参数 Edit Configurations =&gt;Environment=&gt;Program agruments 添加参数即可： aaa bbb ==&gt; 12MyCommondLineRunnerTwo==&gt;&gt;[aaa, bbb]MyCommondLineRunnerOne==&gt;&gt;[aaa, bbb] ③以jar包的方式加入启动参数 注意参数之间的空格 java -jar xml-1.0-SNAPSHOT.jar ccc ddd ==&gt; 12MyCommondLineRunnerTwo==&gt;&gt;[ccc, ddd]MyCommondLineRunnerOne==&gt;&gt;[ccc, ddd] (2)实现ApplicationRunner接口123456789101112131415161718192021@Component@Order(102)public class MyApplicationRunnerOne implements ApplicationRunner { @Override public void run(ApplicationArguments args) throws Exception { //获取所有的值 String[] sourceArgs = args.getSourceArgs(); System.out.println(Arrays.toString(sourceArgs)); //获取所有没有键的数据 List&lt;String&gt; nonOptionArgs = args.getNonOptionArgs(); System.out.println(nonOptionArgs); //获取所有的键值对 Set&lt;String&gt; optionNames = args.getOptionNames(); //通过键获取值 //args.getOptionValues(optionName) for (String optionName : optionNames) { System.out.println(optionName+\":\"+args.getOptionValues(optionName)); } System.out.println(\"-------------------MyApplicationRunnerOne------------------------------\"); }} 123456789101112131415161718192021@Component@Order(101)public class MyApplicationRunnerTwo implements ApplicationRunner { @Override public void run(ApplicationArguments args) throws Exception { //获取所有的值 String[] sourceArgs = args.getSourceArgs(); System.out.println(Arrays.toString(sourceArgs)); //获取所有没有键的数据 List&lt;String&gt; nonOptionArgs = args.getNonOptionArgs(); System.out.println(nonOptionArgs); //获取所有的键值对 Set&lt;String&gt; optionNames = args.getOptionNames(); //通过键获取值 //args.getOptionValues(optionName) for (String optionName : optionNames) { System.out.println(optionName+\":\"+args.getOptionValues(optionName)); } System.out.println(\"-------------------MyApplicationRunnerTwo------------------------------\"); }} 添加启动参数：这里我们只采用jar的形式添加参数，其他的方式和上面类似 注意：键值对的参数要 在前面加两个 - java -jar xml-1.0-SNAPSHOT.jar --name=louchen --address=hubei 张三 李四 ==&gt; 12345678910[--name=louchen, --address=hubei, 张三, 李四][张三, 李四]address:[hubei]name:[louchen]-------------------MyApplicationRunnerTwo------------------------------[--name=louchen, --address=hubei, 张三, 李四][张三, 李四]address:[hubei]name:[louchen]-------------------MyApplicationRunnerOne------------------------------ 11、springboot中的restful请求类型https://www.jianshu.com/p/4981911d5e15 @RequestBody与@RequestParam作用与GET,POST,DELETE,PUT请求上不同 加上@RequestBody的参数注解必须以application/json形式传输参数 一个请求体中的所以数据只在被@RequestBody标记中的有效 加上@RequestParam的参数注解必须以url的形式传输参数 (1)GET请求（默认url传参）①无@RequestBody因为GET请求无请求体，所有传输的参数必须以url形式传输参数 请求形式：localhost:8080/hello/?id=1&amp;name=张三&amp;uid=1001 123456789@RestControllerpublic class UserController { @GetMapping(\"/hello\") public User sayGet(User user,String uid) { System.out.println(user); System.out.println(\"uid:\"+uid); return user; }} ②有@RequestBody没有声明在@RequestBody中的参数必须以url形式传参 声明在@RequestBody中的参数必须以请求体的形式传输 请求形式：content-type:application/json localhost:8080/hello/?uid=1001 1234{ \"id\":2, \"name\":\"李四\"} 1234567@GetMapping(\"/hello\") public User sayGet(@RequestBody User user,@RequestParam(\"uid\") String uid) { System.out.println(user); System.out.println(\"uid:\"+uid); return user; }} (2)POST请求(默认x-www-form-urlencoded)①有@RequestBody被@RequestBody标记必须以json的形式传参 没有被@RequestBody标记必须以url的形式传参 请求形式：content-type:application/json localhost:8080/hello/?uid=222 12345{ \"id\":2, \"name\":\"李四\" } 1234567 @PostMapping(\"/hello\") public User sayPost(@RequestBody User user,@RequestParam(\"uid\") String uid){ System.out.println(user); System.out.println(\"uid:\"+uid); return user; }} ②无@RequestBody默认类型content-type:x-www-form-urlencoded 这种类型只是将参数编码放在url地址栏中 所以请求参数放在url中也可以，当是编码content-type:x-www-form-urlencoded过后再放更合理 key value id 3 name 王五 uid 1000 请求参数：:localhost:8080/hello 1234567@PostMapping(\"/hello\") public User sayPost(User user, @RequestParam(\"uid\")String uid){ System.out.println(user); System.out.println(\"uid:\"+uid); return user; }} (3)PUT请求(默认x-www-form-urlencoded)①有@RequestBody请求类型：content-type:application/json 和POST请求方式一致，被标记的参数只能以application/json参数传递，非标记的以url形式传输参数 ②无@RequestBody请求类型：content-type:x-www-form-urlencoded 与POST请求方式一致，只能以x-www-form-urlencoded形式传参。 所以参数编码后放入url地址栏中。 (4)DELETE请求(默认x-www-form-urlencoded)①有@RequestBody请求类型content-type:application/json 和POST请求方式一致，被标记的参数只能以application/json参数传递，非标记的以url形式传输参数 ②无@RequestBody请求类型content-type:x-www-form-urlencoded 与POST请求方式一致，只能以x-www-form-urlencoded形式传参。 所以参数编码后放入url地址栏中。 (5)总结①从content-type方面：form-data、x-www-form-urlencoded：不可以用@RequestBody。可以用@RequestParam。这种请求类型只是将参数编码放入url地址栏中 application/json：json字符串部分可以用@RequestBody；url中的?后面参数可以用@RequestParam。 ②从注解方面@RequestBody 1234(@RequestBody Map map)(@RequestBody Object object)application/json时候可用form-data、x-www-form-urlencoded时候不可用 @RequestParam 12(@RequestParam Map map)application/json时候，json字符串部分不可用，url中的?后面添加参数即可用 12(@RequestParam Object object)不管application/json、form-data、x-www-form-urlencoded都不可用 12、springboot整合servlet,filter,lister(web基础组件)定义servlet==&gt; 12345678910111213// 映射/myservlet请求@WebServlet(urlPatterns = \"/myservlet\")public class MyServlet extends HttpServlet { @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { System.out.println(\"myServlet\"); } @Override protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException { super.doPost(req, resp); }} 定义过滤器==&gt; 123456789//过滤拦截所有请求@WebFilter(urlPatterns = \"/*\")public class MyFilter implements Filter { @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { System.out.println(\"myFilter\"); filterChain.doFilter(servletRequest, servletResponse); }} 定义监听器==&gt; 123456789101112131415//标记此类为监听器//根据监听器的不同类型实现不同的监听器的接口//实现请求的监听器@WebListenerpublic class MyRequestListener implements ServletRequestListener { @Override public void requestDestroyed(ServletRequestEvent sre) { System.out.println(\"requestListenerDestroyed\"); } @Override public void requestInitialized(ServletRequestEvent sre) { System.out.println(\"requestListenerInitialized\"); }} 扫描servlet,listener,filter @ServletComponentScan(basePackages = &quot;org.lc.xml.servlet&quot;) 扫描指定包下servlet组件 12345678@SpringBootApplication//扫描所有的servlet,filter,listener@ServletComponentScan(basePackages = \"org.lc.xml.servlet\")public class XmlApplication { public static void main(String[] args) { SpringApplication.run(XmlApplication.class,args); }} 请求路径：http://localhost:8080/myservlet 输出顺序: ServletRequestListener监听器请求初始化=&gt; 过滤器执行==&gt; Servlet执行=&gt; ServletRequestListener监听器请求销毁 1234requestListenerInitializedmyFiltermyServletrequestListenerDestroyed 当有springboot中的拦截器时： 注意:这里的拦截器只对controller中的请求有效，对servlet中定义的请求无效 1234567891011121314151617public class MyInterceptor implements HandlerInterceptor { @Override public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception { System.out.println(\"执行之前\"); return true; } @Override public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception { System.out.println(\"执行中\"); } @Override public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception { System.out.println(\"执行后\"); }} 123456789101112@Configurationpublic class WebMvcConfig implements WebMvcConfigurer { @Override public void addInterceptors(InterceptorRegistry registry) { registry.addInterceptor(myInterceptor()).addPathPatterns(\"/**\"); } @Bean MyInterceptor myInterceptor(){ return new MyInterceptor(); }} srtvlet请求:http://localhost:8080/myservlet 1234requestListenerInitializedmyFiltermyServletrequestListenerDestroyed controller请求：http://localhost:8080/say 请求结果==&gt; 123456requestListenerInitializedmyFilter执行之前执行中执行后requestListenerDestroyed 12345678@RestControllerpublic class UserController { @GetMapping(\"/say\") public String sayHello(){ return \"say hello\"; }} 13、springboot中的路径映射当我们只需要返回一个页面时，通常做法,使用控制器返回一个页面（这里使用thmeleaf模板引擎） 1234567@Controllerpublic class LoginController { @GetMapping(\"/login\") public String loginView() { return \"login\"; }} 这里我们摒弃上面的这个做法： 只需要实现WebMvcConfigurer接口即可 123456789@Configurationpublic class WebMvcConfig implements WebMvcConfigurer { @Override public void addViewControllers(ViewControllerRegistry registry) { //添加请求的路径 响应的视图名称 registry.addViewController(\"/login\").setViewName(\"login\"); registry.addViewController(\"/register\").setViewName(\"register\"); }} 14、springboot中使用类型转换器其中S代表需要转换的参数类型 T代表要转成的目标参数类型 12345@FunctionalInterfacepublic interface Converter&lt;S, T&gt; { @Nullable T convert(S var1);} 实现转换器接口==&gt; 1234567891011121314151617@Componentpublic class DateConventer implements Converter&lt;String, Date&gt; { private SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyyy-MM-dd\"); @Override public Date convert(String s) { if (s != null &amp;&amp; !s.equals(\"\")) { try { return simpleDateFormat.parse(s); } catch (ParseException e) { e.printStackTrace(); } } return null; }} 1234567@RestControllerpublic class LoginController { @GetMapping(\"/birthday\") public void sayHello(Date date) { System.out.println(date); }} 请求：http://localhost:8080/birthday/?date=2019-01-01 15、springboot使用AOP1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-aop&lt;/artifactId&gt;&lt;/dependency&gt; 1234567891011@Servicepublic class EmpService { public String getAllEmp(){ System.out.println(\"getAllEmp--service\"); return \"查询所有成功\"; } public String deleteEmpById(Integer id){ System.out.println(\"deleteEmpById--service\"); return \"修改成功\"; }} 1234567891011121314151617@RestControllerpublic class EmpController { @Autowired private EmpService empService; @GetMapping(\"/allEmp\") public String getAllEmp(){ String allEmp = empService.getAllEmp(); System.out.println(allEmp); return \"getAllEmp--controller\"; } @DeleteMapping(\"/delEmp\") public String deleteEmp(){ String s = empService.deleteEmpById(12); System.out.println(s); return \"deleteEmp--controller\"; }} 定义切面文件==&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495@Component//定义类为切面(切点和通知的结合)@Aspectpublic class AopLogger { /** * 定义切点表达式 用来确定哪些类需要代理 * 切点表达式定义：==&gt; * ①方法的可见性 如public，protected；（可省略） （不可用*表示，但是可省略） * ②方法的返回类型 如int，void等；（*代表任意类型） * ③方法所在类的全包名，如com.spring.Aspect； * ④所在类的全名；（*代表该包下的所有类） * ⑤所在类的方法全名 （*代表该类下的所有方法） * ⑥方法的个数 （..代表0个或多个） */ @Pointcut(\"execution(public * org.lc.xml.service.*.*(..))\") public void pc1(){ }// 定义通知// 即对拦截的方法的处理方式（时机） /** * 定义前置通知（代理的方法执行之前的通知） * @param joinPoint JoinPoint对象封装了SpringAop中切面方法的信息, * 在切面方法中添加JoinPoint参数,就可以获取到封装了该方法信息的JoinPoint对象. */ @Before(\"pc1()\") public void before(JoinPoint joinPoint) { String name = joinPoint.getSignature().getName(); System.out.println(\"前置通知执行的方法:\"+name); } /** * 定义后置通知（代理方法执行之后执行的通知） * @param joinPoint */ @After(\"pc1()\") public void after(JoinPoint joinPoint) { String name = joinPoint.getSignature().getName(); System.out.println(\"后置通知执行的方法:\"+name); } /** * 定义返回通知（方法执行完毕执行的通知） * @param joinPoint * @param result 该代理的方法的返回值 * 在注解上的returning = \"result\"则只会匹配只有返回值的方法 */ @AfterReturning(value = \"pc1()\", returning = \"result\") public void afterReturning(JoinPoint joinPoint, Object result) { String name = joinPoint.getSignature().getName(); System.out.println(\"返回通知执行的方法:\"+name+\",该代理方法的返回值为:\"+result); } /** * 定义异常通知（方法执行异常之后的通知） * @param joinPoint * @param e */ @AfterThrowing(value = \"pc1()\",throwing = \"e\") public void afterThrowing(JoinPoint joinPoint,Exception e) { String name = joinPoint.getSignature().getName(); System.out.println(\"异常通知执行的方法:\"+name+\",该方法的异常为:\"+e.getMessage()); } /** * 定义环绕通知 (可同时使用上面的四种通知) * proceedingJoinPoint.proceed();代表执行代理的该方法 */ @Around(value = \"pc1()\") public Object around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable { //调用该方法之前的处理的代码（相当于前置通知） System.out.println(\"------前置通知-around\"); Object proceed = null; try { proceed = proceedingJoinPoint.proceed(); //注意这里的后置通知只是在环绕通知中代理方法的返回之前提前处理了 // 实际在@After是在@AfterReturning之前执行的 //使用该proceed变量，对其进行处理的代码。（相当于返回通知） System.out.println(\"-------返回通知-around\"); } catch (Throwable throwable) { //对异常处理的代码（相当于异常通知） System.out.println(\"------异常通知-around\"); throwable.printStackTrace(); }// 注意：这里的后置通知只是在环绕通知中代理方法的返回之前提前处理了// 实际在@After是在@AfterReturning之前执行的 //调用该方法之后之后处理的代码（相当于后置通知） System.out.println(\"-------后置通知---around\"); //该返回语句执新之前的所有代码 都是未正真正执行的。 return proceed; }} 执行的结果为==&gt; 12345678------前置通知-around前置通知执行的方法:getAllEmpgetAllEmp--service-------返回通知-around-------后置通知---around后置通知执行的方法:getAllEmp返回通知执行的方法:getAllEmp,该代理方法的返回值为:查询所有成功查询所有成功 总结执行的顺序==&gt; 123456789101112@Around先进入环绕通知==&gt;处理环绕通知proceed = proceedingJoinPoint.proceed()方法之前的代码（相当于前置通知）@After进入前置通知@Around处进入环绕通知proceed = proceedingJoinPoint.proceed()方法之后的代码（相当于后置通知和返回通知）若出现异常则直接执行@Around中catch的代码（相当于异常通知）@After进入后置通知@AfterReturning进入返回通知 16、springboot自定义欢迎页这里我们使用thmeleaf 1234567@Controllerpublic class IndexController { @GetMapping(\"/index\") public String index() { return \"index\"; }} 默认启动服务器：localhost:8080 首先访问static中的index.html页面 再访问templates中的index.html页面 17、springboot自定义favicon.icohttps://tool.lu/favicon/ 将favicon.ico放在resources下或static下即可 static下的优先级高于resources 当出现无法访问图标的时候： 12345678910@Configurationpublic class WebMvcConfig implements WebMvcConfigurer { @Override public void addResourceHandlers(ResourceHandlerRegistry registry) { //放在resources下 registry.addResourceHandler(\"/favicon.ico\").addResourceLocations(\"classpath:/\"); //放在static下 //registry.addResourceHandler(\"/favicon.ico\").addResourceLocations(\"classpath:/static/\"); }} 18、springboot排除自动配置排除不需要的自动配置(所有自动配置全部失效) 123456@SpringBootApplication(exclude = WebMvcAutoConfiguration.class)public class XmlApplication { public static void main(String[] args) { SpringApplication.run(XmlApplication.class,args); }} 或者==&gt; 123spring: autoconfigure: exclude: org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration 注解①@ResponseBody响应json数据 ②@RestController@Controller@ResponseBody ③@JsonFormat(pattern = “yyyy-MM-dd”,timezone = “GMT+8”)④@DateTimeFormat(pattern = &quot;yyyy-MM-dd&quot;)注解@JsonFormat主要是后台到前台的时间格式的转换 注解@DataFormAT主要是前后到后台的时间格式的转换 123@DateTimeFormat(pattern = \"yyyy-MM-dd\") @JsonFormat(pattern = \"yyyy-MM-dd\",timezone = \"GMT+8\") private Date birthday; ⑤@configuration和@component的区别总结：@configuration+@Bean（注入的单例） @component+@Bean（注入的多例） https://blog.csdn.net/long476964/article/details/80626930 @Configuration是随容器启动开始加载的,始终存在的单例模式。 @Component中的bean使用一次即实例化一次 @configuration使用cglid动态代理==&gt; 12345678910111213@Configurationpublic class MyBeanConfig { @Bean public Country country(){ return new Country(); } @Bean public UserInfo userInfo(){ return new UserInfo(country()); }} 直接调用 country() 方法返回的是同一个实例 @Component 注解并没有通过 cglib 来代理@Bean 方法的调用==&gt; 12345678910111213@Componentpublic class MyBeanConfig { @Bean public Country country(){ return new Country(); } @Bean public UserInfo userInfo(){ return new UserInfo(country()); }} 每次调用country(),每次都会创建一个实例 ⑥@PropertySource(“classpath:person.properties”)导入properties文件 ⑦@ImportResource(locations = “classpath:beans.xml”)导入配置的xml文件 ⑧@Bean @scope(“singleton”)在Spring中，bean可以被定义为两种模式：prototype（多例）和singleton（单例） singleton（单例）：只有一个共享的实例存在，所有对这个bean的请求都会返回这个唯一的实例。 prototype（多例）：对这个bean的每次请求都会创建一个新的bean实例，类似于new。 Spring bean 默认是单例模式。 123456789101112131415161718191.singleton单例模式, 全局有且仅有一个实例2.prototype原型模式， 每次获取Bean的时候会有一个新的实例3.request request表示该针对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP request内有效，4.session session作用域表示该针对每一次HTTP请求都会产生一个新的bean，同时该bean仅在当前HTTP session内有效5.global sessionglobal session作用域类似于标准的HTTP Session作用域，不过它仅仅在基于portlet的web应用中才有意义。Portlet规范定义了全局Session的概念，它被所有构成某个 portlet web应用的各种不同的portlet所共享。在global session作用域中定义的bean被限定于全局portlet Session的生命周期范围内。如果你在web中使用global session作用域来标识bean，那么web会自动当成session类型来使用。 ⑨容器的单例和多例@Component注解默认实例化的对象是单例，如果想声明成多例对象可以使用@Scope(“prototype”) @Repository默认单例 @Service默认单例 @Controller默认多例 ⑩@order(100)默认为最大值2^31-1，即int的范围。 默认最大值表示优先级最低，即执行的顺序 值越大优先级越低，反之值越小优先级越高 ⑪@RequestBody @RequestParam@RequestBody==&gt; 顾明思意，请求必须是以请求体的形式接受参数 @RequestParam==&gt; 以url传参 ⑫import(configuration.class)导入java的配置文件 被@Configuration标记的文件 ⑬@ConfigurationProperties(prefix = “person”)yaml,properties文件属性配置注入 ⑭@Configuration详解https://www.cnblogs.com/duanxz/p/7493276.html 从Spring3.0，@Configuration用于定义配置类，可替换xml配置文件，被注解的类内部包含有一个或多个被@Bean注解的方法，这些方法将会被AnnotationConfigApplicationContext或AnnotationConfigWebApplicationContext类进行扫描，并用于构建bean定义，初始化Spring容器。 注意：@Configuration注解的配置类有如下要求： @Configuration不可以是final类型； @Configuration不可以是匿名类； 嵌套的configuration必须是静态类。 一、用@Configuration加载spring1.1、@Configuration配置spring并启动spring容器1.2、@Configuration启动容器+@Bean注册Bean1.3、@Configuration启动容器+@Component注册Bean1.4、使用 AnnotationConfigApplicationContext 注册 AppContext 类的两种方法**1.5、配置Web应用程序(web.xml中配置AnnotationConfigApplicationContext)** 二、组合多个配置类2.1、在@configuration中引入spring的xml配置文件2.2、在@configuration中引入其它注解配置2.3、@configuration嵌套（嵌套的Configuration必须是静态类）三、@EnableXXX注解四、@Profile逻辑组配置五、使用外部变量 @ConditionalOnProperty(name = “swagger.enable”, havingValue = “true”)@ConditionalOnProperty来控制Configuration是否生效 通过其两个属性name以及havingValue来实现的，其中name用来从application.properties中读取某个属性值。如果该值为空，则返回false;如果值不为空，则将该值与havingValue指定的值进行比较，如果一样则返回true;否则返回false。如果返回值为false，则该configuration不生效；为true则生效。 1swagger.enable=true","link":"/2020/04/17/springboot/springboot%E5%9F%BA%E7%A1%80%E6%95%B4%E5%90%88%E9%85%8D%E7%BD%AE/"},{"title":"Redis的Scan命令","text":"Redis的ScanRedis中有一个经典的问题，在巨大的数据量的情况下，做类似于查找符合某种规则的Key的信息，这里就有两种方式，一是keys命令，简单粗暴，由于Redis单线程这一特性，keys命令是以阻塞的方式执行的，keys是以遍历的方式实现的复杂度是 O(n），Redis库中的key越多，查找实现代价越大，产生的阻塞时间越长。二是scan命令，以非阻塞的方式实现key值的查找，绝大多数情况下是可以替代keys命令的，可选性更强 keys的缺点： 1、没有limit，我们只能一次性获取所有符合条件的key，如果结果有上百万条，那么等待你的就是“无穷无尽”的字符串输出。 2、keys命令是遍历算法，时间复杂度是O(N)。如我们刚才所说，这个命令非常容易导致Redis服务卡顿。因此，我们要尽量避免在生产环境使用该命令。 scan的优点： scan命令的时间复杂度虽然也是O(N)，但它是分次进行的，不会阻塞线程。 scan命令提供了limit参数，可以控制每次返回结果的最大条数。 一、Scan的简单介绍scan 实际上是 keys 的一个升级版。可以用 keys 来查询 key，在查询的过程中，可以使用通配符。keys 虽然用着还算方便，但是没有分页 功能。同时因为 Redis 是单线程，所以 key 的执行会比较消耗时间，特别是当数据量大的时候，影响整 个程序的运行。为了解决 keys 存在的问题，从 Redis2.8 中开始，引入了 scan。scan 具备 keys 的功能，但是不会阻塞线程，而且可以控制每次返回的结果数。 二、基本用法1、数据准备先准备一千条测试数据 jedis测试工具： pom.xml 1234567&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;3.2.0&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; CallWithJedis 123public interface CallWithJedis { void call(Jedis jedis);} Redis 1234567891011121314151617181920212223242526272829303132public class Redis { private JedisPool jedisPool; public Redis() {// 连接池配置对象 GenericObjectPoolConfig config=new GenericObjectPoolConfig();// 连接池最大空闲数 config.setMaxIdle(300);// 最大连接数 config.setMaxTotal(1000);// 连接最大等待时间（毫秒）。-1表示无限制 config.setMaxWaitMillis(30000);// 在空闲时检查有效性 config.setTestOnBorrow(true); /** * 1、连接池配置 * 2、redis地址 * 3、端口 * 4、超时时间 * 5、密码 */ jedisPool = new JedisPool(config, \"主机\",6379,30000,\"密码\"); } public void execute(CallWithJedis callWithJedis) { try (Jedis jedis=jedisPool.getResource()) { callWithJedis.call (jedis); } }} 12345678910public class ScanTest { public static void main(String[] args) { Redis redis=new Redis(); redis.execute(jedis -&gt; { for (int i = 0; i &lt; 1000; i++) { jedis.set(\"k\" + i, \"v\" + i); } }); }} scan 命令一共提供了三个参数，第一个 cursor，第二个参数是 key，第三个参数是 limit。 cursor 实际上是指一维数组的位置索引，limit 则是遍历的一维数组个数（所以每次返回的数据大小可 能不确定）。 2、scan命令使用SCAN命令是一个基于游标的迭代器。这意味着命令每次被调用都需要使用上一次这个调用返回的游标作为该次调用的游标参数，以此来延续之前的迭代过程。 https://www.cnblogs.com/wy123/p/10955153.html cursor ：游标，遍历的起始位置，一般从0开始 MATCH ：模糊匹配的键 COUNT : COUNT是指本次遍历时, 要遍历多少个元素（不指定count,默认只遍历10个） SCAN cursor [MATCH pattern] [COUNT count] 123456789101112scan 0 match k8* count 100 1) \"360\"2) 1) \"k832\" 2) \"k806\" 3) \"k89\" 4) \"k80\" 5) \"k856\" 6) \"k870\" 7) \"k805\" 8) \"k809\" 9) \"k858\" 注意：上面返回的1)中的360表示下次游标遍历的起始位置 当游标输出为0时，即遍历完毕，回到起始位置 三、基本原理https://www.jianshu.com/p/be15dc89a3e8 1、Redis的结构Redis使用了Hash表作为底层实现，原因不外乎高效且实现简单。说到Hash表，很多Java程序员第一反应就是HashMap。没错，Redis底层key的存储结构就是类似于HashMap那样数组+链表的结构。其中第一维的数组大小为2n(n&gt;=0)。每次扩容数组长度扩大一倍。 scan命令就是对这个一维数组进行遍历。每次返回的游标值也都是这个数组的索引。limit参数表示遍历多少个数组的元素，将这些元素下挂接的符合条件的结果都返回。因为每个元素下挂接的链表大小不同，所以每次返回的结果数量也就不同。 2、scan的遍历顺序首先加入下面的key 1234127.0.0.1:6379&gt; keys *1) \"db_number\"2) \"key1\"3) \"myKey\" 遍历key 123456789101112127.0.0.1:6379&gt; scan 0 MATCH * COUNT 11) \"2\"2) 1) \"db_number\"127.0.0.1:6379&gt; scan 2 MATCH * COUNT 11) \"1\"2) 1) \"myKey\"127.0.0.1:6379&gt; scan 1 MATCH * COUNT 11) \"3\"2) 1) \"key1\"127.0.0.1:6379&gt; scan 3 MATCH * COUNT 11) \"0\"2) (empty list or set) 在遍历的过程中，大家发现游标的顺序是 0 2 1 3，从十进制来看好像没有规律，但是从转为二进制， 则是有规律的：00-&gt;10-&gt;01-&gt;11这种规律就是高位进1，传统的二进制加法，是从右往左加，这里是从左往右加。实际上，在 Redis 中，它的具体计算流程给是这样： 将要计算的数字反转 给反转后的数字加 1 再反转 那么为什么不是按照 0、1、2、3、4…这样的顺序遍历呢？因为主要考虑到两个问题： 字典扩容 字典缩容 假如我们将要访问 110 时，发生了扩容，此时 scan 就会从 0110 开始遍历，之前已经被遍历过的元素 就不会被重复遍历了。假如我们将要访问 110 时，发生缩容，此时 scan 就会从 10 开始遍历，这个时候，也会遍历到 010， 但是 010 之前的不会再被遍历了。所以，在发生缩容的时候，可能返回重复的元素 四、Scan的其他指令scan 是一系列的指令，除了遍历所有的 key 之外，也可以遍历某一个类型的 key，对应的命令有： zscan–&gt;zset hscan–&gt;hash sscan–&gt;set 用法和scan一致","link":"/2020/04/30/redis/Redis%E4%B9%8BScan/"},{"title":"Redis实现GEO地理位置","text":"Redis之GEORedis3.2 开始提供了 GEO 模块。该模块也使用了 GeoHash 算法。 一、GEOHash算法核心思想：GeoHash 是一种地址编码方法，使用这种方式，能够将二维的空间经纬度数据编码成一个 一维字符串。 以经过伦敦格林尼治天文台旧址的经线为 0 度经线，向东就是东经，向西就是西经。如果我们将西经定 义负，经度的范围就是 [-180,180]。 纬度北纬 90 度到南纬 90 度，如果我们将南纬定义负，则纬度的范围就是 [-90,90]。 接下来，以本初子午线和赤道为界，我们可以将地球上的点分配到一个二维坐标中： GeoHash 算法就是基于这样的思想，划分的次数越多，区域越多，每个区域中的面积就更小了，精确 度就会提高。GeoHash 具体算法：以北京天安门广场为例（39.9053908600,116.3980007200）： ①.纬度的范围在 (-90,90) 之间，中间值为 0，对于 39.9053908600 值落在 (0,90),因此得到的值为 1 ②.(0,90) 的中间值为 45，39.9053908600 落在 (0,45) 之间，因此得到一个 0 ③.(0,45) 的中间值为 22.5，39.9053908600 落在 (22.5,45)之间，因此得到一个 1 ④. …. 这样，我们得到的纬度二进制是 101 按照同样的步骤，我们可以算出来经度的二进制是 110 接下来将经纬度合并（经度占偶数位，纬度占奇数位）：111001 按照 Base32 （0-9,b-z,去掉 a i l 0）对合并后的二进制数据进行编码，编码的时候，先将二进制转换为 十进制，然后进行编码。 将编码得到的字符串，可以拿去 geohash.org 网站上解析。 GeoHash 特点：1、用一个字符串表示经纬度 2、 GeoHash 表示的是一个区域，而不是一个点。 3、编码格式有规律，例如一个地址编码之后的格式是 123，另一个地址编码之后的格式是 123456， 从字符串上就可以看出来，123456 处于 123 之中。 经纬度查询：http://www.gpsspg.com/maps.htm 二、GEO在Redis中的使用1、添加地址longitude:经度 latitude:纬度 geoadd [key] [longitude] [latitude] [member] 12geoadd city 121.4737000000 31.2303700000 shanghai ##添加上海的位置geoadd city 114.3052500000 30.5927600000 wuhan ##添加武汉位置 2、查看两个地址之间的距离unit: 默认为 m(米)，可选为 m , km , ft (英尺)，mi(英里) geodist [key] [member1] [member2] [unit] 123geoadd city shanghai wuhan km \"687.6116\" 3、获取元素的位置geopos [key] [member...] 1234geopos city shanghai1) 1) \"121.4736977219581604\" 2) \"31.23036910904709629\" 4、获取元素hash值geohash [key] [member...] 123geohash city wuhan1) \"wt3q114x9r0\" 通过解析的哈希地址，我们可以查看其定位 http://geohash.org/wt3q114x9r0 30.59276 114.30525 5、查看附近的地址(通过成员)key:指定key member:以该地点为中心 radius:距离该中心的半径距离 unit:距离单位 withcoord:经纬度 withhash：hash值 withdist:半径距离 count:显示的数量 asc/desc:升序或者降序 georadiusbymeber [key] [member] [radius] [unit] [withcoord] [withhash] [withdist] [Count count] [asc|desc] 123456789101112131415161718#查询以武汉为中心，距离武汉3000km的3个地点（包括武汉本身），并且显示经纬度，hash值，半径距离，结果以距离的降序排列GEORADIUSBYMEMBER city wuhan 3000 km withcoord withhash withdist count 3 desc1) 1) \"beijing\" 2) \"1049.6601\" 3) (integer) 4069152897912916 4) 1) \"116.49902611970901489\" 2) \"39.85915559490933191\"2) 1) \"guangzhou\" 2) \"858.8102\" 3) (integer) 4046518432493551 4) 1) \"113.35693091154098511\" 2) \"22.91792342803383775\"3) 1) \"jinan\" 2) \"703.7194\" 3) (integer) 4065887515903236 4) 1) \"117.15820580720901489\" 2) \"36.45663716057446635\" 6、查看附件的地址(通过经纬度)GEORADIUSBYMEMBER city wuhan 3000 km withcoord withhash withdist count 3 desc 把上面的wuhan元素替换成经经纬度即可： GEORADIUS city 114.3052500000 30.5927600000 3000 km withcoord withhash withdist count 3 desc","link":"/2020/04/30/redis/Redis%E5%9C%B0%E7%90%86%E4%BD%8D%E7%BD%AEGEO/"},{"title":"Redis通信协议","text":"Redis通信协议Redis 通信使用了文本协议，文本协议比较费流量，但是 Redis 作者认为数据库的瓶颈不在于网络流 量，而在于内部逻辑，所以采用了这样一个费流量的文本协议。这个文本协议叫做 Redis Serialization Protocol，简称 RESP。 Redis 协议将传输的数据结构分为 5 种小单元，单元结束时，加上回车换行符 \\r\\n。 单行字符串以 + 开始，例如 +javaboy.org\\r\\n 多行字符串以$ 开始，后面加上字符串长度，例如 $11\\r\\njavaboy.org\\r\\n 整数值以: 开始，例如 :1024\\r\\n 错误消息以 - 开始 数组以 * 开始，后面加上数组长度。 需要注意的是，如果是客户端连接服务端，只能使用第 5 种 一、修改redis.conf配置文件为了方便客户端连接 Redis，我们关闭 Redis 种的保护模式(在 redis.conf 文件中) 注释无需密码 1#requirepass xxx 关闭保护模式 1protected-mode no 二、自定义redis客户端操作123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110package org.lc.resp;import org.omg.CORBA.PUBLIC_MEMBER;import java.io.IOException;import java.net.Socket;import java.util.Scanner;import java.util.logging.Level;/** * @BelongsProject: resp * @BelongsPackage: org.lc.resp * @Author: lc * @CreateTime: 2020-05-01 12:07 * @Description: */public class LcRedisClient { private Socket socket; public LcRedisClient() { try { socket = new Socket(\"主机\", 6379); } catch (IOException e) { e.printStackTrace(); System.out.println(\"Redis连接失败\"); } } /** * 定义set命令，该命令为数组形式[set,key,value] * @param key * @param value * @return */ public String set(String key, String value) throws IOException { StringBuilder sb=new StringBuilder();// 该数组命令的长度为3 sb.append(\"*3\") .append(\"\\r\\n\")// 插入多行字符串 .append(\"$\")// 并设置字符串长度 .append(\"set\".length()) .append(\"\\r\\n\") .append(\"set\") .append(\"\\r\\n\")// 插入多行字符串 .append(\"$\")// 传入key的长度 若为中文则需要使用byte数组获取长度 .append(key.getBytes().length) .append(\"\\r\\n\") .append(key) .append(\"\\r\\n\")// 插入多行字符串 .append(\"$\")// 设置长度 .append(value.getBytes().length) .append(\"\\r\\n\") .append(value) .append(\"\\r\\n\"); System.out.println(sb.toString());// 写入socket socket.getOutputStream().write(sb.toString().getBytes()); byte[] buf = new byte[1024];// 得到socket服务端返回的数据 socket.getInputStream().read(buf);// 返回服务端的数据 return new String(buf); } /** * 定义get命令 [get key] * @param key * @return */ public String get(String key) throws IOException { StringBuilder sb=new StringBuilder();// 定义数组命令数组长度 sb.append(\"*2\") .append(\"\\r\\n\") .append(\"$\") .append(\"get\".length()) .append(\"\\r\\n\") .append(\"get\") .append(\"\\r\\n\") .append(\"$\") .append(key.getBytes().length) .append(\"\\r\\n\") .append(key) .append(\"\\r\\n\"); System.out.println(sb.toString()); socket.getOutputStream().write(sb.toString().getBytes()); byte[] but = new byte[1024]; socket.getInputStream().read(but); return new String(but); } public static void main(String[] args) { LcRedisClient redisClient=new LcRedisClient(); try {// String set = redisClient.set(\"k1\", \"louchen\");// System.out.println(set); String s = redisClient.get(\"k1\"); Systedm.out.println(s); } catch (IOException e) { e.printStackTrace(); } }} 输出结果分析： set操作 1234567891011*3$3set$2k1$7louchen//以上为在stringbuilder拼接的命令+OK//以上为服务端输出的结果 get操作 1234567891011*2$3get$2k1//以上为在stringbuilder拼接的命令$7louchen//get操作返回两个命令。$7表示返回多行字符串并指定长度","link":"/2020/05/01/redis/Redis%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE/"},{"title":"Redis单线程怎样处理高并发？","text":"Redis单线程怎样处理高并发？一、阻塞IO和非阻塞IO怎样理解阻塞IO,非阻塞IO,同步和异步 ：https://www.zhihu.com/question/19732473 Java 在 JDK1.4 中引入 NIO，但是也有很多人在使用阻塞 IO，这两种 IO 有什么区别？ 在阻塞模式下，如果你从数据流中读取不到指定大小的数据两，IO 就会阻塞。比如已知会有 10 个字节 发送过来，但是我目前只收到 4 个，还剩六个，此时就会发生阻塞。如果是非阻塞模式，虽然此时只收 到 4 个字节，但是读到 4 个字节就会立即返回，不会傻傻等着，等另外 6 个字节来的时候，再去继续读 取。 所以阻塞 IO 性能低于 非阻塞 IO。 如果有一个 Web 服务器，使用阻塞 IO 来处理请求，那么每一个请求都需要开启一个新的线程；但是如 果使用了非阻塞 IO，基本上一个小小线程池就够用了，因为不会发生阻塞，每一个线程都能够高效利 用。 二、Redis的线程模型首先一点，Redis 是单线程。单线程如何解决高并发问题的？实际上，能够处理高并发的单线程应用不仅仅是 Redis，除了 Redis 之外，还有 NodeJS、Nginx 等等 也是单线程。 Redis 虽然是单线程，但是运行很快，主要有如下几方面原因： Redis 中的所有数据都是基于内存的，所有的计算也都是内存级别的计算，所以快。 Redis 是单线程的，所以有一些时间复杂度高的指令，可能会导致 Redis 卡顿，例如 keys。 Redis 在处理并发的客户端连接时，使用了非阻塞 IO 在使用非阻塞 IO 时，有一个问题，就是线程如何知道剩下的数据来了？ https://www.jianshu.com/p/6a6845464770 这里就涉及到一个新的概念叫做多路复用，本质上就是一个事件轮询 API。 Redis 会给每一个客户端指令通过队列来排队进行顺序处理。 Redis 做出响应时，也会有一个响应的队列。","link":"/2020/05/01/redis/Redis%E5%8D%95%E7%BA%BF%E7%A8%8B%E5%A4%84%E7%90%86%E9%AB%98%E5%B9%B6%E5%8F%91/"},{"title":"Redis事务","text":"Redis事务​ 正常来说，一个可以商用的数据库往往都有比较完善的事务支持，Redis 当然也不例外。相对于 关系型 数据库中的事务模型，Redis 中的事务要简单很多。因为简单，所以 Redis 中的事务模型不太严格，所 以我们不能像使用关系型数据库中的事务那样来使用 Redis。 在关系型数据库中，和事务相关的三个指令分别是： begin commit callback 在 Redis 中，当然也有对应的指令： multi(开启事务) 标记一个事务块的开始（ queued ） exec (执行事务) 执行所有事务块的命令 （ 一旦执行exec后，之前加的监控锁都会被取消掉 ） discard(事务回滚) 关系型数据库中ACID事务四大特性： 原子性（Atomicity）原子性是指事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。 一致性（Consistency）事务前后数据的完整性必须保持一致。即操作完成的状态必须一致 隔离性（Isolation）事务的隔离性是多个用户并发访问数据库时，数据库为每一个用户开启的事务，不能被其他事务的操作数据所干扰，多个并发事务之间要相互隔离。 持久性（Durability）持久性是指一个事务一旦被提交，它对数据库中数据的改变就是永久性的，接下来即使数据库发生故障也不应该对其有任何影响 Redis事务的概念：​ Redis 事务的本质是一组命令的集合。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。 总结说：redis事务就是一次性、顺序性、排他性的执行一个队列中的一系列命令。 Redis没有事务的隔离级别的概念：​ 批量操作在发送 EXEC 命令前被放入队列缓存，并不会被实际执行，也就不存在事务内的查询要看到事务里的更新，事务外查询不能看到。 Redis事务的三个阶段： 开始事务 命令入队 执行事务 Redis不保证原子性​ Redis中，单条命令是原子性执行的，但事务不保证原子性，且没有回滚。事务中任意命令执行失败，其余的命令仍会被执行。 注意，Redis 中的事务并不能算作原子性。它仅仅具备隔离性，也就是说当前的事务可以不被其他事务 打断。 由于每一次事务操作涉及到的指令还是比较多的，为了提高执行效率，我们在使用客户端的时候，可以 通过 pipeline 来优化指令的执行。 如下操作： multl/exec: 事务开启–执行 123456789101112131415161718192021127.0.0.1:6379&gt; multi #开启事务OK127.0.0.1:6379&gt; set k1 v1 #操作1QUEUED 127.0.0.1:6379&gt; set k2 v2 #操作2QUEUED127.0.0.1:6379&gt; INCR k1 #给k1键的值自增1，操作失败QUEUED127.0.0.1:6379&gt; exec #执行事务#结果1) OK2) OK3) (error) ERR value is not an integer or out of range #只有第三个操作失败 #结论 事务并没有因为一个操作失败而回滚其他事务，只是具备其隔离性。127.0.0.1:6379&gt; get k1\"v1\"127.0.0.1:6379&gt; keys *1) \"k1\"2) \"k2\" 1、非隔离性事务案例 案例：银行转账 ①、初始化余额： 1set money 1000 ②、开启一个线程A执行取钱操作： 注意此时，我们并没有提交事务 1234127.0.0.1:6379&gt; multi #开启事务OK127.0.0.1:6379&gt; set money 0QUEUED ③、开启另外一个线程B存钱操作 开启事务，并且提交事务。 123456127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set money 3000QUEUED127.0.0.1:6379&gt; exec #提交事务1) OK ④、线程B操作完之后，这是恰好线程A完成取钱操作 12345678127.0.0.1:6379&gt; multi OK127.0.0.1:6379&gt; set money 0QUEUED127.0.0.1:6379&gt; exec 1) OK127.0.0.1:6379&gt; get money\"0\" 这时我们发现存钱的操作没有完成。导致出现事务的非隔离性 2、watch指令​ watch指令类似于乐观锁，在事务提交时，如果watch监控的多个KEY中任何KEY的值已经被其他客户端更改，则使用EXEC执行事务时，事务队列将不会被执行，同时返回Nullmulti-bulk应答以通知调用者事务执行失败。 在Redis中，提供一个watch指令来监控一个key,通过这种监控，我们可以确保在 exec 之前，watch 的键的没有被修改过。 如果一个被watch监控的key被其他事务改变，那么当前事务所操作的就会失败 初始化余额 1set money 1000 ①监视money 开启一个线程A执行取钱操作 注意：这里未提交事务 123456127.0.0.1:6379&gt; watch money #监视要操作的keyOK127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set money 0QUEUED ②开启另一个线程B执行存钱操作 123456127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set money 3000QUEUED127.0.0.1:6379&gt; exec1) OK ③这是B线程执行完毕后，这是恰好线程A再去执行提交操作 监控的key被其他事务所改变，即该事务执行失败。 12345678910127.0.0.1:6379&gt; watch moneyOK127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set money 0QUEUED127.0.0.1:6379&gt; exec (nil) #执行失败127.0.0.1:6379&gt; get money\"3000\" 3、unwatch 指令取消watch对所有key的监控 4、discard指令取消事务，放弃事务块中的所有命令 multi/discard: 事务开启–回滚 （放弃当前事务执行的所有操作） 1234567891011121314127.0.0.1:6379&gt; multiOK127.0.0.1:6379&gt; set k1 v1QUEUED127.0.0.1:6379&gt; set k2 v2QUEUED127.0.0.1:6379&gt; INCR k1QUEUED127.0.0.1:6379&gt; set k3 v3QUEUED127.0.0.1:6379&gt; DISCARDOK127.0.0.1:6379&gt; keys *(empty list or set) 二、java操作reids实现事务jedis连接工具 Redis 12345678910111213141516171819202122232425262728293031public class Redis { private JedisPool jedisPool; public Redis() {// 连接池配置对象 GenericObjectPoolConfig config=new GenericObjectPoolConfig();// 连接池最大空闲数 config.setMaxIdle(300);// 最大连接数 config.setMaxTotal(1000);// 连接最大等待时间（毫秒）。-1表示无限制 config.setMaxWaitMillis(30000);// 在空闲时检查有效性 config.setTestOnBorrow(true); /** * 1、连接池配置 * 2、redis地址 * 3、端口 * 4、超时时间 * 5、密码 */ jedisPool = new JedisPool(config, \"主机\",6379,30000,\"密码\"); } public void execute(CallWithJedis callWithJedis) { try (Jedis jedis=jedisPool.getResource()) { callWithJedis.call(jedis); } }} CallWithJedis 123public interface CallWithJedis { void call(Jedis jedis);} 123456789101112131415161718192021222324252627282930313233343536373839404142public class WatchTest { public static void main(String[] args) { new Redis().execute(jedis -&gt; { Integer integer = savaMoney(jedis, \"louchen\", 2000); System.out.println(integer); }); } /** * 存钱操作 * @param jedis jedis对象 * @param userId 要操作的用户 * @param money 存的金额 * @return 返回用户余额 */ public static Integer savaMoney(Jedis jedis, String userId, Integer money) {// 判断当前用户是否有余额 if (jedis.get(userId) == null) {// 没有余额设为0 jedis.set(userId, \"0\"); }// 若当前事务执行失败 重新执行 while (true) {// 监视用户 jedis.watch(userId);// 加钱 int i = Integer.valueOf(jedis.get(userId)) + money;// 开启事务 Transaction transaction = jedis.multi();//// 重新存入 transaction.set(userId, String.valueOf(i));// 执行当前事务 List&lt;Object&gt; exec = transaction.exec();// 是否存入成功 if (exec != null) {// 成功 跳出 break; } } return Integer.valueOf(jedis.get(userId)); }} 示例：事务异常 当我们监听该key时，运行到开启事务之前的时候，我们用其他事务执行对该key的增加操作，那么会发现操作失败。会重新while循环一次，重新执行。 用其他事务操作： 继续运行代码： 发现出现异常，继续执行。进入while循环，重新执行，此时没有其他事务执行。执行成功 三、要注意的点一但执行 EXEC 开启事务的执行后，无论事务使用执行成功， WARCH 对变量的监控都将被取消。 故当事务执行失败后，需重新执行WATCH命令对变量进行监控，并开启新的事务进行操作。","link":"/2020/05/04/redis/Redis%E4%BA%8B%E5%8A%A1/"},{"title":"Redis持久化方式","text":"Redis持久化方式Redis 是一个缓存工具，也叫做 NoSQL 数据库，既然是数据库，必然支持数据的持久化操作。在 Redis 中，数据库持久化一共有两种方案： 1、RDB(快照方式)：半持久化方式 Reids在内存中的数据库记录定时dump到磁盘上的RDB持久化 RDB持久化是指在指定的时间间隔内将内存中的数据集快照写入磁盘，实际操作过程是fork一个子进程，先将数据集写入临时文件，写入成功后，再替换之前的文件，用二进制压缩存储。 一次全量备份。存储的形式为二进制序列化的形式，存储比较紧簇，比较省空间。 2、AOF(append only file) 全持久化方式 Reids的操作日志以追加的方式写入文件 AOF持久化以日志的形式记录服务器所处理的每一个写、删除操作，查询操作不会记录，以文本的方式记录，可以打开文件看到详细的操作记录。 连续的增量备份，存储的是内存修改的指令的记录文本，随着时间的推移，该文本会越来越大。如果我们服务器需要重启，进行数据恢复加载的时候，会非常慢，相当于把文本中的指令从头到尾重新执行一遍，所以我们需要定期对日志进行重新瘦身 一、RDB（快照持久化）1.1原理Redis使用操作系统的多进程机制来实现快照持久化。Redis持久化的时候，会调用glibc函数fork一个子进程，然后将快照持久化操作完全交给子进程去处理，而父进程处理客户端请求。在这个过程中，子进程能够看到内存中的数据在子进程产生的一瞬间就固定下来了。再也不会改变，这就是Redis持久化交快照 1.2具体配置在我们重启Redis服务器时，发现之前存储的数据依然还在。所以在Redis中，默认情况下RDB快照持久化是默认开启的，我们在Reidis安装目录下默认会产生一个dump.rdb 文件，这个文件就是备份下来的文件。当Redis重新启动时，就会加载该文件。当我们删除drum.rdb文件时，再去重启服务器，会发现没有数据 redis.conf中的具体配置： 12345678910111213141516#快照的频率save 900 1 #900秒内如果有一个键被修改，就备份 save 300 10save 60 10000#在快照创建出错的时候是否继续执行客户端写命令 stop-writes-on-bgsave-error yes #默认为yes#是否对快照文件进行压缩rdbcompression yes #默认为yes#生成日志文件的名称dbfilename dump.rdb#日志文件的目录 默认在当前安装目录的下dir ./ 1.3备份的流程1、在Redis运行过程中，我们可以向Redis发送一条save命令来创建一个快照。（没有手动指定是，在配置文件中满足条件的快照频率，redis自动帮我们执行） 12#手动发送save 但是save是一个阻塞命令，Redis在收到save命令开始处理备份操作的之后，在处理完成之前，将不再处理其他请求。其他命令等待被挂起，所以用到的并不多 2、我们一般使用bgsave命令，bgsave会fork一个子进程去处理备份的事情，不影响父进程处理客户端请求 1bgsave 3、我们定义的备份规则，如果规则 满足，也会自动触发bgsave 4、此外，当我们执行shutdown命令时，也会触发save命令，备份完成后，Redis才会关闭。 5、用Redis搭建主从复制时，在从连上主机之后，会自动发送一个sync同于命令，主机收到命令之后，首先执行bgsave对数据执行快照，然后才会给从机发送快照数据进行同步。 、 1.4 RDB触发备份的三种机制①、save会阻塞当前Redis服务器，执行save期间，不能执行其他客户端命令，只有当前命令执行完毕，才能执行其他命令 ②、bgsaveredis服务器父进程fork一个子进程执行该save命令，不影响父进程执行客户端的其他的命令 ③、自动触发在redis.conf配置中，我们可以save 900 1的配置 表示900秒内有一个key修改就执行该备份操作 二、AOF持久化与快照持久化不同，AOF 持久化是将被执行的命令追加到 aof 文件末尾，在恢复时，只需要把记录下来 的命令从头到尾执行一遍即可。 redis.conf的详细配置： 12345678910111213141516#是否开启 aof配置 默认为noappendonly yes#AOF文件名appendfilename \"appendonly.aof\"#备份的时机# appendfsync always #每执行一个命令都追加appendfsync everysec #每秒都执行一次备份# appendfsync no#表示AOP文件在压缩时，是否还继续进行同步操作no-appendfsync-on-rewrite no#压缩的时机auto-aof-rewrite-percentage 100 #表示当前aof文件大小超过上一次重写时的aof文件大小的百分之多少时，再次进行重新auto-aof-rewrite-min-size 64mb #如果之前没有重写，则以启动的aof大小为依据，同时要求文件大小至少大于64mb 当我们开启aof配置后，如果也开启了rdb配置，则不知道是哪个在备份，这里我们关闭rdb备份 1234 save \"\"#save 900 1#save 300 10#save 60 10000 我们删点之前的dump.rdb的备份文件，然后重启服务器，执行一个set k1 v1的测试命令,回到根目录，这时我们发现增加了一个appendonly.aof的文件。进入到文件中: 123456789101112*2$6SELECT$10*3$3set$2k1$2v1 我们发现就是通过resp协议来执行的命令 手动发送备份的命令： 原理和gbsave一致 自动执行在配置文件中配置 1127.0.0.1:6379&gt; BGREWRITEAOF 2.1 AOP触发备份的三种机制（1）每修改同步always：同步持久化 每次发生数据变更会被立即记录到磁盘 性能较差但数据完整性比较好 （2）每秒同步everysec：异步操作，每秒记录 如果一秒内宕机，有数据丢失 （3）不同no：从不同步 三、RDB和AOP的选择比较1、RDB优势和劣势：①、优势（1）RDB文件紧凑，全量备份，非常适合用于进行备份和灾难恢复。 （2）生成RDB文件的时候，redis主进程会fork()一个子进程来处理所有保存工作，主进程不需要进行任何磁盘IO操作。 （3）RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快 ②、劣势​ RDB快照是一次全量备份，存储的是内存数据的二进制序列化形式，存储上非常紧凑。当进行快照持久化时，会开启一个子进程专门负责快照持久化，子进程会拥有父进程的内存数据，父进程修改内存子进程不会反应出来，所以在快照持久化期间修改的数据不会被保存，可能丢失数据。 2、AOF的优势和劣势①、优势（1）AOF可以更好的保护数据不丢失，一般AOF会每隔1秒，通过一个后台线程执行一次fsync操作，最多丢失1秒钟的数据。 （2）AOF日志文件没有任何磁盘寻址的开销，写入性能非常高，文件不容易破损。 （3）AOF日志文件即使过大的时候，出现后台重写操作，也不会影响客户端的读写。 （4）AOF日志文件的命令通过非常可读的方式进行记录，这个特性非常适合做灾难性的误删除的紧急恢复。比如某人不小心用flushall命令清空了所有数据，只要这个时候后台rewrite还没有发生，那么就可以立即拷贝AOF文件，将最后一条flushall命令给删了，然后再将该AOF文件放回去，就可以通过恢复机制，自动恢复所有数据 ②、劣势（1）对于同一份数据来说，AOF日志文件通常比RDB数据快照文件更大 （2）AOF开启后，支持的写QPS会比RDB支持的写QPS低，因为AOF一般会配置成每秒fsync一次日志文件，当然，每秒一次fsync，性能也还是很高的 （3）以前AOF发生过bug，就是通过AOF记录的日志，进行数据恢复的时候，没有恢复一模一样的数据出来。","link":"/2020/05/04/redis/Redis%E6%8C%81%E4%B9%85%E5%8C%96%E6%93%8D%E4%BD%9C/"},{"title":"深入理解Java并发编程","text":"-Ⅰ、进程和线程 一、进程和线程的区别？简单的比喻：进程=火车，线程=车厢 线程在进程下行进（单纯的车厢无法运行） 一个进程可以包含多个线程（一辆火车可以有多个车厢） 不同进程间数据很难共享（一辆火车上的乘客很难换到另外一辆火车，比如站点换乘） 同一进程下不同线程间数据很易共享（A车厢换到B车厢很容易） 进程要比线程消耗更多的计算机资源（采用多列火车相比多个车厢更耗资源） 进程间不会相互影响，一个线程挂掉将导致整个进程挂掉（一列火车不会影响到另外一列火车，但是如果一列火车上中间的一节车厢着火了，将影响到所有车厢） 进程可以拓展到多机，进程最多适合多核（不同火车可以开在多个轨道上，同一火车的车厢不能在行进的不同的轨道上） 进程使用的内存地址可以上锁，即一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。（比如火车上的洗手间）－“互斥锁” 进程使用的内存地址可以限定使用量（比如火车上的餐厅，最多只允许多少人进入，如果满了需要在门口等，等有人出来了才能进去）－“信号量” 进一步总结： 进程是一个资源的容器，为进程里的所有线程提供共享资源，是对程序的一种静态描述 线程是计算机最小的调度和运行单位，是对程序的一种动态描述 例如： 开个QQ，开了一个进程；开了迅雷，开了一个进程。在QQ的这个进程里，传输文字开一个线程、传输语音开了一个线程、弹出对话框又开了一个线程。 所以运行某个软件，相当于开了一个进程。在这个软件运行的过程里（在这个进程里），多个工作支撑的完成QQ的运行，那么这“多个工作”分别有一个线程。 所以一个进程管着多个线程。 1、进程 程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在 指令运行过程中还需要用到磁盘、网络等设备。进程就是用来加载指令、管理内存、管理 IO 的 当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。 进程就可以视为程序的一个实例。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器 等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等） 2、线程 一个进程之内可以分为一到多个线程。 一个线程就是一个指令流，将指令流中的一条条指令以一定的顺序交给 CPU 执行 Java 中，线程作为小调度单位，进程作为资源分配的小单位。 在 windows 中进程是不活动的，只是作 为线程的容器 3、进程和线程的区别 进程是资源分配的最小单位，线程是CPU调度的最小单位 进程基本上相互独立的，而线程存在于进程内，是进程的一个子集 进程拥有共享的资源，如内存空间等，供其内部的线程共享 进程间通信较为复杂 同一台计算机的进程通信称为 IPC（Inter-process communication） 不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP 线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量 线程更轻量，线程上下文切换成本一般上要比进程上下文切换低 Ⅱ、Java线程一、创建线程的方式1、继承Thread只有调用start()方法才算开启一个线程。否则只是代表创建一个Thread实例。 123456789public class MyThread extends Thread{ @Override public void run() { for (int i = 0; i &lt; 10; i++) {// Thread.currentThread().getName()获取当前线程名称 System.out.println(Thread.currentThread().getName()+\":\"+i); } }} 1234567891011121314151617181920public class T1 { public static void main(String[] args) {// ①继承Thread类 重写run方法 MyThread myThread=new MyThread();// 设置线程的名称 myThread.setName(\"myThread\"); myThread.start();// ②使用匿名内部类继承Thread Thread thread1=new Thread(\"thread1\"){ @Override public void run() { for (int i = 0; i &lt; 10; i++) { System.out.println(Thread.currentThread().getName()+\":\"+i); } } }; thread1.start(); }} 2、实现Runnable接口12345678public class MyRunnable implements Runnable { @Override public void run() { for (int i = 0; i &lt; 10; i++) { System.out.println(Thread.currentThread().getName()+\":\"+i); } }} 123456789101112131415161718public class T1 { public static void main(String[] args) {// ①传入Runnable接口的实现类 Thread thread=new Thread(new MyRunnable(), \"myRunnable\"); thread.start();// ②使用匿名内部类实现Runnable接口 Thread thread1=new Thread(new Runnable(){ @Override public void run() { for (int i = 0; i &lt; 10; i++) { System.out.println(Thread.currentThread().getName()+\":\"+i); } } },\"myRunnable2\"); thread1.start(); }} 3、实现Callable接口Callable和Runnable的区别是，Callable接口可以拿到线程处理后的返回值给其他线程使用 12345678910111213141516171819202122232425262728293031323334353637383940public class MyCallable implements Callable&lt;Integer&gt; { @Override public Integer call() throws Exception { Thread.sleep(2000); System.out.println(Thread.currentThread().getName()); return 100; } public static void main(String[] args) {// 新建任务// ①通过实现Callable接口 FutureTask&lt;Integer&gt; task=new FutureTask&lt;&gt;(new MyCallable());// ②使用匿名内部类实现Callable实现接口 FutureTask&lt;String&gt; task1=new FutureTask&lt;&gt;(()-&gt;{ System.out.println(Thread.currentThread().getName()); return \"hello java\"; });// FutureTask也是实现Runnable接口的 Thread thread=new Thread(task, \"MyCallable\"); Thread thread1=new Thread(task1,\"MyCallable2\");// 开启此线程 thread.start(); thread1.start();// 主线程获取返回值 try {// 注意：主线程会一直阻塞在这里，直到get拿到此返回值 Integer t1 = task.get(); String t2 = task1.get(); System.out.println(t1); System.out.println(t2); } catch (InterruptedException e) { e.printStackTrace(); } catch (ExecutionException e) { e.printStackTrace(); } }} 4、Thread和Runnable的关系Thread 是把线程和任务合并在了一起 Runnable是把线程和任务分开了 用 Runnable 更容易与线程池等高级 API 配合 用 Runnable 让任务类脱离了 Thread 继承体系，更灵活 三、原理之线程运行1、栈与栈帧栈先进后出 Java Virtual Machine Stacks （Java 虚拟机栈） 我们都知道 JVM 中由堆、栈、方法区所组成，其中栈内存是给谁用的呢？其实就是线程，每个线程启动后，虚拟 机就会为其分配一块栈内存。 每个线程都有自己的一个独立的栈帧，栈帧之间互不影响。 每个栈由多个栈帧（Frame）组成，对应着每次方法调用时所占用的内存 每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法 idea中每个方法执行的栈帧，我们可以看到main方法首先入栈，然后method1和method2相继压栈，最后mehtod2和mehtod1执行完后，从上到下出栈 图解分析：方法执行在jvm中内存区域分析： 方法相继出栈： 2、线程上下文切换因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码 线程的 cpu 时间片用完 垃圾回收 有更高优先级的线程需要运行 线程自己调用了 sleep、yield、wait、join、park、synchronized、lock 等方法 当 Context Switch 发生时，需要由操作系统保存当前线程的状态，并恢复另一个线程的状态，Java 中对应的概念 就是程序计数器（Program Counter Register），它的作用是记住下一条 jvm 指令的执行地址，是线程私有的 状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等 Context Switch 频繁发生会影响性能 四、Thread常用方法 方法名 static 功能说明 注意 start() 启动一个新线 程，在新的线程 运行 run 方法 中的代码 start 方法只是让线程进入就绪，里面代码不一定立刻 运行（CPU 的时间片还没分给它）。每个线程对象的 start方法只能调用一次，如果调用了多次会出现 IllegalThreadStateException run() 新线程启动后会 调用的方法 如果在构造 Thread 对象时传递了 Runnable 参数，则 线程启动后会调用 Runnable 中的 run 方法，否则默 认不执行任何操作。但可以创建 Thread 的子类对象， 来覆盖默认行为 join() 等待线程运行结 束 join(long n) 等待线程运行结 束,多等待 n 毫秒 getId() 获取线程长整型 的 id id 唯一 getName() 获取线程名 setName(String name) 修改线程名 getPriority() 获取线程优先级 setPriority(int) 修改线程优先级 java中规定线程优先级是1~10 的整数，较大的优先级 能提高该线程被 CPU 调度的机率 getState() 获取线程状态 Java 中线程状态是用 6 个 enum 表示，分别为： NEW, RUNNABLE, BLOCKED, WAITING, TIMED_WAITING, TERMINATED isInterrupted() 判断是否被打 断 不会清除 打断标记 isAlive() 线程是否存活 （还没有运行完 毕） interrupt() 打断线程 如果被打断线程正在 sleep，wait，join 会导致被打断 的线程抛出 InterruptedException，并清除 打断标记；如果打断的正在运行的线程，则会设置 打断标记；park 的线程被打断，也会设置 打断标记 interrupted() static 判断当前线程是 否被打断 会清除 打断标记 currentThread() static 获取当前正在执 行的线程 sleep(long n) static 让当前执行的线 程休眠n毫秒， 休眠时让出 cpu 的时间片给其它 线程 yield() static 提示线程调度器 让出当前线程对 CPU的使用 主要是为了测试和调试 五、sleep与yield1、sleep①调用 sleep 会让当前线程从 Running 进入 Timed Waiting 状态（阻塞） 1234567891011121314151617181920212223242526272829@Slf4jpublic class T1 { public static void main(String[] args) { Thread t1=new Thread(()-&gt;{ try { Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } });// 新建的线程t1处于new状态// NEW log.info(\"{}\",t1.getState()); t1.start();// 调用start方法后线程t1处于可运行状态// RUNNABLE log.info(\"{}\",t1.getState()); try {// 主线程休眠1秒 Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); }// 此时主线程执行到这的时候，t1线程处于休眠状态// 即此时t1处于超时等待// TIMED_WAITING log.info(\"{}\",t1.getState()); }} ②其它线程可以使用 interrupt 方法打断正在睡眠的线程，这时 sleep 方法会抛出 InterruptedException 123456789101112131415161718@Slf4jpublic class T2 { public static void main(String[] args) throws InterruptedException { Thread t1=new Thread(()-&gt;{ try { log.info(\"start sleep....\"); Thread.sleep(3000); } catch (InterruptedException e) { log.info(\"i wake up\"); e.printStackTrace(); } }); t1.start(); Thread.sleep(1000);// 打断正在休眠的进程 抛出InterruptedException异常 t1.interrupt(); }} 12345617:02:56.329 [Thread-0] INFO org.lc.sleep_yield.T2 - start sleep....17:02:57.325 [Thread-0] INFO org.lc.sleep_yield.T2 - i wake upjava.lang.InterruptedException: sleep interrupted at java.lang.Thread.sleep(Native Method) at org.lc.sleep_yield.T2.lambda$main$0(T2.java:18) at java.lang.Thread.run(Thread.java:748) ③睡眠结束后的线程未必会立刻得到执行 睡眠过后，还是要等cpu来分配时间片给该线程来执行 ④建议用 TimeUnit 的 sleep 代替 Thread 的 sleep 来获得更好的可读性 TimeUnit.DAYS TimeUnit.HOURS TimeUnit.MINUTES TimeUnit.SECONDS 1234567891011121314@Slf4jpublic class T3 { public static void main(String[] args) { log.info(\"start sleep\"); try {// 格式化睡眠时间 1 秒 TimeUnit.SECONDS.sleep(1); } catch (InterruptedException e) { e.printStackTrace(); } log.info(\"end sleep\"); }} 2、yieldThread.yield(); ①调用 yield 会让当前线程从 Running 进入 Runnable 就绪状态，然后调度执行其它线程 ②具体的实现依赖于操作系统的任务调度器 1234567891011121314151617181920public class T4 { public static void main(String[] args) { Thread t1=new Thread(()-&gt;{ int count = 0; for (; ; ) {// 设置yield() 让出cpu Thread.yield(); System.out.println(\"t1----:\"+count++); } },\"t1\"); Thread t2=new Thread(()-&gt;{ int count = 0; for (; ; ) { System.out.println(\"t2----:\"+count++); } },\"t2\"); t1.start(); t2.start(); }} 12345678......t1----:6577t1----:6578t1----:6579t2----:23524t2----:23525t2----:23526.... 我们明显可以发现，yield是有一定作用来让出cpu时间片给其他线程来执行的 3、sleep与yield的区别当运行中的线程调用yield方法时，会直接进入从运行状态进入就绪状态，然后等待cpu时间片的调用。 当运行中的线程调用sleep方法时，线程会进入一个timed waiting阻塞状态，只有该sleep时间片过了，才有机会让cpu调用此线程 4、线程优先级 线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它 如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用 setPriority(int newPriority) 范围：1-10 123456789101112 /** * 线程最小的优先级. */ public final static int MIN_PRIORITY = 1;/** * 线程默认的优先级. */ public final static int NORM_PRIORITY = 5; /** * 线程最大的优先级 */ public final static int MAX_PRIORITY = 10; 12345678910111213141516171819202122public class T4 { public static void main(String[] args) { Thread t1=new Thread(()-&gt;{ int count = 0; for (; ; ) { System.out.println(\"t1----:\"+count++); } },\"t1\"); Thread t2=new Thread(()-&gt;{ int count = 0; for (; ; ) { System.out.println(\"t2----:\"+count++); } },\"t2\");// 设置t1线程最大的优先级 t1.setPriority(Thread.MAX_PRIORITY);// 设置t2线程最小的优先级 t2.setPriority(Thread.MIN_PRIORITY); t1.start(); t2.start(); }} 123456...t1----:34178t1----:34179t2----:28259t2----:28260... 我们可以发现优先级高的线程比优先级高的有明显 5、设置线程优先级和yield的区别都是可以尽量让出cpu时间片给其他线程执行，但是还是取决于cpu的执行能力和cpu是否闲忙的程度 6、sleep应用：使用sleep限制对cpu的占用​ 在没有利用 cpu 来计算时，不要让 while(true) 空转浪费 cpu，这时可以使用 yield 或 sleep 来让出 cpu 的使用权 给其他程序 可以用 wait 或 条件变量达到类似的效果 不同的是，后两种都需要加锁，并且需要相应的唤醒操作，一般适用于要进行同步的场景 sleep 适用于无需锁同步的场景 在单核cpu情况下，如果我们运行一下代码： 123456789public class T5 { public static void main(String[] args) { new Thread(()-&gt;{ while (true) { System.out.println(\"hello world! \"); } }).start(); }} 我们会发现cpu会出现占满的情况。 修改以上代码： 1234567891011121314public class T5 { public static void main(String[] args) { new Thread(()-&gt;{ while (true) { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } System.out.println(\"hello world! \"); } }).start(); }} 我们可以发现加上sleep后cpu占用率明显下降。 六、join的使用join会阻塞当前正在运行的代码。直到该join对应的线程执行完毕。 join底层其实就是wait 1、基本应用1234567891011121314151617181920212223@Slf4jpublic class T6 { static int a=0; public static void main(String[] args) throws InterruptedException { log.info(\"开始\"); Thread t1 = new Thread(() -&gt; { try { log.info(\"开始\"); Thread.sleep(1000); log.info(\"结束\"); } catch (InterruptedException e) { e.printStackTrace(); } a=10; }, \"t1\"); t1.start();// 主线程等待该线程结束 然后才能执行后面的代码 会阻塞当前主线程 t1.join(); log.info(\"结果为:{}\",a); log.info(\"结束\"); }} 1234510:14:00.197 [main] INFO org.lc.sleep_yield.T6 - 开始10:14:00.240 [t1] INFO org.lc.sleep_yield.T6 - 开始10:14:01.240 [t1] INFO org.lc.sleep_yield.T6 - 结束10:14:01.240 [main] INFO org.lc.sleep_yield.T6 - 结果为:1010:14:01.241 [main] INFO org.lc.sleep_yield.T6 - 结束 2、同步应用-等待多个线程结果以调用方角度来讲，如果 需要等待结果返回，才能继续运行就是同步 不需要等待结果返回，就能继续运行就是异步 1234567891011121314151617181920212223242526272829303132333435@Slf4jpublic class T7 { static int a=0; static int b=0; public static void main(String[] args) throws InterruptedException { test(); } private static void test() throws InterruptedException { Thread t1=new Thread(()-&gt;{ try { Thread.sleep(1000); a=10; } catch (InterruptedException e) { e.printStackTrace(); } },\"t1\"); Thread t2=new Thread(()-&gt;{ try { Thread.sleep(2000); b=20; } catch (InterruptedException e) { e.printStackTrace(); } },\"t2\"); long start = System.currentTimeMillis(); t1.start(); t2.start(); t1.join(); t2.join(); long end = System.currentTimeMillis(); log.info(\"a:{} b:{} 花费时间:{}\",a,b,end-start); }} 110:25:45.948 [main] INFO org.lc.sleep_yield.T7 - a:10 b:20 花费时间:2000 我们可以发现，为啥不是3秒呢？ 因为t1线程在跑的同时，t2线程也在跑。当等待t1线程跑完时，经过了1秒，到t2线程时，t2已经跑了1秒，所以现在只用等待1s即可，所以总共为2s 3、限时同步join(long n) 等待线程执行毫秒 1234567891011121314151617181920@Slf4jpublic class T7 { static int a=0; public static void main(String[] args) throws InterruptedException { test1(); } private static void test1() throws InterruptedException { Thread t1=new Thread(()-&gt;{ try { Thread.sleep(3000); a=10; } catch (InterruptedException e) { e.printStackTrace(); } },\"t1\"); t1.start(); t1.join(1500); log.info(\"{}\",a); }} 110:41:59.091 [main] INFO org.lc.sleep_yield.T7 - 0 我们发现当join设置的小于t1线程的执行时间时，t1线程还没有执行完，主线程即不再等待，将执行join后面的代码 12345678910111213141516171819202122@Slf4jpublic class T7 { static int a=0; public static void main(String[] args) throws InterruptedException { test1(); } private static void test1() throws InterruptedException { Thread t1=new Thread(()-&gt;{ try { Thread.sleep(2000); a=10; } catch (InterruptedException e) { e.printStackTrace(); } },\"t1\"); long s=System.currentTimeMillis(); t1.start(); t1.join(4000); long e=System.currentTimeMillis(); log.info(\"{}, 时间：{}\",a,e-s); }} 110:46:03.790 [main] INFO org.lc.sleep_yield.T7 - 10, 时间：2000 我们发现当设置的join时间大于t1线程的执行时间，则t1线程会提前终止join。 七、interrupt使用注意： interrupt() 使线程中断 。实例方法。 isInterrupted() 判断线程是否被打断，不会清除标记 。该方法为实例方法 interrupted() 判断线程是否被打断，会清除标记。该方法为静态方法 1、打断 sleep，wait，join 的阻塞线程打断sleep，wait，join时的阻塞线程，会清除interrupt标记，即isInterrupted()为false 这几个方法都会让线程进入阻塞状态打断 sleep 的线程, 会清空打断状态，以 sleep 为例(打断正在睡眠的线程)： 123456789101112131415161718@Slf4jpublic class T1 { public static void main(String[] args) throws InterruptedException { Thread t1=new Thread(()-&gt;{ try { log.info(\"开始睡眠\"); Thread.sleep(3000); } catch (InterruptedException e) { e.printStackTrace(); } }); t1.start(); Thread.sleep(1000); log.info(\"interrupt\"); t1.interrupt(); log.info(\"打断状态:{}\",t1.isInterrupted()); }} 123456711:38:13.518 [Thread-0] INFO org.lc.interrupt.T1 - 开始睡眠11:38:14.518 [main] INFO org.lc.interrupt.T1 - interruptjava.lang.InterruptedException: sleep interrupted at java.lang.Thread.sleep(Native Method) at org.lc.interrupt.T1.lambda$main$0(T1.java:18) at java.lang.Thread.run(Thread.java:748)11:38:14.518 [main] INFO org.lc.interrupt.T1 - 打断状态:false 2、打断正常运行的线程12345678910111213141516@Slf4jpublic class T2 { public static void main(String[] args) throws InterruptedException { Thread t1=new Thread(()-&gt;{ while (true) { } },\"t1\"); t1.start();// 保证t1线程能够在main线程执行打断方法时运行 Thread.sleep(1000); log.info(\"interrupt\"); t1.interrupt(); log.info(\"打断状态:{}\",t1.isInterrupted()); }} 1211:48:32.775 [main] INFO org.lc.interrupt.T2 - interrupt11:48:32.778 [main] INFO org.lc.interrupt.T2 - 打断状态:true 上述程序未终止 对于正常运行的线程，如果此时t1线程被告知需要打断，则需要在线程内部手动终止程序。否则会一直运行。 1234567891011121314151617181920@Slf4jpublic class T2 { public static void main(String[] args) throws InterruptedException { Thread t1=new Thread(()-&gt;{ while (true) {// 如果当前线程被告知要打断，即设置了interrupte标记为true if(Thread.currentThread().isInterrupted()){ log.info(\"退出循环！\"); break; } } },\"t1\"); t1.start();// 保证t1线程能够在main线程执行打断方法时运行 Thread.sleep(1000); log.info(\"interrupt\"); t1.interrupt(); log.info(\"打断状态:{}\",t1.isInterrupted()); }} 12311:51:59.831 [main] INFO org.lc.interrupt.T2 - interrupt11:51:59.834 [t1] INFO org.lc.interrupt.T2 - 退出循环！11:51:59.834 [main] INFO org.lc.interrupt.T2 - 打断状态:true 3、优雅的利用interrupt打断线程①错误思路 使用线程对象的 stop() 方法停止线程 stop 方法会真正杀死线程，如果这时线程锁住了共享资源，那么当它被杀死后就再也没有机会释放锁， 其它线程将永远无法获取锁 使用 System.exit(int) 方法停止线程 目的仅是停止一个线程，但这种做法会让整个程序都停止 ②终止模式之两阶段终止模式(Two Phase Termination )模拟应用监控，若出现应用出现异常则停止监控。手动点击停止，也停止监控 ③利用 isInterrupted()interrupt 可以打断正在执行的线程，无论这个线程是在 sleep，wait，还是正常运行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051@Slf4jpublic class TwoPhaseTermination {// 监视器线程 private static Thread monitor; /** * 启动线程监控 */ public static void start() { monitor =new Thread(()-&gt;{ while (true) {// 如果当前线程是被提示需要打断 if(Thread.currentThread().isInterrupted()){ log.info(\"日志监控停止...\"); break; } try { Thread.sleep(2000); log.info(\"日志监控中...\"); } catch (InterruptedException e) {// 当主程序第一次打算该线程时，如果在sleep时被打断，则interrupt为false// 当主程序第一次打算该线程时，如果在sleep之外时被打断，则interrupt为true,这时进入while时，interrupt为true// 所以这里我们需要手动设置，该线程要被打断 monitor.interrupt(); e.printStackTrace(); } } },\"monitor\"); monitor.start(); } /** * 终止线程 */ public static void stop() { monitor.interrupt(); } public static void main(String[] args) throws InterruptedException {// 启动监控 start();// 保证已经进入监控线程 Thread.sleep(8000);// 停止监控 log.info(\"stop\"); stop(); }} 12345678913:23:05.423 [monitor] INFO org.lc.interrupt.TwoPhaseTermination - 日志监控中...13:23:07.427 [monitor] INFO org.lc.interrupt.TwoPhaseTermination - 日志监控中...13:23:09.427 [monitor] INFO org.lc.interrupt.TwoPhaseTermination - 日志监控中...13:23:11.423 [main] INFO org.lc.interrupt.TwoPhaseTermination - stopjava.lang.InterruptedException: sleep interrupted at java.lang.Thread.sleep(Native Method) at org.lc.interrupt.TwoPhaseTermination.lambda$start$0(TwoPhaseTermination.java:31) at java.lang.Thread.run(Thread.java:748)13:23:11.423 [monitor] INFO org.lc.interrupt.TwoPhaseTermination - 日志监控停止... 4、打断park线程①打断 park 线程, 不会清空打断状态 ②如果打断标记已经是 true, 则 park 会失效 1234567891011121314151617181920@Slf4jpublic class ParkTest { public static void main(String[] args) throws InterruptedException { Thread t1=new Thread(()-&gt;{ log.info(\"park...\");// 执行到该代码时，该线程会阻塞 LockSupport.park(); log.info(\"unpark...\"); log.info(\"打断状态:{}\",Thread.currentThread().isInterrupted());// 再次使用park,不会阻塞该线程。 当线程打断的标记为true时，park不会阻塞线程 LockSupport.park(); log.info(\"unpark\"); },\"t1\"); t1.start(); Thread.sleep(2000);// 打断park线程 t1.interrupt(); }} 123415:31:21.611 [t1] INFO org.lc.interrupt.ParkTest - park...15:31:23.610 [t1] INFO org.lc.interrupt.ParkTest - unpark...15:31:23.610 [t1] INFO org.lc.interrupt.ParkTest - 打断状态:true15:31:23.611 [t1] INFO org.lc.interrupt.ParkTest - unpark 我们可以发现，打断后的park，线程标记为true,再次使用park时，park不会阻塞。即只有当线程标记为falses时park才有效。 结论：可以使用 Thread.interrupted() 清除打断状态 注意： Thread.currentThread().isInterrupted()和Thread.interrupted()最好不要同时使用。 Thread.interrupted()要在Thread.currentThread().isInterrupted()之前使用 5、 不推荐的方法还有一些不推荐使用的方法，这些方法已过时，容易破坏同步代码块，造成线程死锁 方法名 是否static 功能说明 stop() 停止线程运行 suspend() 挂起（暂停）线程运行 resume() 恢复线程运行 八、主线程和守护线程默认情况下线程为非守护线程，Java 进程需要等待所有线程都运行结束，才会结束。有一种特殊的线程叫做守护线程，只要其它非守 护线程运行结束了，即使守护线程的代码没有执行完，也会强制结束。 设置守护线程的方法：setDaemon(true); 该方法为实例方法 123456789101112131415161718@Slf4jpublic class DaemonTest { public static void main(String[] args) throws InterruptedException { Thread t1=new Thread(()-&gt;{ try { log.info(\"开始运行\"); Thread.sleep(3000); log.info(\"线程t1终止...\"); } catch (InterruptedException e) { e.printStackTrace(); } },\"t1\"); t1.setDaemon(true); t1.start(); Thread.sleep(1000); log.info(\"主线程终止...\"); }} 1216:20:42.775 [t1] INFO org.lc.interrupt.DaemonTest - 开始运行16:20:43.774 [main] INFO org.lc.interrupt.DaemonTest - 主线程终止... 非守护线程执行完后，所有守护线程无论是否执行完毕，直接退出。无需执行守护线程后面代码 注意 垃圾回收器线程就是一种守护线程 Tomcat 中的 Acceptor 和 Poller 线程都是守护线程，所以 Tomcat 接收到 shutdown 命令后，不会等 待它们处理完当前请求 九、线程的状态1、五种状态(操作系统层面) 【初始状态】仅是在语言层面创建了线程对象，还未与操作系统线程关联 【可运行状态】（就绪状态）指该线程已经被创建（与操作系统线程关联），可以由 CPU 调度执行 【运行状态】指获取了 CPU 时间片运行中的状态 当 CPU 时间片用完，会从【运行状态】转换至【可运行状态】，会导致线程的上下文切换 【阻塞状态】 如果调用了阻塞 API，如 BIO(同步阻塞I/O) 读写文件，这时该线程实际不会用到 CPU，会导致线程上下文切换，进入 【阻塞状态】 等 BIO 操作完毕，会由操作系统唤醒阻塞的线程，转换至【可运行状态】 与【可运行状态】的区别是，对【阻塞状态】的线程来说只要它们一直不唤醒，调度器就一直不会考虑 调度它们 【终止状态】表示线程已经执行完毕，生命周期已经结束，不会再转换为其它状态 2、六种状态(Java层面)这是从 Java API 层面来描述的 根据 Thread.State 枚举，分为六种状态 NEW 线程刚被创建，但是还没有调用 start() 方法 RUNNABLE 当调用了 start() 方法之后，注意，Java API 层面的 RUNNABLE 状态涵盖了 操作系统 层面的 【可运行状态】、【运行状态】和【阻塞状态】（由于 BIO 导致的线程阻塞，在 Java 里无法区分，仍然认为 是可运行） BLOCKED ， WAITING， TIMED_WAITING 都是 Java API 层面对【阻塞状态】的细分，后面会在状态转换一节 详述 TERMINATED 当线程代码运行结束 3、代码示例六种状态12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576@Slf4jpublic class PeriodTest { public static void main(String[] args) {// 模拟新建状态NEW Thread t1 = new Thread(() -&gt; { log.info(\"running...\"); }, \"t1\");// 模拟可运行状态Runnable Thread t2 = new Thread(() -&gt; { while (true) {// 即任务的重复执行,执行完后从运行状态又回到可运行状态 } }, \"t2\"); t2.start();// 模拟终止TERMINATED状态 Thread t3 = new Thread(() -&gt; { log.info(\"running...\"); }, \"t3\"); t3.start();// 模拟有时限的等待状态TIMED WAITING Thread t4 = new Thread(() -&gt; {// 获得当前对象锁 synchronized (PeriodTest.class) { try {// 足够的睡眠时间 Thread.sleep(1000000); } catch (InterruptedException e) { e.printStackTrace(); } } }, \"t4\"); t4.start();// 模拟WAITING Thread t5 = new Thread(() -&gt; { try {// 阻塞状态 都不会得到任务调度器的调度 t2.join(); } catch (InterruptedException e) { e.printStackTrace(); } }, \"t5\"); t5.start();// 模拟BLOCK Thread t6 = new Thread(() -&gt; {// 此时的锁已经被t4线程拿到。所以这里拿不到锁 synchronized (PeriodTest.class) { try { Thread.sleep(1000000); } catch (InterruptedException e) { e.printStackTrace(); } } }, \"t6\"); t6.start(); try {// 等待t3线程执行完 Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } log.info(\"t1的线程状态为:{}\", t1.getState()); log.info(\"t2的线程状态为:{}\", t2.getState()); log.info(\"t3的线程状态为:{}\", t3.getState()); log.info(\"t4的线程状态为:{}\", t4.getState()); log.info(\"t5的线程状态为:{}\", t5.getState()); log.info(\"t6的线程状态为:{}\", t6.getState()); }} 123456717:30:16.284 [t3] INFO org.lc.interrupt.PeriodTest - running...17:30:17.284 [main] INFO org.lc.interrupt.PeriodTest - t1的线程状态为:NEW17:30:17.285 [main] INFO org.lc.interrupt.PeriodTest - t2的线程状态为:RUNNABLE17:30:17.285 [main] INFO org.lc.interrupt.PeriodTest - t3的线程状态为:TERMINATED17:30:17.285 [main] INFO org.lc.interrupt.PeriodTest - t4的线程状态为:TIMED_WAITING17:30:17.285 [main] INFO org.lc.interrupt.PeriodTest - t5的线程状态为:WAITING17:30:17.285 [main] INFO org.lc.interrupt.PeriodTest - t6的线程状态为:BLOCKED 十、习题1、烧水泡茶(sleep)阅读华罗庚《统筹方法》，给出烧水泡茶的多线程解决方案 123456789101112131415161718192021222324252627282930313233343536@Slf4jpublic class T8 { public static void main(String[] args) { Thread t1=new Thread(()-&gt;{ try { log.info(\"洗水壶...\"); Thread.sleep(1000); log.info(\"烧水...\"); Thread.sleep(10000); } catch (InterruptedException e) { e.printStackTrace(); } },\"张三\"); Thread t2 = new Thread(() -&gt; { try { log.info(\"洗茶壶...\"); Thread.sleep(1000); log.info(\"洗茶杯...\"); Thread.sleep(1000); log.info(\"拿茶叶...\"); Thread.sleep(1000);// 等待t1烧水的线程执行完。// WAITING t1.join(); log.info(\"泡茶叶...\"); } catch (InterruptedException e) { e.printStackTrace(); } }, \"小三\"); t1.start(); t2.start(); }} 12345618:01:49.779 [小三] INFO org.lc.sleep_yield.T8 - 洗茶壶...18:01:49.780 [张三] INFO org.lc.sleep_yield.T8 - 洗水壶...18:01:50.782 [张三] INFO org.lc.sleep_yield.T8 - 烧水...18:01:50.782 [小三] INFO org.lc.sleep_yield.T8 - 洗茶杯...18:01:51.783 [小三] INFO org.lc.sleep_yield.T8 - 拿茶叶...18:02:00.783 [小三] INFO org.lc.sleep_yield.T8 - 泡茶叶... 2、多线程下载图片12345678910111213141516171819202122232425262728293031323334public class DownloadImage extends Thread{ private String url; private String name; public DownloadImage(String url, String name) { this.url=url; this.name=name; } protected void downloadImageHandler() { try { FileUtils.copyURLToFile(new URL(this.url),new File(this.name)); System.out.println(\"下载文件:\"+this.name); } catch (IOException e) { e.printStackTrace(); } } @Override public void run() { this.downloadImageHandler(); } public static void main(String[] args) { DownloadImage d1=new DownloadImage(\"http://img.louchen.top/2020/05/rdb01.png\", \"1.png\"); DownloadImage d2=new DownloadImage(\"http://img.louchen.top/2020/05/rdb02.png\", \"2.png\"); DownloadImage d3=new DownloadImage(\"http://img.louchen.top/2020/05/aof01.png\", \"3.png\"); DownloadImage d4=new DownloadImage(\"http://img.louchen.top/2020/05/aof02.png\", \"4.png\"); d1.start(); d2.start(); d3.start(); d4.start(); }} 3、龟兔赛跑12345678910111213141516171819202122232425262728293031public class Race implements Runnable { private static String winner; protected boolean isOver(int step){ if(winner!=null){ return true; } if (step == 100) { winner=Thread.currentThread().getName(); System.out.println(\"胜利者是:\"+winner); return true; } return false; } @Override public void run() { for (int i = 0; i &lt;=100; i++) { boolean over = this.isOver(i); if(over){ break; } System.out.println(Thread.currentThread().getName()+\":跑了\"+i+\"步;\"); } } public static void main(String[] args) { Thread t1 = new Thread(new Race(), \"乌龟\"); Thread t2 = new Thread(new Race(), \"兔子\"); t1.start(); t2.start(); }} Ⅲ、共享线程之管程(悲观锁)1、共享带来的问题①、java的体现两个线程对初始值为 0 的静态变量一个做自增，一个做自减，各做 5000 次，结果是 0 吗？ 1234567891011121314151617181920212223@Slf4jpublic class T1 { static int count=0; public static void main(String[] args) throws InterruptedException { Thread t1=new Thread(()-&gt;{ for (int i = 0; i &lt; 5000; i++) { count++; } },\"t1\"); Thread t2=new Thread(()-&gt;{ for (int i = 0; i &lt; 5000; i++) { count--; } },\"t2\"); t1.start(); t2.start(); t1.join(); t2.join(); log.info(\"count:{}\",count); }} 121:47:14.620 [main] INFO org.lc.synchronized_t.T1 - count:486 答案显然不为0 ②、问题分析以上的结果可能是正数、负数、零。为什么呢？因为 Java 中对静态变量的自增，自减并不是原子操作，要彻底理 解，必须从字节码来进行分析 例如对于 i++而言（i 为静态变量），实际会产生如下的 JVM 字节码指令： 1234getstatic i // 获取静态变量i的值iconst_1 // 准备常量1iadd // 自增 putstatic i // 将修改后的值存入静态变量i 而对应 i-- 也是类似： 1234getstatic i // 获取静态变量i的值 iconst_1 // 准备常量1 isub // 自减 putstatic i // 将修改后的值存入静态变量i 而 Java 的内存模型如下，完成静态变量的自增，自减需要在主存和工作内存中进行数据交换： 如果是单线程以上 8 行代码是顺序执行（不会交错）没有问题： 但多线程下这 8 行代码可能交错运行：出现负数的情况： 出现正数的情况: ③、临界区 Critical Section 一个程序运行多个线程本身是没有问题的 问题出在多个线程访问共享资源 多个线程读共享资源其实也没有问题 在多个线程对共享资源读写操作时发生指令交错，就会出现问题 一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为临界区 例如，下面代码中的临界区： 1234567891011static int counter = 0; static void increment() // 临界区 { counter++; } static void decrement() // 临界区 { counter--;} ④、竞态条件(Race Condition )：多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了竞态条件 4、synchronized(也叫互斥锁)解决方案为了避免临界区的竞态条件发生，有多种手段可以达到目的。 阻塞式的解决方案：synchronized，Lock 非阻塞式的解决方案：原子变量 阻塞式的【对象锁】：它采用互斥的方式让同一 时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住。这样就能保证拥有锁 的线程可以安全的执行临界区内的代码，不用担心线程上下文切换 注意: 虽然 java 中互斥和同步都可以采用 synchronized 关键字来完成，但它们还是有区别的： 互斥是保证临界区的竞态条件发生，同一时刻只能有一个线程执行临界区代码 同步是由于线程执行的先后、顺序不同、需要一个线程等待其它线程运行到某个点 ①语法线程1拿到对象锁之后，线程2来访问该临界区会发生blocked阻塞 注意：锁不能为基本数据类型。只能为实例类型或包装类,包括String,且不能为null。 1234synchronized(对象) // 线程1， 线程2(blocked) { 临界区 } ②解决上述1中出现的问题12345678910111213141516171819202122232425262728293031@Slf4jpublic class T1 { static int count=0;// o对象作为锁对象 static Object o=new Object(); public static void main(String[] args) throws InterruptedException { Thread t1=new Thread(()-&gt;{ for (int i = 0; i &lt; 5000; i++) { //临界区为count++ synchronized (o) { count++; } } },\"t1\"); Thread t2=new Thread(()-&gt;{ for (int i = 0; i &lt; 5000; i++) { ////临界区为count-- synchronized (o) { count--; } } },\"t2\"); t1.start(); t2.start(); t1.join(); t2.join(); log.info(\"count:{}\",count); }} 111:15:17.879 [main] INFO org.lc.synchronized_t.T1 - count:0 这时我们发现是始终为0 交替执行count++和count–。 假如t1线程中先拿到锁，执行完count++代码块之后，该线程释放锁，然后，t1和t2线程再次同时竞争该锁，谁拿到锁谁先执行，没拿到的等待。直到所有的代码程序执行完毕。 ③时序提来解释上述过程 ④通俗的方式解释 你可以做这样的类比： synchronized(对象) 中的对象，可以想象为一个房间（room），有唯一入口（门）房间只能一次进入一人 进行计算，线程 t1，t2 想象成两个人 当线程 t1 执行到 synchronized(room) 时就好比 t1 进入了这个房间，并锁住了门拿走了钥匙，在门内执行 count++ 代码 这时候如果 t2 也运行到了 synchronized(room) 时，它发现门被锁住了，只能在门外等待，发生了上下文切 换，阻塞住了 这中间即使 t1 的 cpu 时间片不幸用完，被踢出了门外（不要错误理解为锁住了对象就能一直执行下去哦）， 这时门还是锁住的，t1 仍拿着钥匙，t2 线程还在阻塞状态进不来，只有下次轮到 t1 自己再次获得时间片时才 能开门进入 当 t1 执行完 synchronized{} 块内的代码，这时候才会从 obj 房间出来并解开门上的锁，唤醒 t2 线程把钥 匙给他。t2 线程这时才可以进入 obj 房间，锁住了门拿上钥匙，执行它的 count– 代码 ⑤思考 如果把 synchronized(obj) 放在 for 循环的外面，如何理解？ 1234567891011121314151617181920212223242526272829303132@Slf4jpublic class T1 { static int count=0;// o对象作为锁对象 static Object o=new Object(); public static void main(String[] args) throws InterruptedException { Thread t1=new Thread(()-&gt;{ synchronized (o) { //相当于两条的自增指令，保持原子性执行了200次，该期间不会被其他线程所干扰 for (int i = 0; i &lt; 100; i++) { System.out.println(\"t1\"); count++; } } },\"t1\"); Thread t2=new Thread(()-&gt;{ synchronized (o) { for (int i = 0; i &lt; 100; i++) { System.out.println(\"t2\"); count++; } } },\"t2\"); t1.start(); t2.start(); t1.join(); t2.join(); log.info(\"count:{}\",count); }} 每次需要把synchronized(锁){}中的代码块执行完后才会释放锁，即谁先拿到锁，谁先执行完所有for循环的count++或count–操作。 如果 t1 synchronized(obj1) 而 t2 synchronized(obj2) 会怎样运作？ 锁住的对象不同，没有产生竞争关系。 无效 如果 t1 synchronized(obj) 而 t2 没有加会怎么样？如何理解？ 对象没有产生竞争。无效 ⑥面向对象改进把需要保护的共享变量放入一个类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859@Slf4jpublic class T1 { public static void main(String[] args) throws InterruptedException { Room room=new Room(); Thread t1=new Thread(()-&gt;{ for (int i = 0; i &lt; 1000; i++) { System.out.println(\"t1\"); room.increment(); } },\"t1\"); Thread t2=new Thread(()-&gt;{ for (int i = 0; i &lt; 1000; i++) { System.out.println(\"t2\"); room.decrement(); } },\"t2\"); t1.start(); t2.start();// 让t1线程跑完 t1.join();// 让t2线程跑完 t2.join(); log.info(\"count:{}\",room.getCount()); }}class Room{ private int count=0; /** * 加 */ public void increment(){// 锁住当前创建的对象 synchronized (this){ count++; } } /** * 减 */ public void decrement(){ synchronized (this) { count--; } } /** * 获得值 * @return */ public int getCount() { synchronized (this) { return count; } }} 12//交替执行t1 t212:56:13.825 [main] INFO org.lc.synchronized_t.T1 - count:0 5、方法上的synchronized 非静态方法锁的是对象， 静态方法因为共享性质，锁的是类对象(类对象只能有一份，即无论new多少个对象，其中的类对象只有一份) 类中的非静态成员储存在堆。静态方法储存在方法区，被该类中的对象所共享 ①加在普通方法注意：这里不叫锁方法，而是叫锁当前this对象 12345678910111213class Test{ public synchronized void test(){ }}//等价于==&gt;class Test{ public void test(){ synchronized(this){ } }} ②加在静态方法上注意：这里叫锁类对象，因为在静态方法中无法调用this对象。 12345678910111213class Test{ public synchronized static void test(){ }}//等价于==&gt;class Test{ public static void test(){ synchronized(Test.class){ } }} ③线程八锁其实就是考察 synchronized 锁住的是哪个对象(实例对象，还是类对象) *情况1： * 结果为1 2 或 2 1 12345678910111213141516171819@Slf4jpublic class T2 { public static void main(String[] args) { Number number=new Number();// 使用的同一对象，即锁同一对象，产生互斥 new Thread(()-&gt;{number.a();},\"t1\").start(); new Thread(()-&gt;{number.b();},\"t2\").start(); }}@Slf4jclass Number{ public synchronized void a() { log.debug(\"1\"); } public synchronized void b() { log.debug(\"2\"); }} 情况2: 结果为 2 （1秒后） 1 或 (1秒后) 1 2 123456789101112131415161718192021222324252627@Slf4jpublic class T2 { public static void main(String[] args) { Number number=new Number();// 使用的同一对象，即锁同一对象，产生互斥 Thread t1=new Thread(()-&gt;{number.a();},\"t1\"); Thread t2=new Thread(()-&gt;{number.b();},\"t2\"); t1.start(); t2.start(); }}@Slf4jclass Number{ public synchronized void a() { try { //如果线程首先运行此代码，则后序线程使用该对象(是对象，不是方法)时，会阻塞。 Thread.sleep(1000); log.debug(\"1\"); } catch (InterruptedException e) { e.printStackTrace(); } } public synchronized void b() { log.debug(\"2\"); }} 情况3： 结果为： 3 (1秒后) 1 2 或 3 2 (1秒后) 1 或 2 3 (1秒后) 1 123456789101112131415161718192021222324252627282930313233@Slf4jpublic class T2 { public static void main(String[] args) { Number number=new Number();// t1,t2使用的同一对象，即锁同一对象，产生互斥 Thread t1=new Thread(()-&gt;{number.a();},\"t1\"); Thread t2=new Thread(()-&gt;{number.b();},\"t2\");// t3与(t1,t2)并行，t1与t2产生竞争关系 Thread t3=new Thread(()-&gt;{number.c();},\"t3\"); t1.start(); t2.start(); t3.start(); }}@Slf4jclass Number{ public synchronized void a() { try { Thread.sleep(1000); log.debug(\"1\"); } catch (InterruptedException e) { e.printStackTrace(); } } public synchronized void b() { log.debug(\"2\"); } public void c() { log.debug(\"3\"); }} 情况4：结果为 2 （1秒后） 1 123456789101112131415161718192021222324252627@Slf4jpublic class T2 { public static void main(String[] args) { Number number1=new Number(); Number number2=new Number();// t1,t2使用的不同对象，即不互斥 并行关系 Thread t1=new Thread(()-&gt;{number1.a();},\"t1\"); Thread t2=new Thread(()-&gt;{number2.b();},\"t2\"); t1.start(); t2.start(); }}@Slf4jclass Number{ public synchronized void a() { try { Thread.sleep(2000); log.debug(\"1\"); } catch (InterruptedException e) { e.printStackTrace(); } } public synchronized void b() { log.debug(\"2\"); }} 情况5： 结果为 2 （1秒后） 1 12345678910111213141516171819202122232425262728@Slf4jpublic class T2 { public static void main(String[] args) { Number number1=new Number();// t1执行的为类对象 t2为this实例对象。即为并行关系 Thread t1=new Thread(()-&gt;{number1.a();},\"t1\"); Thread t2=new Thread(()-&gt;{number1.b();},\"t2\"); t1.start(); t2.start(); }}@Slf4jclass Number{// 锁的为类对象 public static synchronized void a() { try { Thread.sleep(1000); log.debug(\"1\"); } catch (InterruptedException e) { e.printStackTrace(); } }// 锁的为this对象实例 public synchronized void b() { log.debug(\"2\"); }} 情况6： 结果为 2 （1秒后） 1 或 (1秒后) 1 2 12345678910111213141516171819202122232425262728@Slf4jpublic class T2 { public static void main(String[] args) { Number number1=new Number();// t1与t2执行的都是同一类对象。即为互斥关系 Thread t1=new Thread(()-&gt;{number1.a();},\"t1\"); Thread t2=new Thread(()-&gt;{number1.b();},\"t2\"); t1.start(); t2.start(); }}@Slf4jclass Number{// 锁的为类对象 public static synchronized void a() { try { Thread.sleep(2000); log.debug(\"1\"); } catch (InterruptedException e) { e.printStackTrace(); } }// 锁的为类对象 public static synchronized void b() { log.debug(\"2\"); }} 情况7： 2 （1秒后) 1 12345678910111213141516171819202122232425262728293031@Slf4jpublic class T2 { public static void main(String[] args) { Number number1=new Number(); Number number2=new Number();// t1锁的为类对象Number，无论new多少个对象，类对象只有一个。// t2锁的为this对象实例// t1与t2并行关系 Thread t1=new Thread(()-&gt;{number1.a();},\"t1\"); Thread t2=new Thread(()-&gt;{number2.b();},\"t2\"); t1.start(); t2.start(); }}@Slf4jclass Number{// 锁的为类对象 public static synchronized void a() { try { Thread.sleep(2000); log.debug(\"1\"); } catch (InterruptedException e) { e.printStackTrace(); } }// 锁的为this实例对象 public synchronized void b() { log.debug(\"2\"); }} 情况8： 结果为 2 （1秒后） 1 或 (1秒后) 1 2 12345678910111213141516171819202122232425262728293031@Slf4jpublic class T2 { public static void main(String[] args) { Number number1=new Number(); Number number2=new Number();// t1锁的为类对象Number，无论new多少个对象，类对象只有一个Number.class。// t1锁的为类对象Number，无论new多少个对象，类对象只有一个Number.class。// t1与t2互斥关系 Thread t1=new Thread(()-&gt;{number1.a();},\"t1\"); Thread t2=new Thread(()-&gt;{number2.b();},\"t2\"); t1.start(); t2.start(); }}@Slf4jclass Number{// 锁的为类对象 public static synchronized void a() { try { Thread.sleep(2000); log.debug(\"1\"); } catch (InterruptedException e) { e.printStackTrace(); } }// 锁的为类对象 public static synchronized void b() { log.debug(\"2\"); }} 结论： 锁类对象：首先判断是否为同一类对象，若为同一类对象，无论new多少次，类对象只有一份。即产生互斥 static synchronized void test(){} &lt;!--￼63--&gt; 锁this类对象： 若使用的同一实例对象(需要在临界区加synchronized)，则产生互斥。 synchronized void test(){} &lt;!--￼64--&gt; 6、变量的线程安全分析①成员变量和静态变量是否线程安全 如果它们没有共享，则线程安全 如果它们被共享了，根据它们的状态是否能够改变，又分两种情况 如果只有读操作，则线程安全 如果有读写操作，则这段代码是临界区，需要考虑线程安全 ②局部变量是否线程安全？ 局部变量是线程安全的 但局部变量引用的对象则未必 如果该对象没有逃离方法的作用访问，它是线程安全的 如果该对象逃离方法的作用范围(即该对象为方法外的变量)，需要考虑线程安全 局部变量线程安全分析1234public static void test1() { int i = 10; i++;} 每个线程调用 test1() 方法时局部变量 i，会在每个线程的栈帧内存中被创建多份，因此不存在共享。即每个线程在栈中的独立栈帧都会创建一个新的i变量内存 ③引用的变量在方法外(产生线程安全问题)123456789101112131415161718192021222324252627282930313233public class T3 {// 线程个数 static final int THRUED_NUMBER=2;// 循环次数 static final int LOOP_NUMBER=200; public static void main(String[] args) { ThreadUnSafe test=new ThreadUnSafe(); for (int i = 0; i &lt; THRUED_NUMBER; i++) {// 这里两个线程共用同一个对象中的list成员变量。所以会发生remove异常(未添加元素就移除) new Thread(()-&gt;{ test.method1(LOOP_NUMBER); },\"Thread:\"+i).start(); } }}class ThreadUnSafe{// 成员变量 ArrayList&lt;String&gt; list=new ArrayList&lt;&gt;(); public void method1(int loopNumber) { for (int i = 0; i &lt; loopNumber; i++) { //临界区 产生竞争条件 this.method2(); this.method3(); } } private void method2() { list.add(\"1\"); } private void method3() { list.remove(0); }} 1234567Exception in thread \"Thread:0\" java.lang.IndexOutOfBoundsException: Index: 0, Size: 0 at java.util.ArrayList.rangeCheck(ArrayList.java:657) at java.util.ArrayList.remove(ArrayList.java:496) at org.lc.synchronized_t.ThreadUnSafe.method3(T3.java:45) at org.lc.synchronized_t.ThreadUnSafe.method1(T3.java:36) at org.lc.synchronized_t.T3.lambda$main$0(T3.java:21) at java.lang.Thread.run(Thread.java:748) 分析：即某一个线程先执行add,我们发现add源码中有一个size++，该size是成员变量，多个线程共享size操作，即会出现线程不安全的问题。即不同的线程操作add时，可能size可能出现竞争导致size写回的时候不会添加或者添加被覆盖的情况。即会出现索引越界的异常 ④引用的变量在方法内(线程安全)将 list 修改为局部变量 12345678910111213141516171819202122232425262728293031public class T3 {// 线程个数 static final int THRUED_NUMBER=2;// 循环次数 static final int LOOP_NUMBER=200; public static void main(String[] args) { ThreadUnSafe test=new ThreadUnSafe(); for (int i = 0; i &lt; THRUED_NUMBER; i++) { new Thread(()-&gt;{ test.method1(LOOP_NUMBER); },\"Thread:\"+i).start(); } }}class ThreadUnSafe{ public void method1(int loopNumber) { // 局部变量 ArrayList&lt;String&gt; list=new ArrayList&lt;&gt;(); for (int i = 0; i &lt; loopNumber; i++) { this.method2(list); this.method3(list); } } private void method2(ArrayList&lt;String&gt; list) { list.add(\"1\"); } private void method3(ArrayList&lt;String&gt; list) { list.remove(0); }} 分析： list 是局部变量，每个线程调用时会创建其不同实例，没有共享 不同线程为list变量创建不同的栈帧内存。即不共享 而 method2 的参数是从 method1 中传递过来的，与 method1 中引用同一个对象 方法访问修饰符带来的思考，如果把 method2 和 method3 的方法修改为 public 会不会代理线程安全问题？ 情况1：有其它线程调用 method2 和 method3 情况2：在 情况1 的基础上，为 ThreadSafe 类添加子类，子类覆盖 method2 或 method3 方法，即 123456789101112131415161718192021222324class ThreadUnSafe{ public void method1(int loopNumber) { ArrayList&lt;String&gt; list=new ArrayList&lt;&gt;(); for (int i = 0; i &lt; loopNumber; i++) { method2(list); method3(list); } } public void method2(ArrayList&lt;String&gt; list) { list.add(\"1\"); } public void method3(ArrayList&lt;String&gt; list) { list.remove(0); }}class ThreadSafeSubClass extends ThreadUnSafe{ @Override public void method3(ArrayList&lt;String&gt; list) { new Thread(()-&gt;{ list.remove(0); }).start(); }} 结论：从这个例子可以看出 private 或 ﬁnal 提供【安全】的意义所在，请体会开闭原则中的【闭】 7、常见线程安全类 String Integer StringBuﬀer Random Vector Hashtable java.util.concurrent 包下的类 这里说它们是线程安全的是指，多个线程调用它们同一个实例的某个方法时，是线程安全的。也可以理解为： HashTable给每个方法加上synchronized给对象上锁。即多个线程操作同一个对象会产生互斥，只要是操作了对象中的任意synchronized方法 1234567Hashtable hashtable=new Hashtable();new Thread(()-&gt;{ hashtable.put(\"k1\", \"v1\");},\"t1\").start();new Thread(()-&gt;{ hashtable.put(\"k2\", \"v2\");},\"t2\").start(); 它们的每个方法是原子的 ①线程安全类方法的组合(非线程安全)这种组合方式，并不能保证原子性。 12345Hashtable hashtable=new Hashtable();//多个线程操作 t1,t2if(hashtable.get(\"k1\")==null){ hashtable.put(\"k1\", \"v1\");} 注意：假设线程1先拿到锁，先执行get操作，执行完后会释放锁。此时t2线程开始执行get操作，执行完后释放锁，恰巧t2线程又拿到了锁执行put操作，执行完后释放锁。然后t1线程拿到锁执行put操作，此时t2线程的put操作已被t1线程覆盖 ②不可变类线程安全性String、Integer 等都是不可变类，因为其内部的状态不可以改变，因此它们的方法都是线程安全的 String 有 replace，substring 等方法【可以】改变值啊，那么这些方法又是如何保证线程安 全的呢？ 因为我们从源码可以发现，replace和substring 都是对其原来的字符串进行修改拷贝后重新new了一个新的字符串 12345678910public String substring(int beginIndex) { if (beginIndex &lt; 0) { throw new StringIndexOutOfBoundsException(beginIndex); } int subLen = value.length - beginIndex; if (subLen &lt; 0) { throw new StringIndexOutOfBoundsException(subLen); } return (beginIndex == 0) ? this : new String(value, beginIndex, subLen); } 8、习题①买票1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980@Slf4jpublic class T4 {// random线程安全 static Random random=new Random(); /** * 随机获取买票数量 1-5 * @return */ public static int randomAmount() { return random.nextInt(5)+1; } public static void main(String[] args) { TicketWindow ticketWindow = new TicketWindow(2000);// 储存线程 List&lt;Thread&gt; threadList=new ArrayList&lt;&gt;();// 存储每个线程卖的票数// 这里需要使用Vector来保证线程安全，因为多个线程多同一个集合进行操作 List&lt;Integer&gt; sellCount=new Vector&lt;&gt;(); for (int i = 0; i &lt; 1000; i++) { Thread thread=new Thread(()-&gt;{ try {// 模拟线程创建延迟 Thread.sleep(10); } catch (InterruptedException e) { e.printStackTrace(); }// 多个线程对同一ticketWindow对象操作，产生线程安全问题 int sell = ticketWindow.sell(randomAmount());// 多个线程对同一集合操作，产生线程安全问题 sellCount.add(sell); });// 这里的集合线程安全，因为只是对thread变量的引用进行添加操作，线程没有对threadList集合操作 threadList.add(thread);// 启动线程 thread.start(); }// 遍历所有线程 threadList.forEach(t-&gt; { try {// 保证所有线程执行完毕 t.join(); } catch (InterruptedException e) { e.printStackTrace(); } });// 遍历集合进行买票求和操作 int sum = sellCount.stream().mapToInt(t -&gt; t).sum(); log.info(\"卖的总票数为:{}\",sum); log.info(\"剩余总票数为:{}\",ticketWindow.getCount()); }}//模拟售票窗口class TicketWindow{ //余票 private int count; public TicketWindow(int count) { this.count = count; } //获取余票 public int getCount() { return count; } /** *售票方法 * @param amount 售票数量 * @return 成功售票,返回售票数量。售票失败。返回0 */ public int sell(int amount){ if (this.count &gt;= amount) { this.count -= amount; return amount; } return 0; }} 结果 售票数量和初始余票数量(2000)不一致。线程不安全。 1212:57:03.578 [main] INFO org.lc.synchronized_t.T4 - 卖的总票数为:204812:57:03.582 [main] INFO org.lc.synchronized_t.T4 - 剩余总票数为:0 解决方法： 给售票方法(临界区)加synchornized 123456789101112/** *售票方法 * @param amount 售票数量 * @return 成功售票,返回售票数量。售票失败。返回0 */ public synchronized int sell(int amount){ if (this.count &gt;= amount) { this.count -= amount; return amount; } return 0; } ②转账12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364@Slf4jpublic class T5 { static Random random = new Random(); //随机转账1到100 public static int randomInt() { return random.nextInt(100) + 1; } public static void main(String[] args) throws InterruptedException {// 账户a 1000 Account a = new Account(1000);// 账户b 1000 Account b = new Account(1000);// 线程t1实现a对b的多次随机转账 Thread t1 = new Thread(() -&gt; { for (int i = 0; i &lt; 1000; i++) {// 线程不安全 a.transfer(b, randomInt()); } });// 线程2实现b对a的多次随机转账 Thread t2=new Thread(()-&gt;{ for (int i = 0; i &lt; 1000; i++) {// 线程不安全 b.transfer(a, randomInt()); } }); t1.start(); t2.start(); t1.join(); t2.join(); log.info(\"账户a:{}\",a.getMoney()); log.info(\"账户b:{}\",b.getMoney()); }}//账户类class Account { // 账户余额 private int money; public Account(int money) { this.money = money; } public int getMoney() { return money; } public void setMoney(int money) { this.money = money; } /** * 转账操作 * * @param target 目标转账用户 * @param amount 转账金额 */ public void transfer(Account target, int amount) { if (this.money &gt;= amount) { this.setMoney(this.getMoney() - amount); target.setMoney(target.getMoney() + amount); } }} 结果为：账户完全紊乱。 1215:42:02.613 [main] INFO org.lc.synchronized_t.T5 - 账户a:160715:42:02.617 [main] INFO org.lc.synchronized_t.T5 - 账户b:0 首先我们可以想到给方法加锁: 123456public synchronized void transfer(Account target, int amount) { if (this.money &gt;= amount) { this.setMoney(this.getMoney() - amount); target.setMoney(target.getMoney() + amount); } } 注意：上述方法是给当前对象加锁，即当前调用transfer方法的对象加锁，但是传过来的Account对象还是两个线程在共享使用，即会出现问题。 最终解决：我们给当前类对象加锁，尽管你创建多个账户对象，但是对个线程进行转账的时候，只有一个线程能执行该方法。即类对象只有一个，给类对象加锁，被多个线程使用时互斥。但是这会出现一个缺点，同一个时间只有一个线程能做此事，导致效率非常低。 12345678public void transfer(Account target, int amount) { synchronized (Account.class) { if (this.money &gt;= amount) { this.setMoney(this.getMoney() - amount); target.setMoney(target.getMoney() + amount); } } } 1215:46:10.728 [main] INFO org.lc.synchronized_t.T5 - 账户a:199915:46:10.733 [main] INFO org.lc.synchronized_t.T5 - 账户b:1 9、Monitor概念①java对象头 例如： Integer对象大小=8字节(Object Header)+储存值的4字节 int 大小=4字节 以 32 位虚拟机为例 普通对象： Klass Word 存储的是对象的类型，即类对象的指针 Mark Word 包含的为对象的详细信息，即对象的成员 Mark Word结构： 10、wait、notify①为什么需要wait ②wait原理 Owner 线程发现条件(即该线程已经获得了锁)不满足，调用 wait 方法，即可进入 WaitSet 变为 WAITING 状态 BLOCKED 和 WAITING 的线程都处于阻塞状态，不占用 CPU 时间片 BLOCKED 线程会在 Owner 线程释放锁时唤醒 ③API介绍调用wait方法，会取消偏量锁撤销，升级为重量锁 WAITING 线程会在 Owner 线程调用 notify 或 notifyAll 时唤醒，但唤醒后并不意味者立刻获得锁，仍需进入 EntryList 重新竞争 obj.wait() 让进入 object 监视器的线程到 waitSet 等待 obj.notify() 在 object 上正在 waitSet 等待的线程中挑一个唤醒 obj.notifyAll() 让 object 上正在 waitSet 等待的线程全部唤醒 它们都是线程之间进行协作的手段，都属于 Object 对象的方法。必须获得此对象的锁，才能调用这几个方法 即必须为锁的这个对象才能调用wait/notify。即synchronized(lock)中的 lock对象调用wait/notify 注意：没有获得锁的线程执行wait/notify方法会报错 12345678910public class T1 { static final Object object=new Object(); public static void main(String[] args) { try { object.wait(); } catch (InterruptedException e) { e.printStackTrace(); } }} 1234Exception in thread \"main\" java.lang.IllegalMonitorStateException at java.lang.Object.wait(Native Method) at java.lang.Object.wait(Object.java:502) at org.lc.wait_notify.T1.main(T1.java:14) 正确的姿势： 123456789101112131415public class T1 { static final Object object=new Object(); public static void main(String[] args) { try { synchronized (object) { object.wait(); } } catch (InterruptedException e) { e.printStackTrace(); } }} wait(),notify(),notifyAll()实例： 123456789101112131415161718192021222324252627282930313233343536373839404142@Slf4jpublic class T1 { static final Object object=new Object(); public static void main(String[] args) throws InterruptedException { new Thread(()-&gt;{ synchronized (object) { log.info(\"开始执行...\"); try { //线程进入waiting阻塞 object.wait(); } catch (InterruptedException e) { e.printStackTrace(); } log.info(\"其他代码...\"); } },\"t1\").start(); new Thread(()-&gt;{ synchronized (object) { log.info(\"开始执行...\"); try { //线程进入waiting阻塞 object.wait(); } catch (InterruptedException e) { e.printStackTrace(); } log.info(\"其他代码...\"); } },\"t2\").start(); // 先让其他线程执行 Thread.sleep(2000); synchronized (object) {// 唤醒一个线程(唤醒的线程竞争)// object.notify();// 唤醒所有waiting线程 object.notifyAll(); } }} 123411:28:06.797 [t1] INFO org.lc.wait_notify.T1 - 开始执行...11:28:06.799 [t2] INFO org.lc.wait_notify.T1 - 开始执行...11:28:08.795 [t2] INFO org.lc.wait_notify.T1 - 其他代码...11:28:08.795 [t1] INFO org.lc.wait_notify.T1 - 其他代码... wait(long n)有时限的等待, 到 n 毫秒后结束等待，重新争抢锁。或是被 notify/notifyAll 123456789101112131415161718@Slf4jpublic class T2 { static final Object object=new Object(); public static void main(String[] args) throws InterruptedException { new Thread(() -&gt; { synchronized (object) { log.info(\"开始执行...\"); try { //线程进入waiting阻塞 object.wait(3000); } catch (InterruptedException e) { e.printStackTrace(); } log.info(\"其他代码...\"); } }, \"t1\").start(); }} 1211:32:31.444 [t1] INFO org.lc.wait_notify.T2 - 开始执行...11:32:34.447 [t1] INFO org.lc.wait_notify.T2 - 其他代码... 3秒后自动被唤醒 ④wait(long n)和sleep(long n)的区别1) sleep 是 Thread 方法，而 wait 是 Object 的方法 2) sleep 不需要强制和 synchronized 配合使用，但 wait 需要 和 synchronized 一起用 3) sleep 在睡眠的同时，不会释放对象锁的，但 wait 在等待的时候会释放对象锁 4) 它们 状态都是 TIMED_WAITING ⑤唤醒占用同一锁的其他指定线程-实例注意：这里不能用sleep，因为sleep不会释放锁，而要用wiat,wait会释放锁 用 notifyAll 仅解决某个线程的唤醒问题，但使用 if + wait 判断仅有一次机会，一旦条件不成立，就没有重新 判断的机会了 解决方法，用 while + wait，当条件不成立，再次 wait 虚假唤醒：notify 只能随机唤醒一个 WaitSet 中的线程，这时如果有其它线程也在等待，那么就可能唤醒不了正确的线 程，称之为【虚假唤醒】 解决方法，改为 notifyAll 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364@Slf4jpublic class T3 { // 锁 final static Object room = new Object(); // 是否有烟 static boolean hasSomke = false; // 是否有外卖 static boolean hasLunch = false; public static void main(String[] args) throws InterruptedException { new Thread(()-&gt;{ synchronized (room) { log.info(\"有烟没？{}\",hasSomke); while (!hasSomke) { log.info(\"先休息一下...\"); try {// 若错误被唤醒，那么会重新判断条件 room.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } log.info(\"有烟没?{}\",hasSomke); if (hasSomke) { log.info(\"开始干活...\"); } } },\"烟枪王\").start(); new Thread(()-&gt;{ synchronized (room) { log.info(\"午饭到没？{}\",hasLunch); if (!hasLunch) { log.info(\"做等饭来...\"); try { room.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } log.info(\"午饭到没？{}\", hasLunch); if (hasLunch) { log.info(\"开吃...\"); } } },\"大胃王\").start();// 先执行其他线程 Thread.sleep(2000); synchronized (room) {// 预先送饭 hasLunch=true; log.info(\"送饭了...\");// 当我们使用notity()时，这是可能会唤醒送烟线程，导致虚假唤醒// notify 只能随机唤醒一个 WaitSet 中的线程// room.notify(); room.notifyAll(); } }} 1234567812:36:46.600 [烟枪王] INFO org.lc.wait_notify.T3 - 有烟没？false12:36:46.605 [烟枪王] INFO org.lc.wait_notify.T3 - 先休息一下...12:36:46.605 [大胃王] INFO org.lc.wait_notify.T3 - 午饭到没？false12:36:46.605 [大胃王] INFO org.lc.wait_notify.T3 - 做等饭来...12:36:48.600 [main] INFO org.lc.wait_notify.T3 - 送饭了...12:36:48.600 [大胃王] INFO org.lc.wait_notify.T3 - 午饭到没？true12:36:48.600 [大胃王] INFO org.lc.wait_notify.T3 - 开吃...12:36:48.600 [烟枪王] INFO org.lc.wait_notify.T3 - 先休息一下... 11、同步模式之保护性暂停①.定义即 Guarded Suspension，用在一个线程等待另一个线程的执行结果要点 有一个结果需要从一个线程传递到另一个线程，让他们关联同一个 GuardedObject 如果有结果不断从一个线程到另一个线程那么可以使用消息队列（见生产者/消费者） JDK 中，join 的实现、Future 的实现，采用的就是此模式 因为要等待另一方的结果，因此归类到同步模式 ②应用- 超时效果1234567891011121314//下载返回读取的网页public class Downloader { public static List&lt;String&gt; download() throws IOException { HttpsURLConnection connection= (HttpsURLConnection) new URL(\"https://www.baidu.com/\").openConnection(); List&lt;String&gt; list=new ArrayList&lt;&gt;(); try(BufferedReader reader=new BufferedReader(new InputStreamReader(connection.getInputStream(), StandardCharsets.UTF_8))) { String line; while ((line = reader.readLine()) != null) { list.add(line); } } return list; }} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374@Slf4jpublic class T4 { public static void main(String[] args) {// 线程1等待线程2的下载结果 GuardedObject guardedObject=new GuardedObject(); new Thread(()-&gt;{// 等待结果 log.info(\"等待结果...\");// 设置超时时间 List&lt;String&gt; o = (List&lt;String&gt;) guardedObject.get(2000); log.info(\"下载的内容:{}\", o==null?\"已超时...\":o.toString()); },\"t1\").start(); new Thread(()-&gt;{ log.info(\"执行下载\"); try {// 下载 List&lt;String&gt; download = Downloader.download();// 传入下载的结果// 这时会唤醒阻塞的线程 guardedObject.complete(download); } catch (IOException e) { e.printStackTrace(); } },\"t2\").start(); }}class GuardedObject{// 结果 private Object response; /** * 获取值 * @param timeout 超时的时间 * @return 返回的结果 */ public Object get(long timeout) { synchronized (this){// 开始时间 long start=System.currentTimeMillis();// 经历的时间 long passedTime=0;// 是否得到结果 while (response==null) {// 这一轮循环应该等待的时间 long waitTime=timeout-passedTime;// 如果经历时间超过 预设的超时时间 if (waitTime&lt;=0) {// 直接退出 break; } try {// 防止虚假唤醒 this.wait(waitTime); } catch (InterruptedException e) { e.printStackTrace(); }// 求得经历的时间 passedTime=System.currentTimeMillis()-start; }// 不为空 返回此结果 return response; } }// 产生结果 public void complete(Object response) { synchronized (this) { this.response=response;// 唤醒等待结果的线程 this.notifyAll(); } }} 设置超时时间：2000(2s) guardedObject.get(2000); 12315:48:00.528 [t1] INFO org.lc.wait_notify.T4 - 等待结果...15:48:00.528 [t2] INFO org.lc.wait_notify.T4 - 执行下载15:48:02.081 [t1] INFO org.lc.wait_notify.T4 - 下载的内容:[&lt;!DOCTYPE html&gt;, &lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt;&lt;meta http-equiv=content-type content=text/html;charset=utf-8&gt;&lt;meta http-.. 设置超时时间：1000(1s) guardedObject.get(1000); 12315:53:50.537 [t2] INFO org.lc.wait_notify.T4 - 执行下载15:53:50.537 [t1] INFO org.lc.wait_notify.T4 - 等待结果...15:53:51.541 [t1] INFO org.lc.wait_notify.T4 - 下载的内容:已超时... ③应用 - join原理12Thread t1=new Thread(()-&gt;{});t1.join(2000); 源码如下： 12345678910111213141516171819202122232425262728public final synchronized void join(long millis) throws InterruptedException { long base = System.currentTimeMillis(); long now = 0; if (millis &lt; 0) { throw new IllegalArgumentException(\"timeout value is negative\"); } //如果没有传入过期时间 if (millis == 0) { //轮询 查询该t1线程是否消亡 while (isAlive()) { //主线程一直阻塞 wait(0); } } else { //调用者线程进入t1的waitSet等待，直到t1运行结束 while (isAlive()) { long delay = millis - now; if (delay &lt;= 0) { break; } //休眠指定的实现 wait(delay); now = System.currentTimeMillis() - base; } } } ​ join方法的本质调用的是Object中的wait方法实现线程的阻塞，但是我们需要知道的是，调用wait方法必须要获取锁，所以join方法是被synchronized修饰的，synchronized修饰在方法层面相当于synchronized(this),this就是t1本身的实例。​ 实际上主线程会持有t1这个对象的锁（即把当前线程对象当锁），然后调用wait方法去阻塞，而这个方法的调用者是在主线程中的。所以造成主线程阻塞。 ④应用- 多任务版 GuardedObject12、异步模式之生产者/消费者①定义要点 与前面的保护性暂停中的 GuardObject 不同，不需要产生结果和消费结果的线程一一对应 消费队列可以用来平衡生产和消费的线程资源 生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据 消息队列是有容量限制的，满时不会再加入数据，空时不会再消耗数据 JDK 中各种阻塞队列，采用的就是这种模式 ②实例 定义消息 12345678910111213141516171819202122//定义消息final class Message{ private int id; private Object value; public Message(int id, Object value) { this.id = id; this.value = value; } public int getId() { return id; } public Object getValue() { return value; } @Override public String toString() { return \"Message{\" + \"id=\" + id + \", value=\" + value + '}'; }} 消息队列 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657@Slf4jclass MessageQueue{// 消息的队列集合 //双向队列 private LinkedList&lt;Message&gt; list=new LinkedList&lt;&gt;(); //队列容量 private int capcity; public MessageQueue(int capcity) { this.capcity = capcity; } //获取消息 public Message take(){ synchronized (list) {// 判断队列是否为空 while (list.isEmpty()) { try { log.info(\"队列为空,消费者线程等待...\");// 为空一直等待 list.wait(); } catch (InterruptedException e) { e.printStackTrace(); } }// 从队列的头部取 Message message = list.removeFirst(); log.info(\"已消费消息{}\",message);// 唤醒存入消息的线程 list.notifyAll(); return message; } } //存入消息 public void put(Message message) { synchronized (list) {// 检查队列是否已满 while (list.size() == capcity) { try { log.info(\"队列已满,生产者等待...\"); list.wait(); } catch (InterruptedException e) { e.printStackTrace(); } }// 从队列的尾部加 list.addLast(message); log.info(\"已生产消息{}\",message);// 唤醒取出消息的线程 list.notifyAll(); } }} 测试 1234567891011121314151617181920212223public class T6 { public static void main(String[] args) throws InterruptedException { MessageQueue queue=new MessageQueue(2); for (int i = 0; i &lt; 3; i++) { int id=i+1; new Thread(()-&gt;{ queue.put(new Message(id,\"值:\"+id )); },\"生产者:\"+id).start(); } Thread.sleep(1000); new Thread(()-&gt;{ while (true) { try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } queue.take(); } },\"消费者\").start(); }} 1234567820:52:02.285 [生产者:1] INFO org.lc.wait_notify.MessageQueue - 已生产消息Message{id=1, value=值:1}20:52:02.290 [生产者:3] INFO org.lc.wait_notify.MessageQueue - 已生产消息Message{id=3, value=值:3}20:52:02.290 [生产者:2] INFO org.lc.wait_notify.MessageQueue - 队列已满,生产者等待...20:52:04.285 [消费者] INFO org.lc.wait_notify.MessageQueue - 已消费消息Message{id=1, value=值:1}20:52:04.285 [生产者:2] INFO org.lc.wait_notify.MessageQueue - 已生产消息Message{id=2, value=值:2}20:52:05.286 [消费者] INFO org.lc.wait_notify.MessageQueue - 已消费消息Message{id=3, value=值:3}20:52:06.287 [消费者] INFO org.lc.wait_notify.MessageQueue - 已消费消息Message{id=2, value=值:2}20:52:07.287 [消费者] INFO org.lc.wait_notify.MessageQueue - 队列为空,消费者线程等待... 13、park和unpark①基本使用它们是 LockSupport 类中的方法 12345// 暂停当前线程 LockSupport.park();// 恢复某个线程的运行 LockSupport.unpark(暂停线程对象) 先 park 后 unpark 123456789101112131415161718192021@Slf4jpublic class T1 { public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(() -&gt; { log.info(\"start...\"); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } log.info(\"park...\"); LockSupport.park(); log.info(\"resume...\"); }, \"t1\"); t1.start(); Thread.sleep(2000); log.info(\"unpark\"); LockSupport.unpark(t1); }} 123421:09:20.417 [t1] INFO org.lc.park_unpark.T1 - start...21:09:21.421 [t1] INFO org.lc.park_unpark.T1 - park...21:09:22.415 [main] INFO org.lc.park_unpark.T1 - unpark21:09:22.415 [t1] INFO org.lc.park_unpark.T1 - resume... 先 unpark 后 park 。也能唤醒park进程 123456789101112131415161718192021@Slf4jpublic class T1 { public static void main(String[] args) throws InterruptedException { Thread t1 = new Thread(() -&gt; { log.info(\"start...\"); try { Thread.sleep(2000); } catch (InterruptedException e) { e.printStackTrace(); } log.info(\"park...\"); LockSupport.park(); log.info(\"resume...\"); }, \"t1\"); t1.start(); Thread.sleep(1000); log.info(\"unpark\"); LockSupport.unpark(t1); }} 123421:11:05.473 [t1] INFO org.lc.park_unpark.T1 - start...21:11:06.473 [main] INFO org.lc.park_unpark.T1 - unpark21:11:07.476 [t1] INFO org.lc.park_unpark.T1 - park...21:11:07.476 [t1] INFO org.lc.park_unpark.T1 - resume... ②基本原理每个线程都有自己的一个 Parker 对象，由三部分组成_counter ， _cond和 _mutex打个比喻 线程就像一个旅人，Parker 就像他随身携带的背包，条件变量就好比背包中的帐篷。_counter 就好比背包中 的备用干粮（0 为耗尽，1 为充足） 调用 park 就是要看需不需要停下来歇息 如果备用干粮耗尽，那么钻进帐篷歇息 如果备用干粮充足，那么不需停留，继续前进 调用 unpark，就好比令干粮充足 如果这时线程还在帐篷，就唤醒让他继续前进 如果这时线程还在运行，那么下次他调用 park 时，仅是消耗掉备用干粮，不需停留继续前进 因为背包空间有限，多次调用 unpark 仅会补充一份备用干粮 ③与Object的wait&amp;notify相比 wait，notify 和 notifyAll 必须配合 Object Monitor 一起使用，而 park，unpark 不必 park &amp; unpark 是以线程为单位来【阻塞】和【唤醒】线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程，就不那么【精确】 park &amp; unpark 可以先 unpark，而 wait &amp; notify 不能先 notify 14、活跃性①多把不相干的锁将锁的粒度细分 好处，是可以增强并发度 坏处，如果一个线程需要同时获得多把锁，就容易发生死锁 共用一把锁this： 12345678910111213141516171819202122232425262728293031323334public class T1 { public static void main(String[] args) { Room room=new Room(); new Thread(()-&gt;{ try { room.sleep(); } catch (InterruptedException e) { e.printStackTrace(); } },\"t1\").start(); new Thread(()-&gt;{ try { room.study(); } catch (InterruptedException e) { e.printStackTrace(); } },\"t2\").start(); }}@Slf4jclass Room{ public void sleep() throws InterruptedException { synchronized (this) { log.info(\"sleep...\"); Thread.sleep(2000); } } public void study() throws InterruptedException { synchronized (this) { log.info(\"study...\"); Thread.sleep(2000); } }} 1220:03:29.176 [t2] INFO org.lc.deathLock.Room - study...20:03:31.176 [t1] INFO org.lc.deathLock.Room - sleep... 我们发现始终是顺序执行的，即是互斥的。但是两个线程业务并不相干。所有我们可以使用不同的锁。 多个锁： 修改Room类 12345678910111213141516171819@Slf4jclass Room{ public final static Object sleepRoom=new Object(); public final static Object studyRoom=new Object(); public void sleep() throws InterruptedException { synchronized (sleepRoom) { log.info(\"sleep...\"); Thread.sleep(2000); } } public void study() throws InterruptedException { synchronized (studyRoom) { log.info(\"study...\"); Thread.sleep(2000); } }} 1220:03:29.176 [t2] INFO org.lc.deathLock.Room - study...20:03:29.176 [t1] INFO org.lc.deathLock.Room - sleep... ②死锁一个线程需要同时获取多把锁，这时就容易发生死锁 t1 线程 获得 o1对象 锁，接下来想获取 o2对象 的锁 t2 线程 获得 o2对象 锁,接下来想获取 o1对象 的锁 123456789101112131415161718192021222324252627282930313233@Slf4jpublic class T2 { static Object o1=new Object(); static Object o2=new Object(); public static void main(String[] args) { new Thread(()-&gt;{ synchronized (o1){ log.info(\"get lock o1\"); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (o2){ log.info(\"get lock o2\"); } } },\"t1\").start(); new Thread(()-&gt;{ synchronized (o2){ log.info(\"get lock o2\"); try { Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } synchronized (o1){ log.info(\"get lock o1\"); } } },\"t2\").start(); }} 12320:08:51.708 [t2] INFO org.lc.deathLock.T2 - get lock o220:08:51.708 [t1] INFO org.lc.deathLock.T2 - get lock o1//程序未终止.. ③活锁活锁出现在两个线程互相改变对方的结束条件，后谁也无法结束 123456789101112131415161718192021222324252627282930@Slf4jpublic class T3 { static int count=10; public static void main(String[] args) { new Thread(()-&gt;{ //期望到0就退出 while (count&gt;0) { try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } log.info(\"count:{}\", count); count--; } },\"t1\").start(); new Thread(()-&gt;{ //期望到20就退出循环 while (count&lt;20){ try { Thread.sleep(100); } catch (InterruptedException e) { e.printStackTrace(); } log.info(\"count:{}\",count); count++; } },\"t2\").start(); }} 123420:17:59.724 [t1] INFO org.lc.deathLock.T3 - count:1120:17:59.811 [t2] INFO org.lc.deathLock.T3 - count:1020:17:59.825 [t1] INFO org.lc.deathLock.T3 - count:11//一值循环的增减 ④饥饿很多教程中把饥饿定义为，一个线程由于优先级太低，始终得不到 CPU 调度执行，也不能够结束，饥饿的情况不 易演示，讲读写锁时会涉及饥饿问题 看使用顺序加锁的方式解决之前的死锁问题 顺序加锁的解决方案 15、ReentrantLock(可重入锁)相对于 synchronized 它具备如下特点 可中断 在阻塞中没有获得锁的线程可中断阻塞。 可以设置超时时间 没有获得锁的线程，最多等待的时间则会放弃获得锁 可以设置为公平锁 支持多个条件变量 与 synchronized 一样，都支持可重入 (轻量级锁) 基本语法： 123456789 ReentrantLock reentrantLock=new ReentrantLock();// 获得锁 reentrantLock.lock(); try { //临界区... }finally { //释放锁 reentrantLock.unlock(); } ①可重入可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁 如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住 123456789101112131415161718192021222324252627282930313233@Slf4jpublic class T1 { static ReentrantLock lock=new ReentrantLock(); public static void main(String[] args) { m1(); } static void m1() { lock.lock(); try { log.info(\"m1...\"); m2(); }finally { lock.unlock(); } } static void m2() { lock.lock(); try { log.info(\"m2...\"); m3(); }finally { lock.unlock(); } } static void m3() { lock.lock(); try { log.info(\"m3...\"); }finally { lock.unlock(); } }} 12312:00:10.170 [main] INFO org.lc.Reentrant_Lock.T2 - m1...12:00:10.173 [main] INFO org.lc.Reentrant_Lock.T2 - m2...12:00:10.173 [main] INFO org.lc.Reentrant_Lock.T2 - m3... ②可打断让没有获得锁的线程中在阻塞的线程被打断 lock.lockInterruptibly() 可打断获得锁的模式 可中断模式： 123456789101112131415161718192021222324252627282930313233@Slf4jpublic class T3 { private static ReentrantLock lock=new ReentrantLock(); public static void main(String[] args) throws InterruptedException { Thread t1=new Thread(()-&gt;{ try { //如果没有竞争那么此方法就会获取lock锁 //如果有竞争就进入阻塞队列，可以被其他线程用interrupt打断 log.info(\"尝试获取锁...\"); lock.lockInterruptibly(); } catch (InterruptedException e) { e.printStackTrace(); log.info(\"没有获得到锁...返回\"); //这里我们被打断，后面的代码也就无需执行了 return; } try { log.info(\"获取到锁...\"); }finally { lock.unlock(); } },\"t1\"); //主线程先获取到锁 lock.lock(); t1.start(); Thread.sleep(1000); //打断t1线程 t1.interrupt(); }} 123412:23:27.170 [t1] INFO org.lc.Reentrant_Lock.T3 - 尝试获取锁...java.lang.InterruptedException at ....12:23:28.168 [t1] INFO org.lc.Reentrant_Lock.T3 - 没有获得到锁...返回 不可中断模式，那么即使使用了 interrupt 也不会让等待中断 12345678910111213141516171819202122@Slf4jpublic class T3 { private static ReentrantLock lock=new ReentrantLock(); public static void main(String[] args) throws InterruptedException { Thread t1=new Thread(()-&gt;{ try { //如果没有竞争那么此方法就会获取lock锁 //如果有竞争就进入阻塞队列，可以被其他线程用interrupt打断 log.info(\"尝试获取锁...\"); lock.lock(); } finally { lock.unlock(); } },\"t1\"); //主线程先获取到锁 lock.lock(); t1.start(); Thread.sleep(1000); log.info(\"打断...\"); t1.interrupt(); }} 12312:34:20.364 [t1] INFO org.lc.Reentrant_Lock.T3 - 尝试获取锁...12:34:21.361 [main] INFO org.lc.Reentrant_Lock.T3 - 打断...//阻塞的线程并没有被打断。 ③锁超时 如果没有获得到锁，立刻失败返回 tryLock() 获取到锁返回true,否则返回false 1234567891011121314151617181920212223242526@Slf4jpublic class T4 { private static ReentrantLock lock=new ReentrantLock(); public static void main(String[] args) throws InterruptedException { Thread t1=new Thread(()-&gt;{ log.info(\"尝试获取锁...\"); if(!lock.tryLock()){ //没有获得锁 返回false log.info(\"没有获得到锁...\"); return; } try { log.info(\"获得了锁...\"); } finally { lock.unlock(); } },\"t1\"); //主线程先获取到锁 lock.lock(); t1.start(); }} 1212:43:47.121 [t1] INFO org.lc.Reentrant_Lock.T4 - 尝试获取锁...12:43:47.123 [t1] INFO org.lc.Reentrant_Lock.T4 - 没有获得到锁... 在指定的时间内等待锁，等待的时候可被打断。 tryLock(long timeout, TimeUnit unit) 1234567891011121314151617181920212223242526272829303132333435363738@Slf4jpublic class T4 { private static ReentrantLock lock=new ReentrantLock(); public static void main(String[] args) throws InterruptedException { Thread t1=new Thread(()-&gt;{ try { log.info(\"尝试获取锁...\"); //最多等待3秒，没有获得到锁返回false if (!lock.tryLock(3, TimeUnit.SECONDS)) { //没有获得锁 返回false log.info(\"没有获得到锁...\"); //直接退出 return; } } catch (InterruptedException e) { e.printStackTrace(); log.info(\"被打断...没有获得到锁\");// 打断后也应该返回 return; } try { log.info(\"获得了锁...\"); } finally { lock.unlock(); } },\"t1\"); //主线程先获取到锁 lock.lock(); t1.start(); Thread.sleep(1000); //主线程获得锁1s后打断在阻塞等待的t1线程 t1.interrupt(); }} 123412:53:08.668 [t1] INFO org.lc.Reentrant_Lock.T4 - 尝试获取锁...java.lang.InterruptedException at ....12:53:09.666 [t1] INFO org.lc.Reentrant_Lock.T4 - 被打断...没有获得到锁 ④公平锁即在WaitSet中阻塞的线程争抢锁的时候是非公平的，即随机争抢。 而公平锁，阻塞线程在争抢锁的时候是按照阻塞队列的顺序来的。 ReentrantLock默认是不公平的 12//设置公平锁ReentrantLock lock = new ReentrantLock(true); 公平锁一般没有必要，会降低并发度。 ⑤条件变量​ synchronized 中也有条件变量，就是我们讲原理时那个 waitSet 休息室，当条件不满足时进入 waitSet 等待 ReentrantLock 的条件变量比 synchronized 强大之处在于，它是支持多个条件变量的，这就好比 synchronized 是那些不满足条件的线程都在一间休息室等消息 而 ReentrantLock 支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤 醒，即阻塞队列的存放位置可以分组， 使用要点(和synchronized类似，只是阻塞队列做了区分，然后需要手动释放锁) await 前需要获得锁 await 执行后，会释放锁，进入 conditionObject 等待 await 的线程被唤醒(signal)（或打断、或超时）取重新竞争 lock 锁 竞争 lock 锁成功后，从 await 后继续执行 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788@Slf4jpublic class T6 {// 是否有烟 static boolean hasSmoke=false;// 是否有饭 static boolean hasLunch=false;// 可重入锁 static ReentrantLock lock=new ReentrantLock();// 抽烟的队列 static Condition somekRoom=lock.newCondition();// 吃饭的队列 static Condition lunchRoom=lock.newCondition(); public static void main(String[] args) throws InterruptedException { new Thread(()-&gt;{// 尝试获得锁 lock.lock(); try { log.info(\"有烟没？{}\",hasSmoke); while (!hasSmoke) { try { log.info(\"烟没到，休息下...\"); //没烟。等烟 somekRoom.await(); } catch (InterruptedException e) { //可打断 e.printStackTrace(); } } //有烟 log.info(\"有烟，开始干活！\"); }finally {// 释放锁 lock.unlock(); } },\"烟杆子\").start(); new Thread(()-&gt;{// 尝试获得锁 lock.lock(); try { log.info(\"有饭没？{}\",hasLunch); while (!hasLunch) { try { log.info(\"没饭，睡一会...\"); lunchRoom.await(); } catch (InterruptedException e) {// 可被打断 e.printStackTrace(); } } log.info(\"饭来了，恰饭!\"); }finally {// 释放锁 lock.unlock(); } },\"饭桶\").start(); new Thread(()-&gt;{// 获取锁 lock.lock(); try {// 送烟 hasSmoke=true;// 唤醒阻塞的烟杆子// 这里signal()只会唤醒somkeRoom中的一个 somekRoom.signal(); }finally { lock.unlock(); } },\"工具人1\").start(); Thread.sleep(2000); new Thread(()-&gt;{// 获得锁 lock.lock(); try {// 送饭 hasLunch=true;// 关系lunchRoom中等待的队列 lunchRoom.signal(); }finally { lock.unlock(); } },\"工具人2\").start(); }} 12345616:27:44.550 [烟杆子] INFO org.lc.Reentrant_Lock.T6 - 有烟没？false16:27:44.554 [烟杆子] INFO org.lc.Reentrant_Lock.T6 - 烟没到，休息下...16:27:44.554 [饭桶] INFO org.lc.Reentrant_Lock.T6 - 有饭没？false16:27:44.554 [饭桶] INFO org.lc.Reentrant_Lock.T6 - 没饭，睡一会...16:27:44.554 [烟杆子] INFO org.lc.Reentrant_Lock.T6 - 有烟，开始干活！16:27:46.548 [饭桶] INFO org.lc.Reentrant_Lock.T6 - 饭来了，恰饭! 16、设计模式-同步模式之顺序控制①固定运行顺序题目：必须先打印2后打印11、使用wait/notify1234567891011121314151617181920212223242526272829303132@Slf4jpublic class T1 { static Object lock=new Object(); static boolean isRun=false; public static void main(String[] args) { Thread t1 = new Thread(() -&gt; { synchronized (lock) { while (!isRun) { try { lock.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } log.info(\"RunWith 1...\"); } }, \"t1\"); Thread t2=new Thread(()-&gt;{ synchronized (lock) { log.info(\"RunWith 2...\"); if(!isRun){ isRun=true; lock.notify(); } } },\"t2\"); t1.start(); t2.start(); }} 1216:48:20.774 [t2] INFO org.lc.desiger_.T1 - RunWith 2...16:48:20.776 [t1] INFO org.lc.desiger_.T1 - RunWith 1... 2、使用ReentrantLock123456789101112131415161718192021222324252627282930313233343536@Slf4jpublic class T2 { static ReentrantLock lock=new ReentrantLock(); static Condition waitSet=lock.newCondition(); static boolean isRun=false; public static void main(String[] args) { new Thread(()-&gt;{ lock.lock(); try { while (!isRun){ try { waitSet.await(); } catch (InterruptedException e) { e.printStackTrace(); } } log.info(\"runwith 1\"); }finally { lock.unlock(); } },\"t1\").start(); new Thread(()-&gt;{ lock.lock(); try { if (!isRun) { isRun=true; log.info(\"runwith 2\"); waitSet.signal(); } }finally { lock.unlock(); } },\"t1\").start(); }} 1216:59:17.669 [t1] INFO org.lc.desiger_.T2 - runwith 216:59:17.671 [t1] INFO org.lc.desiger_.T2 - runwith 1 3、使用park和unpark123456789101112131415@Slf4jpublic class T3 { public static void main(String[] args) { Thread t1= new Thread(() -&gt; { LockSupport.park(); log.info(\"runwith 1\"); }, \"t1\"); t1.start(); new Thread(()-&gt;{ log.info(\"runwith 2\"); LockSupport.unpark(t1); },\"t2\").start(); }} ②交替输出题目：线程 1 输出 a 5 次，线程 2 输出 b 5 次，线程 3 输出 c 5 次。现在要求输出 abcabcabcabcabc 怎么实现 1、使用wait/notify1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class T4 { public static void main(String[] args) {// 下一定义标记为1 即先打印a PrintABC printABC = new PrintABC(1, 5); new Thread(()-&gt;{ printABC.print(\"a\", 1, 2); },\"t1\").start(); new Thread(()-&gt;{ printABC.print(\"b\", 2, 3); },\"t2\").start(); new Thread(()-&gt;{ printABC.print(\"c\", 3, 1); },\"t3\").start(); }}/**依次打印abc五次 * 当前打印标记 下一打印标记 * a 1 2 * b 2 3 * c 3 1 */class PrintABC{// 当前打印标记 int flag;// 下一打印标记 int nextFlag;// 循环次数 int loopNumber; public PrintABC(int nextFlag, int loopNumber) { this.nextFlag = nextFlag; this.loopNumber = loopNumber; } public void print(String word, int flag, int nextFlag){ for (int i = 0; i &lt; loopNumber; i++) { synchronized (this) {// 如果当前传过来的标记和下一打印标记不一致 while (this.nextFlag!=flag) { try {// 等待 this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } System.out.print(word); this.nextFlag=nextFlag;// 唤醒所有进程 this.notifyAll(); } } }} 1abcabcabcabcabc 2、使用ReentrantLock12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class T5 { public static void main(String[] args) throws InterruptedException { ReentrantPrint reentrantPrint = new ReentrantPrint(5); Condition a = reentrantPrint.newCondition(); Condition b = reentrantPrint.newCondition(); Condition c = reentrantPrint.newCondition(); new Thread(()-&gt;{ reentrantPrint.print(\"a\", a, b); },\"t1\").start(); new Thread(()-&gt;{ reentrantPrint.print(\"b\", b, c); },\"t2\").start(); new Thread(()-&gt;{ reentrantPrint.print(\"c\", c, a); },\"t3\").start(); //先让上述线程都进入各自的阻塞队列 Thread.sleep(2000);// 主线程启动 先唤醒t1打印a reentrantPrint.lock(); try {// 唤醒a队列 a.signal(); System.out.println(\"start...\"); }finally { //释放锁 reentrantPrint.unlock(); } }}class ReentrantPrint extends ReentrantLock {// 循环次数 int loopNumber; public ReentrantPrint(int loopNumber) { this.loopNumber = loopNumber; } /** * 打印的方法 * @param word 打印的内容 * @param cond 当前线程睡眠的队列 * @param nextCond 下一个唤醒的队列 */ public void print(String word,Condition cond,Condition nextCond) { for (int i = 0; i &lt; loopNumber; i++) {// 尝试获得锁 lock(); try { try { //a等待的队列 cond.await();// 打印单词 System.out.print(word);// 下一个唤醒的队列 nextCond.signal(); } catch (InterruptedException e) { e.printStackTrace(); } }finally { unlock(); } } }} 12start...abcabcabcabcabc 3、park和unpark1234567891011121314151617181920212223242526272829303132333435363738394041public class T6 { static Thread t1; static Thread t2; static Thread t3; public static void main(String[] args) throws InterruptedException { ParkPrint parkPrint = new ParkPrint(5); t1 = new Thread(() -&gt; { parkPrint.print(\"a\", t2); }, \"t1\"); t2 = new Thread(() -&gt; { parkPrint.print(\"b\", t3); }, \"t2\"); t3 = new Thread(() -&gt; { parkPrint.print(\"c\", t1); }, \"t3\"); t1.start(); t2.start(); t3.start();// 保证上述线程启动完毕 Thread.sleep(2000);// 先唤醒t1线程 打印a LockSupport.unpark(t1); }}class ParkPrint{ int loopNumber; public ParkPrint(int loopNumber) { this.loopNumber = loopNumber; } public void print(String word,Thread nextThread){ for (int i = 0; i &lt; loopNumber; i++) {// 先阻塞 LockSupport.park(); System.out.print(word); LockSupport.unpark(nextThread); } }} 1abcabcabcabcabc 17、本章小结 Ⅳ、共享模型之内存1、java内存模型JMM: java memory model 它定义了主存(线程共享的数据、静态成员变量，成员变量)、工作内存(局部变量)抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、 CPU 指令优化等。 JMM 体现在以下几个方面 原子性 - 保证指令不会受到线程上下文切换的影响 可见性 - 保证指令不会受 cpu 缓存的影响 有序性 - 保证指令不会受 cpu 指令并行优化的影响 2、可见性①退不出的循环先来看一个现象，按道理来说，主线程经过1秒后修改flag变量，线程t1终止，但是main 线程对 flag变量的修改对于 t1 线程不可见，导致了 t 1线程无法停止： 12345678910111213public class T1 { static boolean flag = true; public static void main(String[] args) throws InterruptedException { new Thread(()-&gt;{ while (flag) { } },\"t1\").start(); Thread.sleep(1000); flag=false; }} 原因： 初始状态t1线程开始从主存flag的值到工作内存中 因为t1线程要频繁的从主存中读取flag的值，JIT(just-in-time compilation)即时编译器会将flag的值缓存到自己的工作内存中的高速缓存中，减少对主存中flag的访问，以提高效率 1 秒之后，main 线程修改了 flag的值，并同步至主存，而 t1线程 是从自己工作内存中的高速缓存中读取这个变量 的值，结果永远是旧值 解决方法： 使用volatile关键字 加上volatile(易变的)关键字，只能修饰成员变量，不能修饰局部变量 1volatile static boolean flag = true; 使用加synchronized锁的方式 1234567891011121314151617181920@Slf4jpublic class T1 { static boolean flag = true; static Object lock=new Object(); public static void main(String[] args) throws InterruptedException { new Thread(()-&gt;{ while (true) { synchronized (lock) { if (!flag) { break; } } } },\"t1\").start(); Thread.sleep(1000); log.info(\"退出...\"); flag=false; }} 3、原子性和可见性前面例子体现的实际就是可见性，它保证的是在多个线程之间，一个线程对 volatile 变量的修改对另一个线程可 见， 不能保证原子性，仅用在一个写线程，多个读线程的情况： 上例从字节码理解是这样的： 123456getstatic run // 线程 t 获取 run true getstatic run // 线程 t 获取 run true getstatic run // 线程 t 获取 run true getstatic run // 线程 t 获取 run true putstatic run // 线程 main 修改 run 为 false， 仅此一次 getstatic run // 线程 t 获取 run false 比较一下之前我们将线程安全时举的例子：两个线程一个 i++ 一个 i– ，只能保证看到新值，不能解决指令交错 1234567891011// 假设i的初始值为0 getstatic i // 线程2-获取静态变量i的值 线程内i=0 getstatic i // 线程1-获取静态变量i的值 线程内i=0 iconst_1 // 线程1-准备常量1 iadd // 线程1-自增 线程内i=1 putstatic i // 线程1-将修改后的值存入静态变量i 静态变量i=1 iconst_1 // 线程2-准备常量1 isub // 线程2-自减 线程内i=-1 putstatic i // 线程2-将修改后的值存入静态变量i 静态变量i=-1 ①synchronized和volatile区别： synchronized语句块既可以保证代码块的原子性，也同时保证代码块内变量的可见性，也可以保证有序性(但是需要将修改的变量全部交由synchronized管理)。但缺点是synchronize属于重量级的操作，性能相对较低。 volatile并不能保证原子性，但是能够保证其有序性和可见性。他适用于一个线程读，另一个线程写的情况 4、终止模式之两阶段终止模式(volatile)我们之前使用isInterrupted来实现，现在我们使用volatile实现监视器功能 12345678910111213141516171819202122232425262728293031323334353637public class T2 { public static void main(String[] args) throws InterruptedException { LogMonitor logMonitor=new LogMonitor(); logMonitor.start(); //5秒后停止监控 Thread.sleep(5000); logMonitor.stop(); }}@Slf4jclass LogMonitor{ private Thread thread; private volatile boolean flag=false; public void start(){ thread=new Thread(()-&gt;{ while (true) { if(flag){ log.info(\"停止监控...\"); break; } try { Thread.sleep(1000); log.info(\"监控记录中...\"); } catch (InterruptedException e) { } } },\"监视器\"); thread.start(); } public void stop() { flag=true; //打断线程 避免在睡眠后又一次记录 thread.interrupt(); }} 1234519:50:16.992 [监视器] INFO org.lc.volatile_.LogMonitor - 监控记录中...19:50:17.996 [监视器] INFO org.lc.volatile_.LogMonitor - 监控记录中...19:50:18.997 [监视器] INFO org.lc.volatile_.LogMonitor - 监控记录中...19:50:19.998 [监视器] INFO org.lc.volatile_.LogMonitor - 监控记录中...19:50:20.991 [监视器] INFO org.lc.volatile_.LogMonitor - 停止监控... 5、同步模式之Balking(犹豫模式)①定义：Balking （犹豫）模式用在一个线程发现另一个线程或本线程已经做了某一件相同的事，那么本线程就无需再做 了，直接结束返回 ②监控日志-案例防止创建多个启动实例 synchronized+volatile synchronzed保证原子性，volatile保证可见性 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class T2 { public static void main(String[] args) throws InterruptedException { LogMonitor logMonitor=new LogMonitor();// 这里启动多个实例 还是按照每秒执行一次来监控 logMonitor.start(); logMonitor.start(); logMonitor.start(); //5秒后停止监控// Thread.sleep(5000);// logMonitor.stop(); }}@Slf4jclass LogMonitor{ private Thread thread; private volatile boolean flag=false;// 判断是否已经启动了该监视器 private boolean isStaring=false; public void start(){ //多个线程来访问修改isStrating,会产生线程安全问题 需要使用synchronize来保证原子性 synchronized (this) { if (isStaring) {// 已经启动了 直接返回 return; } } isStaring=true; thread=new Thread(()-&gt;{ while (true) { if(flag){ log.info(\"停止监控...\"); break; } try { Thread.sleep(1000); log.info(\"监控记录中...\"); } catch (InterruptedException e) { } } },\"监视器\"); thread.start(); } public void stop() { flag=true; //打断线程 避免在睡眠后又一次记录 thread.interrupt(); }} 123420:09:15.560 [监视器] INFO org.lc.volatile_.LogMonitor - 监控记录中...20:09:16.566 [监视器] INFO org.lc.volatile_.LogMonitor - 监控记录中...20:09:17.566 [监视器] INFO org.lc.volatile_.LogMonitor - 监控记录中...... ③线程安全的单例模式效率太低，详细请看7下的第④个。 12345678910111213public class SafeSingleton { private static SafeSingleton safeSingleton=null; private SafeSingleton() { } public static synchronized SafeSingleton getInstance() { if (safeSingleton != null) { return safeSingleton; } return safeSingleton=new SafeSingleton(); }} 6、有序性JVM 会在不影响正确性的前提下，可以调整语句的执行顺序，思考下面一段代码 1234static int i; static int j; // 在某个线程内执行如下赋值操作 i = ...; j = ...; 可以看到，至于是先执行 i 还是 先执行 j ，对终的结果不会产生影响。所以，上面代码真正执行时，既可以是 12i = ...; j = ...; 也可以是 12j = ...; i = ...; 这种特性称之为『指令重排』，多线程下『指令重排』会影响正确性。 使用：volatile 修饰的变量，可以防止指令重排 即被volatile修饰的变量在修改之前的代码都是有序的(只是在本线程有效)，不可被jvm进行优化，重新排列运行 7、volatile原理①读屏障和写屏障的可见性和有序性 可见性 写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中 而读屏障（lfence）保证在该屏障之后，对共享变量的读取，加载的是主存中新数据 有序性 写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后 读屏障会确保指令重排序时，不会将读屏障之后的代码排在读屏障之前 volatile 的底层实现原理是内存屏障，Memory Barrier（Memory Fence） 对 volatile 变量的写指令后会加入写屏障 对 volatile 变量的写指令后会加入写屏障 ②如何保证可见性 写屏障（sfence）保证在该屏障之前的，对共享变量的改动，都同步到主存当中 private volatile boolena ready=false; public void actor2(I_Result r) { num = 2; //写到主存中 ready = true; // ready 是 volatile 赋值带写屏障 // 写屏障 } &lt;!--￼151--&gt; &lt;img src=\"http://img.louchen.top/2020/05/20200528102536.png\" style=\"zoom: 67%;\" /&gt; ③如何保证有序性 写屏障会确保指令重排序时，不会将写屏障之前的代码排在写屏障之后 public void actor2(I_Result r) { num = 2; ready = true; // ready 是 volatile 赋值带写屏障 // 写屏障 } &lt;!--￼152--&gt; &lt;img src=\"C:\\Users\\42119\\AppData\\Roaming\\Typora\\typora-user-images\\1590632954308.png\" alt=\"1590632954308\" style=\"zoom:67%;\" /&gt; 总结： 被volatile修饰的成员变量，只能在本线程保证有序性和可见性，不能解决指令交错。 写屏障：保证被volatile的修饰的成员变量在改变之前的代码都是写到主存中。保证在修改该变量之前的代码不会排在该变量之后。 读屏障：保证被volatile的修饰的成员变量在读取之后的代码都是从主存中读。保证在读该变量之后的代码不会排在该变量之前。 ④单例模式的 double-checked locking (双重检查)之前创建的单例的方式： 这种方式效率非常低。 12345678910111213public class SafeSingleton { private static SafeSingleton safeSingleton=null; private SafeSingleton() { } public static SafeSingleton getInstance() { synchronized (SafeSingleton.class) { if (safeSingleton == null) { return safeSingleton==new SafeSingleton();; } } return safeSingleton }} 改进： 1234567891011121314151617public class SafeSingleton { private static SafeSingleton safeSingleton=null; private SafeSingleton() { } public static SafeSingleton getInstance() { //多个线程访问 如果实例不为空则直接返回，后面的线程无需再竞争锁 if(safeSingleton==null) {// 第一个进来的线程 获得到锁创建 synchronized (SafeSingleton.class) { if (safeSingleton == null) { return safeSingleton=new SafeSingleton(); } } } return safeSingleton; }} 以上的实现特点是： 懒惰实例化 首次使用 getInstance() 才使用 synchronized 加锁，后续使用时无需加锁 有隐含的，但很关键的一点：第一个 if 使用了 INSTANCE 变量，是在同步块之外 但在多线程环境下，上面的代码是有问题的，getInstance 方法对应的字节码为： 其中 17 表示创建对象，将对象引用入栈 // new Singleton 20 表示复制一份对象引用 // 引用地址 21 表示利用一个对象引用，调用构造方法 24 表示利用一个对象引用，赋值给 static INSTANCE 也许 jvm 会优化为：先执行 24，再执行 21。如果两个线程 t1，t2 按如下时间序列执行： 通俗一点就是，线程t2执行第一个if(safeSingleton==null)时,线程t1已经执行到第二个if(safeSingleton==null)中的safeSingleton=new SafeSingleton();，但是由于jvm指令重排的关系，可能会先执行对safeSingleton的引用赋值情况，但是new SafeSingleton()还未执行完毕。所以线程t2拿到返回的实例为未被初始化完毕的实例。 注意：对 INSTANCE 使用 volatile 修饰即可，可以禁用指令重排，但要注意在 JDK 5 以上的版本的 volatile 才会真正有效 最终解决方案： 123456789101112131415161718192021public class SafeSingleton { //给实例加上volatile关键字 加入内存屏障 private volatile static SafeSingleton safeSingleton=null; private SafeSingleton() { } public static SafeSingleton getInstance() {// 可见性：读：该屏障后面的代码都会从主存中读// 有序性：读：该屏障后面的代码都会在该屏障之后执行 if(safeSingleton==null) { synchronized (SafeSingleton.class) { if (safeSingleton == null) { //可见性：写：该屏障之前的代码都会写到主存中 //有序性，写：该屏障之前的代码后会在该屏障之前执行 //保证对变量safeSingleton的赋值为有序性，即先调用构造方法，再赋值引用给safeSingleton return safeSingleton=new SafeSingleton(); } } } return safeSingleton; }} 8、习题①balking 模式习题希望 doInit() 方法仅被调用一次，下面的实现是否有问题，为什么？ 123456789101112131415class TestVolatile{ volatile Boolean initialized=false; void init() { if (initialized) { return; } doInit(); initialized=true; } private void doInit() { //初始化的一些操作 }} 上述代码存在多线程并发操作，doInit()调用多次的情况, 修改如下： 1234567891011121314151617181920class TestVolatile{ volatile boolean initialized=false; void init() { if (initialized) { return; } synchronized (TestVolatile.class) { if(initialized){ return; } doInit(); initialized=true; } } private void doInit() { //初始化的一些操作 }} ②线程安全单例习题单例模式有很多实现方法，饿汉、懒汉、静态内部类、枚举类，试分析每种实现下获取单例对象（即调用 getInstance）时的线程安全，并思考注释中的问题 饿汉式：类加载就会导致该单实例对象被创建 懒汉式：类加载不会导致该单实例对象被创建，而是首次使用该对象时才会创建 实现1(饿汉式)：1234567891011121314151617//1、为什么加final? 答：防止子类对父类覆盖创建对象方法的干扰//2、如果实现了序列化接口，还要做什么来防止序列化破坏单例？ 答：加上一个readResovle方法public final class Singleton implements Serializable { //3、为什么设置为私有？ 答：防止通过new无限制的创建对象。 是否能防止反序列化创建新的实例？ 答：不能 private Singleton() { } //4、这样初始化能否保证线程安全问题? 答：在类加载的时候，该对象即被jvm创建，所有为线程安全的 private static final Singleton INSTANCE = new Singleton(); //5、为什么使用方法提供实例，而不是直接通过设置字段成员公有提供实例？ 答：更好的封装性，扩展性 public static Singleton getInstance() { return INSTANCE; } //若该类有readResolve方法，则使用该方法返回的对象，而不是使用序列化后的对象实例 public Object readResolve() { return INSTANCE; }} 实现2(懒汉式)：12345678910111213public class Singleton { private Singleton() { } private static Singleton INSTANCE=null; //对Singleton类对象上锁，性能比较低。 public static synchronized Singleton getInstance() { if (INSTANCE != null) { return INSTANCE; } INSTANCE=new Singleton(); return INSTANCE; }} 实现3(double-checked locking 双重检查)懒汉123456789101112131415161718192021public class Singleton { private Singleton() { } //加上volatile，防止在创建对象的时候指令重排 private static volatile Singleton INSTANCE=null; public static Singleton getInstance() { if (INSTANCE != null) { return INSTANCE; } synchronized (Singleton.class) { if(INSTANCE!=null){ return INSTANCE; } //创建对象 INSTANCE = new Singleton(); return INSTANCE; } }} 实现4(静态内部类)懒汉：1234567891011121314public class Singleton { private Singleton() { } //使用静态内部类，对外部不可见。 //jvm本身对类加载是懒惰的，即只调用到getInstance方法时，使用到LazyHolder对象时该内部类才会被加载，里面的实例才会被加载 private static class LazyHolder{ static final Singleton INSTANCE=new Singleton(); } //调用时才会加载此内部类 public static Singleton getInstance() { return LazyHolder.INSTANCE; }} 实现5(枚举)12345678910111213141516171819202122232425//反编译后的问题：继承Enum枚举类//final enum Singleton extends Enum{// 类加载时创建对象// public final static enum Singleton INSTANCE;// }//1、枚举单例是如何实现限制实例个数的？ 每个枚举实例，都是一个单例对象//2、枚举单例在创建时是否有有并发问题？ 没有，final static实例会在类初始化的时候创建//3、枚举单例能否被反序列化破坏单例？ 枚举类默认实现序列化接口，可被序列化和反序列，但是不破坏单例//4、枚举能否通过反射破坏单例？ 不能。//5、枚举单例属于饿汉式//6、枚举单例中可以加入一些字段和构造方法，来初始化单例的属性public enum Singleton { INSTANCE; public static Singleton GetInstance(){ return INSTANCE; }}class SingleTest{ public static void main(String[] args) { Singleton instance = Singleton.GetInstance(); Singleton instance1 = Singleton.INSTANCE;// true System.out.println(instance==instance1); }} Ⅴ、共享模型之无锁1、存取款问题①有锁方式synchronized 账户接口 123456789101112131415161718192021222324252627interface Account { //获取余额 Integer getBalance(); //取款 void withdraw(Integer amount); static void demo(Account account) { List&lt;Thread&gt; list = new ArrayList&lt;&gt;(); long start = System.currentTimeMillis(); for (int i = 0; i &lt; 1000; i++) { list.add(new Thread(() -&gt; { account.withdraw(10); })); } list.forEach(Thread::start); list.forEach(t -&gt; { try { t.join(); } catch (InterruptedException e) { e.printStackTrace(); } }); long end = System.currentTimeMillis(); System.out.println(account.getBalance() + \" cost:\" + (end - start)+\"ms\"); }} 实现接口 123456789101112131415161718192021222324public class T1 { public static void main(String[] args) { AcccountSafe safe = new AcccountSafe(10000); Account.demo(safe); }}class AcccountSafe implements Account { // 余额 private Integer balance; public AcccountSafe(Integer balance) { this.balance = balance; } @Override public synchronized Integer getBalance() { return this.balance; } @Override public synchronized void withdraw(Integer amount) { this.balance -= amount; }} 10 cost:126ms ②无锁方式CAS 账户接口 不变 实现接口 12345678910111213141516171819202122232425262728293031323334353637public class T1 { public static void main(String[] args) { AccountCAS cas=new AccountCAS(10000); Account.demo(cas); }}class AccountCAS implements Account{ //余额 //使用原子的Atomic private AtomicInteger balance; public AccountCAS(Integer balance) { this.balance = new AtomicInteger(balance); } @Override public Integer getBalance() { //获取最新的值 return balance.get(); } @Override public void withdraw(Integer amount) { //使用cas操作 while (true) { //获取最新的余额 int pre=balance.get(); //取钱之后的余额 int next=pre-amount; //期望最新值 操作完之后的值 if(balance.compareAndSet(pre, next)){ break; } } }} 10 cost:68ms 结果： 无锁的操作相比加锁确实效率提升了不少 120 cost:126ms //加锁0 cost:68ms //无锁 2、CAS与Volatile①CAS操作分析前面看到的 AtomicInteger 的解决方法，内部并没有用锁来保护共享变量的线程安全。那么它是如何实现的呢？ 1234567891011121314151617@Override public void withdraw(Integer amount) { //不断循环重试，知道成功为止 while (true) { //获取最新的余额 比如，拿到最新的值10000 int pre=balance.get(); //取钱之后的余额 操作 10000-10=9990 int next=pre-amount; //当前线程读取到的最新余额 ; 操作完之后的余额 //compareAndSet这个操作是原子性的 //例如，当该线程t1读取到当前的余额和操作之后的余额得到compareAndSet(10000,9990) //此外，线程t2再此原子操作之前修改了最新的余额为9990，即当前线程t1执行compareAndSet之前 //pre会和最新的期望余额值进行比较，如果不一致，则next作废，返回false,重试。否则没有其他线程对余额进行操作，返回true,退出循环 if(balance.compareAndSet(pre, next)){ break; } } } 其中的关键是 compareAndSet，它的简称就是 CAS （也有 Compare And Swap 比较交换 的说法），它必须是原子操作。 我们可以发现在 AtomicInteger 中 是使用volatile保证可见性 123456789101112131415161718public class AtomicInteger extends Number implements java.io.Serializable { private static final long serialVersionUID = 6214790243416807050L; // setup to use Unsafe.compareAndSwapInt for updates private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long valueOffset; static { try { valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField(\"value\")); } catch (Exception ex) { throw new Error(ex); } } private volatile int value; //** //**} 注意： 其实 CAS 的底层是 lock cmpxchg 指令（X86 架构），在单核 CPU 和多核 CPU 下都能够保证【比较-交 换】的原子性。 在多核状态下，某个核执行到带 lock 的指令时，CPU 会让总线锁住，当这个核把此指令执行完毕，再 开启总线。这个过程中不会被线程的调度机制所打断，保证了多个线程对内存操作的准确性，是原子 的。 CAS 必须借助 volatile 才能读取到共享变量的新值来实现【比较并交换】的效果 ②为什么无锁效率高？ 无锁情况下，即使重试失败，线程始终在高速运行，没有停歇，而 synchronized 会让线程在没有获得锁的时 候，发生上下文切换，进入阻塞。打个比喻 线程就好像高速跑道上的赛车，高速运行时，速度超快，一旦发生上下文切换，就好比赛车要减速、熄火， 等被唤醒又得重新打火、启动、加速… 恢复到高速运行，代价比较大 但无锁情况下，因为线程要保持运行，需要额外 CPU 的支持，CPU 在这里就好比高速跑道，没有额外的跑 道，线程想高速运行也无从谈起，虽然不会进入阻塞，但由于没有分到时间片，仍然会进入可运行状态，还 是会导致上下文切换。 ③CAS特点结合 CAS 和 volatile 可以实现无锁并发，适用于线程数少、多核 CPU 的场景下 CAS 是基于乐观锁的思想：乐观的估计，不怕别的线程来修改共享变量，就算改了也没关系，我吃亏点再 重试呗。 每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。 synchronized 是基于悲观锁的思想：悲观的估计，得防着其它线程来修改共享变量，我上了锁你们都别想 改，我改完了解开锁，你们才有机会。 这种线程一旦得到锁，其他需要锁的线程就挂起的情况就是悲观锁 CAS 体现的是无锁并发、无阻塞并发，请仔细体会这两句话的意思 因为没有使用 synchronized，所以线程不会陷入阻塞，这是效率提升的因素之一 但如果竞争激烈，可以想到重试必然频繁发生，反而效率会受影响 3、原子整数 java.util.concurrent.atomic下的 AtomicIntegerAtomicBooleanAtomicLong以AtomicInteger为例： 123456789101112131415161718192021222324252627282930public class T2 { public static void main(String[] args) {// 初始化值为0 AtomicInteger i = new AtomicInteger(1);// 先获取再自增1 返回：1 System.out.println(i.getAndIncrement()); //i++// 先自增1再获取 返回：3 System.out.println(i.incrementAndGet()); //++i// 先自减1再获取 返回：2 System.out.println(i.decrementAndGet());// --i;// 先获取再自减1 返回：2 System.out.println(i.getAndDecrement());// i--;// 直接获取值 返回：1 System.out.println(i.get());// 加上指定的值大小(先获取，再加) 返回：1 结果为11 System.out.println(i.getAndAdd(10));// 加上指定的值大小(先增加，再获取)// i.addAndGet(10)// 对指定的值进行更新操作 IntUnaryOperator函数式接口提供一个int类型参数，int类型的返回值的方法// 先更新后获取 返回：22 结果：22 System.out.println(i.updateAndGet(value -&gt; value * 2));// 对指定的值进行更新操作// 先获取后更新 返回22 结果2200 System.out.println(i.getAndUpdate(value -&gt; value * 100));// 先计算再获取 IntBinaryOperator函数式接口提供两个int类型参数 第一个为值i为2200，第二个为传来的参数200，返回一个int类型 // 返回2000 结果为2000 System.out.println(i.accumulateAndGet(200, (p, x) -&gt; p - x)); }} 即我们可以将上述取钱的操作修改： 12345678910111213141516@Override public void withdraw(Integer amount) {// //使用cas操作// while (true) {// //获取最新的余额// int pre=balance.get();// //取钱之后的余额// int next=pre-amount;// //期望最新值 操作完之后的值// if(balance.compareAndSet(pre, next)){// break;// }// } //取钱加一个负数即可 balance.addAndGet(-1*amount); } 手动实现UpdateAndGet方法： 1234567891011121314151617public class T3 { public static void main(String[] args) { AtomicInteger i = new AtomicInteger(10); System.out.println(updateAndGet(i, value -&gt; value * 10)); } static int updateAndGet(AtomicInteger i, IntUnaryOperator operator){ while (true) {// 获取最新的值 int pre = i.get(); int next = operator.applyAsInt(pre);// 调用cas操作 if(i.compareAndSet(pre, next)){ return next; } } }} AtomicInteger的UpdateAndGet方法源码： 12345678public final int updateAndGet(IntUnaryOperator updateFunction) { int prev, next; do { prev = get(); next = updateFunction.applyAsInt(prev); } while (!compareAndSet(prev, next)); return next; } 4、原子引用AtomicReferenceAtomicMarkableReferenceAtomicStampedReference①AtomicReference&lt;V&gt;的使用对引用类型进行原子操作 取款问题，若存取的操作为引用类型。则需要AtomicReference保护该类型 账户类 123456789101112131415161718192021222324252627interface AccountR { //获取余额 BigDecimal getBalance(); //取款 void withdraw(BigDecimal amount); static void demo(AccountR account) { List&lt;Thread&gt; list = new ArrayList&lt;&gt;(); long start = System.currentTimeMillis(); for (int i = 0; i &lt; 1000; i++) { list.add(new Thread(() -&gt; { account.withdraw(new BigDecimal(String.valueOf(10))); })); } list.forEach(Thread::start); list.forEach(t -&gt; { try { t.join(); } catch (InterruptedException e) { e.printStackTrace(); } }); long end = System.currentTimeMillis(); System.out.println(account.getBalance() + \" cost:\" + (end - start)+\"ms\"); }} 实现类 1234567891011121314151617181920212223242526272829303132public class T4 { public static void main(String[] args) { DecimalAccountCas cas=new DecimalAccountCas(new BigDecimal(String.valueOf(10000))); AccountR.demo(cas); }}class DecimalAccountCas implements AccountR{// 原子引用 &lt;要保护的类型&gt; private AtomicReference&lt;BigDecimal&gt; reference; public DecimalAccountCas(BigDecimal balance) { this.reference = new AtomicReference&lt;&gt;(balance); } @Override public BigDecimal getBalance() { return reference.get(); } @Override public void withdraw(BigDecimal amount) { while (true) { BigDecimal pre=reference.get(); //subtract减操作 BigDecimal next=pre.subtract(amount);// 使用cas if (reference.compareAndSet(pre, next)) { break; } } }} 10 cost:159ms ②ABA问题及其解决ABA问题12345678910111213141516171819202122232425@Slf4jpublic class T5 { static AtomicReference&lt;String&gt; ref=new AtomicReference&lt;&gt;(\"A\"); public static void main(String[] args) throws InterruptedException { log.info(\"main start...\");// 获取值 String value = ref.get(); //其他线程对变量修改 other(); Thread.sleep(1000);// 尝试修改为// 能否判断该变量value被其他线程修改过？ log.info(\"change A-&gt;C {}\",ref.compareAndSet(value, \"C\")); } static void other() throws InterruptedException { new Thread(()-&gt;{ log.info(\"change A-&gt;B {}\",ref.compareAndSet(ref.get(),\"B\")); },\"t1\").start(); Thread.sleep(500); new Thread(()-&gt;{ log.info(\"change B-&gt;A {}\",ref.compareAndSet(ref.get(),\"A\")); },\"t2\").start(); }} 123419:04:04.348 [main] INFO org.lc.cas.T5 - main start...19:04:04.386 [t1] INFO org.lc.cas.T5 - change A-&gt;B true19:04:04.886 [t2] INFO org.lc.cas.T5 - change B-&gt;A true19:04:05.886 [main] INFO org.lc.cas.T5 - change A-&gt;C true 我们发现，在主线程main执行cas操作的时候，并不能感知其他线程对其值value修改过的操作。只是表面上的一致。中间操作还是被其他线程修改过。 主线程仅能判断出共享变量的值与初值 A 是否相同，不能感知到这种从 A 改为 B 又 改回 A 的情况，如果主线程 希望： 只要有其它线程【动过了】共享变量，那么自己的 cas 就算失败，这时，仅比较值是不够的，需要再加一个版本号 ③AtomicStampedReference&lt;V&gt;解决ABA问题(加版本号)保证期望值匹配和版本号匹配CAS才能成功 123456789101112131415161718192021222324252627282930313233343536373839@Slf4jpublic class T6 { //赋初值的时候加版本号 static AtomicStampedReference&lt;String&gt; ref=new AtomicStampedReference&lt;&gt;(\"A\",0); public static void main(String[] args) throws InterruptedException { log.info(\"main start...\");// 获取值 String value = ref.getReference();// 获取版本号 int stamp = ref.getStamp(); log.info(\"值为:{},版本号为:{}\",value,stamp); //其他线程对变量修改 other(); Thread.sleep(1000); log.info(\"值为:{},版本号为:{}\",value,stamp);// 尝试修改为// 期望的值；新值；期望的版本号；新的版本号// stamp为0，但是other中的方法对已经对stamp进行了修改为2，版本号不匹配，即此CAS操作失败 log.info(\"change A-&gt;C {}\",ref.compareAndSet(value,\"C\",stamp, stamp+1));// 输出为A. 是other中的线程t2的cas操作的结果 System.out.println(ref.getReference()); } static void other() throws InterruptedException { new Thread(()-&gt;{ String value=ref.getReference(); int stamp=ref.getStamp(); log.info(\"值为:{},版本号为:{}\",value,stamp); log.info(\"change A-&gt;B {}\",ref.compareAndSet(value,\"B\",ref.getStamp(),stamp+1)); },\"t1\").start(); Thread.sleep(500); new Thread(()-&gt;{ String value=ref.getReference(); int stamp=ref.getStamp(); log.info(\"值为:{},版本号为:{}\",value,stamp); log.info(\"change A-&gt;B {}\",ref.compareAndSet(value,\"A\",ref.getStamp(),stamp+1)); },\"t2\").start(); }} 12345678919:24:01.934 [main] INFO org.lc.cas.T6 - main start...19:24:01.936 [main] INFO org.lc.cas.T6 - 值为:A,版本号为:019:24:01.974 [t1] INFO org.lc.cas.T6 - 值为:A,版本号为:019:24:01.974 [t1] INFO org.lc.cas.T6 - change A-&gt;B true19:24:02.474 [t2] INFO org.lc.cas.T6 - 值为:B,版本号为:119:24:02.474 [t2] INFO org.lc.cas.T6 - change A-&gt;B true19:24:03.475 [main] INFO org.lc.cas.T6 - 值为:A,版本号为:019:24:03.475 [main] INFO org.lc.cas.T6 - change A-&gt;C falseA AtomicStampedReference 可以给原子引用加上版本号，追踪原子引用整个的变化过程，如： A -&gt; B -&gt; A -&gt; C ，通过AtomicStampedReference，我们可以知道，引用变量中途被更改了几次。但是有时候，并不关心引用变量更改了几次，只是单纯的关心是否更改过，所以就有了 AtomicMarkableReference ④AtomicMarkableReference&lt;V&gt;解决ABA问题(true/false标记)保证期望值匹配和标志匹配CAS才能成功 垃圾袋类 1234567891011121314151617//垃圾袋class GarbageBag{ String desc; public GarbageBag(String desc) { this.desc = desc; } public GarbageBag setDesc(String desc) { this.desc = desc; return this; } @Override public String toString() { return \"GarbageBag{\" + \"desc='\" + desc + '\\'' + '}'; }} 实现操作 1234567891011121314151617181920@Slf4jpublic class T7 { public static void main(String[] args) throws InterruptedException { GarbageBag bag=new GarbageBag(\"这是一个装满了垃圾的垃圾袋\");// 初始化并标记 标记为true，这里只是作为一个标记，其他线程修改该值时，将此标记改为false AtomicMarkableReference&lt;GarbageBag&gt; reference=new AtomicMarkableReference&lt;&gt;(bag, true); log.info(\"主线程 start...\"); GarbageBag prev = reference.getReference(); log.info(prev.toString()); Thread.sleep(1000); log.info(\"想换一只垃圾袋？\"); //CAS操作 //参数： 期望的值；修改后的值；期望的标记；修改后的标记 //先匹配prev的值是否被修改，再匹配第三个参数期望的标记是否为初始化时的标记为true. //都匹配，则cas成功。否则失败 boolean result = reference.compareAndSet(prev, new GarbageBag(\"新的垃圾袋\"), true, false); log.info(\"换成功没？ {}\",result); }} 123419:51:28.716 [main] INFO org.lc.cas.T7 - 主线程 start...19:51:28.718 [main] INFO org.lc.cas.T7 - GarbageBag{desc='这是一个装满了垃圾的垃圾袋'}19:51:29.719 [main] INFO org.lc.cas.T7 - 想换一只垃圾袋？19:51:29.719 [main] INFO org.lc.cas.T7 - 换成功没？ true 当其他线程对其prev修改时，主线程能否CAS成功? 123456789101112131415161718192021222324252627@Slf4jpublic class T7 { public static void main(String[] args) throws InterruptedException { GarbageBag bag=new GarbageBag(\"这是一个装满了垃圾的垃圾袋\");// 初始化并标记 AtomicMarkableReference&lt;GarbageBag&gt; reference=new AtomicMarkableReference&lt;&gt;(bag, true); log.info(\"主线程 start...\"); GarbageBag prev = reference.getReference(); log.info(prev.toString()); //此线程就是修改了prev的desc的变量值 new Thread(()-&gt;{ GarbageBag bag1 = reference.getReference(); log.info(\"打扫卫生的线程 start...\"); bag1.setDesc(\"垃圾已打扫，这是一个空垃圾袋\"); //cas成功 while (!reference.compareAndSet(bag1,bag1,true,false)){ } log.info(bag.toString()); },\"t1\").start(); Thread.sleep(1000); log.info(\"想换一只垃圾袋？\"); //cas失败 因为pre已经被修改，且新的期望值已经变为false. boolean result = reference.compareAndSet(prev, new GarbageBag(\"新的垃圾袋\"), true, false); log.info(\"换成功没？ {}\",result); }} 12345619:59:31.901 [main] INFO org.lc.cas.T7 - 主线程 start...19:59:31.903 [main] INFO org.lc.cas.T7 - GarbageBag{desc='这是一个装满了垃圾的垃圾袋'}19:59:31.947 [t1] INFO org.lc.cas.T7 - 打扫卫生的线程 start...19:59:31.947 [t1] INFO org.lc.cas.T7 - GarbageBag{desc='垃圾已打扫，这是一个空垃圾袋'}19:59:32.948 [main] INFO org.lc.cas.T7 - 想换一只垃圾袋？19:59:32.948 [main] INFO org.lc.cas.T7 - 换成功没？ false 5、原子数组AtomicIntegerArrayAtomicLongArrayAtomicReferenceArray①AtomicIntegerArray的使用对数组的每个索引处进行10000的累加操作。期望结果：[10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000] 123456789101112131415161718192021222324252627282930313233343536373839404142434445 /** *数组测试 * @param arraySupplier 提供数组，可以是线程不安全数组或线程安全数组 * @param lengthFun 获取数组长度的方法 * @param putConsume 自增方法，回传array,index * @param printConsume 打印数组的方法 * @param &lt;T&gt;类型定义 */ private static &lt;T&gt; void demo( // T get(); Supplier&lt;T&gt; arraySupplier, // R apply(T t); Function&lt;T,Integer&gt; lengthFun, // void accept(T t, U u); BiConsumer&lt;T,Integer&gt; putConsume, // void accept(T t); Consumer&lt;T&gt; printConsume){ List&lt;Thread&gt; ts=new ArrayList&lt;&gt;();// 获取数组 T array = arraySupplier.get();// 获取数组长度 Integer length = lengthFun.apply(array);// 循环10次 for (int i = 0; i &lt; length; i++) { //每个线程对数组10000次操作 ts.add(new Thread(()-&gt;{ //对每个索引的位置进行1000的累加操作 for (int j = 0; j &lt; 10000; j++) { //数组; 得到 0,1,2,3,4,5,6,7,8,9索引 putConsume.accept(array, j % length); } })); } ts.forEach(Thread::start); ts.forEach(thread -&gt; { try { thread.join(); } catch (InterruptedException e) { e.printStackTrace(); } }); //打印数组 printConsume.accept(array); }} 非安全操作： 12345678910111213public static void main(String[] args) { demo( //传递长度为10的int数组 ()-&gt;new int[10], //传入数组长度 (array-&gt;array.length), //对数组中的每个索引位10000次加1操作 //array[index]++,这里可能存在指令的交错。导致线程不安全 (array,index)-&gt;array[index]++, //打印操作完后的数组 array-&gt; System.out.println(Arrays.toString(array)) ); } 1[9312, 9230, 9238, 9229, 9222, 9210, 9291, 9263, 9247, 9230] 安全操作： 123456789101112public static void main(String[] args) { demo( //传递长度为10的int数组 ()-&gt;new AtomicIntegerArray(10), //传入数组长度 (array-&gt;array.length()), //对数组中的每个索引位10000次加1操作 (array,index)-&gt;array.getAndIncrement(index), //打印操作完后的数组 array-&gt; System.out.println(array) ); } 1[10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000, 10000] 6、字段更新器我们只能对对象进行原子保护，但是不能对对象中的字段进行保护。因为对象中属性的改变并不会导致期望值的改变。所以我们需要字段更新器 根据要修改的字段类型，决定使用什么类型： AtomicReferenceFieldUpdaterAtomicIntegerFieldUpdaterAtomicLongFieldUpdater①AtomicReferenceFieldUpdater的使用注意：要操作的字段必须加volatile 1234567891011121314151617181920212223242526272829303132333435363738public class T10 { public static void main(String[] args) throws InterruptedException { AtomicReferenceFieldUpdater fieldUpdater=AtomicReferenceFieldUpdater.newUpdater(Student.class,String.class, \"name\"); Student student=new Student(); new Thread(()-&gt;{ //下面的cas成功 student.setName(\"李四\"); //下面的cas失败 //student.setName(\"张三\"); },\"t1\").start(); Thread.sleep(500);// cas操作：将对象字段的预期值和操作的对象中的值进行比较。如果一致则cas成功，否则失败 //当前操作的对象; 对象字段的预期值(原始值); 更新自动后的值 System.out.println(fieldUpdater.compareAndSet(student, \"李四\", \"张三\")); System.out.println(student.toString()); }}class Student{ //这里必须要配合volatile操作 volatile String name; public String getName() { return name; } public Student setName(String name) { this.name = name; return this; } @Override public String toString() { return \"Student{\" + \"name='\" + name + '\\'' + '}'; }} 7、原子累加器LongAdder①比较 AtomicLong 与 LongAdder123456789101112131415161718192021222324252627282930313233public class T11 { public static void main(String[] args) { //20000000 cost:327 demo(() -&gt; new AtomicLong(), adder -&gt; adder.getAndIncrement()); //20000000 cost:49 demo(() -&gt; new LongAdder(), adder -&gt; adder.increment()); } private static &lt;T&gt; void demo(Supplier&lt;T&gt; adderSupplier, Consumer&lt;T&gt; action) { T adder = adderSupplier.get(); long start = System.nanoTime(); List&lt;Thread&gt; ts = new ArrayList&lt;&gt;();// 4个线程 每个线程累加50万 for (int i = 0; i &lt; 40; i++) { ts.add(new Thread(() -&gt; { for (int j = 0; j &lt; 500000; j++) { action.accept(adder); } })); } ts.forEach(t -&gt; t.start()); ts.forEach(t -&gt; { try { t.join(); } catch (InterruptedException e) { e.printStackTrace(); } }); long end = System.nanoTime(); System.out.println(adder + \" cost:\" + (end - start) / 1000_000); }} 性能提升的原因很简单，就是在有竞争时，设置多个累加单元，Therad-0 累加 Cell[0]，而 Thread-1 累加 Cell[1]… 后将结果汇总。这样它们在累加时操作的不同的 Cell 变量，因此减少了 CAS 重试失败，从而提高性 能。 Ⅵ、共享模型之不可变1、日期转换出现的线程安全问题1234567891011121314public class T1 { public static void main(String[] args) { SimpleDateFormat sdf=new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\"); for (int i = 0; i &lt; 10; i++) { new Thread(()-&gt;{ try { System.out.println(sdf.parse(\"2019-1-1 11:11:11\")); } catch (ParseException e) { e.printStackTrace(); } }).start(); } }} 12345678Exception in thread \"Thread-5\" java.lang.NumberFormatException: multiple points at sun.misc.FloatingDecimal.readJavaFormatString(FloatingDecimal.java:1890) at sun.misc.FloatingDecimal.parseDouble(FloatingDecimal.java:110) at java.lang.Double.parseDouble(Double.java:538) at java.text.DigitList.getDouble(DigitList.java:169)......Tue Jan 01 11:11:11 GMT+08:00 2019Tue Jan 01 11:11:11 GMT+08:00 2019 多线程同时操作同一个日期转换对象可能出现异常 ①加锁synchronized效率比较低 ②使用不可变类12345678910111213141516public class T1 { public static void main(String[] args) { DateTimeFormatter sdf = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\"); for (int i = 0; i &lt; 10; i++) { new Thread(()-&gt;{ try { System.out.println(sdf.parse(\"2019-01-01 11:11:11\",(LocalDateTime::from))); //等价-&gt; // System.out.println(sdf.parse(\"2019-01-01 11:11:11\", (TemporalAccessor temporal) -&gt; LocalDateTime.from(temporal))); } catch (Exception e) { e.printStackTrace(); } }).start(); } }} 12345* @implSpec* This class is immutable and thread-safe. //类不可变且是线程安全的 public final class DateTimeFormatter { //... } 2、不可变类的设计另一个大家更为熟悉的 String 类也是不可变的，以它为例，说明一下不可变设计的要素 1234public final class String implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence { //.... } ①final的使用发现该类、类中所有属性都是 ﬁnal 的 属性用 ﬁnal 修饰保证了该属性是只读的，不能修改 类用 ﬁnal 修饰保证了该类中的方法不能被覆盖，防止子类无意间破坏不可变性 ②保护性拷贝例如String中的substring 方法 1234567891011public String substring(int beginIndex) { if (beginIndex &lt; 0) { throw new StringIndexOutOfBoundsException(beginIndex); } int subLen = value.length - beginIndex; if (subLen &lt; 0) { throw new StringIndexOutOfBoundsException(subLen); } //实际new了一个新的对象 return (beginIndex == 0) ? this : new String(value, beginIndex, subLen); } 通过创建副本对象来避 免共享的手段称之为【保护性拷贝（defensive copy）】 3、享元模式定义 英文名称：Flyweight pattern. 当需要重用数量有限的同一类对象时 ①包装类体现在JDK中 Boolean，Byte，Short，Integer，Long，Character 等包装类提供了 valueOf 方法，例如 Long 的 valueOf 会缓存 -128~127 之间的 Long 对象，在这个范围之间会重用对象，大于这个范围，才会新建 Long 对 象： Long对象 1234567public static Long valueOf(long l) { final int offset = 128; if (l &gt;= -128 &amp;&amp; l &lt;= 127) { // will cache return LongCache.cache[(int)l + offset]; } return new Long(l); } 注意: Byte, Short, Long 缓存的范围都是 -128~127 Character 缓存的范围是 0~127 Integer的默认范围是 -128~127 最小值不能变 但最大值可以通过调整虚拟机参数 -Djava.lang.Integer.IntegerCache.high 来改变 Boolean 缓存了 TRUE 和 FALSE ②BigInteger和BigDecimal体现我们可以发现在BigDecimal进行add操作时，也是通过new一个BigDecimal进行的累加操作，不存在线程安全问题。但是多个方法同时操作，多线程的情况下则存在线程安全问题。 ③实现简单的享元模式(数据库连接池)例如：一个线上商城应用，QPS（每秒查询率（QPS，Queries-per-second）是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准。） 达到数千，如果每次都重新创建和关闭数据库连接，性能会受到极大影响。 这时 预先创建好一批连接，放入连接池。一次请求到达后，从连接池获取连接，使用完毕后再还回连接池，这样既节约 了连接的创建和关闭时间，也实现了连接的重用，不至于让庞大的连接数压垮数据库 连接对象 12345678910111213//模拟连接对象实现class MockConnection implements Connection{ private String connectionName; @Override public String toString() { return \"MockConnection{\" + \"connectionName='\" + connectionName + '\\'' + '}'; } //其他代码 略} 连接池 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465@Slf4jclass Pool{// 连接池大小 private final int poolSize;// 连接对象数组 private Connection[] connections;// 连接状态数组 0空闲 1表示繁忙 private AtomicIntegerArray states;// 构造方法初始化 public Pool(int poolSize) { this.poolSize = poolSize; this.connections = new Connection[poolSize]; this.states=new AtomicIntegerArray(new int[poolSize]); for (int i = 0; i &lt; poolSize; i++) {// 初始化所有连接 connections[i]=new MockConnection(\"连接\"+(i+1)); } } // 借连接 public Connection borrow() { while (true) { for (int i = 0; i &lt; poolSize; i++) {// 获取空闲连接// 使用cas操作 将该位置的连接更新为1 表示该位置的连接已被占用 if(states.compareAndSet(i, 0, 1)){// 获得连接 log.info(\"借到连接 {}\",connections[i]); return connections[i]; } }// 如果遍历完所有的连接池中的连接 还没有获得连接 synchronized (this){ try {// 等待连接 log.info(\"没有空闲连接，请等待...\"); this.wait(); } catch (InterruptedException e) { e.printStackTrace(); } } } } /** * 归还连接 * @param connection 归还的连接对象 */ public void free(Connection connection){ for (int i = 0; i &lt; poolSize; i++) {// 找到归还的连接对象 if(connections[i]==connection){// 这里无需cas ,应为传过来的Conncetion对象已确定 states.set(i, 0); synchronized (this) { log.info(\"已释放该连接{}...\",connection); this.notify(); } break; } } }} 测试 1234567891011121314151617public class T3 { public static void main(String[] args) { Pool pool = new Pool(2); for (int i = 0; i &lt; 5; i++) { new Thread(()-&gt;{ Connection con = pool.borrow(); try { //模拟 随机1秒内的执行时间 Thread.sleep(new Random().nextInt(1000)); } catch (InterruptedException e) { e.printStackTrace(); } pool.free(con); },\"\"+(i+1)).start(); } }} 1234567891011121321:00:48.700 [3] INFO org.lc.flyweight_pattern.Pool - 没有空闲连接，请等待...21:00:48.700 [1] INFO org.lc.flyweight_pattern.Pool - 借到连接 MockConnection{connectionName='连接1'}21:00:48.703 [4] INFO org.lc.flyweight_pattern.Pool - 没有空闲连接，请等待...21:00:48.703 [5] INFO org.lc.flyweight_pattern.Pool - 没有空闲连接，请等待...21:00:48.700 [2] INFO org.lc.flyweight_pattern.Pool - 借到连接 MockConnection{connectionName='连接2'}21:00:49.183 [1] INFO org.lc.flyweight_pattern.Pool - 已释放该连接MockConnection{connectionName='连接1'}...21:00:49.183 [3] INFO org.lc.flyweight_pattern.Pool - 借到连接 MockConnection{connectionName='连接1'}21:00:49.668 [2] INFO org.lc.flyweight_pattern.Pool - 已释放该连接MockConnection{connectionName='连接2'}...21:00:49.669 [4] INFO org.lc.flyweight_pattern.Pool - 借到连接 MockConnection{connectionName='连接2'}21:00:49.748 [3] INFO org.lc.flyweight_pattern.Pool - 已释放该连接MockConnection{connectionName='连接1'}...21:00:49.748 [5] INFO org.lc.flyweight_pattern.Pool - 借到连接 MockConnection{connectionName='连接1'}21:00:49.752 [4] INFO org.lc.flyweight_pattern.Pool - 已释放该连接MockConnection{connectionName='连接2'}...21:00:50.464 [5] INFO org.lc.flyweight_pattern.Pool - 已释放该连接MockConnection{connectionName='连接1'}... 4、final原理①设置final变量的原理理解了 volatile 原理，再对比 ﬁnal 的实现就比较简单了 123public class TestFinal { final int a = 20; } 字节码: 12345670: aload_0 1: invokespecial #1 // Method java/lang/Object.\"&lt;init&gt;\":()V 4: aload_0 5: bipush 20 7: putfield #2 // Field a:I &lt;-- 写屏障 10: return 发现 ﬁnal 变量的赋值也会通过 putﬁeld 指令来完成，同样在这条指令之后也会加入写屏障，保证在其它线程读到 它的值时不会出现为 0 的情况 线程安全问题：当多线操作int a= 20时， a变量的赋值情况为先初始化0 ，然后再赋值20，再次过程中可能线程读到的为0，所以导致线程安全问题。加final修饰的变量可以解决此问题。 Ⅶ 、共享模型之工具1、自定义线程池 ThreadPool线程池：包含核心的线程数(总共的线程大小)，若任务的个数超过核心线程数的时候，会将多余的任务存入阻塞队列中的，等待线程池中的线程执行当前任务后，再从阻塞队列中获取。 Blocking Queue阻塞队列：存放多余任务的地方，由主线程提供任务，线程池消费阻塞队列中的任务。 ①自定义拒绝策略接口为阻塞队列之外的任务提供策略的抽象方法 12345678910111213/** * 拒绝策略接口 * 解决阻塞队列的任务满的时候，对多余的任务的处理的方式 */@FunctionalInterfaceinterface RejectPolicy&lt;T&gt;{ /** * 策略抽象 * @param queue 阻塞队列 * @param task 任务 */ void reject(BlockingQueue&lt;T&gt; queue,T task);} ②自定义阻塞任务队列123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164@Slf4jclass BlockingQueue&lt;T&gt;{// 1、任务队列 存放任务 双向队列 (先进先出) private Deque&lt;T&gt; queue=new ArrayDeque&lt;&gt;();// 2、锁 保证任务队列里的一个任务只有一个线程执行 private ReentrantLock lock=new ReentrantLock();// 3、生产者条件变量 保证队列满的时候，生产者不再生产任务 private Condition fullWaitSet=lock.newCondition();// 4、消费者条件变量 保证队列空的时候，线程不再消费任务 private Condition emptyWaitSet=lock.newCondition();// 5、容量 private int capcity; public BlockingQueue(int capcity) { this.capcity = capcity; } // 带超时的阻塞获取 消费者获取任务 public T pull(long timeout, TimeUnit unit) { lock.lock(); try { //我们传入的超时时间转换为纳秒 long nanos = unit.toNanos(timeout); //队列是否为空 while (queue.isEmpty()) { try { //返回的剩余时间小于0 证明已经超时 if (nanos &lt; 0) {// 无需等待直接返回 return null; }// 返回的值为：剩余等待的时间 = 设置的超时时间 - 已经等待的时间 nanos=emptyWaitSet.awaitNanos(nanos); } catch (InterruptedException e) { e.printStackTrace(); } } //不为空 开始获取任务 //从任务队列中移除第一个任务并返回该任务 T task=queue.removeFirst();// 唤醒生成者生产任务 fullWaitSet.signal(); return task; }finally { lock.unlock(); } }// 阻塞获取 消费者获取任务 public T take() { lock.lock(); try { //队列是否为空 while (queue.isEmpty()) { try { //为空等待 emptyWaitSet.await(); } catch (InterruptedException e) { e.printStackTrace(); } } //不为空 开始获取任务 //从任务队列中移除第一个任务并返回该任务 T task=queue.removeFirst();// 唤醒生成者生产任务 fullWaitSet.signal(); return task; }finally { lock.unlock(); } }// 阻塞添加 生成者生产任务 public void put(T task) { lock.lock(); try { //队列中的任务数是否和容量相等 while (queue.size() == capcity) {// 容量已满 阻塞 try { log.info(\"等待加入任务队列{}\",task); fullWaitSet.await(); } catch (InterruptedException e) { e.printStackTrace(); } } log.info(\"加入任务队列{}\",task); //没有满 添加任务 queue.addLast(task); //唤醒消费者线程 emptyWaitSet.signal(); }finally { lock.unlock(); } } // 带超时时间的阻塞添加 如果在指定的超时时间内该任务还没有进入队列则放弃执行该任务 public boolean offer(T task,long timeout,TimeUnit timeUnit) { lock.lock(); try { long nanos = timeUnit.toNanos(timeout); //队列中的任务数是否和容量相等 while (queue.size() == capcity) {// 容量已满 阻塞 try { if (nanos &lt; 0) { return false; } log.info(\"等待加入任务队列{}\",task); nanos=fullWaitSet.awaitNanos(nanos); } catch (InterruptedException e) { e.printStackTrace(); } } log.info(\"加入任务队列{}\",task); //没有满 添加任务 queue.addLast(task); //唤醒消费者线程 emptyWaitSet.signal(); return true; }finally { lock.unlock(); } } // 获取阻塞队列中任务数 public int size() { lock.lock(); try { return queue.size(); }finally { lock.unlock(); } } /** * 策略模式对阻塞队列已满的抽象处理 * @param rejectPolicy 策略对象 * @param task 任务 */ public void tryPut(RejectPolicy&lt;T&gt; rejectPolicy, T task) { lock.lock(); try {// 阻塞队列已满 if (queue.size() == capcity) { //具体策略由调用者实现 rejectPolicy.reject(this,task); }else{ //有空闲 log.info(\"加入任务队列{}\",task); //没有满 添加任务 queue.addLast(task); //唤醒消费者线程 emptyWaitSet.signal(); } }finally { lock.unlock(); } }} ③自定义线程池123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118/** * 线程池 */@Slf4jclass ThreadPool{// 任务队列 BlockingQueue&lt;Runnable&gt; taskQueue;// 线程集合 private HashSet&lt;Worker&gt; workes=new HashSet();// 核心的线程数(即线程池的线程总数) private int coreSize;// 获取任务的超时时间 private long timeout;// 时间单位 private TimeUnit timeUnit; /** * 拒绝策略对象 */ private RejectPolicy&lt;Runnable&gt; rejectPolicy; /** * 线程池中任务的创建 * @param task 任务对象 */ public void execute(Runnable task){// 当任务数没有超过coreSize时，直接交给Worker对象执行// 当任务数超过了的coreSize是，加入任务队列暂存// 当线程数还不够时，小于核心线程数时 该集合操作并不安全 需要加锁 synchronized (workes) { if (workes.size() &lt; coreSize) { //新建一个线程执行此任务 Worker worker = new Worker(task); log.info(\"新增worker{}, {}\",worker, task);// 加入到线程集合中 workes.add(worker);// 执行任务 线程中的run执行任务中的run方法 worker.start(); } else { // 队列已满 选择死等// taskQueue.put(task);// 策略模式的使用：具体实现由调用者选择。// 当阻塞队列任务满的时候，执行的策略有很多种// 1&gt;死等// 2&gt;超时等待// 3&gt;让调用者放弃任务执行// 4&gt;让调用者抛出异常// 5&gt;让调用者抛出异常// 这里我们通过策略模式来实现。 taskQueue.tryPut(rejectPolicy,task); } } } /** * 初始化线程池 * @param coreSize 核心线程数 * @param timeout 超时时间 * @param timeUnit 超时时间单位 * @param queueCapcity 阻塞队列容量 * @param rejectPolicy 拒绝策略的实现对象 */ public ThreadPool(int coreSize, long timeout, TimeUnit timeUnit,int queueCapcity,RejectPolicy&lt;Runnable&gt; rejectPolicy) { this.coreSize = coreSize; this.timeout = timeout; this.timeUnit = timeUnit; this.rejectPolicy=rejectPolicy; this.taskQueue=new BlockingQueue&lt;&gt;(queueCapcity); } /** * 自定义worker包装我们的线程类 */ class Worker extends Thread{ private Runnable task; public Worker(Runnable task) { this.task = task; } /** * worker具体的执行方法 */ @Override public void run() {// ①当task不为空，执行任务// ②当task执行完毕，再接着从任务队列获取任务并执行// 判断初始化的时候是否有任务 || 从阻塞队列中获取任务(执行全部任务)// while (task != null || (task=taskQueue.take())!=null) {// 获取阻塞队列中任务，使用带超时的获取方式。若等待一段时间，阻塞队列还没有任务则不等待 while (task != null || (task=taskQueue.pull(timeout, timeUnit))!=null) { try { log.info(\"正在执行...{}\",task); //相当于执行Runnable中的普通run方法 task.run(); } catch (Exception e) { e.printStackTrace(); }finally { //执行完毕后 将初始化的任务设为null task=null; } }// 所有阻塞的任务和初始化的任务都被执行完毕 移除线程 synchronized (workes) { log.info(\"worker被移除{}\",this); //移除当前线程 workes.remove(this); } } }} ④测试12345678910111213141516171819202122232425262728293031@Slf4jpublic class TestPool { public static void main(String[] args) { ThreadPool threadPool=new ThreadPool(1, 1000, TimeUnit.MILLISECONDS, 1,((queue,task)-&gt;{// 策略模式测试：// 1、实现 死等// queue.put(task);// 2、带超时的等待 设定的超时时间小于任务的执行时间则该任务放弃。// queue.offer(task, 1500, TimeUnit.MILLISECONDS);// 3、让调用者放弃任务执行// log.info(\"放弃任务{}\",task);// 4、让调用者抛出异常// throw new RuntimeException(\"任务执行失败\"+task);// 5、让调用者自己去执行任务 task.run(); }));// 当需要执行的任务超过阻塞队列的长度时 由调用者来实现我们的策略(即真正执行的方法) for (int i = 0; i &lt; 3; i++) { int j=i; threadPool.execute(()-&gt;{ try { //模拟执行很长 Thread.sleep(1000); } catch (InterruptedException e) { e.printStackTrace(); } log.info(\"{}\",j); }); } }} 1234567816:10:10.673 [main] INFO org.lc.Thread_pool.ThreadPool - 新增workerThread[Thread-0,5,main], org.lc.Thread_pool.TestPool$$Lambda$2/1030870354@22927a8116:10:10.676 [main] INFO org.lc.Thread_pool.BlockingQueue - 加入任务队列org.lc.Thread_pool.TestPool$$Lambda$2/1030870354@20fa23c116:10:10.676 [Thread-0] INFO org.lc.Thread_pool.ThreadPool - 正在执行...org.lc.Thread_pool.TestPool$$Lambda$2/1030870354@22927a8116:10:11.676 [main] INFO org.lc.Thread_pool.TestPool - 216:10:11.676 [Thread-0] INFO org.lc.Thread_pool.TestPool - 016:10:11.676 [Thread-0] INFO org.lc.Thread_pool.ThreadPool - 正在执行...org.lc.Thread_pool.TestPool$$Lambda$2/1030870354@20fa23c116:10:12.677 [Thread-0] INFO org.lc.Thread_pool.TestPool - 116:10:13.678 [Thread-0] INFO org.lc.Thread_pool.ThreadPool - worker被移除Thread[Thread-0,5,main] 2、ThreadPoolExecutorpackage java.util.concurrent; ①线程池状态ThreadPoolExecutor 使用 int 的高 3 位来表示线程池状态，低 29 位表示线程数量 从数字上比较，TERMINATED &gt; TIDYING &gt; STOP &gt; SHUTDOWN &gt; RUNNING（111 为负数） 这些信息存储在一个原子变量 ctl 中，目的是将线程池状态与线程个数合二为一，这样就可以用一次 cas 原子操作 进行赋值 12345// c 为旧值， ctlOf 返回结果为新值 ctl.compareAndSet(c, ctlOf(targetState, workerCountOf(c)))); // rs 为高 3 位代表线程池状态， wc 为低 29 位代表线程个数，ctl 是合并它们 private static int ctlOf(int rs, int wc) { return rs | wc; } ②构造方法12345678public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) {} corePoolSize 核心线程数目 （最多保留的线程数，核心线程不会超时） maximumPoolSize 最大线程数据(救急线程数+核心线程数) keepAliveTime 生存时间 - 针对救急线程 TimeUnit 时间单位 - 针对救急线程 workQueue 阻塞队列 threadFactory 线程工厂 - 可以为线程创建时起个好名字 handler 拒绝策略（救急线程用完，阻塞队列已满，会执行该策略） 工作方式： 线程池中刚开始还没有线程，当一个任务提交给线程池后，线程池会创建一个新任务来执行任务 当现场数达到corePoolSize并没有空闲线程，这时再加入任务，新加的任务会被加入workQqueue队列排队，直到有空闲的线程 如果队列选择了有界队列，那么任务超过了队列大小时，会创建 maximumPoolSize - corePoolSize 数目的线 程来救急（阻塞任务队列满的时候，会根据这个线程数目来创建救急线程执行多余的任务） 如果线程到达 maximumPoolSize 仍然有新任务这时会执行拒绝策略（救急线程也全部创建完毕，还有其他的任务，则会执行拒绝策略）。拒绝策略 jdk 提供了 4 种实现，其它 著名框架也提供了实现 AbortPolicy 让调用者抛出 RejectedExecutionException 异常，这是默认策略 CallerRunsPolicy 让调用者运行任务 DiscardPolicy 放弃本次任务 DiscardOldestPolicy 放弃队列中早的任务，本任务取而代之 ———————-其他框架实现————————— Dubbo 的实现，在抛出 RejectedExecutionException 异常之前会记录日志，并 dump 线程栈信息，方 便定位问题 Netty 的实现，是创建一个新线程来执行任务 ActiveMQ 的实现，带超时等待（60s）尝试放入队列，类似我们之前自定义的拒绝策略 PinPoint 的实现，它使用了一个拒绝策略链，会逐一尝试策略链中每种拒绝策略 当高峰过去后，超过corePoolSize 的救急线程如果一段时间没有任务做，需要结束节省资源，这个时间由 keepAliveTime 和 unit 来控制。 ③newFixedThreadPool1234567public class Executors { public static ExecutorService newFixedThreadPool(int nThreads) { return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;()); }} 特点: 核心线程数 = 最大线程数（没有救急线程被创建），因此也无需超时时间 阻塞队列是无界的，可以放任意数量的任务 任务执行完毕后，核心线程不会主动结束。 使用场景：适用于任务量已知，相对耗时的任务 12345678910111213141516171819202122232425@Slf4jpublic class T1 { public static void main(String[] args) {// 创建两个核心线程数// ExecutorService pool = Executors.newFixedThreadPool(2);// 创建两个核心线程数 并自定义实现线程工厂 ExecutorService pool = Executors.newFixedThreadPool(2, new ThreadFactory() { private AtomicInteger t=new AtomicInteger(1); @Override public Thread newThread(Runnable r) {// 自定义线程名称 使用cas赋值自增名称 return new Thread(r,\"mypool_\"+t.getAndIncrement()); } }); pool.execute(()-&gt;{ log.info(\"1\"); }); pool.execute(()-&gt;{ log.info(\"2\"); }); pool.execute(()-&gt;{ log.info(\"3\"); }); }} 12319:46:08.701 [mypool_1] INFO org.lc.Thread_pool.T1 - 1 //线程1 执行任务119:46:08.701 [mypool_2] INFO org.lc.Thread_pool.T1 - 2 //线程2 执行任务219:46:08.704 [mypool_1] INFO org.lc.Thread_pool.T1 - 3 //线程1 执行任务3 ④newCachedThreadPool1234567public class Executors {public static ExecutorService newCachedThreadPool() { return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;()); }} 特定： 核心线程数是 0， 最大线程数是 Integer.MAX_VALUE，救急线程的空闲生存时间是 60s，意味着 全部都是救急线程（60s 后可以回收） 救急线程可以无限创建 队列采用了 SynchronousQueue 实现特点是，它没有容量，没有线程来取是放不进去的（一手交钱、一手交 货） 使用场景：整个线程池表现为线程数会根据任务量不断增长，没有上限，当任务执行完毕，空闲 1分钟后释放线 程。 适合任务数比较密集，但每个任务执行时间较短的情况 ⑤newSingleThreadExecutor12345678public class Executors {public static ExecutorService newSingleThreadExecutor() { return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;Runnable&gt;())); }} 使用场景：希望多个任务排队执行。线程数固定为 1，任务数多于 1 时，会放入无界队列排队。任务执行完毕，这唯一的线程 也不会被释放。 区别： 自己创建一个单线程串行执行任务，如果任务执行失败而终止那么没有任何补救措施，而线程池还会新建一 个线程，保证池的正常工作 Executors.newSingleThreadExecutor() 线程个数始终为1，不能修改 FinalizableDelegatedExecutorService 应用的是装饰器模式，只对外暴露了 ExecutorService 接口，因 此不能调用 ThreadPoolExecutor 中特有的方法，不能对核心线程数等参数进行修改。 Executors.newFixedThreadPool(1) 初始时为1，以后还可以修改 对外暴露的是 ThreadPoolExecutor 对象，可以强转后调用 setCorePoolSize 等方法进行修改 12345678910111213141516171819@Slf4jpublic class T3 { public static void main(String[] args) { ExecutorService pool = Executors.newSingleThreadExecutor(); pool.execute(()-&gt;{ int i=1/0; //出现异常的是否 当前线程会放弃该任务 log.info(\"task 1\"); }); pool.execute(()-&gt;{ log.info(\"task 2\"); }); pool.execute(()-&gt;{ log.info(\"task 3\"); }); }} 1234567Exception in thread \"pool-1-thread-1\" java.lang.ArithmeticException: / by zero at org.lc.Thread_pool.T3.lambda$main$0(T3.java:20) at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1149) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:624) at java.lang.Thread.run(Thread.java:748)22:50:39.111 [pool-1-thread-2] INFO org.lc.Thread_pool.T3 - task 222:50:39.113 [pool-1-thread-2] INFO org.lc.Thread_pool.T3 - task 3 ​","link":"/2020/06/01/thread/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"title":"深入理解JVM虚拟机","text":"Ⅰ、jvm简介一、什么是JVMjava虚拟机(java virtual machine) java程序的运行环境(java二进制字节码的运行环境) 好处： 一次编写，导出运行 自动内存管理，垃圾回收功能 多态 数组下标越界检查 … 二、jre、jdk、jvm的区别？ ### 三、JVM组成部分 四、常见的jvm Ⅱ、JVM内存结构一、程序计数器(Program Counter Register) 1.1定义Program Counter Register 程序计数器（寄存器） java程序执行流程：首先java源代码编译成 –&gt; 二进制字节码(包含一系列jvm指令)–&gt; 通过解释器解释成机器码–&gt;机器码交给cpu识别运行 程序计数器实现：在物理实现上是寄存器实现的 作用：是记住下一条jvm指令的执行地址 (例如执行地址0 的代码getstatic,那么jvm就会存储3所对应的地址astore_1) 特点： 线程私有 不会存在内存溢出 二、虚拟机栈(Java Virtual Machine Stacks ) 2.1定义Java Virtual Machine Stacks （Java 虚拟机栈） 栈中存的是基本数据类型和堆中对象的引用 每个线程运行时所分配的内存为虚拟机栈，jvm为每个线程分配一个虚拟机栈 每个栈有多个栈帧(Frame)组成,对应着每个方法调用时的所占用的内存(每个运行的方法对应一个栈帧) 每个线程只能有一个活动栈帧(正在执行的那个方法)、对应着当前正在执行的那个方法 2.2栈演示：12345678910111213public class T1 { public static void main(String[] args) { method1(); } static void method1() { method2(2,3); } private static int method2(int a, int b) { return a+b; }} 方法执行过程通过压栈的方式，为每一个方法分配一个栈帧，方法执行完后，采用先进后出的方式依次出栈。 2.3问题辨析①垃圾回收是否涉及栈内存？不涉及，栈帧对应着一个一个的方法，方法执行完后，将出栈，自动释放内存。垃圾回收只是对堆内存回收 ②栈内存越大越好吗？可通过-Xss分配栈的内存，默认根据机器的内存自动分配。若本机内存500M,栈内存设置为1M,那么可以创建500个线程来使用分配栈的内存 ③方法内的局部变量是否线程安全？不会，每个线程对应一个虚拟机栈，方法的执行对应每一个栈帧，内存相互独立，不会干扰。 如果方法内的局部变量没有逃离方法的作用范围，则线程安全 若引用类型的变量通过方法传参，返回值返回则非线程安全 2.4栈内存溢出(StackOverflowError)①栈帧过多导致内存溢出(方法的递归调用)②栈帧过大导致栈内存溢出(-Xss)12345678910111213141516public class T2 { static int count; public static void main(String[] args) { try { method1(); } catch (Throwable e) { e.printStackTrace(); System.out.println(count); } } static void method1() { count++; method1(); }} 1234java.lang.StackOverflowError at org.lc.jvm_stack.T2.method1(T2.java:23) //....18340 上述递归方法执行了18340后出现栈的溢出，我们可以通过修改栈的内存大小为512K来让栈更快溢出 1234java.lang.StackOverflowError at org.lc.jvm_stack.T2.method1(T2.java:23) //....6617 这次只递归调用了6617此即溢出 ③线程运行诊断(jstack)1)cpu过高(线程高负荷运行没有终止)例如：线程中没有终止的条件对while(true)循环 用top定位哪个进程对cpu的占用过高 ps H -eo pid,tid,%cpu | grep 进程id（用ps命令进一步定位是哪个线程引起的cpu占用过高） H: 展示所有进程中的所有线程信息 eo: 输出指定内容 pid:进程id tid:线程id %cpu: cpu占用信息 | grep 进程id : 利用管道操作符查找匹配进程id 找到占用高的cpu的线程后，记住进程id，使用 jstack 进程id jstack 进程id 列出该进程下的所有线程信息 可以根据线程id 找到有问题的线程，进一步定位到问题代码的源码行号。因为使用jstack展示的线程信息的id为16进制,所以我们需要将占用cpu高的线程tid，32665转换为16进制为7F99，找到7F99对应的线程thread1，找到出问题的代码行数 2)程序运行很长时间没有结果 (死锁)三、本地方法栈(Native Method Stacks) 为本地的方法提供一块内存空间；例如Object中的wait,clone,sleep方法，方法用native修饰 四、堆(Heap) 4.1定义Heap 堆 通过 new 关键字，创建对象都会使用堆内存。jdk&gt;=1.7类的静态变量也存在堆中。jdk&lt;=1.6类的静态变量存在方法区 特点: 它是线程共享的，堆中对象都需要考虑线程安全的问题 有垃圾回收机制 4.2堆内存溢出(OutofMemoryError)(-Xmx)123456789101112131415public class T1 { public static void main(String[] args) { int i=0; try { String a = \"hello\"; while (true) { a=a+a; //会不断创建字符串进行拼接，该对象一直不被释放 i++; } } catch (Throwable throwable) { throwable.printStackTrace(); System.out.println(i); } }} 123456java.lang.OutOfMemoryError: Java heap space at java.util.Arrays.copyOfRange(Arrays.java:3664) at java.lang.String.&lt;init&gt;(String.java:207) at java.lang.StringBuilder.toString(StringBuilder.java:407) at org.lc.jvm_heap.T1.main(T1.java:16)26 通过参数-Xmx修改堆内存大小为8M缩短堆内存的溢出时间 1234567java.lang.OutOfMemoryError: Java heap space at java.util.Arrays.copyOf(Arrays.java:3332) at java.lang.AbstractStringBuilder.ensureCapacityInternal(AbstractStringBuilder.java:124) at java.lang.AbstractStringBuilder.append(AbstractStringBuilder.java:448) at java.lang.StringBuilder.append(StringBuilder.java:136) at org.lc.jvm_heap.T1.main(T1.java:16)17 4.3堆内存诊断①jps 工具 模拟高内存占用代码 12345678910111213public class T2 { public static void main(String[] args) throws InterruptedException { System.out.println(\"1.....\"); Thread.sleep(30000); byte[] array=new byte[1024*1024*10]; System.out.println(\"2....\"); Thread.sleep(30000); array=null; System.gc();//垃圾回收 System.out.println(\"3....\"); Thread.sleep(100000000L); }} 查看当前系统中S哪些 java 进程 ②jmap 工具 查看堆内存占用情况 jmap - heap 进程id ③jconsole工具 图形界面的，多功能的监测工具，可以连续监测 直接输入jconsole命令即可 ④jvisualvm工具(高内存占用)程序运行很长时间没有结果 模拟代码 123456789101112public class T3 { public static void main(String[] args) throws InterruptedException { List&lt;Student&gt; list=new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 200; i++) { list.add(new Student()); } Thread.sleep(100000000L); }}class Student { private byte[] big = new byte[1024 * 1024];} 我们首先使用jconsole工具来查看，并执行GC 我们发现虽然执行GC回收了一些内存，但是但是占用很高的内存。这时我们使用jvisualvm命令 执行堆Dump，对内存进行快照 点击查找 点击进入占用内存大的类 我们查看elementData存储的为元素Size有200个,每个元素占用1M作用。查看代码找出问题 五、方法区(Method Area) 5.1定义官方：https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.5.4 ​ Java虚拟机有一个区域的方法,是所有Java虚拟机线程之间共享。方法区域类似于编译代码的存储区域传统语言或类似于“文本”段在一个操作系统的过程。它存储每个类结构如运行时常量池、字段和方法的数据和方法和构造函数的代码,包括特殊方法(§2.9)中使用的类和实例初始化和接口初始化(类的构造器)。方法区在jvm启动时创建，逻辑上(概念)是堆的组成部分。所以我们的方法区只是一种规范，方法区的实现由不同厂商决定，不强制它的实现位置。 5.2组成在我们使用的Oracle的jdk实现版本中，方法区的实现如下： jdk1.6 method Area只是一种概念。具体的实现是永久代(PermGen) StringTable为串池 jdk1.8 方法区的实现由永久代废弃，变为元空间(Metaspace)的实现，占用的内存为本地内存，即操作系统的内存 5.3方法区内存溢出(-XX:MaxMetaspaceSize) 测试代码 123456789101112131415161718192021//ClassLoader: 用来加载类的二进制字节码public class T4 extends ClassLoader{ public static void main(String[] args) { int j=0; try { T4 test=new T4(); for (int i = 0; i &lt; 10000; i++,j++) { //ClassWriter 作用是生成类的二进制字节码 ClassWriter cw=new ClassWriter(0);// 版本号 ; publc; 类名；包名； 父类； 接口 cw.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, \"Class\"+i,null, \"java/lang/Object\", null);// 返回byte[] byte[] code=cw.toByteArray();// 执行了类的加载 test.defineClass(\"Class\"+i,code, 0, code.length); //Class对象 } }finally { System.out.println(j); } }} 110000 默认不会出现内存溢出，因为此时jdk1.8的元空间实现的方法区使用的为操作系统的内存。本机操作系统内存足够大。 设置元空间(方法区)的大小为8M参数：-XX:MaxMetaspaceSize=10m 123456789//加载3331个类文件内存溢出3331Exception in thread \"main\" java.lang.OutOfMemoryError: Compressed class space at java.lang.ClassLoader.defineClass1(Native Method) at java.lang.ClassLoader.defineClass(ClassLoader.java:763) at java.lang.ClassLoader.defineClass(ClassLoader.java:642) at org.lc.jvm_heap.T4.main(T4.java:27)Process finished with exit code 1 1.8 以前会导致永久代内存溢出 设置永久代内存大小 -XX:MaxPermSize=10m java.lang.OutOfMemoryError: permGen space 1.8 之后会导致元空间内存溢出(默认不会溢出) 设置元空间内存大小 -XX:MaxMetaspaceSize=10m java.lang.OutOfMemoryError: Compressed class space 5.4常量池&amp;运行时常量池 测试代码 12345public class T1 { public static void main(String[] args) { System.out.println(\"hello world\"); }} 反编译文件：javap -v T1.class 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475Last modified 2020-6-7; size 547 bytes MD5 checksum 8f4a2ef03e7776481657f0feef4a573a Compiled from \"T1.java\"public class org.lc.method_area.T1 minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPER //常量池.......main方法中的指令根据`#序号`会在此处寻找对应的类型和输出的值Constant pool: #1 = Methodref #6.#20 // java/lang/Object.\"&lt;init&gt;\":()V #2 = Fieldref #21.#22 // java/lang/System.out:Ljava/io/PrintStream; #3 = String #23 // hello world #4 = Methodref #24.#25 // java/io/PrintStream.println:(Ljava/lang/String;)V #5 = Class #26 // org/lc/method_area/T1 #6 = Class #27 // java/lang/Object #7 = Utf8 &lt;init&gt; #8 = Utf8 ()V #9 = Utf8 Code #10 = Utf8 LineNumberTable #11 = Utf8 LocalVariableTable #12 = Utf8 this #13 = Utf8 Lorg/lc/method_area/T1; #14 = Utf8 main #15 = Utf8 ([Ljava/lang/String;)V #16 = Utf8 args #17 = Utf8 [Ljava/lang/String; #18 = Utf8 SourceFile #19 = Utf8 T1.java #20 = NameAndType #7:#8 // \"&lt;init&gt;\":()V #21 = Class #28 // java/lang/System #22 = NameAndType #29:#30 // out:Ljava/io/PrintStream; #23 = Utf8 hello world #24 = Class #31 // java/io/PrintStream #25 = NameAndType #32:#33 // println:(Ljava/lang/String;)V #26 = Utf8 org/lc/method_area/T1 #27 = Utf8 java/lang/Object #28 = Utf8 java/lang/System #29 = Utf8 out #30 = Utf8 Ljava/io/PrintStream; #31 = Utf8 java/io/PrintStream #32 = Utf8 println #33 = Utf8 (Ljava/lang/String;)V{ public org.lc.method_area.T1(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.\"&lt;init&gt;\":()V 4: return LineNumberTable: line 10: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lorg/lc/method_area/T1; public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=1, args_size=1 //通过`#序号`的方式在常量池Constant pool中寻找对应的类型。 0: getstatic #2 //在常量池中寻找#2序号 // Field java/lang/System.out:Ljava/io/PrintStream; 3: ldc #3 // String hello world 5: invokevirtual #4 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 8: return LineNumberTable: line 12: 0 line 13: 8 LocalVariableTable: Start Length Slot Name Signature 0 9 0 args [Ljava/lang/String;}SourceFile: \"T1.java\" 常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量 等信息 运行时常量池，常量池是 *.class 文件中的，当该类被加载，它的常量池信息就会放入运行时常量 池，并把里面的#符号地址变为真实地址，此时的常量池就叫运行时常量池 5.5StringTable(串池)12345678910111213141516171819202122232425262728public class T1 { public static void main(String[] args) {// 1、串池 StringTable[\"a\",\"b,\"ab\"] hashtable结构，不能扩容// 2、串池中的字符串都不是重复的，若发现首次在串池中找不到所需的字符串，则会在创建的时候保存在串池中一份// 3、字符串都是懒惰加载的,即允许到该代码行时才会在串池中创建存储// 4、通过String s1=new String(\"ab\")创建的字符传,若常量池中没有则，则会先将常量\"ab\"放在常量池中保存一份。再通过new一个String对象来从常量池中加载该\"ab\"常量,但是引用的变量s1为堆中的地址。只有调用s1.intern()方法，此s1才会执行常量池中的地址 //// 将\"a\" 保存在串池 String s1 = \"a\";// 将\"b\" 保存在串池 String s2 = \"b\";// 将\"ab\" 保存在串池 String s3 = \"ab\";// 反编译发现 new StringBuilder().append(s1).append(s2).toString()。 即new String(\"ab\")// 重新在堆中创建一个字符串对象 String s4 = s1 + s2;// 因为\"a\",\"b\"在编译期已确定不会再更改，所以jvm在编译期间就帮我们优化为\"ab\" String s5 = \"a\" + \"b\";// 反编译发现 new StringBuilder().append(s1).append(\"b\").toString()。 即new String(\"ab\") String s6 = s1 + \"b\";// true，都是指向串池中的地址 System.out.println(s3==s5);// s3位串池中的地址。s6为堆中的地址，即false System.out.println(s3==s6); }} javap -v T1.class 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586 Last modified 2020-6-7; size 993 bytes MD5 checksum 72da179befc5b24f8006197550ecf10c Compiled from \"T1.java\"public class org.lc.method_area.T1 minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #12.#37 // java/lang/Object.\"&lt;init&gt;\":()V #2 = String #38 // a #3 = String #39 // b #4 = String #40 // ab //.... stack=3, locals=7, args_size=1 //从串池中加载(即在常量池#2位置加载字符串a) a 0: ldc #2 // String a //存储给变量Slot=1的变量，即变量s1 2: astore_1 //从串池中加载 b 3: ldc #3 // String b //存储给变量Slot=2的变量，即变量s2 5: astore_2 //从串池中加载 ab 6: ldc #4 // String ab //存储给变量Slot=3的变量，即变量s3 8: astore_3 //创建StringBuilder对象 9: new #5 // class java/lang/StringBuilder 12: dup //创建一个无参的构造函数 13: invokespecial #6 // Method java/lang/StringBuilder.\"&lt;init&gt;\":()V //从Slot=1的变量位置读取字符串String s1=\"a\" 16: aload_1 //使用append方法 17: invokevirtual #7 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; //从Slot=2的变量位置读取字符串String s2=\"b\" 20: aload_2 //再次使用append方法 21: invokevirtual #7 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; //回调虚方法 toString() 24: invokevirtual #8 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; //储存到slot=4的位置 即储存给变量s4 27: astore 4 //直接从常量池中的#4位置加载字符串\"ab\" 29: ldc #4 // String ab //储存给Slot=5的位置，即变量s5 31: astore 5 //下面同理 33: new #5 // class java/lang/StringBuilder 36: dup 37: invokespecial #6 // Method java/lang/StringBuilder.\"&lt;init&gt;\":()V 40: aload_1 41: invokevirtual #7 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 44: ldc #3 // String b 46: invokevirtual #7 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 49: invokevirtual #8 // Method java/lang/StringBuilder.toString:()Ljava/lang/String; 52: astore 6 54: getstatic #9 // Field java/lang/System.out:Ljava/io/PrintStream; 57: aload_3 58: aload 6 60: if_acmpne 67 63: iconst_1 64: goto 68 67: iconst_0 68: invokevirtual #10 // Method java/io/PrintStream.println:(Z)V 71: return LineNumberTable: line 16: 0 line 18: 3 line 20: 6 line 23: 9 line 25: 29 line 26: 33 line 28: 54 line 29: 71 //从此处加载和赋值变量 LocalVariableTable: Start Length Slot Name Signature 0 72 0 args [Ljava/lang/String; 3 69 1 s1 Ljava/lang/String; 6 66 2 s2 Ljava/lang/String; 9 63 3 s3 Ljava/lang/String; 29 43 4 s4 Ljava/lang/String; 33 39 5 s5 Ljava/lang/String; 54 18 6 s6 Ljava/lang/String; //..... 5.6StringTable特性 常量池中的字符串仅是符号，第一次用到时才变为对象 利用串池的机制，来避免重复创建字符串对象 字符串变量拼接的原理是 StringBuilder （1.8） 字符串常量拼接的原理是编译期优化 可以使用 intern 方法，主动将串池中还没有的字符串对象放入串池 1.8 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池， 会把串 池中的对象返回 1.6 将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有会把此对象复制一份， 放入串池， 会把串池中的对象返回 123456789101112public class T2 { public static void main(String[] args) {// 首先在串池中放入 \"a\",\"b\" String s1 = new String(\"a\") + new String(\"b\");// 再将s1拼接成的\"ab\"手动放入串池，串池中没有，放入成功，则s1指向串池的内容。 String s2=s1.intern(); //将s1放入串池的地址赋值给s2// 所以 s1也为串池的内容 true //注意若这里的jdk版本为1.6那么为fasle，因为这里会将对象s1拷贝一份到常量池,使用s1的时候还是堆中的对象，而不是常量池中的对象 System.out.println(s1 == \"ab\");// 所以 s2也为串池的内容 true System.out.println(s2 == \"ab\"); }} 123456789101112131415public class T2 { public static void main(String[] args) {// 首先在串池中放入 \"ab\" String s0=\"ab\";// 再在串池放入 \"a\" \"b\" String s1 = new String(\"a\") + new String(\"b\");// 再将s1拼接成的\"ab\"手动放入串池。// 注意此时的串池中有\"ab\",则放入失败。返回串池中的\"ab\"给s2 String s2=s1.intern();// 所以 s1是堆中的那个对象new String(\"ab\") false System.out.println(s1 == s0);// 所以 s2也为串池的内容 true System.out.println(s2 == s0); }} 5.7StringTale位置 jdk1.6的时候，串池在方法区，即永久代。 jdk1.8的时候，串池在堆空间。方法区为元空间, 即本地内存。 12345678910111213141516public class T3 { public static void main(String[] args) { List&lt;String&gt; list=new ArrayList&lt;&gt;(); int j=0; try { for (int i = 0; i &lt; 260000; i++) { list.add(String.valueOf(i).intern()); j++; } } catch (Throwable throwable) { throwable.printStackTrace(); }finally { System.out.println(j); } }} 12345java.lang.OutOfMemoryError: GC overhead limit exceeded //超过了GC回收的限制 GC花费了大量的时间进行垃圾回收，但是还是只回收了一部分内存。 at java.lang.Integer.toString(Integer.java:401) at java.lang.String.valueOf(String.java:3099) at org.lc.method_area.T3.main(T3.java:19)145683 关掉GC回收，-Xmx10m -XX:-UseGCOverheadLimit -XX:-UseGCOverheadLimit -代表关闭 +代表开启 12345java.lang.OutOfMemoryError: Java heap space //堆空间内存溢出 at java.lang.Integer.toString(Integer.java:401) at java.lang.String.valueOf(String.java:3099) at org.lc.method_area.T3.main(T3.java:19)146834 5.8StringTable 垃圾回收当串池中的数据快占用满堆内存的时候，会触发一次GC垃圾回收操作，将没有地址引用的对象进行垃圾进行回收 5.8StringTable调优①调整XX:StringTableSizeStringTable是由hash表加链表组成(和hashmap类似) 例如：如果要把上万级的单词数量代码加载到串池中。若串池的StringTable的桶的个数过少，则索引时间会变慢，hash冲突会变高。 若读取到的40万个单词存到串池中，若设置StringTable个数为1000,那么每个桶的放的个数为400个单词。寻找字符串的时间会非常慢。所以当我们存储的字符串非常多需要放到串池中，那么我们可以考虑设置StringTable桶的个数： -XX:StringTableSize=桶个数，来减少hash碰撞的概率。 ②决定是否将字符串入池(使用intern()）当我们使用的字符串有大量的重复串时，我们可以使用String的intern()方法入池,下次遇到重复的串存储时，直接从串池中拿即可。减少内存占用。 在jdk1.8的时候，intern()方法首先对字符串入池，若池中存在则返回池中的字符串，否则将该字符串入池 六、直接内存(Direct Memory)6.1NIO/IO 同步阻塞IO模型读取文件： java本身不具备磁盘读写的能力，必须调用操作系统的函数才能方法读取内存中的数据 当CPU运行到内核态时，磁盘文件先加载到系统缓存区，java会在内存中划分一块缓冲区，再将系统缓冲区的代码读到java堆内存的缓冲区，完成一次缓冲拷贝，周而复始完成读取操作。 同步非阻塞NIO模型读取文件： 操作系统划分一块direct memory区，操作系统和java代码都可以直接访问此缓冲区的数据，所以NIO少了一部分数据的复制操作。 6.2定义 常见于 NIO 操作时，用于数据缓冲区 分配回收成本较高，但读写性能高 不受 JVM 内存回收管理（System.gc()只能回收jvm的垃圾，不能回收直接内存） 6.3直接内存溢出 使用NIO划分内存区域，模拟内存溢出 12345678910111213141516171819public class T4 { //100mb static int _100Mb = 1024 * 1024 * 100; public static void main(String[] args) { List&lt;ByteBuffer&gt; list=new ArrayList&lt;&gt;(); int i=0; try { while (true) { //一次划分直接内存100MB ByteBuffer byteBuffer=ByteBuffer.allocateDirect(_100Mb); list.add(byteBuffer); i++; } }finally { System.out.println(i); } }} 123456Exception in thread \"main\" java.lang.OutOfMemoryError: Direct buffer memory at java.nio.Bits.reserveMemory(Bits.java:694) at java.nio.DirectByteBuffer.&lt;init&gt;(DirectByteBuffer.java:123) at java.nio.ByteBuffer.allocateDirect(ByteBuffer.java:311) at org.lc.method_area.T4.main(T4.java:27)36 6.4直接内存分配和回收原理12345678910111213public class T1 {// 1GB static int _1GB=1024*1024*1024; public static void main(String[] args) throws IOException {// 划分一块1GB大小的直接内存 ByteBuffer byteBuffer=ByteBuffer.allocateDirect(_1GB); System.out.println(\"分配完毕...\"); System.in.read(); System.out.println(\"开始释放...\"); System.gc(); }} 我们查看任务资源管理器，查看该程序的内存占用情况为1GB： 运行完该代码后，发现内存已释放，我们能否得出结论是System.gc()释放的吗？不是。 通过底层发现是使用了 Unsafe 对象完成直接内存的分配回收，并且回收需要主动调用 freeMemory 方法 ByteBuﬀer 的实现类内部，使用了 Cleaner （虚引用）来监测 ByteBuﬀer 对象，一旦 ByteBuﬀer 对象被垃圾回收，那么就会由 ReferenceHandler 线程通过 Cleaner 的 clean 方法调 用 freeMemory 来释放直接内存 ①禁用显示的垃圾回收(System.gc())即让System.gc()失效，避免程序员在代码中无意使用该Full GC方式回收垃圾，会回收新生代和老年代，会造成程序暂停时间较长。 -XX:+DisableExplicitGC 禁用GC回收 -XX:-DisableExplicitGC 开启GC回收 禁用垃圾回收以后，我们可以使用Unsafe的freeMemory来实现垃圾回收。或者等到内存占用到一定比例由jvm自动回收 Ⅲ、垃圾回收一、如何判断对象可以回收1.1引用计数法(废弃)对象被引用，计数+1 对象直接相互引用，但是两个对象都没用到，对象无法回收 1.2可达性分析算法 Java 虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象 扫描堆中的对象，看是否能够沿着 GC Root对象 为起点的引用链找到该对象，找不到，表示可以 回收 哪些对象可以作为 GC Root ? 系统类，Object,HashMap,String… 本地方法 正在加锁的对象 活动线程中的对象 1.3四种引用 注：实线代表强引用 ①强引用 只有所有 GC Roots 对象都不通过【强引用】引用该对象，该对象才能被垃圾回 强引用类型是我们平时写代码的时候最常用的引用 12345678910111213public class Main { public static void main(String[] args) { //创建一个对象，new出来的对象都是分配在java堆中的 Sample sample = new Sample(); //sample这个引用就是强引用 sample = null; //将这个引用指向空指针, //那么上面那个刚new来的对象就没用任何其它有效的引用指向它了 //也就说该对象对于垃圾收集器是符合条件的 //因此在接下来某个时间点 GC进行收集动作的时候, 该对象将会被销毁，内存被释放 }}class Sample {} 由以上图可知，GCRoot根对象C和B同时引用对象A1,那么此时A1对象不能被回收。 只有C和B同时断开和A1对象的引用时，A1对象才能被回收 ②软引用 仅有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次出发垃圾回收，回收软引用 对象 可以配合引用队列来释放软引用自身 当A2对象有强对象B引用它时，A2对象不能被回收 当A2没有被强对象引用时，只是被C对象间接引用(软引用)，那么当jvm进行垃圾回收时，若回收后还是发现内存不足，那么A2对象也有可能会被回收 ③弱引用 仅有弱引用引用该对象时，在垃圾回收时，无论内存是否充足，都会回收弱引用对象 可以配合引用队列来释放弱引用自身 当A3对象有强对象B引用它时，A3对象不能被回收 当A2没有被强对象B引用时，只是被C对象间接引用(弱引用)，那么当jvm进行垃圾回收操作时，无论内存是否充足，该对象都会被回收 1)软弱引用配合引用队列软引用和弱引用可以配合引用队列使用，也可以不配合引用队列使用 当软引用和弱引用的对象被释放后，引用自身也是一个对象，如果在创建的时候给软弱引用分配了一个引用队列，软弱引用所引用的对象被回收时，该软弱引用会进入这个引用队列。因为软弱引用也占用一定内存，也有可能被强引用所引用，所以需要当对软弱引用进行释放的时候，需要在引用队列中找到该软弱引用把它释放掉 ④虚引用 必须配合引用队列使用，主要配合 ByteBuﬀer 使用，被引用对象回收时，会将虚引用入队， 由 Reference Handler 线程调用虚引用相关方法释放直接内存 例如:当我们使用ByteBuffer声明一块直接内存的时候，如果ByteBuffer没有被B对象引用时，ByteBuffer可能被回收，但是此时所分配的直接内存不能被jvm所直接回收，所以此时ByteBuffer被释放后，虚引用会进入引用队列，使用Unsafe中的freeMemory方法找到该直接内存地址把该直接内存释放掉 *⑤终结器引用 无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队（被引用对象 暂时没有被回收），再由 Finalizer 线程通过终结器引用找到被引用对象并调用它的 ﬁnalize 方法，第二次 GC 时才能回收被引用对象 当A4对象没有被强B对象引用时，A4对象可能会被回收，当jvm对A4对象回收时，会为A4对象创建一个终结器引用，并把该引用放入引用队列，这是A4对象还没有被回收，jvm在合适的时机再用一个优先级很低的finallizehandler线程，去队列中寻找有没有一个新加入的终结器引用，根据终结器引用找到该A4对象，并调用finallize()方法，释放该对象内存。所以该方法效率非常低，在第二次的时候才能被回收，优先级较低的线程使该finallize()可能不会被执行。 1)虚引用和终结器引用必须配合引用队列使用1.4四种引用的应用①软引用 未使用引用，将堆内存设置为20M 12345678910public class T1 { private static final int _4MB=4*1024*1024; public static void main(String[] args) throws IOException { List&lt;byte[]&gt; list=new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 5; i++) { list.add(new byte[_4MB]); } System.in.read(); }} 123//发生堆内存溢出Exception in thread \"main\" java.lang.OutOfMemoryError: Java heap space at org.lc.jvm_reference.T1.main(T1.java:19) 使用软引用 -XX:+PrintGCDetails -verbose:gc 查看GC的详细信息 1234567891011121314 public static void soft() { //创建软引用对象，此时引用 List--&gt; SoftReference --&gt; byte[] List&lt;SoftReference&lt;byte[]&gt;&gt; list=new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 5; i++) { SoftReference&lt;byte[]&gt; softReference = new SoftReference&lt;&gt;(new byte[_4MB]); list.add(softReference); System.out.println(list.size()); } System.out.println(\"循环结束...\"+list.size()); for (SoftReference&lt;byte[]&gt; ref : list) { System.out.println(ref.get()); } }} 12345678910111213141516171819202122232425262728293031123//加入第四个字节对象时，发现内存不足，进行一次垃圾回收[GC (Allocation Failure) [PSYoungGen: 1994K-&gt;488K(6144K)] 14282K-&gt;13005K(19968K), 0.0027620 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] 4//但是，回收后发现内存还是不足，即进行软引用的垃圾回收，将前面四个软引用回收掉[GC (Allocation Failure) --[PSYoungGen: 4696K-&gt;4696K(6144K)] 17214K-&gt;17222K(19968K), 0.0009000 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [Full GC (Ergonomics) [PSYoungGen: 4696K-&gt;4520K(6144K)] [ParOldGen: 12525K-&gt;12491K(13824K)] 17222K-&gt;17012K(19968K), [Metaspace: 3214K-&gt;3214K(1056768K)], 0.0042977 secs] [Times: user=0.06 sys=0.02, real=0.00 secs] [GC (Allocation Failure) --[PSYoungGen: 4520K-&gt;4520K(6144K)] 17012K-&gt;17052K(19968K), 0.0005820 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]//触发full gc,把新生代和老年代内存都释放掉，即回收前四个软引用[Full GC (Allocation Failure) [PSYoungGen: 4520K-&gt;0K(6144K)] [ParOldGen: 12531K-&gt;610K(8704K)] 17052K-&gt;610K(14848K), [Metaspace: 3214K-&gt;3214K(1056768K)], 0.0055406 secs] [Times: user=0.00 sys=0.00, real=0.01 secs] 5循环结束...5nullnullnullnull //只获得了最后一次加入对象[B@135fbaa4Heap //新生代占的内存最大，即为最后一次加入的字节数组大小 PSYoungGen total 6144K, used 4376K [0x00000000ff980000, 0x0000000100000000, 0x0000000100000000) eden space 5632K, 77% used [0x00000000ff980000,0x00000000ffdc6220,0x00000000fff00000) from space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000) to space 512K, 0% used [0x00000000fff80000,0x00000000fff80000,0x0000000100000000) //老年代的被回收 ParOldGen total 8704K, used 610K [0x00000000fec00000, 0x00000000ff480000, 0x00000000ff980000) object space 8704K, 7% used [0x00000000fec00000,0x00000000fec98888,0x00000000ff480000) Metaspace used 3220K, capacity 4500K, committed 4864K, reserved 1056768K class space used 349K, capacity 388K, committed 512K, reserved 1048576K 1)使用引用队列1234567891011121314151617181920212223242526272829303132public class T1 { private static final int _4MB=4*1024*1024; public static void main(String[] args) throws IOException { //创建软引用对象，此时引用 List--&gt; SoftReference --&gt; byte[] List&lt;SoftReference&lt;byte[]&gt;&gt; list=new ArrayList&lt;&gt;();// 引用队列 ReferenceQueue&lt;byte[]&gt; queue=new ReferenceQueue&lt;&gt;(); for (int i = 0; i &lt; 5; i++) { //软引用关联引用队列 SoftReference&lt;byte[]&gt; softReference = new SoftReference&lt;&gt;(new byte[_4MB],queue); list.add(softReference); System.out.println(list.size()); }// 从队列中获取无用的 软引用对象，并移除 Reference&lt;? extends byte[]&gt; poll = queue.poll(); while (poll != null) { //从集合重移除无用的软引用对象 list.remove(poll);// 从队列中移除 poll=queue.poll(); } System.out.println(\"循环结束...\"+list.size()); for (SoftReference&lt;byte[]&gt; ref : list) { System.out.println(ref.get()); } }} 123456712345循环结束...1[B@135fbaa4 ②弱引用1)使用引用队列123456789101112131415public class T2 { private static final int _4MB=4*1024*1024; public static void main(String[] args) { List&lt;WeakReference&lt;byte[]&gt;&gt; list=new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 5; i++) { WeakReference&lt;byte[]&gt; weakReference = new WeakReference&lt;&gt;(new byte[_4MB]); list.add(weakReference); for (WeakReference&lt;byte[]&gt; w:list){ System.out.print(w.get()+\"\"); } System.out.println(); } System.out.println(\"循环结束\"); }} 1234567891011121314151617181920[B@135fbaa4[B@135fbaa4[B@45ee12a7[B@135fbaa4[B@45ee12a7[B@330bedb4//存入第四个对象的时候发生一次垃圾回收 触发minorGC回收年轻代 [GC (Allocation Failure) [PSYoungGen: 1993K-&gt;488K(6144K)] 14281K-&gt;12985K(19968K), 0.0019001 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] //第四个对象勉强存放成功[B@135fbaa4[B@45ee12a7[B@330bedb4[B@2503dbd3 //第五次存入对象的之前 再触发minorGC回收年轻代 回收掉第四次的若引用对象 [GC (Allocation Failure) [PSYoungGen: 4696K-&gt;488K(6144K)] 17194K-&gt;13065K(19968K), 0.0006471 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] [B@135fbaa4[B@45ee12a7[B@330bedb4 null [B@4b67cf4d循环结束Heap PSYoungGen total 6144K, used 4752K [0x00000000ff980000, 0x0000000100000000, 0x0000000100000000) eden space 5632K, 75% used [0x00000000ff980000,0x00000000ffdaa000,0x00000000fff00000) from space 512K, 95% used [0x00000000fff80000,0x00000000ffffa020,0x0000000100000000) to space 512K, 0% used [0x00000000fff00000,0x00000000fff00000,0x00000000fff80000) ParOldGen total 13824K, used 12577K [0x00000000fec00000, 0x00000000ff980000, 0x00000000ff980000) object space 13824K, 90% used [0x00000000fec00000,0x00000000ff848700,0x00000000ff980000) Metaspace used 3218K, capacity 4500K, committed 4864K, reserved 1056768K class space used 349K, capacity 388K, committed 512K, reserved 1048576K 二、垃圾回收算法2.1标记清除(Mark Sweep) 速度快 会造成内存碎片 先记录未被使用的对象(垃圾)的起始地址，再清除该起始地址的数据，并不会整理合并地址块，新加入的对象地址直接塞到对应空的地址块即可 2.2标记整理(Mark Compact) 速度慢 没有内存碎片 对比垃圾清除算法，多了一步再垃圾进行清除后，会对内存碎片进行整理，使存储空间得到充分利用，缺点时耗费性能。 清除一块垃圾的时候，将存活的对象向前移动。 2.3复制(Copy) 不会有内存碎片 复制占用双倍的内存空间 占用双倍的存储空间，首先将被GCRoot引用的对象移动至另一块内存区域，并进行整理，留下的垃圾区域直接清除，然后再交换两块内存区域的位置 三、分代垃圾回收 ​ 首先，先创建的对象放入伊甸园区，伊甸园被区被占满后，触发第一次Minor GC，采用可达性分析算法，根据GC Root引用链去找可以回收的垃圾，将垃圾进行标记，标记成功，采用复制算法，将回收后幸存的垃圾复制到幸存区To中，并让幸存对象的寿命加1，然后可以回收掉伊甸园中其他的垃圾，将幸存区To的位置和幸存区From的位置进行交换(它们内存空间大小不会改变,此时存活的对象在幸存区From中)。即伊甸园中的空间已释放，又可以创建新的对象放入伊甸园中。当伊甸园中的内存又满了的时候，再触发第二次Minor GC，再根据引用链找到伊甸园和幸存区From中的对象，将存活的对象放入幸存区To中，将伊甸园中来的对象寿命加1，将幸存区From中还存或的对象加1(即变成2)，剩下在伊甸园和幸存区From中的垃圾清除释放，然后又把在幸存To中的对象位置和幸存区From进行交换(此时存活对象在幸存区From中)。 ​ 当幸存区中的对象年龄的阈值超过默认值15时，我们的虚拟机认为这是价值较高的对象，不会被轻易回收，会将该对象晋升到老年代中，老年代不会轻易被回收。或者当年轻代中的内存被占满的时候，这是还要放比较大的对象时，新生代中已存在的对象会忽略阈值的限制直接晋升到老年代，腾出空间给新加入的对象使用。 ​ 当老年代内存也快满的时候，会触发一次Full GC来触发一次老年代的垃圾回收,Full GC会回收新生代和老年代的垃圾回收。当老年代空间不足时会先尝试触发minor gc（JDK 6 update 24 之后规定，只要老年代的连续空间大于新时代的对象总大小或者平均晋升大小就会进行minor GC），如果之后空间不足(又有对象从新生代区域升级到老年代)，那么触发Full gc, 那么stop the world会更长，应避免这种操作，如果full gc后老年代空间还不足则 out of memory 要点： full gc 又叫 major gc (major garbage collection ) 新生代区的GC会频繁进行。因而，一般在这里需要使用速度快、效率高的算法，使新生代区能尽快空闲出来。 对象首先分配在伊甸园区 新生代空间不足时，触发Minor GC，伊甸园和from存货的对象使用copy赋值到to中，是存活对象的年龄加1，并且交换form,to中的值，并释放的垃圾对象 minor gc 会引发 stop the world 暂停其他用户的线程，等待垃圾回收结束，用户线程才恢复运行。 对象寿命超过阈值时，会晋升至老年代，最大寿命是15(4bit 1111 转为十进制为15) 当老年代空间不足时会先尝试触发minor gc（JDK 6 update 24 之后规定，只要老年代的连续空间大于新时代的对象总大小或者平均晋升大小就会进行minor GC），如果之后空间不足(又有对象从新生代区域升级到老年代)，那么触发Full gc, 那么stop the world会更长，应避免这种操作，如果full gc后老年代空间还不足则 out of memory 3.1为什么要进行分代垃圾回收分代的垃圾回收策略，是基于这样一个事实：不同的对象的生命周期是不一样的。因此，不同生命周期的对象可以采取不同的收集方式，以便提高回收效率。 在Java程序运行的过程中，会产生大量的对象，其中有些对象是与业务信息相关，比如Http请求中的Session对象、线程、Socket连接，这类对象跟业务直接挂钩，因此生命周期比较长。但是还有一些对象，主要是程序运行过程中生成的临时变量，这些对象生命周期会比较短，比如：String对象，由于其不变类的特性，系统会产生大量的这些对象，有些对象甚至只用一次即可回收。 试想，在不进行对象存活时间区分的情况下，每次垃圾回收都是对整个堆空间进行回收，花费时间相对会长，同时，因为每次回收都需要遍历所有存活对象，但实际上，对于生命周期长的对象而言，这种遍历是没有效果的，因为可能进行了很多次遍历，但是他们依旧存在。因此，分代垃圾回收采用分治的思想，进行代的划分，把不同生命周期的对象放在不同代上，不同代上采用最适合它的垃圾回收方式进行回收。 3.2相关JVM参数 堆初始大小 -Xms 堆最大大小 -Xmx 或 -XX:MaxHeapSize=size 新生代大小 -Xmn 或 (-XX:NewSize=size + -XX:MaxNewSize=size ) 幸存区比例（动态） -XX:InitialSurvivorRatio=ratio 和 -XX:+UseAdaptiveSizePolicy 幸存区比例 -XX:SurvivorRatio=ratio 晋升阈值 -XX:MaxTenuringThreshold=threshold 晋升详情 -XX:+PrintTenuringDistribution GC详情 -XX:+PrintGCDetails -verbose:gc FullGC 前 MinorGC -XX:+ScavengeBeforeFullGC (fullgc前是否进行minor gc 默认开启) 3.3GC分析①基本信息123456789101112131415public class T1 {// 模拟512KB对象存储 private static final int _512KB=512*1024;// 模拟1MB private static final int _1MB=1024*1024;// 模拟6MB private static final int _6MB=6*1024*1024;// 模拟7MB private static final int _7MB=7*1024*1024;// 模拟8MB private static final int _8MB=8*1024*1024; //设置虚拟机参数 -Xms20M( 堆初始大小20M) -Xmx20M(堆最大大小20M) -Xmn10M(新生代大小10M) -XX:+UseSerialGC(使用UseSerialGC垃圾回收器保证幸存区大小不会动态调整) -XX:+PrintGCDetails -verbose:gc(打印gc日志) public static void main(String[] args) { }} 123456789101112131415Heap //新生代 总大小为9M，还有1M分配给幸存区To空闲的一块位置 def new generation total 9216K, used 1997K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000) //伊甸园区 已经使用24%(系统启动类) eden space 8192K, 24% used [0x00000000fec00000, 0x00000000fedf37f8, 0x00000000ff400000) //幸存区From from space 1024K, 0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000) //幸存区To to space 1024K, 0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000) //老年代 tenured generation total 10240K, used 0K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000) the space 10240K, 0% used [0x00000000ff600000, 0x00000000ff600000, 0x00000000ff600200, 0x0000000100000000) //元空间 Metaspace used 3093K, capacity 4496K, committed 4864K, reserved 1056768K class space used 335K, capacity 388K, committed 512K, reserved 1048576K ②minor gc 触发第一次GC: 12345public static void main(String[] args) { List&lt;byte[]&gt; list=new ArrayList&lt;&gt;(); list.add(new byte[_7MB]); list.add(new byte[_512KB]); } 12345678910111213141516//首先存入7MB对象时伊甸园区存不下，触发一次minor gc垃圾回收后，512K的对象恰好放到伊甸园区。// 新生代(总大小为9216k)回收前占2001k,回收后占628k 堆(总大小为19456K)回收前占2001k,回收后占628k [GC (Allocation Failure) [DefNew: 2001K-&gt;628K(9216K), 0.0012164 secs] 2001K-&gt;628K(19456K), 0.0012517 secs] //花费时间 0.00[Times: user=0.00 sys=0.00, real=0.00 secs] Heap //此时新生代内存已经非常紧张 def new generation total 9216K, used 8718K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000) //伊甸园区栈已使用98% eden space 8192K, 98% used [0x00000000fec00000, 0x00000000ff3e6840, 0x00000000ff400000) //幸存区From已占用61% from space 1024K, 61% used [0x00000000ff500000, 0x00000000ff59d1b8, 0x00000000ff600000) to space 1024K, 0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000) tenured generation total 10240K, used 0K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000) the space 10240K, 0% used [0x00000000ff600000, 0x00000000ff600000, 0x00000000ff600200, 0x0000000100000000) Metaspace used 3202K, capacity 4496K, committed 4864K, reserved 1056768K class space used 347K, capacity 388K, committed 512K, reserved 1048576K 触发第二次GC: 123456public static void main(String[] args) { List&lt;byte[]&gt; list=new ArrayList&lt;&gt;(); list.add(new byte[_7MB]); list.add(new byte[_512KB]); list.add(new byte[_512KB]); } 123456789101112131415//当存入_7MB触发该次GC,进行垃圾回收，512k恰好放入伊甸园区[GC (Allocation Failure) [DefNew: 2001K-&gt;620K(9216K), 0.0014167 secs] 2001K-&gt;620K(19456K), 0.0014490 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] //当存入第二个512k对象时，触发第二次minor gc[GC (Allocation Failure) [DefNew: 8628K-&gt;517K(9216K), 0.0045477 secs] 8628K-&gt;8284K(19456K), 0.0045761 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] Heap //此时的新生代 只占用1193k def new generation total 9216K, used 1193K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000) eden space 8192K, 8% used [0x00000000fec00000, 0x00000000feca91d8, 0x00000000ff400000) from space 1024K, 50% used [0x00000000ff400000, 0x00000000ff481580, 0x00000000ff500000) to space 1024K, 0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000) //新生代的中的7MB对象晋升到老年代中，当内存非常紧张时，会忽略阈值的限制，直接进入老年代 tenured generation total 10240K, used 7766K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000) the space 10240K, 75% used [0x00000000ff600000, 0x00000000ffd95af8, 0x00000000ffd95c00, 0x0000000100000000) Metaspace used 3216K, capacity 4496K, committed 4864K, reserved 1056768K class space used 349K, capacity 388K, committed 512K, reserved 1048576K ③大对象直接晋升老年代1234public static void main(String[] args) { List&lt;byte[]&gt; list=new ArrayList&lt;&gt;(); list.add(new byte[_8MB]); } 123456789//当我们的对象超过新生代存放的最大大小时，会直接进入老年代。就是你新生代gc再干净，也存不下 def new generation total 9216K, used 2165K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000) eden space 8192K, 26% used [0x00000000fec00000, 0x00000000fee1d620, 0x00000000ff400000) from space 1024K, 0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000) to space 1024K, 0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000) tenured generation total 10240K, used 8192K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000) the space 10240K, 80% used [0x00000000ff600000, 0x00000000ffe00010, 0x00000000ffe00200, 0x0000000100000000) Metaspace used 3215K, capacity 4496K, committed 4864K, reserved 1056768K class space used 349K, capacity 388K, committed 512K, reserved 1048576K ④Full gc12345public static void main(String[] args) { List&lt;byte[]&gt; list=new ArrayList&lt;&gt;(); list.add(new byte[_8MB]); list.add(new byte[_8MB]);} 123456789101112131415//内存溢出前，full gc触发新生代的minor gc垃圾回收[GC (Allocation Failure) [DefNew: 2001K-&gt;649K(9216K), 0.0012435 secs][Tenured: 8192K-&gt;8840K(10240K), 0.0023755 secs] 10193K-&gt;8840K(19456K), [Metaspace: 3209K-&gt;3209K(1056768K)], 0.0036723 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] //触发full gc[Full GC (Allocation Failure) [Tenured: 8840K-&gt;8822K(10240K), 0.0015547 secs] 8840K-&gt;8822K(19456K), [Metaspace: 3209K-&gt;3209K(1056768K)], 0.0015824 secs] [Times: user=0.02 sys=0.00, real=0.00 secs] Heap def new generation total 9216K, used 246K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000) eden space 8192K, 3% used [0x00000000fec00000, 0x00000000fec3d890, 0x00000000ff400000) from space 1024K, 0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000) to space 1024K, 0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000) tenured generation total 10240K, used 8822K [0x00000000ff600000, 0x0000000100000000, 0x0000000100000000) the space 10240K, 86% used [0x00000000ff600000, 0x00000000ffe9d948, 0x00000000ffe9da00, 0x0000000100000000) Metaspace used 3241K, capacity 4496K, committed 4864K, reserved 1056768K class space used 352K, capacity 388K, committed 512K, reserved 1048576KException in thread \"main\" java.lang.OutOfMemoryError: Java heap space at org.lc.jvm_gc.T1.main(T1.java:30) ⑤一个线程中的OOM，不会导致我们主程序结束四、垃圾回收器1、垃圾回收器比较①串行 单线程 堆内存较小，适应个人电脑 ②吞吐量优先 多线程 堆内存较大，多核cpu 让单位时间内，stw的时间最端。 即某一段时间内发生的gc次数少。但是每次耗费的时间多 ③响应时间优先 多线程 堆内存较大 多核cpu 尽可能让单次stw的时间最短 。即某一段时间发生的gc虽然多，但是每次耗费的时间短 2、串行(Serial)①-XX:+UseSerialGC = Serial + SerialOld (包括新生代和老年代的垃圾回收器) 采用新生代：复制算法，老年代：标记整理算法进行垃圾回收。当一个线程进行垃圾的回收，其他的用户线程会阻塞，保证正在进行数据内存整理不受其他线程的干扰 3、吞吐量垃圾回收(Parallel并行)并行收集器。 采用新生代：复制算法，老年代：标记整理算法进行垃圾回收 垃圾回收线程的个数取决于CPU核心数，充分利用CPU的性能。 ①-XX:+UseParallelGC :新生代的垃圾回收器。 -XX:+UseParallelOldGC 老年代的垃圾回收器。 jdk8默认开启的，只要开启一个，另一个自动开启。 ②-XX:+UseAdaptiveSizePolicy :动态调整堆中新生代中区域大小 ③-XX:GCTimeRatio=ratio gc时间比率，一般为 1+(1+ratio) ratio一般为19，即100分钟执行gc时间为2分钟 ④-XX:MaxGCPauseMillis=ms 默认200ms gc最大暂停时间 ⑤-XX:ParallelGCThreads=n 垃圾回收线程的个数 4、响应时间优先(CMS:并发标记清除) 并行（Parallel） ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。 并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。 CMS （Concurrent Mark Sweep）：收集器是一种以获取最短回收停顿时间为目标的收集器。它非常符合在注重用户体验的应用上使用。 CMS（Concurrent Mark Sweep）：收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。 CMS存在的问题：因为采用标记清除的方式清除垃圾，当新生代和老年代内存碎片非常多时，此时会并发gc失败，会退化使用串行的gc方式，使gc执行的时间变得很长 ①-XX:+UseConcMarkSweepGC：老年代的垃圾回收器 ,当该垃圾回收器执行失败时，会退化到执行使用Serial Old串行的收集器 -XX:+UseParNewGC 新生代的垃圾回收器。 ②-XX:ParallelGCThreads=n ： 并行的线程数 -XX:ConcGCThreads=threads：并发的线程数 一般如果cpu总核数为4，那么并行数为3(执行其他用户线程)，并发数为1(执行垃圾回收) ③-XX:CMSInitiatingOccupancyFraction=percent 若percent为80，则代表当老年代内存为80的时候，就出发一次垃圾回收。目的时留下多余的空间给浮动垃圾(并行清理的过程中，其他用户线程留下的垃圾)。percent值越小，触发gc的时间就越早 ④-XX:+CMSScavengeBeforeRemark 在重新标记之前，对新生代做一次垃圾回收 从名字中的Mark Sweep这两个词可以看出，CMS 收集器是一种 “标记-清除”算法实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤： 初始标记(会stw)： 暂停所有的其他线程，并记录下直接与 root 相连的对象，速度很快 ； 并发标记(不会stw)： 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以 GC 线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。 重新标记： 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短 并发清除： 开启用户线程，同时 GC 线程开始对未标记的区域做清扫 1)并发和并行的区别？ 如果某个系统支持两个或者多个动作（Action）同时存在，那么这个系统就是一个并发系统。如果某个系统支持两个或者多个动作同时执行，那么这个系统就是一个并行系统。并发系统与并行系统这两个定义之间的关键差异在于“存在”这个词。 在并发程序中可以同时拥有两个或者多个线程。这意味着，如果程序在单核处理器上运行，那么这两个线程将交替地换入或者换出内存。这些线程是同时“存在”的——每个线程都处于执行过程中的某个状态。如果程序能够并行执行，那么就一定是运行在多核处理器上。此时，程序中的每个线程都将分配到一个独立的处理器核上，因此可以同时运行。 “并行”概念是“并发”概念的一个子集。也就是说，你可以编写一个拥有多个线程或者进程的并发程序，但如果没有多核处理器来执行这个程序，那么就不能以并行方式来运行代码。因此，凡是在求解单个问题时涉及多个执行流程的编程模式或者执行行为，都属于并发编程的范畴。 5、G1 (Garbage-First)收集器 2004 论文发布 2009 JDK 6u14 体验 2012 JDK 7u4 官方支持 2017 JDK 9 默认 适用场景： 同时注重吞吐量（Throughput）和低延迟（Low latency），默认的暂停目标是 200 ms 超大堆内存，会将堆划分为多个大小相等的 Region 整体上是 标记+整理 算法，两个区域之间是 复制 算法 相关 JVM 参数 -XX:+UseG1GC -XX:G1HeapRegionSize=size -XX:MaxGCPauseMillis=time ①G1垃圾回收阶段 1)Young Collection(新生代垃圾回收)会 STW。新创建的对象会放入伊甸园区 进行新生代的垃圾回收后通过复制算法将伊甸园(E)中存活的对象放入幸存区(S) 当幸存区中的对象满了的时候或者幸存区中的对象年龄超过阈值的年龄时，幸存区中对象将会晋升到老年代中(S) 2) Young Collection + CM (新生代垃圾回收+并发标记) 基本步骤 初始标记：在 Young GC 时会进行 GC Root 的初始标记(找到根对象) 并发标记: ** 老年代占用堆空间比例达到阈值时，进行并发标记**（不会 STW） 3)Mixed Collection(混合收集)会对 E(伊甸园区)、S(幸存区)、O(老年代) 进行全面垃圾回收 最终标记（Remark）会 STW 。解决在并发标记中用户线程改变的一些需要回收垃圾对象的引用。 拷贝存活（Evacuation）会 STW。 注意，这里的老年代也会采用复制算法进行清除垃圾，但是不会全部进行复制清除，而是会根据最大暂停时间MaxGCPauseMillis来动态清除需要回收的垃圾。若设定的最大暂停时间够，则执行老年代的全部垃圾清除，否则将根据jvm来自动判断哪些垃圾优先清除获得收益最大。 6、Full GC SerialGC 新生代内存不足发生的垃圾收集 - minor gc 老年代内存不足发生的垃圾收集 - full gc ParallelGC 新生代内存不足发生的垃圾收集 - minor gc 老年代内存不足发生的垃圾收集 - full gc G1,CMS 新生代内存不足发生的垃圾收集 - minor gc 老年代内存不足 当老年代内存占比45%(默认)以上，会触发并发标记和混合收集阶段。如果回收速度 &gt; 用户线程产生垃圾 (还是属于并发标记阶段)。 当回收速度&lt; 用户线程产生垃圾 (退化为串行的收集器，触发full fc) Ⅳ、类加载和字节码技术1.类文件结构 2. 字节码指令 3. 编译期处理 4. 类加载阶段 5. 类加载器 6. 运行期优化 一、类文件结构 根据 Java 虚拟机规范，类文件由单个 ClassFile 结构组成： 123456789101112131415161718ClassFile { u4 magic; //Class 文件的标志 u2 minor_version;//Class 的小版本号 u2 major_version;//Class 的大版本号 u2 constant_pool_count;//常量池的数量 cp_info constant_pool[constant_pool_count-1];//常量池 u2 access_flags;//Class 的访问标记 u2 this_class;//当前类 u2 super_class;//父类 u2 interfaces_count;//接口 u2 interfaces[interfaces_count];//一个类可以实现多个接口 u2 fields_count;//Class 文件的字段属性 field_info fields[fields_count];//一个类会可以有个字段 u2 methods_count;//Class 文件的方法数量 method_info methods[methods_count];//一个类可以有个多个方法 u2 attributes_count;//此类的属性表中的属性数 attribute_info attributes[attributes_count];//属性表集合} 1、魔数2、版本3、常量池常量池中每一项常量都是一个表，这14种表有一个共同的特点：开始的第一位是一个 u1 类型的标志位 -tag 来标识常量的类型，代表当前这个常量属于哪种常量类型． 类型 标志（tag） 描述 CONSTANT_utf8_info 1 UTF-8编码的字符串 CONSTANT_Integer_info 3 整形字面量 CONSTANT_Float_info 4 浮点型字面量 CONSTANT_Long_info ５ 长整型字面量 CONSTANT_Double_info ６ 双精度浮点型字面量 CONSTANT_Class_info ７ 类或接口的符号引用 CONSTANT_String_info ８ 字符串类型字面量 CONSTANT_Fieldref_info ９ 字段的符号引用 CONSTANT_Methodref_info 10 类中方法的符号引用 CONSTANT_InterfaceMethodref_info 11 接口中方法的符号引用 CONSTANT_NameAndType_info 12 字段或方法的符号引用 CONSTANT_MothodType_info 16 标志方法类型 CONSTANT_MethodHandle_info 15 表示方法句柄 CONSTANT_InvokeDynamic_info 18 表示一个动态方法调用点 4、访问标识与继承信息5、Filed信息 6、method信息7、附加信息二、字节码指令1、javap工具自己分析类文件结构太麻烦了，Oracle 提供了 javap 工具来反编译 class 文件 反编译：javap -v 编译后的class文件名称.class java源文件 12345public class T1 { public static void main(String[] args) { System.out.println(\"hello wrold\"); }} class反编译文件 javap -v T1.class 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798Classfile /F:/jvm/jvm_demo/target/classes/org/lc/jvm_class/T1.class //最后修改时间 字节大小 Last modified 2020-6-13; size 543 bytes //md5签名 MD5 checksum 8f97f15345eca913d4885be87c3c3632 //编译哪个原文件 Compiled from \"T1.java\"public class org.lc.jvm_class.T1 minor version: 0 //魔数 代表jdk8 major version: 52 //访问修饰符 flags: ACC_PUBLIC, ACC_SUPER //常量池Constant pool:// 方法引用 引用的位置#6和位置#20 引用的详细信息 #1 = Methodref #6.#20 // java/lang/Object.\"&lt;init&gt;\":()V //字段引用 引用的位置#6和位置#22 引用的详细信息 #2 = Fieldref #21.#22 // java/lang/System.out:Ljava/io/PrintStream; #3 = String #23 // hello wrold #4 = Methodref #24.#25 // java/io/PrintStream.println:(Ljava/lang/String;)V #5 = Class #26 // org/lc/jvm_class/T1 #6 = Class #27 // java/lang/Object #7 = Utf8 &lt;init&gt; #8 = Utf8 ()V #9 = Utf8 Code #10 = Utf8 LineNumberTable #11 = Utf8 LocalVariableTable #12 = Utf8 this #13 = Utf8 Lorg/lc/jvm_class/T1; #14 = Utf8 main #15 = Utf8 ([Ljava/lang/String;)V #16 = Utf8 args #17 = Utf8 [Ljava/lang/String; #18 = Utf8 SourceFile #19 = Utf8 T1.java #20 = NameAndType #7:#8 // \"&lt;init&gt;\":()V #21 = Class #28 // java/lang/System #22 = NameAndType #29:#30 // out:Ljava/io/PrintStream; #23 = Utf8 hello wrold #24 = Class #31 // java/io/PrintStream #25 = NameAndType #32:#33 // println:(Ljava/lang/String;)V #26 = Utf8 org/lc/jvm_class/T1 #27 = Utf8 java/lang/Object #28 = Utf8 java/lang/System #29 = Utf8 out #30 = Utf8 Ljava/io/PrintStream; #31 = Utf8 java/io/PrintStream #32 = Utf8 println #33 = Utf8 (Ljava/lang/String;)V{ //构造方法 public org.lc.jvm_class.T1(); //构造方法的参数信息 descriptor: ()V //访问修饰符 flags: ACC_PUBLIC Code: //最大操作栈的深度 局部变量表的长度 参数的长度 stack=1, locals=1, args_size=1 //把局部变量表的第0项加到操作数栈 0: aload_0 //调用常量池#1 中的方法 1: invokespecial #1 // Method java/lang/Object.\"&lt;init&gt;\":()V //返回 4: return //上面的0 1 4代表字节码中的行号 LineNumberTable: //10代表源java文件中的行号 0代表字节码中的行号 line 10: 0 // //本地变量表 LocalVariableTable: //从字节码的文件start行开始到length的作用范围为5行 变量名为this Start Length Slot Name Signature 0 5 0 this Lorg/lc/jvm_class/T1; //main方法 public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=1, args_size=1 //到常量池中的#2取静态变量System.out 0: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; //加载常量池中的hello world常量 3: ldc #3 // String hello wrold //回调方法PrintStream.println 5: invokevirtual #4 // Method java/io/PrintStream.println:(Ljava/lang/String;)V //返回 8: return LineNumberTable: //源文件中的12行对象 字节码中的第0行 line 12: 0 line 13: 8 LocalVariableTable: Start Length Slot Name Signature 0 9 0 args [Ljava/lang/String;}SourceFile: \"T1.java\" 2、图解方法执行流程1)原始java代码12345678910public class Demo3_1 { public static void main(String[] args) { int a = 10; //当存储的整数小于short的最大范围内，和方法的字节码指令存在一起 //当存储的整数大于short的最大值时，它会存在常量池中 int b = Short.MAX_VALUE + 1; int c = a + b; System.out.println(c); } } 2)编译后的字节码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192 Last modified 2020-6-13; size 602 bytes MD5 checksum 6db3390c8e1a174924ec1bb427f963ed Compiled from \"T2.java\"public class org.lc.jvm_class.T2 minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #7.#25 // java/lang/Object.\"&lt;init&gt;\":()V #2 = Class #26 // java/lang/Short #3 = Integer 32768 #4 = Fieldref #27.#28 // java/lang/System.out:Ljava/io/PrintStream; #5 = Methodref #29.#30 // java/io/PrintStream.println:(I)V #6 = Class #31 // org/lc/jvm_class/T2 #7 = Class #32 // java/lang/Object #8 = Utf8 &lt;init&gt; #9 = Utf8 ()V #10 = Utf8 Code #11 = Utf8 LineNumberTable #12 = Utf8 LocalVariableTable #13 = Utf8 this #14 = Utf8 Lorg/lc/jvm_class/T2; #15 = Utf8 main #16 = Utf8 ([Ljava/lang/String;)V #17 = Utf8 args #18 = Utf8 [Ljava/lang/String; #19 = Utf8 a #20 = Utf8 I #21 = Utf8 b #22 = Utf8 c #23 = Utf8 SourceFile #24 = Utf8 T2.java #25 = NameAndType #8:#9 // \"&lt;init&gt;\":()V #26 = Utf8 java/lang/Short #27 = Class #33 // java/lang/System #28 = NameAndType #34:#35 // out:Ljava/io/PrintStream; #29 = Class #36 // java/io/PrintStream #30 = NameAndType #37:#38 // println:(I)V #31 = Utf8 org/lc/jvm_class/T2 #32 = Utf8 java/lang/Object #33 = Utf8 java/lang/System #34 = Utf8 out #35 = Utf8 Ljava/io/PrintStream; #36 = Utf8 java/io/PrintStream #37 = Utf8 println #38 = Utf8 (I)V{ public org.lc.jvm_class.T2(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.\"&lt;init&gt;\":()V 4: return LineNumberTable: line 10: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lorg/lc/jvm_class/T2; public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=4, args_size=1 0: bipush 10 2: istore_1 3: ldc #3 // int 32768 5: istore_2 6: iload_1 7: iload_2 8: iadd 9: istore_3 10: getstatic #4 // Field java/lang/System.out:Ljava/io/PrintStream; 13: iload_3 14: invokevirtual #5 // Method java/io/PrintStream.println:(I)V 17: return LineNumberTable: line 12: 0 line 15: 3 line 16: 6 line 17: 10 line 18: 17 LocalVariableTable: Start Length Slot Name Signature 0 18 0 args [Ljava/lang/String; 3 15 1 a I 6 12 2 b I 10 8 3 c I}SourceFile: \"T2.java\" 3)常量载入运行时常量池将字节码中的常量池内容载入到运行时常量池中(也是属于方法区) 4)方法字节码载入方法区将字节码中的方法载入方法区 5)main线程开始运行，分配栈帧内存stack=2 操作栈的深度2 locals=4 局部变量表的长度4 6)执行引擎开始执行字节码(1) bipush 10 将一个 byte 压入操作数栈（其长度会补齐 4 个字节），类似的指令还有 sipush 将一个 short 压入操作数栈（其长度会补齐 4 个字节） ldc 将一个 int 压入操作数栈 ldc2_w 将一个 long 压入操作数栈（分两次压入，因为 long 是 8 个字节） 这里小的数字都是和字节码指令存在一起，超过 short 范围的数字存入了常量池 (2) istore_1将操作数栈顶数据弹出，存入局部变量表的 slot 1 这一步相当于 *int a=10; *的操作 (3) ldc #3 从常量池加载 #3 数据到操作数栈 注意 Short.MAX_VALUE 是 32767，所以 32768 = Short.MAX_VALUE + 1 实际是在编译期间计算 好的 (4) istore_2 (5)iload_1 (6)iload_2 (7)iadd (8)istore_3 (9)getstatic #4 (10)iload_3 (11)invokevirtual #5 找到常量池 #5 项 定位到方法区 java/io/PrintStream.println:(I)V 方法 生成新的栈帧（分配 locals、stack等） 传递参数，执行新栈帧中的字节码 执行完毕，弹出栈帧 清除 main 操作数栈内容 (12)return 完成 main 方法调用，弹出 main 栈帧 程序结束 7) i++/++i问题12345678public class T3 { public static void main(String[] args) { int a=10; int b=a++ + ++a + a--; System.out.println(a); System.out.println(b); }} 反编译文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293 Last modified 2020-6-13; size 577 bytes MD5 checksum 27586d3e5e18016da857182af5251ba9 Compiled from \"T3.java\"public class org.lc.jvm_class.T3 minor version: 0 major version: 52 flags: ACC_PUBLIC, ACC_SUPERConstant pool: #1 = Methodref #5.#22 // java/lang/Object.\"&lt;init&gt;\":()V #2 = Fieldref #23.#24 // java/lang/System.out:Ljava/io/PrintStream; #3 = Methodref #25.#26 // java/io/PrintStream.println:(I)V #4 = Class #27 // org/lc/jvm_class/T3 #5 = Class #28 // java/lang/Object #6 = Utf8 &lt;init&gt; #7 = Utf8 ()V #8 = Utf8 Code #9 = Utf8 LineNumberTable #10 = Utf8 LocalVariableTable #11 = Utf8 this #12 = Utf8 Lorg/lc/jvm_class/T3; #13 = Utf8 main #14 = Utf8 ([Ljava/lang/String;)V #15 = Utf8 args #16 = Utf8 [Ljava/lang/String; #17 = Utf8 a #18 = Utf8 I #19 = Utf8 b #20 = Utf8 SourceFile #21 = Utf8 T3.java #22 = NameAndType #6:#7 // \"&lt;init&gt;\":()V #23 = Class #29 // java/lang/System #24 = NameAndType #30:#31 // out:Ljava/io/PrintStream; #25 = Class #32 // java/io/PrintStream #26 = NameAndType #33:#34 // println:(I)V #27 = Utf8 org/lc/jvm_class/T3 #28 = Utf8 java/lang/Object #29 = Utf8 java/lang/System #30 = Utf8 out #31 = Utf8 Ljava/io/PrintStream; #32 = Utf8 java/io/PrintStream #33 = Utf8 println #34 = Utf8 (I)V{ public org.lc.jvm_class.T3(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.\"&lt;init&gt;\":()V 4: return LineNumberTable: line 10: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lorg/lc/jvm_class/T3; public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=3, args_size=1 0: bipush 10 2: istore_1 3: iload_1 4: iinc 1, 1 7: iinc 1, 1 10: iload_1 11: iadd 12: iload_1 13: iinc 1, -1 16: iadd 17: istore_2 18: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 21: iload_1 22: invokevirtual #3 // Method java/io/PrintStream.println:(I)V 25: getstatic #2 // Field java/lang/System.out:Ljava/io/PrintStream; 28: iload_2 29: invokevirtual #3 // Method java/io/PrintStream.println:(I)V 32: return LineNumberTable: line 12: 0 line 13: 3 line 14: 18 line 15: 25 line 16: 32 LocalVariableTable: Start Length Slot Name Signature 0 33 0 args [Ljava/lang/String; 3 30 1 a I 18 15 2 b I}SourceFile: \"T3.java\" 注意: iinc 指令(自增指令)是直接在局部变量 slot 上进行运算 a++ 和 ++a 的区别是先执行 iload (从本地变量表加载)还是 先执行 iinc 【1】首先将10入栈 【2】将10出栈存入局部变量表中的变量a 【3】读取a变量的值加载到栈中 【4】执行a++操作，即在slot槽中完成自增1操作，但是不会影响栈中已经加载的数据。此时的a为11 【5】执行++a的iinc操作，即再次在slot槽中完成自增1操作但是不会影响栈中已经加载的数据。此时的a为12 【6】iload加载局部变量表中a的值并入栈 【7】在栈中完成add加操作 【8】执行a - - 的iload操作完成入栈,此时a为12 【9】执行a– 的iinc的操作完成自减1的操作 ，此时a为11 【10】在栈中完成add累加操作 【11】将34出栈，存入本地变量表中的变量b 8)静态块/静态变量执行流程(类的初始化&lt;cinit&gt;()V )123456789101112131415161718192021public class T4 { static { //静态成员变量的再次声明修改必须在静态块中或者方法中才能修改 i=20; } //先把i放入常量池中，赋值操作还未执行，从上到下依次执行静态块中的赋值操作 static int i=10; static { //静态成员变量的再次声明修改必须在静态块中或者方法中才能修改 i=30; j=10; } //先把j放入常量池中，赋值操作还未执行，从上到下依次执行静态块中的赋值操作 static int j=20; public static void main(String[] args) { //30 System.out.println(i); //20 System.out.println(j); }} 编译器会按从上至下的顺序，收集所有 static 静态代码块和静态成员赋值的代码，合并为一个特殊的方法 &lt;cinit&gt;()V ： 123456789101112131415161718192021222324static {}; descriptor: ()V flags: ACC_STATIC Code: stack=1, locals=0, args_size=0 //20压栈 0: bipush 20 //赋值常量池中的变量i 2: putstatic #3 // Field i:I //10压栈 5: bipush 10 //赋值常量池中变量i 7: putstatic #3 // Field i:I 10: bipush 30 12: putstatic #3 // Field i:I 15: bipush 10 17: putstatic #5 // Field j:I 20: return LineNumberTable: line 12: 0 line 14: 5 line 16: 10 line 17: 15 line 18: 20 &lt;cinit&gt;()V 方法会在类加载的初始化阶段被调用 9)游离块/构造函数执行流程(对象的初始化)123456789101112131415161718192021222324public class T5 { //构造函数中的所有操作，总是在所有成员变量和游离块中的内容依次加载完毕才会执行 public T5(String a, int b) { //最后执行 this.a = a; this.b = b; } //成员变量a的声明先放入常量池中，但赋值操作还未进行,从上到下依次加载成员变量和赋值操作 private String a=\"s1\"; { b=20; } //成员变量a的声明先放入常量池中，但赋值操作还未进行，从上到下依次加载成员变量和赋值操作 private int b=10; { a = \"s2\"; } public static void main(String[] args) { T5 t5 = new T5(\"S3\", 30); System.out.println(t5.a); System.out.println(t5.b); }} 编译器会按从上至下的顺序，收集所有 {} 代码块和成员变量赋值的代码，形成新的构造方法，但原始构 造方法内的代码总是在后 12345678910111213141516171819202122232425262728293031323334353637383940public org.lc.jvm_class.T5(java.lang.String, int); descriptor: (Ljava/lang/String;I)V flags: ACC_PUBLIC Code: stack=2, locals=3, args_size=3 0: aload_0 1: invokespecial #1 // Method java/lang/Object.\"&lt;init&gt;\":()V 4: aload_0 5: ldc #2 // String s1 7: putfield #3 // Field a:Ljava/lang/String; 10: aload_0 11: bipush 20 13: putfield #4 // Field b:I 16: aload_0 17: bipush 10 19: putfield #4 // Field b:I 22: aload_0 23: ldc #5 // String s2 25: putfield #3 // Field a:Ljava/lang/String; 28: aload_0 29: aload_1 30: putfield #3 // Field a:Ljava/lang/String; 33: aload_0 34: iload_2 35: putfield #4 // Field b:I 38: return LineNumberTable: line 20: 0 line 11: 4 line 13: 10 line 15: 16 line 17: 22 line 21: 28 line 22: 33 line 23: 38 LocalVariableTable: Start Length Slot Name Signature 0 39 0 this Lorg/lc/jvm_class/T5; 0 39 1 a Ljava/lang/String; 0 39 2 b I 10)不同方法的调用123456789101112131415public class T6 { public T6() { } private void test1() { } private final void test2() { } public void test3(){} public static void test4(){} public static void main(String[] args) { T6 t6=new T6(); t6.test1(); t6.test2(); t6.test3();// 类名直接调用 T6.test4(); }} 1234567891011121314151617181920212223242526272829303132333435public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=2, args_size=1 //new一个对象在堆中。 在操作数栈中分配一块引用 0: new #2 // class org/lc/jvm_class/T6 //将栈中的对象的引用赋值一份调用此构造方法，然后出栈释放 3: dup //构造方法唯一确定 4: invokespecial #3 // Method \"&lt;init&gt;\":()V 7: astore_1 8: aload_1 //private私有方法唯一确定，不能被继承，即直接能够直接从类中找到该方法 9: invokespecial #4 // Method test1:()V 12: aload_1 //final方法唯一确定，即不能被覆盖，即直接能够直接从类中找到该方法 13: invokespecial #5 // Method test2:()V 16: aload_1 //public公共方法不能确定，可能被其他类重写，在编译期间不能确定。 17: invokevirtual #6 // Method test3:()V //static静态方法，直接通过类名调用。 20: invokestatic #7 // Method test4:()V 23: return LineNumberTable: line 17: 0 line 18: 8 line 19: 12 line 20: 16 line 22: 20 line 23: 23 LocalVariableTable: Start Length Slot Name Signature 0 24 0 args [Ljava/lang/String; 8 16 1 t6 Lorg/lc/jvm_class/T6; invokespecial，invokestatic属于静态绑定，即在编译期间就能确定其唯一性。 invokevirtual 属于动态绑定，需要在运行时才能确定其唯一性。 11)synchronized字节码分析12345678public class T8 { public static void main(String[] args) { Object lock=new Object(); synchronized (lock) { System.out.println(\"ok\"); } }} 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667{ public org.lc.jvm_class.T8(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.\"&lt;init&gt;\":()V 4: return LineNumberTable: line 10: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lorg/lc/jvm_class/T8; public static void main(java.lang.String[]); descriptor: ([Ljava/lang/String;)V flags: ACC_PUBLIC, ACC_STATIC Code: stack=2, locals=4, args_size=1 //new一份对象放入堆中，将地址引用放入操作数栈中 0: new #2 // class java/lang/Object //赋值一份该对象的在栈中的引用，这个引用将调用构造方法 3: dup 4: invokespecial #1 // Method java/lang/Object.\"&lt;init&gt;\":()V //将对象赋给lock变量 Object lock=new Object(); 7: astore_1 //将对象引用加载到操作数栈 8: aload_1 //赋值一份锁对象，分别对应一份加锁一份解锁用 9: dup 10: astore_2 //这里赋值的对象加到一个本地变量表中的匿名参数中astrore_2上 11: monitorenter 12: getstatic #3 // Field java/lang/System.out:Ljava/io/PrintStream; 15: ldc #4 // String ok 17: invokevirtual #5 // Method java/io/PrintStream.println:(Ljava/lang/String;)V 20: aload_2 21: monitorexit 22: goto 30 25: astore_3 26: aload_2 27: monitorexit 28: aload_3 29: athrow 30: return Exception table: from to target type 12 22 25 any 25 28 25 any LineNumberTable: line 12: 0 line 13: 8 line 14: 12 line 15: 20 line 16: 30 LocalVariableTable: Start Length Slot Name Signature 0 31 0 args [Ljava/lang/String; 8 23 1 lock Ljava/lang/Object; StackMapTable: number_of_entries = 2 frame_type = 255 /* full_frame */ offset_delta = 25 locals = [ class \"[Ljava/lang/String;\", class java/lang/Object, class java/lang/Object ] stack = [ class java/lang/Throwable ] frame_type = 250 /* chop */ offset_delta = 4} 三、编译器处理所谓的 *语法糖 *其实就是指 java 编译器把 *.java 源码编译为 *.class 字节码的过程中，自动生成 和转换的一些代码，主要是为了减轻程序员的负担，算是 java 编译器给我们的一个额外福利（给糖吃 嘛）注意，以下代码的分析，借助了 javap 工具，idea 的反编译功能，idea 插件 jclasslib 等工具。另外， 编译器转换的结果直接就是 class 字节码，只是为了便于阅读，给出了 几乎等价 的 java 源码方式，并 不是编译器还会转换出中间的 java 源码，切记 1、默认构造函数12public class T1 {} 伪字节码： 123456789package org.lc.jvm_compiler;public class T1 { // 这个无参构造是编译器帮助我们加上的 public T1() { // 即调用父类 Object 的无参构造方法，即调用 java/lang/Object.\" &lt;init&gt;\":()V super(); }} 2、自动拆装箱包装类.valueOf(值); //装箱 包装类实例对象.intValue(); //拆箱 这个特性是 JDK 5 开始加入的， 代码片段1 ： 123456public class T1 { public static void main(String[] args) { Integer x=1; int y=x; }} 这段代码在 JDK 5 之前是无法编译通过的，必须改写为 代码片段2 : 123456public class T1 { public static void main(String[] args) { Integer x=Integer.valueOf(1); int y=x.intValue(); }} 3、泛型集合取值泛型也是在 JDK 5 开始加入的特性，但 java 在编译泛型代码后会执行 泛型擦除 的动作，即泛型信息 在编译为字节码之后就丢失了，实际的类型都当做了 Object 类型来处理： 1234567public class T1 { public static void main(String[] args) { List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); list.add(10); // 实际调用的是 List.add(Object e) Integer x = list.get(0); // 实际调用的是 Object obj = List.get(int index); }} 所以在取值时，编译器真正生成的字节码中，还要额外做一个类型转换的操作： 12// 需要将 Object 转为 Integer Integer x = (Integer)list.get(0); 如果前面的 x 变量类型修改为 int 基本类型那么终生成的字节码是： 12// 需要将 Object 转为 Integer, 并执行拆箱操作 int x = ((Integer)list.get(0)).intValue(); 4、可变参数可变参数也是 JDK 5 开始加入的新特性： 例如： 1234567891011public class T2 { public static void main(String[] args) { foo(\"hello\",\"world\"); } public static void foo(String... args) {// 直接赋值 String[] array=args; System.out.println(array); }} 可变参数 String… args 其实是一个 String[] args ，从代码中的赋值语句中就可以看出来。 同 样 java 编译器会在编译期间将上述代码变换为： 1234567891011public class T2 { public static void main(String[] args) { foo(new String[]{\"hello\",\"world\"}); } public static void foo(String[] args) {// 直接赋值 String[] array=args; System.out.println(array); }} 注意 : 如果调用了 foo() 则等价代码为 foo(new String[]{}) ，创建了一个空的数组，而不会 传递 null 进去 5、foreach循环 数组的循环 仍是 JDK 5 开始引入的语法糖，数组的循环： 123456789public class T3 { public static void main(String[] args) {// 数组的初始化赋值操作 int[] array = {1, 2, 3, 4, 5, 6}; for (int arr : array) { System.out.println(arr); } }} 12345678public class T3 { public static void main(String[] args) { int[] array = new int[]{1, 2, 3, 4, 5, 6}; for (int i = 0; i &lt; array.length; i++) { System.out.println(array[i]); } }} 集合的循环 12345678public class T3 { public static void main(String[] args) { List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6); for (Integer i : list) { System.out.println(i); } }} 实际被编译器转换为对迭代器的调用： 123456789public static void main(String[] args) { List&lt;Integer&gt; list = Arrays.asList(1, 2, 3, 4, 5, 6); Iterator var2 = list.iterator(); while(var2.hasNext()) { Integer i = (Integer)var2.next(); System.out.println(i); } } 注意: foreach 循环写法，能够配合数组，以及所有实现了 Iterable 接口的集合类一起使用，其 中 Iterable 用来获取集合的迭代器（ Iterator) 6、switch字符串枚举允许的类型： 基本数据类型：byte, short, char, int 包装数据类型：Byte, Short, Character, Integer 枚举类型：Enum Jdk 7+（JDK1.7之后） 开始支持 字符串类型：String（Jdk 7+（JDK1.7之后） 开始支持 不支持boolean和double，float，long型 12345678910public static void choose(String str) { switch (str) { case \"hello\": System.out.println(\"h\"); break; case \"world\": System.out.println(\"w\"); break; } } 注意 switch 配合 String 和枚举使用时，变量不能为null，原因分析完语法糖转换后的代码应当自 然清楚 字节码： 12345678910111213141516171819202122232425public static void choose(String str) { byte var2 = -1; //其实是将字符串转换为hashcode 即为字符串和枚举时不能为空 switch(str.hashCode()) { //case的变量在编译的时候已经确定 case 99162322: if (str.equals(\"hello\")) { var2 = 0; } break; case 113318802: if (str.equals(\"world\")) { var2 = 1; } } switch(var2) { case 0: System.out.println(\"h\"); break; case 1: System.out.println(\"w\"); } } 可以看到，执行了两遍 switch，第一遍是根据字符串的 hashCode 和 equals 将字符串的转换为相应 byte 类型，第二遍才是利用 byte 执行进行比较。 为什么第一遍时必须既比较 hashCode，又利用 equals 比较呢？hashCode 是为了提高效率，减少可 能的比较；而 equals 是为了防止 hashCode 冲突，例如 BM 和 C. 这两个字符串的hashCode值都是 2123 ，如果有如下代码： 12345678910public static void choose(String str) { switch (str) { case \"BM\": System.out.println(\"h\"); break; case \"C.\": System.out.println(\"w\"); break; } } 字节码 12345678910111213141516171819202122public static void choose(String str) { byte var2 = -1; switch(str.hashCode()) { //hash碰撞 case 2123: //hash碰撞后再采用equals进行值的比较，提高效率。这样做和hashmap类似 if (str.equals(\"C.\")) { var2 = 1; } else if (str.equals(\"BM\")) { var2 = 0; } default: switch(var2) { case 0: System.out.println(\"h\"); break; case 1: System.out.println(\"w\"); } } } 7、switch枚举12345678910111213141516171819public class T4 { public static void main(String[] args) { } public static void choose(Sex sex) { switch (sex) { case MALE: System.out.println(\"男\"); break; case FEMALE: System.out.println(\"女\"); break; } }}enum Sex{ MALE, FEMALE} 8、枚举类JDK 7 新增了枚举类，以前面的性别枚举为例： 1234enum Sex { MALE, FEMALE } 转换后代码： 9、try-with-resourcesJDK 7 开始新增了对需要关闭的资源处理的特殊语法 try-with-resources： 12345try(资源变量 = 创建资源对象){ } catch( ) { } 其中资源对象需要实现 AutoCloseable 接口，例如 InputStream 、 OutputStream 、 Connection 、 Statement 、 ResultSet 等接口都实现了 AutoCloseable ，使用 try-withresources 可以不用写 finally 语句块，编译器会帮助生成关闭资源代码，例如： 1234567public static void main(String[] args) { try (InputStream is = new FileInputStream(\"d:/1.txt\")) { System.out.println(is); } catch (IOException e) { e.printStackTrace(); } } 编译后的代码： 12345678910111213141516171819202122232425262728293031323334public static void main(String[] args) { try { InputStream is = new FileInputStream(\"d:/1.txt\"); Throwable var2 = null; try { System.out.println(is); } catch (Throwable var12) { //var2是我们代码出现的异常 var2 = var12; throw var12; } finally { //判断资源不为空 if (is != null) { //如果我们代码有异常 if (var2 != null) { try { is.close(); } catch (Throwable var11) { // 如果 close 出现异常，作为被压制异常添加 var2.addSuppressed(var11); } } else { // 如果我们代码没有异常，close 出现的异常就是后 catch 块中的 e is.close(); } } } } catch (IOException var14) { var14.printStackTrace(); } } 为什么要设计一个 addSuppressed(Throwable e) （添加被压制异常）的方法呢？是为了防止异常信 息的丢失（想想 try-with-resources 生成的 ﬁanlly 中如果抛出了异常）： 1234567891011121314151617public class T5 { public static void main(String[] args) { try (MyResouce myResouce=new MyResouce()){ int i=1/0; } catch (Exception e) { //执行的代码异常 e.printStackTrace(); } }}class MyResouce implements AutoCloseable{ @Override public void close() throws Exception { //关闭时的异常 throw new Exception(\"close异常\"); }} 执行的代码和关闭时的异常都能捕获到。 12345java.lang.ArithmeticException: / by zero at org.lc.jvm_compiler.T5.main(T5.java:20) Suppressed: java.lang.Exception: close异常 at org.lc.jvm_compiler.MyResouce.close(T5.java:30) at org.lc.jvm_compiler.T5.main(T5.java:21) 10、方法重写时的桥接我们都知道，方法重写时对返回值分两种情况： 父子类的返回值完全一致 子类返回值可以是父类返回值的子类（比较绕口，见下面的例子） 对于子类，java 编译器会做如下处理： 其中桥接方法比较特殊，仅对 java 虚拟机可见，并且与原来的 public Integer m() 没有命名冲突，可以 用下面反射代码来验证 123for (Method m : B.class.getDeclaredMethods()) { System.out.println(m); } 会输出： 12public java.lang.Integer test.candy.B.m()public java.lang.Number test.candy.B.m() 11、匿名内部类12345678910public class T7 { public static void main(String[] args) { Runnable runnable=new Runnable() { @Override public void run() { System.out.println(\"ok\"); } }; }} 转换之后的代码： 1234567// 额外生成的类 final class Candy11$1 implements Runnable { Candy11$1() { } public void run() { System.out.println(\"ok\"); } } 12345public class T7 { public static void main(String[] args) { Runnable runnable=new Candy11$1(); }} 引用局部变量的匿名内部类 转换后代码： 12345public class T7 { public static void test(final int x) { Runnable runnable=new Candy11$1(x); }} 为了保证一致性，即局部变量中的值在匿名内部类中使用始终不变，即在局部变量上加final 四、类加载阶段1、加载 将类的字节码载入方法区中，内部采用 C++ 的 instanceKlass 描述 java 类，它的重要 ﬁeld 有： _java_mirror 即 java 的类镜像，例如对 String 来说，就是 String.class，作用是把 klass 暴 露给 java 使用 _super 即父类 _ﬁelds 即成员变量 _methods 即方法 _constants 即常量池 _class_loader 即类加载器 _vtable 虚方法表 _itable 接口方法表 如果这个类还有父类没有加载，先加载父类 加载和链接可能是交替运行的 注意: instanceKlass 这样的【元数据】是存储在方法区（1.8 后的元空间内），但 _java_mirror 是存储在堆中 可以通过前面介绍的 HSDB 工具查看 2、链接①验证验证类是否符合 JVM规范，安全性检查 用 UE 等支持二进制的编辑器修改 HelloWorld.class 的魔数，在控制台运行 ②准备为 static 变量分配空间，设置默认值 static 变量在 JDK 7 之前存储于 instanceKlass 末尾(方法区元空间)，从 JDK 7 开始，存储于 _java_mirror 末尾(堆) static 变量分配空间和赋值是两个步骤，分配空间在准备阶段完成，赋值在初始化阶段完成 如果 static 变量是 ﬁnal 的基本类型，以及字符串常量，那么编译阶段值就确定了，赋值在准备阶 段完成 如果 static 变量是 ﬁnal 的，但属于引用类型，那么赋值也会在初始化阶段完成 12345678910111213public class T8 { //静态成员是在准备阶段做分配空间的操作(和赋初始值)，并未赋值 static int a; //静态成员是在准备阶段做分配空间的操作，在类的构造(&lt;cinit()V&gt;)时候即初始化阶段赋值 static int b=10; //静态final成员，若为基本类型(包括String)。在准备阶段即完成赋值操作， static final int c=20; //静态final成员在准备阶段即完成赋值操作 static final String d = \"hello\"; //静态final成员，若为引用类型(String除外)，赋值阶段是在类的构造(&lt;cinit()V&gt;)进行的即初始化阶段 static final Object e=new Object();} 字节码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556{ static int a; descriptor: I flags: ACC_STATIC static int b; descriptor: I flags: ACC_STATIC static final int c; descriptor: I flags: ACC_STATIC, ACC_FINAL ConstantValue: int 20 static final java.lang.String d; descriptor: Ljava/lang/String; flags: ACC_STATIC, ACC_FINAL ConstantValue: String hello static final java.lang.Object e; descriptor: Ljava/lang/Object; flags: ACC_STATIC, ACC_FINAL //构造方法 public org.lc.jvm_compiler.T8(); descriptor: ()V flags: ACC_PUBLIC Code: stack=1, locals=1, args_size=1 0: aload_0 1: invokespecial #1 // Method java/lang/Object.\"&lt;init&gt;\":()V 4: return LineNumberTable: line 10: 0 LocalVariableTable: Start Length Slot Name Signature 0 5 0 this Lorg/lc/jvm_compiler/T8; //类的构造 static {}; descriptor: ()V flags: ACC_STATIC Code: stack=2, locals=0, args_size=0 0: bipush 10 2: putstatic #2 // Field b:I 5: new #3 // class java/lang/Object 8: dup 9: invokespecial #1 // Method java/lang/Object.\"&lt;init&gt;\":()V 12: putstatic #4 // Field e:Ljava/lang/Object; 15: return LineNumberTable: line 14: 0 line 19: 5}SourceFile: \"T8.java\" ③解析将常量池中的符号引用解析为直接引用。我们将字节码的方法字段等信息加载到方法区，未解析之前这些只是一些未知的符号，当经过解析之后，将把符号和内存中的位置(地址)相关联。 3、初始化&lt;cinit&gt;()v方法 初始化即调用&lt;cinit&gt;()v,虚拟机会保证这个类的『构造方法』的线程安全 发生的时机： 会发生初始化 概括得说，类初始化是【懒惰的】 main 方法所在的类，总会被首先初始化 首次访问这个类的静态变量或静态方法时 子类初始化，如果父类还没初始化，会引发 父类的初始化 子类访问父类的静态变量，只会触发父类的初始化 Class.forName 默认会造成类的初始化 new 会导致初始化 调用静态方法会触发类的初始化，若父类未初始化，则会优先触发父类的初始化。若子类调用父类的静态方法则，只会触发父类的初始化 不会发生初始化 访问类的 static ﬁnal 静态常量（基本类型和字符串）不会触发初始化。在链接的准备阶段即完成赋值操作。 类对象.class 不会触发初始化 。 在类加载的时候就会加载此Class (_java_mirror 即 java 的类镜像) 创建该类的数组不会触发初始化 调用类加载器的loadClass方法 Class.forName的第二个参数为false。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class A{ static int a=0; static { System.out.println(\"a init\"); }}class B extends A{ final static double b=5.0; static boolean c=false; static { System.out.println(\"b init\"); }}public class T1 { // 若类初始化 则会执行static中的内容 static { System.out.println(\"main init\"); } //有main方法所在的类会初始化 public static void main(String[] args) throws ClassNotFoundException {// ***************************不会初始化的情况***********************************// 1、静态常量(基本类型和字符串)不会触发初始化// System.out.println(B.b);// 2、类.class不会触发初始化(加载阶段已经创建好class)// System.out.println(B.class);// 3、创建该类的数组不会触发初始化// System.out.println(new B[0]);// 4、不会初始化A,B 但是会加载A,B// ClassLoader c1= Thread.currentThread().getContextClassLoader();// c1.loadClass(\"org.lc.jvm_classloader.B\");// 5、不会初始化A,B 但是会加载A,B// ClassLoader c2=Thread.currentThread().getContextClassLoader();// 不初始化:参数设为false// Class.forName(\"org.lc.jvm_classloader.B\", false, c2); // ***************************会初始化的情况***********************************// 1、首次访问这个类的静态变量或静态方法时。初始化A// System.out.println(A.a);// 2、子类初始化，如果父类还没有初始化，会引发父类的初始化。初始化A,B。父类优先初始化// System.out.println(B.c);// 3、子类访问父类的静态变量，只触发父类的初始化，初始化A// System.out.println(B.a);// 4、会初始A,B. 优先初始化父类A// Class.forName(\"org.lc.jvm_classloader.B\");// 从源码 默认初始化参数为true// return forName0(className, true, ClassLoader.getClassLoader(caller), caller); }} *4、练习12345678910111213141516171819public class T2 { public static void main(String[] args) {// 不会初始化 System.out.println(E.a);// 不会初始化 System.out.println(E.b); //会初始化 System.out.println(E.c); }}class E { static { System.out.println(\"E init\"); } public static final int a = 10; public static final String b = \"hello\"; //会初始化 因为jvm在编译期间自动帮我们对20进行装箱的操作 public static final Integer c = 20; //Integer.valueOf(20);} 安全的单例模式： 1234567891011121314public class Singleton { private Singleton(){ } //静态内部类可以访问外部类的成员 private static class LazyHolder{ static final Singleton INSTANCE=new Singleton(); }// 第一次调用 getInstance 方法，才会导致内部类加载和初始化其静态成员 public static Singleton getInstance() { return LazyHolder.INSTANCE; }} *5、静态成员存储位置​ 在JDK8之前，静态成员（静态变量和静态方法）都是存储在方法区（永久代）中的静态区中（这里指类被加载后，静态成员的存储位置）。但在JDK8之后，永久代被移除了，取而代之的是元空间（metaspace）。但元空间中存储的主要是.class文件的元数据信息，静态成员的存储位置由方法区转到了堆内存（heap）中。​ 不过，不管是JDK8，还是更早的版本中，静态方法的执行（不仅仅是静态方法，还有普通的成员方法）都是在栈内存（stack）中进行的。每个线程都会在栈内存中开辟一个栈，在调用方法时，对应的方法都会在执行这个方法的线程的栈中创建一个“栈帧”，栈帧中保存了局部变量表（基本数据类型和对象引用）、操作数栈、动态连接和返回地址等信息。等到方法执行完毕，栈帧被销毁，对应的内存也将被释放 五、类加载器1、类加载器分类以jdk8为例： 名称 加载哪的类 说明 Bootstrap ClassLoader(启动类加载器) JAVA_HOME/jre/lib 无法直接访问 Extension ClassLoader(扩展类加载器) JAVA_HOME/jre/lib/ext 上级为 Bootstrap，显示为 null Application ClassLoader(应用程序加载器) classpath(我们应用程序启动的路径) 上级为 Extension 自定义类加载器 自定义 上级为 Application Bootstrap ClassLoader启动类加载器由c++实现。其余的加载器均由java实现且全部继承自java.lang.ClassLoader 123456789101112131415161718public class T3 { public static void main(String[] args) throws ClassNotFoundException { //1、使用 Class类获取该类的ClassLoader对象。 获取该类的类加载器 //null 说明为启动类加载器 System.out.println(String.class.getClassLoader()); //2、使用 ClassLoader类加载器对象的getParent()获取该类的上一级加载器 //sun.misc.Launcher$ExtClassLoader@135fbaa4 说明为本级为应用程序类加载器。上一级为扩展类加载器 System.out.println(T1.class.getClassLoader().getParent()); //3、上述方式1,2不会触发类的初始化 //通过Class.forName会触发类的初始化 Class&lt;?&gt; aClass = Class.forName(\"org.lc.jvm_classloader.T1\"); //sun.misc.Launcher$AppClassLoader@18b4aac2 说明为应用程序类加载器 System.out.println(aClass.getClassLoader()); }} 2、双亲委派模式所谓的双亲委派，就是指调用类加载器的 loadClass 方法时，查找类的规则 默认通过ClassLoader加载指定类走的是双亲委派机制 123456public class T3 { public static void main(String[] args) throws ClassNotFoundException { ClassLoader classLoader = T3.class.getClassLoader(); System.out.println(classLoader.loadClass(\"org.lc.jvm_classloader.T1\").getClassLoader()); }} 源码分析 1234567891011121314151617181920212223242526272829303132333435363738394041424344protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException { synchronized (getClassLoadingLock(name)) { // First, check if the class has already been loaded //1、首先检查本类的类加载器是否已经加载该类，首次肯定没有。 Class&lt;?&gt; c = findLoadedClass(name); if (c == null) { long t0 = System.nanoTime(); try { //2、如果本类的上级类加载器不为空 if (parent != null) { //3、使用上级的类加载器查找该类是否加载。采用递归的方式继续向上级查找 c = parent.loadClass(name, false); } else { //4、直到上级为空即为BootstrapClassloader时，然后调用 c = findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { //类没找到抛出异常 // ClassNotFoundException thrown if class not found // from the non-null parent class loader } if (c == null) { // If still not found, then invoke findClass in order // to find the class. //当递归到BootstrapClassloader加载器时，会分别使用各自的加载器向下递归加载类，若找到则返回，否则抛出的异常ClassNotFoundException被下一级类加载器捕获 long t1 = System.nanoTime(); //使用各自的类加载器加载该类 c = findClass(name); // this is the defining class loader; record the stats sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0); sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1); sun.misc.PerfCounter.getFindClasses().increment(); } } if (resolve) { resolveClass(c); } return c; } } 就上述例子执行流程 1、首先使用本类的加载器(应用程序类加载器)查看要加载的类T1是否被加载，首次应该没用被加载。 2、然后会使用本类的上一级加载器(扩展类加载器)查看T1类是否被加载(parent.loadClass(name, false))，此时开始递归调用，直到递归到parent为null即到启动类加载器的时候，查看T1类是否被加载，若没有则开始使用启动类加载器加载此类，若找不到此类，则抛出异常，该异常有下一级类加载器捕获。从上到下依次使用各自的类加载器加载此类。直达加载到此类返回，或者抛出异常ClassNotFoundException。 3、从本级的类加载器开始向上级类加载器寻找要加载的类是否已经被加载，直到递归到顶级类加载器(BootStrapClassloader)时，若还未发现要加载的类没有被加载，则开始使用各自的类加载器加载要加载的类(findClass(name))，从上级往下级依次使用类加载器加载。知道找到类或抛出异常 双亲委派的作用： 防止重复加载同一个.class。通过委托去向上面问一问，加载过了，就不用再加载一遍。保证数据安全。 保证核心.class不能被篡改。通过委托方式，不会去篡改核心.class，即使篡改也不会去加载，即使加载也不会是同一个.class对象了。不同的加载器加载同一个.class也不是同一个Class对象。这样保证了Class执行安全。 3、线程上下文类加载器我们在使用 JDBC 时，都需要加载 Driver 驱动，不知道你注意到没有，不写 1Class.forName(\"com.mysql.jdbc.Driver\") 也是可以让 com.mysql.jdbc.Driver 正确加载的，你知道是怎么做的吗？ 让我们追踪一下源码: 123456789public class DriverManager { // 注册驱动的集合 private final static CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers= new CopyOnWriteArrayList&lt;&gt;(); // 初始化驱动 static { loadInitialDrivers(); println(\"JDBC DriverManager initialized\"); }} 先不看别的，看看 DriverManager 的类加载器： 1System.out.println(DriverManager.class.getClassLoader()); 打印 null，表示它的类加载器是 Bootstrap ClassLoader，会到 JAVA_HOME/jre/lib 下搜索类，但 JAVA_HOME/jre/lib 下显然没有 mysql-connector-java-5.1.47.jar 包，这样问题来了，在 DriverManager 的静态代码块中，怎么能正确加载 com.mysql.jdbc.Driver 呢？ 这里其实是打破双亲委派模式的规则，因为我们发现DriverManager 的类加载器为启动类加载器，但是启动类加载器中并没有类文件，所以无法找到 1)使用ServiceLoader机制加载启动 即SPI Thread.currentThread().getContextClassLoader(); 获取的还是启动类加载器 12345public static &lt;S&gt; ServiceLoader&lt;S&gt; load(Class&lt;S&gt; service) { //默认把应用程序类加载器赋值给当前线程。当前线程获取的时候拿到的即为应用程序类加载器 ClassLoader cl = Thread.currentThread().getContextClassLoader(); return ServiceLoader.load(service, cl); } 12345678910ServiceLoader&lt;Driver&gt; loadedDrivers = ServiceLoader.load(Driver.class); Iterator&lt;Driver&gt; driversIterator = loadedDrivers.iterator(); try{ while(driversIterator.hasNext()) { driversIterator.next(); } } catch(Throwable t) { // Do nothing } return null; 2)使用 jdbc.drivers 定义的驱动名加载驱动 我们从源码发现，其实内部还是调用的一个 ClassLoader.getSystemClassLoader() 获得的是应用程序类加载器加载Dirver驱动 123456789101112131415if (drivers == null || drivers.equals(\"\")) { return; } String[] driversList = drivers.split(\":\"); println(\"number of Drivers:\" + driversList.length); for (String aDriver : driversList) { try { println(\"DriverManager.Initialize: loading \" + aDriver); //使用ClassLoader.getSystemClassLoader()获得应用程序类加载器加载驱动 Class.forName(aDriver, true, ClassLoader.getSystemClassLoader()); } catch (Exception ex) { println(\"DriverManager.Initialize: load failed: \" + ex); } } 4、自定义类加载器 什么时候需要自定义类加载器 1）想加载非 classpath 随意路径中的类文件 2）都是通过接口来使用实现，希望解耦时，常用在框架设计 3）这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于 tomcat 容器 步骤： 继承 ClassLoader 父类 要遵从双亲委派机制，重写 ﬁndClass 方法 注意不是重写 loadClass 方法，否则不会走双亲委派机制 读取类文件的字节码 调用父类的 deﬁneClass 方法来加载类 使用者调用该类加载器的 loadClass 方法 注意：认定是同一个类的条件是：类加载器相同，名称相同，命名空间相同。 使用不同的类加载器加载的类不同","link":"/2020/06/17/jvm/JVM/"}],"tags":[{"name":"多数据源","slug":"多数据源","link":"/tags/%E5%A4%9A%E6%95%B0%E6%8D%AE%E6%BA%90/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"ActiveMQ","slug":"ActiveMQ","link":"/tags/ActiveMQ/"},{"name":"消息服务","slug":"消息服务","link":"/tags/%E6%B6%88%E6%81%AF%E6%9C%8D%E5%8A%A1/"},{"name":"MongoDB","slug":"MongoDB","link":"/tags/MongoDB/"},{"name":"Maven","slug":"Maven","link":"/tags/Maven/"},{"name":"Spring Boot","slug":"Spring-Boot","link":"/tags/Spring-Boot/"},{"name":"Session","slug":"Session","link":"/tags/Session/"},{"name":"Redis","slug":"Redis","link":"/tags/Redis/"},{"name":"IDEA","slug":"IDEA","link":"/tags/IDEA/"},{"name":"SpringBoot","slug":"SpringBoot","link":"/tags/SpringBoot/"},{"name":"Spring Security","slug":"Spring-Security","link":"/tags/Spring-Security/"},{"name":"RESTful","slug":"RESTful","link":"/tags/RESTful/"},{"name":"Shiro","slug":"Shiro","link":"/tags/Shiro/"},{"name":"WebSocket","slug":"WebSocket","link":"/tags/WebSocket/"},{"name":"Nginx","slug":"Nginx","link":"/tags/Nginx/"},{"name":"JAR","slug":"JAR","link":"/tags/JAR/"},{"name":"WAR","slug":"WAR","link":"/tags/WAR/"},{"name":"Swagger2","slug":"Swagger2","link":"/tags/Swagger2/"},{"name":"OAuth2","slug":"OAuth2","link":"/tags/OAuth2/"},{"name":"JWT","slug":"JWT","link":"/tags/JWT/"},{"name":"Quartz","slug":"Quartz","link":"/tags/Quartz/"},{"name":"定时任务","slug":"定时任务","link":"/tags/%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/"},{"name":"Ehcache","slug":"Ehcache","link":"/tags/Ehcache/"},{"name":"RabbitMQ","slug":"RabbitMQ","link":"/tags/RabbitMQ/"},{"name":"FastDFS","slug":"FastDFS","link":"/tags/FastDFS/"},{"name":"邮件服务","slug":"邮件服务","link":"/tags/%E9%82%AE%E4%BB%B6%E6%9C%8D%E5%8A%A1/"},{"name":"Docker","slug":"Docker","link":"/tags/Docker/"},{"name":"MySql","slug":"MySql","link":"/tags/MySql/"},{"name":"多线程","slug":"多线程","link":"/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"},{"name":"JVM","slug":"JVM","link":"/tags/JVM/"}],"categories":[{"name":"Spring Boot","slug":"Spring-Boot","link":"/categories/Spring-Boot/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"项目构建部署","slug":"项目构建部署","link":"/categories/%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E9%83%A8%E7%BD%B2/"},{"name":"Redis","slug":"Redis","link":"/categories/Redis/"},{"name":"IDEA","slug":"IDEA","link":"/categories/IDEA/"},{"name":"SpringBoot","slug":"SpringBoot","link":"/categories/SpringBoot/"},{"name":"Spring Security","slug":"Spring-Security","link":"/categories/Spring-Security/"},{"name":"Windows","slug":"Windows","link":"/categories/Windows/"},{"name":"Nginx","slug":"Nginx","link":"/categories/Nginx/"},{"name":"Spring Cache","slug":"Spring-Cache","link":"/categories/Spring-Cache/"},{"name":"Linux","slug":"Linux","link":"/categories/Linux/"},{"name":"数据库","slug":"数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"并发编程","slug":"并发编程","link":"/categories/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"},{"name":"虚拟机","slug":"虚拟机","link":"/categories/%E8%99%9A%E6%8B%9F%E6%9C%BA/"}]}